<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CCF推荐国际学术会议和期刊目录（网络与信息安全）</title>
    <url>/2020/04/20/CCF%E6%8E%A8%E8%8D%90%E5%9B%BD%E9%99%85%E5%AD%A6%E6%9C%AF%E4%BC%9A%E8%AE%AE%E5%92%8C%E6%9C%9F%E5%88%8A%E7%9B%AE%E5%BD%95%EF%BC%88%E7%BD%91%E7%BB%9C%E4%B8%8E%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%EF%BC%89/</url>
    <content><![CDATA[<p><a href="https://www.ccf.org.cn/c/2019-04-25/663625.shtml" target="_blank" rel="noopener">https://www.ccf.org.cn/c/2019-04-25/663625.shtml</a></p>
<a id="more"></a>
<h2 id="中国计算机学会推荐国际学术期刊（网络与信息安全）"><a href="#中国计算机学会推荐国际学术期刊（网络与信息安全）" class="headerlink" title="中国计算机学会推荐国际学术期刊（网络与信息安全）"></a>中国计算机学会推荐国际学术期刊（网络与信息安全）</h2><h3 id="A类"><a href="#A类" class="headerlink" title="A类"></a>A类</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">序号</th>
<th style="text-align:center">刊物简称</th>
<th style="text-align:center">刊物全称</th>
<th style="text-align:center">出版社</th>
<th style="text-align:center">网址</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">TDSC</td>
<td style="text-align:center">IEEE Transactions on Dependable and Secure Computing</td>
<td style="text-align:center">IEEE</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/journals/tdsc/" target="_blank" rel="noopener">http://dblp.uni-trier.de/db/journals/tdsc/</a></td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">TIFS</td>
<td style="text-align:center">IEEE Transactions on Information Forensics and Security</td>
<td style="text-align:center">IEEE</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/journals/tifs/" target="_blank" rel="noopener">http://dblp.uni-trier.de/db/journals/tifs/</a></td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center"></td>
<td style="text-align:center">Journal of Cryptology</td>
<td style="text-align:center">Springer</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/journals/joc/" target="_blank" rel="noopener">http://dblp.uni-trier.de/db/journals/joc/</a></td>
</tr>
</tbody>
</table>
</div>
<h3 id="B类"><a href="#B类" class="headerlink" title="B类"></a>B类</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">序号</th>
<th style="text-align:center">刊物简称</th>
<th style="text-align:center">刊物全称</th>
<th style="text-align:center">出版社</th>
<th style="text-align:center">网址</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">TOPS</td>
<td style="text-align:center">ACM Transactions on Privacy and Security</td>
<td style="text-align:center">ACM</td>
<td style="text-align:center"><a href="https://tops.acm.org/" target="_blank" rel="noopener">https://tops.acm.org/</a></td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center"></td>
<td style="text-align:center">Computers &amp; Security</td>
<td style="text-align:center">Elsevier</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/journals/compsec/" target="_blank" rel="noopener">http://dblp.uni-trier.de/db/journals/compsec/</a></td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center"></td>
<td style="text-align:center">Designs, Codes and Cryptography</td>
<td style="text-align:center">Springer</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/journals/dcc/" target="_blank" rel="noopener">http://dblp.uni-trier.de/db/journals/dcc/</a></td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">JCS</td>
<td style="text-align:center">Journal of Computer Security</td>
<td style="text-align:center">IOS Press</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/journals/jcs/" target="_blank" rel="noopener">http://dblp.uni-trier.de/db/journals/jcs/</a></td>
</tr>
</tbody>
</table>
</div>
<h3 id="C类"><a href="#C类" class="headerlink" title="C类"></a>C类</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">序号</th>
<th style="text-align:center">刊物简称</th>
<th style="text-align:center">刊物全称</th>
<th style="text-align:center">出版社</th>
<th style="text-align:center">网址</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">CLSR</td>
<td style="text-align:center">Computer Law and Security Review</td>
<td style="text-align:center">Elsevier</td>
<td style="text-align:center"><a href="http://www.journals.elsevier.com/computer-law-and-security-review/" target="_blank" rel="noopener">http://www.journals.elsevier.com/computer-law-and-security-review/</a></td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center"></td>
<td style="text-align:center">EURASIP Journal on Information Security</td>
<td style="text-align:center">Springer</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/journals/ejisec/" target="_blank" rel="noopener">http://dblp.uni-trier.de/db/journals/ejisec/</a></td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center"></td>
<td style="text-align:center">IET Information Security</td>
<td style="text-align:center">IET</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/journals/iet-ifs/" target="_blank" rel="noopener">http://dblp.uni-trier.de/db/journals/iet-ifs/</a></td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">IMCS</td>
<td style="text-align:center">Information Management &amp; Computer Security</td>
<td style="text-align:center">Emerald</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/journals/imcs/" target="_blank" rel="noopener">http://dblp.uni-trier.de/db/journals/imcs/</a></td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center">IJICS</td>
<td style="text-align:center">International Journal of Information and Computer Security</td>
<td style="text-align:center">Inderscience</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/journals/ijics/" target="_blank" rel="noopener">http://dblp.uni-trier.de/db/journals/ijics/</a></td>
</tr>
<tr>
<td style="text-align:center">6</td>
<td style="text-align:center">IJISP</td>
<td style="text-align:center">International Journal of Information Security and Privacy</td>
<td style="text-align:center">Idea Group Inc</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/journals/ijisp/" target="_blank" rel="noopener">http://dblp.uni-trier.de/db/journals/ijisp/</a></td>
</tr>
<tr>
<td style="text-align:center">7</td>
<td style="text-align:center">JISA</td>
<td style="text-align:center">Journal of Information Security and Application</td>
<td style="text-align:center">Elsevier</td>
<td style="text-align:center"><a href="https://dblp.uni-trier.de/db/journals/istr/" target="_blank" rel="noopener">https://dblp.uni-trier.de/db/journals/istr/</a></td>
</tr>
<tr>
<td style="text-align:center">8</td>
<td style="text-align:center">SCN</td>
<td style="text-align:center">Security and Communication Networks</td>
<td style="text-align:center">Wiley</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/journals/scn/" target="_blank" rel="noopener">http://dblp.uni-trier.de/db/journals/scn/</a></td>
</tr>
</tbody>
</table>
</div>
<h2 id="中国计算机学会推荐国际学术会议（网络与信息安全）"><a href="#中国计算机学会推荐国际学术会议（网络与信息安全）" class="headerlink" title="中国计算机学会推荐国际学术会议（网络与信息安全）"></a>中国计算机学会推荐国际学术会议（网络与信息安全）</h2><h3 id="A类-1"><a href="#A类-1" class="headerlink" title="A类"></a>A类</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">序号</th>
<th style="text-align:center">会议简称</th>
<th style="text-align:center">会议全称</th>
<th style="text-align:center">出版社</th>
<th style="text-align:center">网址</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">CCS</td>
<td style="text-align:center">ACM Conference on Computer and Communications Security</td>
<td style="text-align:center">ACM</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/conf/ccs/" target="_blank" rel="noopener">http://dblp.uni-trier.de/db/conf/ccs/</a></td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">EUROCRYPT</td>
<td style="text-align:center">European Cryptology Conference</td>
<td style="text-align:center">Springer</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/conf/eurocrypt/" target="_blank" rel="noopener">http://dblp.uni-trier.de/db/conf/eurocrypt/</a></td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">S&amp;P</td>
<td style="text-align:center">IEEE Symposium on Security and Privacy</td>
<td style="text-align:center">IEEE</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/conf/sp/" target="_blank" rel="noopener">http://dblp.uni-trier.de/db/conf/sp/</a></td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">CRYPTO</td>
<td style="text-align:center">International Cryptology Conference</td>
<td style="text-align:center">Springer</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/conf/crypto/" target="_blank" rel="noopener">http://dblp.uni-trier.de/db/conf/crypto/</a></td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center">USENIX Security</td>
<td style="text-align:center">Usenix Security Symposium</td>
<td style="text-align:center">USENIX Association</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/conf/uss/" target="_blank" rel="noopener">http://dblp.uni-trier.de/db/conf/uss/</a></td>
</tr>
</tbody>
</table>
</div>
<h3 id="B类-1"><a href="#B类-1" class="headerlink" title="B类"></a>B类</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">序号</th>
<th style="text-align:center">会议简称</th>
<th style="text-align:center">会议全称</th>
<th style="text-align:center">出版社</th>
<th style="text-align:center">网址</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">ACSAC</td>
<td style="text-align:center">Annual Computer Security Applications Conference</td>
<td style="text-align:center">IEEE</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/conf/acsac/" target="_blank" rel="noopener">http://dblp.uni-trier.de/db/conf/acsac/</a></td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">ASIACRYPT</td>
<td style="text-align:center">Annual International Conference on the Theory and Application of Cryptology and Information Security</td>
<td style="text-align:center">Springer</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/conf/asiacrypt/" target="_blank" rel="noopener">http://dblp.uni-trier.de/db/conf/asiacrypt/</a></td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">ESORICS</td>
<td style="text-align:center">European Symposium on Research in Computer Security</td>
<td style="text-align:center">Springer</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/conf/esorics/" target="_blank" rel="noopener">http://dblp.uni-trier.de/db/conf/esorics/</a></td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">FSE</td>
<td style="text-align:center">Fast Software Encryption</td>
<td style="text-align:center">Springer</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/conf/fse/" target="_blank" rel="noopener">http://dblp.uni-trier.de/db/conf/fse/</a></td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center">CSFW</td>
<td style="text-align:center">IEEE Computer Security Foundations Workshop</td>
<td style="text-align:center">IEEE</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/conf/csfw/" target="_blank" rel="noopener">http://dblp.uni-trier.de/db/conf/csfw/</a></td>
</tr>
<tr>
<td style="text-align:center">6</td>
<td style="text-align:center">SRDS</td>
<td style="text-align:center">IEEE International Symposium on Reliable Distributed Systems</td>
<td style="text-align:center">IEEE</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/conf/srds/" target="_blank" rel="noopener">http://dblp.uni-trier.de/db/conf/srds/</a></td>
</tr>
<tr>
<td style="text-align:center">7</td>
<td style="text-align:center">CHES</td>
<td style="text-align:center">International Conference on Cryptographic Hardware and Embedded Systems</td>
<td style="text-align:center">Springer</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/conf/ches/" target="_blank" rel="noopener">http://dblp.uni-trier.de/db/conf/ches/</a></td>
</tr>
<tr>
<td style="text-align:center">8</td>
<td style="text-align:center">DSN</td>
<td style="text-align:center">International Conference on Dependable Systems and Networks</td>
<td style="text-align:center">IEEE/IFIP</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/conf/dsn/" target="_blank" rel="noopener">http://dblp.uni-trier.de/db/conf/dsn/</a></td>
</tr>
<tr>
<td style="text-align:center">9</td>
<td style="text-align:center">RAID</td>
<td style="text-align:center">International Symposium on Recent Advances in Intrusion Detection</td>
<td style="text-align:center">Springer</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/conf/raid/" target="_blank" rel="noopener">http://dblp.uni-trier.de/db/conf/raid/</a></td>
</tr>
<tr>
<td style="text-align:center">10</td>
<td style="text-align:center">PKC</td>
<td style="text-align:center">International Workshop on Practice and Theory in Public Key Cryptography</td>
<td style="text-align:center">Springer</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/conf/pkc/" target="_blank" rel="noopener">http://dblp.uni-trier.de/db/conf/pkc/</a></td>
</tr>
<tr>
<td style="text-align:center">11</td>
<td style="text-align:center">NDSS</td>
<td style="text-align:center">ISOC Network and Distributed System Security Symposium</td>
<td style="text-align:center">ISOC</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/conf/ndss/" target="_blank" rel="noopener">http://dblp.uni-trier.de/db/conf/ndss/</a></td>
</tr>
<tr>
<td style="text-align:center">12</td>
<td style="text-align:center">TCC</td>
<td style="text-align:center">Theory of Cryptography Conference</td>
<td style="text-align:center">Springer</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/conf/tcc/" target="_blank" rel="noopener">http://dblp.uni-trier.de/db/conf/tcc/</a></td>
</tr>
</tbody>
</table>
</div>
<h3 id="C类-1"><a href="#C类-1" class="headerlink" title="C类"></a>C类</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">序号</th>
<th style="text-align:center">会议简称</th>
<th style="text-align:center">会议全称</th>
<th style="text-align:center">出版社</th>
<th style="text-align:center">网址</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">WiSec</td>
<td style="text-align:center">ACM Conference on Security and Privacy in Wireless and Mobile Networks</td>
<td style="text-align:center">ACM</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/conf/wisec/" target="_blank" rel="noopener">http://dblp.uni-trier.de/db/conf/wisec/</a></td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">SACMAT</td>
<td style="text-align:center">ACM Symposium on Access Control Models and Technologies</td>
<td style="text-align:center">ACM</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/conf/sacmat/" target="_blank" rel="noopener">http://dblp.uni-trier.de/db/conf/sacmat/</a></td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">DRM</td>
<td style="text-align:center">ACM Workshop on Digital Rights Management</td>
<td style="text-align:center">ACM</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/conf/drm/" target="_blank" rel="noopener">http://dblp.uni-trier.de/db/conf/drm/</a></td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">IH&amp;MMSec</td>
<td style="text-align:center">ACM Workshop on Information Hiding and Multimedia Security</td>
<td style="text-align:center">ACM</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/conf/ih/" target="_blank" rel="noopener">http://dblp.uni-trier.de/db/conf/ih/</a></td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center">ACNS</td>
<td style="text-align:center">Applied Cryptography and Network Security</td>
<td style="text-align:center">Springer</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/conf/acns/" target="_blank" rel="noopener">http://dblp.uni-trier.de/db/conf/acns/</a></td>
</tr>
<tr>
<td style="text-align:center">6</td>
<td style="text-align:center">AsiaCCS</td>
<td style="text-align:center">Asia Conference on Computer and Communications Security</td>
<td style="text-align:center">ACM</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/conf/ccs/" target="_blank" rel="noopener">http://dblp.uni-trier.de/db/conf/ccs/</a></td>
</tr>
<tr>
<td style="text-align:center">7</td>
<td style="text-align:center">ACISP</td>
<td style="text-align:center">Australasia Conference on Information Security and Privacy</td>
<td style="text-align:center">Springer</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/conf/acisp/" target="_blank" rel="noopener">http://dblp.uni-trier.de/db/conf/acisp/</a></td>
</tr>
<tr>
<td style="text-align:center">8</td>
<td style="text-align:center">CT-RSA</td>
<td style="text-align:center">Cryptographer’s Track at RSA Conference</td>
<td style="text-align:center">Springer</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/conf/ctrsa/" target="_blank" rel="noopener">http://dblp.uni-trier.de/db/conf/ctrsa/</a></td>
</tr>
<tr>
<td style="text-align:center">9</td>
<td style="text-align:center">DIMVA</td>
<td style="text-align:center">Detection of Intrusions and Malware &amp; Vulnerability Assessment</td>
<td style="text-align:center"></td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/conf/dimva/" target="_blank" rel="noopener">http://dblp.uni-trier.de/db/conf/dimva/</a></td>
</tr>
<tr>
<td style="text-align:center">10</td>
<td style="text-align:center">DFRWS</td>
<td style="text-align:center">Digital Forensic Research Workshop</td>
<td style="text-align:center">Elsevier</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/conf/dfrws/" target="_blank" rel="noopener">http://dblp.uni-trier.de/db/conf/dfrws/</a></td>
</tr>
<tr>
<td style="text-align:center">11</td>
<td style="text-align:center">FC</td>
<td style="text-align:center">Financial Cryptography and Data Security</td>
<td style="text-align:center">Springer</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/conf/fc/" target="_blank" rel="noopener">http://dblp.uni-trier.de/db/conf/fc/</a></td>
</tr>
<tr>
<td style="text-align:center">12</td>
<td style="text-align:center">TrustCom</td>
<td style="text-align:center">IEEE International Conference on Trust, Security and Privacy in Computing and Communications</td>
<td style="text-align:center">IEEE</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/conf/trustcom/" target="_blank" rel="noopener">http://dblp.uni-trier.de/db/conf/trustcom/</a></td>
</tr>
<tr>
<td style="text-align:center">13</td>
<td style="text-align:center">SEC</td>
<td style="text-align:center">IFIP International Information Security Conference</td>
<td style="text-align:center">Springer</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/conf/sec/" target="_blank" rel="noopener">http://dblp.uni-trier.de/db/conf/sec/</a></td>
</tr>
<tr>
<td style="text-align:center">14</td>
<td style="text-align:center">IFIP WG 11.9</td>
<td style="text-align:center">IFIP WG 11.9 International Conference on Digital Forensics</td>
<td style="text-align:center">Springer</td>
<td style="text-align:center">*<a href="http://www.ifip119.org/Conferences/" target="_blank" rel="noopener">http://www.ifip119.org/Conferences/</a></td>
</tr>
<tr>
<td style="text-align:center">15</td>
<td style="text-align:center">ISC</td>
<td style="text-align:center">Information Security Conference</td>
<td style="text-align:center">Springer</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/conf/isw/" target="_blank" rel="noopener">http://dblp.uni-trier.de/db/conf/isw/</a></td>
</tr>
<tr>
<td style="text-align:center">16</td>
<td style="text-align:center">ICDF2C</td>
<td style="text-align:center">International Conference on Digital Forensics &amp; Cyber Crime</td>
<td style="text-align:center">Springer</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/conf/icdf2c/" target="_blank" rel="noopener">http://dblp.uni-trier.de/db/conf/icdf2c/</a></td>
</tr>
<tr>
<td style="text-align:center">17</td>
<td style="text-align:center">ICICS</td>
<td style="text-align:center">International Conference on Information and Communications Security</td>
<td style="text-align:center">Springer</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/conf/icics/" target="_blank" rel="noopener">http://dblp.uni-trier.de/db/conf/icics/</a></td>
</tr>
<tr>
<td style="text-align:center">18</td>
<td style="text-align:center">SecureComm</td>
<td style="text-align:center">International Conference on Security and Privacy in Communication Networks</td>
<td style="text-align:center">ACM</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/conf/securecomm/" target="_blank" rel="noopener">http://dblp.uni-trier.de/db/conf/securecomm/</a></td>
</tr>
<tr>
<td style="text-align:center">19</td>
<td style="text-align:center">NSPW</td>
<td style="text-align:center">New Security Paradigms Workshop</td>
<td style="text-align:center">ACM</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/conf/nspw/" target="_blank" rel="noopener">http://dblp.uni-trier.de/db/conf/nspw/</a></td>
</tr>
<tr>
<td style="text-align:center">20</td>
<td style="text-align:center">PAM</td>
<td style="text-align:center">Passive and Active Measurement Conference</td>
<td style="text-align:center">Springer</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/conf/pam/" target="_blank" rel="noopener">http://dblp.uni-trier.de/db/conf/pam/</a></td>
</tr>
<tr>
<td style="text-align:center">21</td>
<td style="text-align:center">PETS</td>
<td style="text-align:center">Privacy Enhancing Technologies Symposium</td>
<td style="text-align:center">Springer</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/conf/pet/" target="_blank" rel="noopener">http://dblp.uni-trier.de/db/conf/pet/</a></td>
</tr>
<tr>
<td style="text-align:center">22</td>
<td style="text-align:center">SAC</td>
<td style="text-align:center">Selected Areas in Cryptography</td>
<td style="text-align:center">Springer</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/conf/sacrypt/" target="_blank" rel="noopener">http://dblp.uni-trier.de/db/conf/sacrypt/</a></td>
</tr>
<tr>
<td style="text-align:center">23</td>
<td style="text-align:center">SOUPS</td>
<td style="text-align:center">Symposium On Usable Privacy and Security</td>
<td style="text-align:center">USENIX</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/conf/soups/" target="_blank" rel="noopener">http://dblp.uni-trier.de/db/conf/soups/</a></td>
</tr>
<tr>
<td style="text-align:center">24</td>
<td style="text-align:center">HotSec</td>
<td style="text-align:center">USENIX Workshop on Hot Topics in Security</td>
<td style="text-align:center">USENIX</td>
<td style="text-align:center">*<a href="http://www.usenix.org/events/" target="_blank" rel="noopener">http://www.usenix.org/events/</a></td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <categories>
        <category>Papers</category>
      </categories>
      <tags>
        <tag>密码学</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo博客NexT主题使用不蒜子统计访客数</title>
    <url>/2020/05/11/Hexo%E5%8D%9A%E5%AE%A2NexT%E4%B8%BB%E9%A2%98%E4%BD%BF%E7%94%A8%E4%B8%8D%E8%92%9C%E5%AD%90%E7%BB%9F%E8%AE%A1%E8%AE%BF%E5%AE%A2%E6%95%B0/</url>
    <content><![CDATA[<p>想为自己的博客添加访问统计，经过一番查阅，找到了好用又方便的不蒜子统计，不蒜子是一个极简的网页计数器。</p>
<a id="more"></a>
<h1 id="安装NexT"><a href="#安装NexT" class="headerlink" title="安装NexT"></a>安装NexT</h1><p>参考 <a href="http://theme-next.iissnan.com/getting-started.html" target="_blank" rel="noopener">http://theme-next.iissnan.com/getting-started.html</a></p>
<h1 id="打开不蒜子统计开关"><a href="#打开不蒜子统计开关" class="headerlink" title="打开不蒜子统计开关"></a>打开不蒜子统计开关</h1><p>新版的next主题已经把不蒜子集成进去，只需要打开开关即可：</p>
<ol>
<li><p>编辑<code>\themes\next\_config.yml</code>，找到里面的<code>busuanzi_count</code>配置项，将<code>enable</code>设为<code>true</code>：</p>
<p><img src="http://images.yingwai.top/picgo/busuanzif1.png" alt=""></p>
<p>当<code>enable: true</code>时，代表开启全局开关。若<code>site_uv</code>、<code>site_pv</code>、<code>page_pv</code>的值均为<code>false</code>时，不蒜子仅作记录而不会在页面上显示。</p>
</li>
<li><p>打开对应的站点配置：当<code>site_uv: true</code>时，代表在页面底部显示站点的UV值；当<code>site_pv: true</code>时，代表在页面底部显示站点的PV值。</p>
</li>
</ol>
<h1 id="不蒜子统计不显示的问题"><a href="#不蒜子统计不显示的问题" class="headerlink" title="不蒜子统计不显示的问题"></a>不蒜子统计不显示的问题</h1><p>完成上面的步骤后，进入博客，发现统计人数显示不出来：</p>
<p><img src="http://images.yingwai.top/picgo/busuanzif2.png" alt=""></p>
<p><strong>原因：不蒜子的域名更换了，但是next主题里面写进去的域名还是以前的。</strong></p>
<p><a href="http://busuanzi.ibruce.info/" target="_blank" rel="noopener">不蒜子官网</a>：</p>
<p><img src="http://images.yingwai.top/picgo/busuanzif3.png" alt=""></p>
<p><strong>解决方法：</strong></p>
<p>打开<code>\themes\next\layout\_third-party\analytics</code>文件夹里面的<code>busuanzi-counter.swig</code>文件，将旧的域名更换为新的域名：</p>
<p>原来的域名：</p>
<p><img src="http://images.yingwai.top/picgo/busuanzif4.png" alt=""></p>
<p>更换后：</p>
<p><img src="http://images.yingwai.top/picgo/busuanzif5.png" alt=""></p>
<p>此时博客的访客数就可以正常显示了。</p>
]]></content>
      <categories>
        <category>Env</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>NexT</tag>
        <tag>不蒜子</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo博客NexT主题翻页按钮显示不正常的解决方法</title>
    <url>/2020/05/11/Hexo%E5%8D%9A%E5%AE%A2NexT%E4%B8%BB%E9%A2%98%E7%BF%BB%E9%A1%B5%E6%8C%89%E9%92%AE%E6%98%BE%E7%A4%BA%E4%B8%8D%E6%AD%A3%E5%B8%B8%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>搭好博客后，上去发现底下的翻页按钮显示有问题，显示为<code>&lt;i class=&quot;fa fa-angle-right&quot;&gt;&lt;/i&gt;</code>，原因不明：</p>
<a id="more"></a>
<p><img src="http://images.yingwai.top/picgo/fanyef1.png" alt=""></p>
<p><strong>解决办法：</strong></p>
<p>最简单的办法就是将<code>&lt;i class=&quot;fa fa-angle-right&quot;&gt;&lt;/i&gt;</code>这个不能正常显示的字体图标改成一般的字符，我就是按照网上的方法改成正常的一般左右键字符 “ &gt; ”。</p>
<p>到<code>\themes\next\layout\_partials</code>目录下找到<code>pagination.swig</code>文件，将</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;% if page.prev or page.next %&#125;</span><br><span class="line">  <span class="tag">&lt;<span class="name">nav</span> <span class="attr">class</span>=<span class="string">"pagination"</span>&gt;</span></span><br><span class="line">    &#123;&#123;</span><br><span class="line">      paginator(&#123;</span><br><span class="line">        prev_text: '<span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-angle-left"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span>',</span><br><span class="line">        next_text: '<span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-angle-right"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span>',</span><br><span class="line">        mid_size: 1</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>
<p>改成</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;% if page.prev or page.next %&#125;</span><br><span class="line">  <span class="tag">&lt;<span class="name">nav</span> <span class="attr">class</span>=<span class="string">"pagination"</span>&gt;</span></span><br><span class="line">    &#123;&#123;</span><br><span class="line">      paginator(&#123;</span><br><span class="line">        prev_text: '<span class="tag">&lt;<span class="name">',</span></span></span><br><span class="line"><span class="tag">        <span class="attr">next_text:</span> '&gt;</span>',</span><br><span class="line">        mid_size: 1</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>
<p>重新部署即可看到已经正常显示了：</p>
<p><img src="http://images.yingwai.top/picgo/fanyef2.png" alt=""></p>
]]></content>
      <categories>
        <category>Env</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>NexT</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo博客搭建</title>
    <url>/2020/04/11/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h2 id="Hexo简介"><a href="#Hexo简介" class="headerlink" title="Hexo简介"></a>Hexo简介</h2><p>​    Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 <a href="http://daringfireball.net/projects/markdown/" target="_blank" rel="noopener">Markdown</a>（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p>
<a id="more"></a>
<h2 id="搭建流程（Windows）"><a href="#搭建流程（Windows）" class="headerlink" title="搭建流程（Windows）"></a>搭建流程（Windows）</h2><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><h4 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h4><p>到 <a href="https://git-scm.com/download" target="_blank" rel="noopener">https://git-scm.com/download</a> 选择对应的平台进行下载安装即可。</p>
<h4 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h4><p>到 <a href="https://nodejs.org/en/" target="_blank" rel="noopener">https://nodejs.org/en/</a> 下载安装即可。（Node.js 版本需不低于 8.10，建议使用 Node.js 10.0 及以上版本）</p>
<h3 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h3><p>安装需要借助npm包管理器，由于在国内这个镜像源很慢，因此可以利用npm安装cnpm淘宝镜像源，在命令行中输入：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm install -g cnpm --registry=https://registry.npm.taobao.org</span></span><br></pre></td></tr></table></figure>
<p>安装完后就可以使用cnpm安装hexo：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cnpm install -g hexo-cli</span></span><br></pre></td></tr></table></figure>
<p>可以用<code>hexo -v</code>来验证是否安装成功。</p>
<h3 id="正式搭建"><a href="#正式搭建" class="headerlink" title="正式搭建"></a>正式搭建</h3><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>建立一个名为 <em>Blog</em> 的文件夹，在命令行中进入这个文件夹，在命令行中输入：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> hexo init</span></span><br></pre></td></tr></table></figure>
<p>初始化完成后，在命令行中输入<code>hexo s</code>，此时在浏览器中输入<code>localhost:4000</code>就可以看到博客已经创建好了，并且默认创建了一篇文章。</p>
<p>确认过后，键盘按 <em>Ctrl + C</em> 即可停止服务。</p>
<h4 id="部署到Github"><a href="#部署到Github" class="headerlink" title="部署到Github"></a>部署到Github</h4><p>首先登陆到<a href="https://github.com/" target="_blank" rel="noopener">Github</a>，新建一个仓库，命名为 “<strong>你的Github昵称.github.io</strong>“。</p>
<p>然后需要安装一个git部署插件，在命令行中打开 <em>Blog</em> 目录，输入：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cnpm install --save hexo-deployer-git</span></span><br></pre></td></tr></table></figure>
<p>打开 <em>Blog</em> 目录下的站点配置文件，在文件最后的 <strong><em>repo</em></strong> 处输入刚刚创建的仓库的地址并在下方添加一行：</p>
<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="meta"># Deployment</span></span><br><span class="line"><span class="meta">## Docs: https:<span class="comment">//hexo.io/docs/deployment.html</span></span></span><br><span class="line"><span class="symbol">deploy:</span></span><br><span class="line"><span class="symbol">  type:</span> git</span><br><span class="line"><span class="symbol">  repo:</span> https:<span class="comment">//github.com/xxx/xxx.github.io.git</span></span><br><span class="line"><span class="symbol">  branch:</span> master	<span class="meta"># 指定分支，不填默认为master</span></span><br></pre></td></tr></table></figure>
<p>保存退出后，在命令行中输入：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> hexo d</span></span><br></pre></td></tr></table></figure>
<p>部署到远端，此时刷新一下自己的Github仓库页面，会发现多了很多文件。在浏览器中访问 <strong>xxx.github.io</strong>，就可以看到博客已经成功部署。</p>
<h2 id="使用Hexo"><a href="#使用Hexo" class="headerlink" title="使用Hexo"></a>使用Hexo</h2><h3 id="新建文章"><a href="#新建文章" class="headerlink" title="新建文章"></a>新建文章</h3><p>在命令行中输入：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> hexo n <span class="string">"文章标题"</span></span></span><br></pre></td></tr></table></figure>
<p>会在博客目录的<code>/source/_posts</code>目录下生成一个markdown文件，使用编辑器打开即可编辑这篇文章。</p>
<h3 id="发布文章"><a href="#发布文章" class="headerlink" title="发布文章"></a>发布文章</h3><p>在命令行中依次输入：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> hexo clean	<span class="comment"># 清理缓存文件和已生成的静态文件</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> hexo g	<span class="comment"># 生成静态文件</span></span></span><br></pre></td></tr></table></figure>
<p>再使用<code>hexo s</code>命令就可以在<code>localhost:4000</code>页面看到新生成的文章已经发布到了博客上面。</p>
]]></content>
      <categories>
        <category>Env</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo博客NexT主题点击侧边栏日志出现问题的解决办法</title>
    <url>/2020/05/11/Hexo%E5%8D%9A%E5%AE%A2NexT%E4%B8%BB%E9%A2%98%E7%82%B9%E5%87%BB%E4%BE%A7%E8%BE%B9%E6%A0%8F%E6%97%A5%E5%BF%97%E5%87%BA%E7%8E%B0%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
    <content><![CDATA[<p>部署好博客并安装了NexT主题后，发现一个问题：侧边栏头像下面的日志点击是404的页面。于是到网上搜索，发现是符号转码的问题。</p>
<a id="more"></a>
<p><strong>解决方法：</strong></p>
<p>到<code>\themes\next\layout\_macro</code>目录下找到<code>sidebar.swig</code>文件，打开找到这一行：</p>
<p><img src="http://images.yingwai.top/picgo/nextsidebarrizhif1.png" alt=""></p>
<p>原因是<code>url_for</code>函数将<code>||</code>转码了，</p>
<p>将<code>theme.menu.archives</code>后面的括号更换一下位置即可：</p>
<p><img src="http://images.yingwai.top/picgo/nextsidebarrizhif2.png" alt=""></p>
<p>这时候点击日志就会自动跳转到归档页。</p>
]]></content>
      <categories>
        <category>Env</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>NexT</tag>
      </tags>
  </entry>
  <entry>
    <title>JupyterLab安装</title>
    <url>/2020/05/01/JupyterLab%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<p>JupyterLab 是一个交互式的开发环境，是 Jupyter notebook 的下一代产品，集成了更多的功能，十分好用。</p>
<a id="more"></a>
<h1 id="安装Miniconda"><a href="#安装Miniconda" class="headerlink" title="安装Miniconda"></a>安装Miniconda</h1><p>1、进入清华大学开源软件镜像站找到Miniconda: <a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/miniconda/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/anaconda/miniconda/</a></p>
<p><img src="http://images.yingwai.top/picgo/jupyterinstallf1.png" alt=""></p>
<p>2、找到Miniconda的Linux版本，右键复制链接地址，然后在服务器中下载：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> wget -c https://mirrors.tuna.tsinghua.edu.cn/anaconda/miniconda/Miniconda3-py37_4.8.2-Linux-x86_64.sh</span></span><br></pre></td></tr></table></figure>
<p>3、安装刚刚下载的Miniconda：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> bash Miniconda3-py37_4.8.2-Linux-x86_64.sh</span></span><br></pre></td></tr></table></figure>
<p>根据提示按enter键或输入yes即可。</p>
<p>4、安装成功后，会在当前用户目录下生成一个miniconda3文件夹。</p>
<h2 id="安装pip"><a href="#安装pip" class="headerlink" title="安装pip"></a>安装pip</h2><p>在终端中输入以下命令安装pip：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> conda install pip</span></span><br></pre></td></tr></table></figure>
<h3 id="添加清华源"><a href="#添加清华源" class="headerlink" title="添加清华源"></a>添加清华源</h3><p>如果下载速度太慢，可以将conda默认的软件源更换为国内的清华源：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> conda config --<span class="built_in">set</span> show_channel_urls yes</span></span><br></pre></td></tr></table></figure>
<p>添加完成后可以使用<code>conda info</code>命令查看是否添加成功。</p>
<h1 id="安装并配置JupyterLab"><a href="#安装并配置JupyterLab" class="headerlink" title="安装并配置JupyterLab"></a>安装并配置JupyterLab</h1><p>准备工作完成后，就可以开始安装Jupyterlab。</p>
<h2 id="安装JupyterLab"><a href="#安装JupyterLab" class="headerlink" title="安装JupyterLab"></a>安装JupyterLab</h2><p>在终端中输入：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> pip install jupyterlab</span></span><br></pre></td></tr></table></figure>
<h2 id="远程访问配置"><a href="#远程访问配置" class="headerlink" title="远程访问配置"></a>远程访问配置</h2><p>在终端中打开ipython：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ipython</span></span><br><span class="line"></span><br><span class="line">In [1]: from notebook.auth import passwd</span><br><span class="line"></span><br><span class="line">In [2]: passwd()</span><br><span class="line">Enter password:		# 输入你要设置的密码</span><br><span class="line">Verify password:</span><br><span class="line">Out[2]: 'xxxxx...'</span><br></pre></td></tr></table></figure>
<p>这里输出的字符串要复制下来。</p>
<p>执行完上面的命令后，退出ipython，然后在终端中输入：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> jupyter lab --generate-config</span></span><br></pre></td></tr></table></figure>
<p>修改配置文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> vi .jupyter/jupyter_notebook_config.py</span></span><br></pre></td></tr></table></figure>
<p>更改内容如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 将ip设置为*，意味允许任何IP访问</span></span><br><span class="line">c.NotebookApp.ip = '*'</span><br><span class="line"><span class="meta">#</span><span class="bash"> 这里的密码就是上面生成的那一串</span></span><br><span class="line">c.NotebookApp.password = 'xxxxx...' </span><br><span class="line"><span class="meta">#</span><span class="bash"> 服务器上并没有浏览器可以供Jupyter打开 </span></span><br><span class="line">c.NotebookApp.open_browser = False </span><br><span class="line"><span class="meta">#</span><span class="bash"> 监听端口设置为8888或其他自己喜欢的端口 </span></span><br><span class="line">c.NotebookApp.port = 8888</span><br><span class="line"><span class="meta">#</span><span class="bash"> 允许远程访问 </span></span><br><span class="line">c.NotebookApp.allow_remote_access = True</span><br></pre></td></tr></table></figure>
<p>启动jupyter服务：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> jupyter lab --allow-root</span></span><br></pre></td></tr></table></figure>
<p>此时在浏览器搜索框中输入<code>你的服务器ip:你设置的端口</code>，然后在打开的页面中输入密码就可以进入jupyterlab：</p>
<p><img src="http://images.yingwai.top/picgo/jupyterinstallf2.png" alt=""></p>
<h2 id="后台运行JupyterLab程序"><a href="#后台运行JupyterLab程序" class="headerlink" title="后台运行JupyterLab程序"></a>后台运行JupyterLab程序</h2><p>JupyterLab启动后占用了一个终端窗口，可以用<code>nohup</code>命令使JupyterLab在后台运行，并且关闭当前终端也不会停止运行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> nohup jupyter lab &amp;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>nohup</code>命令</p>
<p>用途：Run COMMAND, ignoring hangup signals.</p>
<p>输出文件：程序的输出默认重定向到当前文件夹下的<code>nohup.out</code>文件中。也可以通过<code>nohup COMMAND &gt; FILE</code>命令的方式将输出文件重定位到指定的<code>FILE</code>文件中。如果要查看JupyterLab的日志文件，可以打开<code>nohup.out</code>文件进行查看。</p>
</li>
<li><p><code>&amp;</code>命令</p>
<p>作用：在后台运行程序</p>
</li>
</ul>
<h2 id="查看、关闭后台运行进程"><a href="#查看、关闭后台运行进程" class="headerlink" title="查看、关闭后台运行进程"></a>查看、关闭后台运行进程</h2><p><code>job -l</code>命令查看当前终端中后台运行的进程，如果关闭终端后不能显示，需要使用<code>ps</code>命令。</p>
<p><code>ps -aux | grep jupyter</code>查看运行的<code>jupyter</code>进程：</p>
<p><img src="http://images.yingwai.top/picgo/jupyterinstallf3.png" alt=""></p>
<p>用户名后面的数字就是JupyterLab的pid，使用<code>kill -9 pid</code>命令关闭运行中的JupyterLab。</p>
]]></content>
      <categories>
        <category>Env</category>
      </categories>
      <tags>
        <tag>Jupyter</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>LaTeX常用符号表示方法</title>
    <url>/2020/04/26/LaTeX%E5%B8%B8%E7%94%A8%E7%AC%A6%E5%8F%B7%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>图片来源：<a href="https://blog.csdn.net/caiandyong/article/details/53351737" target="_blank" rel="noopener">https://blog.csdn.net/caiandyong/article/details/53351737</a></p>
<a id="more"></a>
<h1 id="希腊字母、数学构造、定界符、大型运算符以及标准函数名"><a href="#希腊字母、数学构造、定界符、大型运算符以及标准函数名" class="headerlink" title="希腊字母、数学构造、定界符、大型运算符以及标准函数名"></a>希腊字母、数学构造、定界符、大型运算符以及标准函数名</h1><p><img src="http://images.yingwai.top/picgo/latexf1.jpg" alt=""></p>
<h1 id="二元运算、关系符"><a href="#二元运算、关系符" class="headerlink" title="二元运算、关系符"></a>二元运算、关系符</h1><p><img src="http://images.yingwai.top/picgo/latexf2.jpg" alt=""></p>
<h1 id="箭头符号、各种符号以及数学模式重音符"><a href="#箭头符号、各种符号以及数学模式重音符" class="headerlink" title="箭头符号、各种符号以及数学模式重音符"></a>箭头符号、各种符号以及数学模式重音符</h1><p><img src="http://images.yingwai.top/picgo/latexf3.jpg" alt=""></p>
<h1 id="数列环境、其它风格的字体以及字体大小"><a href="#数列环境、其它风格的字体以及字体大小" class="headerlink" title="数列环境、其它风格的字体以及字体大小"></a>数列环境、其它风格的字体以及字体大小</h1><p><img src="http://images.yingwai.top/picgo/latexf4.jpg" alt=""></p>
]]></content>
      <categories>
        <category>Env</category>
      </categories>
      <tags>
        <tag>LaTeX</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode刷题</title>
    <url>/2020/05/25/LeetCode%E5%88%B7%E9%A2%98/</url>
    <content><![CDATA[<p>记录一下每日刷题 $\surd$</p>
<a id="more"></a>
<h1 id="14-最长公共前缀"><a href="#14-最长公共前缀" class="headerlink" title="14. 最长公共前缀"></a>14. 最长公共前缀</h1><p><a href="https://leetcode-cn.com/problems/longest-common-prefix/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-common-prefix/</a></p>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>编写一个函数来查找字符串数组中的最长公共前缀。</p>
<p>如果不存在公共前缀，返回空字符串 <code>&quot;&quot;</code>。</p>
<p>示例 1:</p>
<figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line">输入: [<span class="string">"flower"</span>,<span class="string">"flow"</span>,<span class="string">"flight"</span>]</span><br><span class="line">输出: <span class="string">"fl"</span></span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line">输入: [<span class="string">"dog"</span>,<span class="string">"racecar"</span>,<span class="string">"car"</span>]</span><br><span class="line">输出: <span class="string">""</span></span><br><span class="line">解释: 输入不存在公共前缀。</span><br></pre></td></tr></table></figure>
<p>说明:</p>
<p>所有输入只包含小写字母 <code>a-z</code> 。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>Python中的<code>max()</code>和<code>min()</code>可以比较字符串，按照ASCII值逐位比较：比如<code>cba</code>、<code>cbab</code>、<code>cbd</code>中最大为<code>cbd</code>，最小为<code>cba</code>。因此只要比较最大最小的两个字符串即可找到最大公共前缀。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestCommonPrefix</span><span class="params">(self, strs: List[str])</span> -&gt; str:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> strs: <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">        str1 = min(strs)</span><br><span class="line">        str2 = max(strs)</span><br><span class="line">        <span class="keyword">for</span> i,x <span class="keyword">in</span> enumerate(str1):</span><br><span class="line">            <span class="keyword">if</span> x != str2[i]:</span><br><span class="line">                <span class="keyword">return</span> str2[:i]</span><br><span class="line">        <span class="keyword">return</span> str1</span><br></pre></td></tr></table></figure>
<h1 id="121-买卖股票的最佳时机"><a href="#121-买卖股票的最佳时机" class="headerlink" title="121. 买卖股票的最佳时机"></a>121. 买卖股票的最佳时机</h1><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/</a></p>
<h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p>
<p>如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。</p>
<p>注意：你不能在买入股票前卖出股票。</p>
<p>示例 1:</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">7</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">4</span>]</span><br><span class="line">输出: <span class="number">5</span></span><br><span class="line">解释: 在第 <span class="number">2</span> 天（股票价格 = <span class="number">1</span>）的时候买入，在第 <span class="number">5</span> 天（股票价格 = <span class="number">6</span>）的时候卖出，最大利润 = <span class="number">6</span><span class="number">-1</span> = <span class="number">5</span> 。</span><br><span class="line">     注意利润不能是 <span class="number">7</span><span class="number">-1</span> = <span class="number">6</span>, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">7</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line">输出: <span class="number">0</span></span><br><span class="line">解释: 在这种情况下, 没有交易完成, 所以最大利润为 <span class="number">0</span>。</span><br></pre></td></tr></table></figure>
<h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>因为有时间因素，因此不能简单地用最大值减去最小值。可以用维护两个变量<code>minp</code>和<code>maxp</code>，其中<code>minp</code>记录到当前为止的最小价格，<code>maxp</code>记录当前为止的最大差价。通过对数组的一遍扫描，每扫描到一个值就与<code>minp</code>作比较、计算当前值与<code>minp</code>的差价，若大于<code>maxp</code>则更新。</p>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices: List[int])</span> -&gt; int:</span></span><br><span class="line">        maxp = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> len(prices) &gt; <span class="number">0</span>:</span><br><span class="line">            minp = prices[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">for</span> price <span class="keyword">in</span> prices:</span><br><span class="line">                <span class="keyword">if</span> price &lt; minp:</span><br><span class="line">                    minp = price</span><br><span class="line">                <span class="keyword">if</span> price - minp &gt; maxp:</span><br><span class="line">                    maxp = price - minp</span><br><span class="line">        <span class="keyword">return</span> maxp</span><br></pre></td></tr></table></figure>
<h1 id="152-乘积最大子数组"><a href="#152-乘积最大子数组" class="headerlink" title="152. 乘积最大子数组"></a>152. 乘积最大子数组</h1><p><a href="https://leetcode-cn.com/problems/maximum-product-subarray/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-product-subarray/</a></p>
<h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个整数数组 <code>nums</code> ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。</p>
<p>示例 1:</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">2</span>,<span class="number">3</span>,<span class="number">-2</span>,<span class="number">4</span>]</span><br><span class="line">输出: <span class="number">6</span></span><br><span class="line">解释: 子数组 [<span class="number">2</span>,<span class="number">3</span>] 有最大乘积 <span class="number">6</span>。</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">-2</span>,<span class="number">0</span>,<span class="number">-1</span>]</span><br><span class="line">输出: <span class="number">0</span></span><br><span class="line">解释: 结果不能为 <span class="number">2</span>, 因为 [<span class="number">-2</span>,<span class="number">-1</span>] 不是子数组。</span><br></pre></td></tr></table></figure>
<h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>可以用动态规划。因为负负得正，所以当前的数为负的话，与前一个数的最小值相乘有可能得到比最大值更大的数。因此需要维护两个变量：当前的最大值和最小值。</p>
<p>动态方程如下：</p>
<script type="math/tex; mode=display">
\begin{aligned}
maxDP[i+1] &= \max(dmax[i+1] \cdot nums[i], \  nums[i],\  dmin[i] \cdot nums[i])\\
minDP[i+1] &= \min(dmax[i+1] \cdot nums[i],\  nums[i],\  dmin[i] \cdot nums[i])\\
DP[i+1] &= \max(DP[i],\ maxDP[i+1])
\end{aligned}</script><p>当<code>nums[i]</code>为0时，<code>dmax</code>和<code>dmin</code>都为0，于是需要从<code>nums[i+1]</code>重新开始。</p>
<h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProduct</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> len(nums)==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">elif</span> len(nums)==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">        m = dmax = dmin = nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(nums)):</span><br><span class="line">            tmp = dmax</span><br><span class="line">            dmax = max(max(dmax*nums[i], nums[i]), dmin*nums[i])</span><br><span class="line">            dmin = min(min(tmp*nums[i], nums[i]), dmin*nums[i])</span><br><span class="line">            m = max(dmax, m)</span><br><span class="line">        <span class="keyword">return</span> m</span><br></pre></td></tr></table></figure>
<h1 id="169-多数元素"><a href="#169-多数元素" class="headerlink" title="169. 多数元素"></a>169. 多数元素</h1><p><a href="https://leetcode-cn.com/problems/majority-element/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/majority-element/</a></p>
<h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数大于 <code>⌊ n/2 ⌋</code> 的元素。</p>
<p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p>
<p>示例 1:</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">输出: <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>]</span><br><span class="line">输出: <span class="number">2</span></span><br></pre></td></tr></table></figure>
<h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>这里可以使用摩尔投票法：</p>
<p>候选人<code>k</code>初始化为数组第一个元素<code>nums[0]</code>，票数<code>cnt</code>初始化为1。从第二个元素<code>nums[1]</code>开始遍历，遇到与候选人相同的数则把票数加1，遇到不同的则把票数减1，如果票数减完之后为0，则更换当前数<code>nums[i]</code>为候选人并把票数重设为1。</p>
<p>因为多数元素的个数肯定比其它元素的个数之和多，因此其票数在最后肯定是<code>&gt;= 1</code>的。</p>
<h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">majorityElement</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        cnt = <span class="number">1</span></span><br><span class="line">        k = nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i] == k:</span><br><span class="line">                cnt += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cnt -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> cnt == <span class="number">0</span>:</span><br><span class="line">                    cnt = <span class="number">1</span></span><br><span class="line">                    k = nums[i]</span><br><span class="line">        <span class="keyword">return</span> k</span><br></pre></td></tr></table></figure>
<h1 id="198-打家劫舍"><a href="#198-打家劫舍" class="headerlink" title="198. 打家劫舍"></a>198. 打家劫舍</h1><p><a href="https://leetcode-cn.com/problems/house-robber/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/house-robber/</a></p>
<h2 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h2><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你不触动警报装置的情况下，一夜之内能够偷窃到的最高金额。</p>
<p>示例 1:</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line">输出: <span class="number">4</span></span><br><span class="line">解释: 偷窃 <span class="number">1</span> 号房屋 (金额 = <span class="number">1</span>) ，然后偷窃 <span class="number">3</span> 号房屋 (金额 = <span class="number">3</span>)。</span><br><span class="line">     偷窃到的最高金额 = <span class="number">1</span> + <span class="number">3</span> = <span class="number">4</span> 。</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">2</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line">输出: <span class="number">12</span></span><br><span class="line">解释: 偷窃 <span class="number">1</span> 号房屋 (金额 = <span class="number">2</span>), 偷窃 <span class="number">3</span> 号房屋 (金额 = <span class="number">9</span>)，接着偷窃 <span class="number">5</span> 号房屋 (金额 = <span class="number">1</span>)。</span><br><span class="line">     偷窃到的最高金额 = <span class="number">2</span> + <span class="number">9</span> + <span class="number">1</span> = <span class="number">12</span> 。</span><br></pre></td></tr></table></figure>
<h2 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h2><p>动态规划，用 $\rm dp[i]$ 表示前 $\rm i$ 个房间能偷到的最大值，根据题目条件有以下动态方程：</p>
<script type="math/tex; mode=display">
\rm dp[i] = \max (dp[i-1], dp[i-2] + nums[i])</script><h2 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rob</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">elif</span> len(nums) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">        dp = []</span><br><span class="line">        dp.append(nums[<span class="number">0</span>])</span><br><span class="line">        dp.append(max(nums[<span class="number">0</span>], nums[<span class="number">1</span>]))</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, len(nums)):</span><br><span class="line">            dp.append(max(dp[i<span class="number">-1</span>], dp[i<span class="number">-2</span>] + nums[i]))</span><br><span class="line">        <span class="keyword">return</span> dp[len(nums)<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
<h1 id="287-寻找重复数"><a href="#287-寻找重复数" class="headerlink" title="287. 寻找重复数"></a>287. 寻找重复数</h1><p><a href="https://leetcode-cn.com/problems/find-the-duplicate-number/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/find-the-duplicate-number/</a></p>
<h2 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。</p>
<p>示例 1:</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">2</span>]</span><br><span class="line">输出: <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">3</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>]</span><br><span class="line">输出: <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>说明：</p>
<ol>
<li>不能更改原数组（假设数组是只读的）。</li>
<li>只能使用额外的 $O(1)$ 的空间。</li>
<li>时间复杂度小于 $O(n^2)$ 。</li>
<li>数组中只有一个重复的数字，但它可能不止重复出现一次。</li>
</ol>
<h2 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h2><p>由于题目限制了空间，所以打表法之类的方法就无法使用。可以用二分法：</p>
<p>对于给定题目条件的数组 <code>nums</code>，设<code>mid</code>为 1 到 n 的中位数。扫描数组，若数组中小于等于<code>mid</code>的数的数量严格大于<code>mid</code>，则可以确定重复的数就在 1 到<code>mid</code>之间，反之则在<code>mid</code>到 n 之间。</p>
<h2 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findDuplicate</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        size = len(nums)</span><br><span class="line">        left = <span class="number">1</span></span><br><span class="line">        right = size - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            cnt = <span class="number">0</span></span><br><span class="line">            mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">                <span class="keyword">if</span> num &lt;= mid:</span><br><span class="line">                    cnt += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> cnt &gt; mid:</span><br><span class="line">                right = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> left</span><br></pre></td></tr></table></figure>
<h1 id="300-最长上升子序列"><a href="#300-最长上升子序列" class="headerlink" title="300. 最长上升子序列"></a>300. 最长上升子序列</h1><p><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-increasing-subsequence/</a></p>
<h2 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个无序的整数数组，找到其中最长上升子序列的长度。</p>
<p>示例:</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">10</span>,<span class="number">9</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">101</span>,<span class="number">18</span>]</span><br><span class="line">输出: <span class="number">4</span> </span><br><span class="line">解释: 最长的上升子序列是 [<span class="number">2</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">101</span>]，它的长度是 <span class="number">4</span>。</span><br></pre></td></tr></table></figure>
<p>说明:</p>
<ul>
<li>可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。</li>
<li>你算法的时间复杂度应该为 $O(n^2)$。</li>
</ul>
<p>进阶: 你能将算法的时间复杂度降低到 $O(n \log{n})$ 吗?</p>
<h2 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h2><p>$O(n \log{n})$ 还没想到，这里介绍 $O(n^2)$ 的动态规划方法：</p>
<p>用 $\rm dp[i]$ 表示以第 $\rm i$ 个元素结尾的最长上升子序列的长度，则可以得到以下的状态转移方程：</p>
<script type="math/tex; mode=display">
\rm dp[i] = \max(dp[i], dp[j] + 1),\ nums[j] < nums[i],\  j < i.</script><p>扫描完整个数组后，$\rm dp$ 数组中的最大值即为结果。</p>
<h2 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLIS</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        dp = []     <span class="comment"># 存以第i个元素结尾的最长上升子序列的长度</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            dp.append(<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i):</span><br><span class="line">                <span class="keyword">if</span> nums[j] &lt; nums[i]:</span><br><span class="line">                    dp[i] = max(dp[i], dp[j]+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> max(dp)</span><br></pre></td></tr></table></figure>
<h1 id="394-字符串解码"><a href="#394-字符串解码" class="headerlink" title="394. 字符串解码"></a>394. 字符串解码</h1><p><a href="https://leetcode-cn.com/problems/decode-string/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/decode-string/</a></p>
<h2 id="题目描述-7"><a href="#题目描述-7" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个经过编码的字符串，返回它解码后的字符串。</p>
<p>编码规则为: <code>k[encoded_string]</code>，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。</p>
<p>你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。</p>
<p>此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 <code>3a</code> 或 <code>2[4]</code> 的输入。</p>
<p>示例:</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">s</span> = <span class="string">"3[a]2[bc]"</span>, 返回 <span class="string">"aaabcbc"</span>.</span><br><span class="line"><span class="attribute">s</span> = <span class="string">"3[a2[c]]"</span>, 返回 <span class="string">"accaccacc"</span>.</span><br><span class="line"><span class="attribute">s</span> = <span class="string">"2[abc]3[cd]ef"</span>, 返回 <span class="string">"abcabccdcdcdef"</span>.</span><br></pre></td></tr></table></figure>
<h2 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h2><p>这里可以使用栈，对字符串按顺序扫描：</p>
<ol>
<li>将右括号以外的字符全部入栈，直到扫描到右括号；</li>
<li>扫描到右括号则开始退栈，保存在一个字符串<code>ss</code>中，直到遇到左括号；</li>
<li>根据题目的条件，在左括号前面的一定是数字，此时就可以统计当前字符串出现的次数<code>t</code>，把<code>ss</code>复制<code>t</code>次重新入栈；</li>
<li>最后把栈中所有元素拼接在一起即可。</li>
</ol>
<h2 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decodeString</span><span class="params">(self, s: str)</span> -&gt; str:</span></span><br><span class="line">        <span class="keyword">if</span> len(s) &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">        ans = <span class="string">""</span></span><br><span class="line">        tmps = []   <span class="comment"># 栈</span></span><br><span class="line">        i = <span class="number">1</span></span><br><span class="line">        tmps.append(s[<span class="number">0</span>])</span><br><span class="line">        ss, t = <span class="string">""</span>, <span class="string">""</span>	<span class="comment"># 分别存当前字符串和当前的次数</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; len(s):</span><br><span class="line">            w = s[i]</span><br><span class="line">            <span class="keyword">if</span> w == <span class="string">']'</span>:	<span class="comment"># 扫描到右括号则开始退栈，直到遇到左括号</span></span><br><span class="line">                <span class="keyword">while</span> tmps[<span class="number">-1</span>] != <span class="string">'['</span>:</span><br><span class="line">                    ss = tmps.pop() + ss</span><br><span class="line">                tmps.pop()      <span class="comment"># 将左括号退栈</span></span><br><span class="line">                <span class="keyword">while</span> len(tmps) &gt; <span class="number">0</span> <span class="keyword">and</span> tmps[<span class="number">-1</span>].isdigit():		<span class="comment"># 统计次数</span></span><br><span class="line">                    t = tmps.pop() + t</span><br><span class="line">                tmps.append(ss*int(t))</span><br><span class="line">                ss, t = <span class="string">""</span>, <span class="string">""</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                tmps.append(w)</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> tmp <span class="keyword">in</span> tmps:</span><br><span class="line">            ans = ans + tmp</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<h1 id="409-最长回文串"><a href="#409-最长回文串" class="headerlink" title="409. 最长回文串"></a>409. 最长回文串</h1><p><a href="https://leetcode-cn.com/problems/longest-palindrome/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-palindrome/</a></p>
<h2 id="题目描述-8"><a href="#题目描述-8" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个包含大写字母和小写字母的字符串，找到通过这些字母构造成的最长的回文串。</p>
<p>在构造过程中，请注意区分大小写。比如 <code>&quot;Aa&quot;</code> 不能当做一个回文字符串。</p>
<p>注意:<br>假设字符串的长度不会超过 1010。</p>
<p>示例 1:</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">输入:</span></span><br><span class="line"><span class="string">"abccccdd"</span></span><br><span class="line"></span><br><span class="line"><span class="section">输出:</span></span><br><span class="line">7</span><br><span class="line"></span><br><span class="line"><span class="section">解释:</span></span><br><span class="line">我们可以构造的最长的回文串是<span class="string">"dccaccd"</span>, 它的长度是 7。</span><br></pre></td></tr></table></figure>
<h2 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h2><p>由题意可知回文串中奇数的字母只能出现在中间，即只能选取一个来构造回文串。因此可以先统计每个字母在字符串中出现的个数存在字典中，然后遍历字典，将数量为偶数的直接累加；数量为奇数的则判断前面是否已出现了奇数，若不是则直接累加，若是则只选取偶数数量的当前字母，即把当前数量 $-1$ 再累加。</p>
<h2 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        d = dict()</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        flag = <span class="number">0</span>    <span class="comment"># 判断前面有无加奇数</span></span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> w <span class="keyword">in</span> d:</span><br><span class="line">                d[w] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                d[w] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> value <span class="keyword">in</span> d.values():</span><br><span class="line">            <span class="keyword">if</span> value%<span class="number">2</span>==<span class="number">0</span>:</span><br><span class="line">                ans += value</span><br><span class="line">            <span class="keyword">elif</span> flag:</span><br><span class="line">                ans += value - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ans += value</span><br><span class="line">                flag = <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<h1 id="974-和可被-K-整除的子数组"><a href="#974-和可被-K-整除的子数组" class="headerlink" title="974. 和可被 K 整除的子数组"></a>974. 和可被 K 整除的子数组</h1><p><a href="https://leetcode-cn.com/problems/subarray-sums-divisible-by-k/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/subarray-sums-divisible-by-k/</a></p>
<h2 id="题目描述-9"><a href="#题目描述-9" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个整数数组 A，返回其中元素之和可被 K 整除的（连续、非空）子数组的数目。</p>
<p>示例：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入：A = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">-2</span>,<span class="number">-3</span>,<span class="number">1</span>], K = <span class="number">5</span></span><br><span class="line">输出：<span class="number">7</span></span><br><span class="line">解释：</span><br><span class="line">有 <span class="number">7</span> 个子数组满足其元素之和可被 K = <span class="number">5</span> 整除：</span><br><span class="line">[<span class="number">4</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">-2</span>, <span class="number">-3</span>, <span class="number">1</span>], [<span class="number">5</span>], [<span class="number">5</span>, <span class="number">0</span>], [<span class="number">5</span>, <span class="number">0</span>, <span class="number">-2</span>, <span class="number">-3</span>], [<span class="number">0</span>], [<span class="number">0</span>, <span class="number">-2</span>, <span class="number">-3</span>], [<span class="number">-2</span>, <span class="number">-3</span>]</span><br></pre></td></tr></table></figure>
<p>提示：</p>
<ol>
<li><code>1 &lt;= A.length &lt;= 30000</code></li>
<li><code>-10000 &lt;= A[i] &lt;= 10000</code></li>
<li><code>2 &lt;= K &lt;= 10000</code></li>
</ol>
<h2 id="思路-9"><a href="#思路-9" class="headerlink" title="思路"></a>思路</h2><p>一个前缀和的问题。设 $\rm presum[i]$是数组 $\rm A$ 第 $\rm i$ 个元素的前缀和，那么 $\rm A[i]$ 就可以表示为 $\rm presum[i] - presum[i-1]$，子数组 $\rm A[k]$ 到 $\rm A[i]$ 的和就是 $\rm presum[i] - presum[k-1]$。</p>
<p>题目要求的是满足 $\rm presum[i] - presum[k-1] \bmod K = 0$ 的子数组 $\rm [A[k],…,A[i]]$ 的个数，根据同余定理，可以把问题转换为求同余的 $\rm presum[i]$ 的个数。每扫描到数组中的一个数，就检查哈希表中有没有同余的数组，若有则计算同余的数量，若无把当前模 $\rm K$ 的余数保存在哈希表中，一次遍历即可解决问题。</p>
<h2 id="代码-9"><a href="#代码-9" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subarraysDivByK</span><span class="params">(self, A: List[int], K: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> len(A)==<span class="number">0</span> <span class="keyword">or</span> K==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        d = &#123;<span class="number">0</span>:<span class="number">1</span>&#125;</span><br><span class="line">        presum, cnt = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> a <span class="keyword">in</span> A:</span><br><span class="line">            presum += a</span><br><span class="line">            m = presum % K</span><br><span class="line">            s = d.get(m, <span class="number">0</span>)</span><br><span class="line">            cnt += s</span><br><span class="line">            d[m] = s + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> cnt</span><br></pre></td></tr></table></figure>
<h1 id="994-腐烂的橘子"><a href="#994-腐烂的橘子" class="headerlink" title="994. 腐烂的橘子"></a>994. 腐烂的橘子</h1><p><a href="https://leetcode-cn.com/problems/rotting-oranges/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/rotting-oranges/</a></p>
<h2 id="题目描述-10"><a href="#题目描述-10" class="headerlink" title="题目描述"></a>题目描述</h2><p>在给定的网格中，每个单元格可以有以下三个值之一：</p>
<p>值 <code>0</code> 代表空单元格；<br>值 <code>1</code> 代表新鲜橘子；<br>值 <code>2</code> 代表腐烂的橘子。<br>每分钟，任何与腐烂的橘子（在 4 个正方向上）相邻的新鲜橘子都会腐烂。</p>
<p>返回直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 <code>-1</code>。</p>
<p>示例 1：</p>
<p><img src="http://images.yingwai.top/picgo/oranges.png" alt=""></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入：[[<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>]]</span><br><span class="line">输出：<span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入：[[<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>]]</span><br><span class="line">输出：<span class="number">-1</span></span><br><span class="line">解释：左下角的橘子（第 <span class="number">2</span> 行， 第 <span class="number">0</span> 列）永远不会腐烂，因为腐烂只会发生在 <span class="number">4</span> 个正向上。</span><br></pre></td></tr></table></figure>
<p>示例 3：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入：[[<span class="number">0</span>,<span class="number">2</span>]]</span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：因为 <span class="number">0</span> 分钟时已经没有新鲜橘子了，所以答案就是 <span class="number">0</span> 。</span><br></pre></td></tr></table></figure>
<p>提示：</p>
<ol>
<li><code>1 &lt;= grid.length &lt;= 10</code></li>
<li><code>1 &lt;= grid[0].length &lt;= 10</code></li>
<li><code>grid[i][j]</code>仅为<code>0</code>、<code>1</code>或<code>2</code></li>
</ol>
<h2 id="思路-10"><a href="#思路-10" class="headerlink" title="思路"></a>思路</h2><p>广度优先搜索，一圈一圈往外腐蚀。</p>
<h2 id="代码-10"><a href="#代码-10" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">orangesRotting</span><span class="params">(self, grid: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        dx = [<span class="number">-1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">        dy = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>]</span><br><span class="line">        rotlist = list()    <span class="comment"># 腐烂橘子的队列</span></span><br><span class="line">        minute = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(grid)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(grid[<span class="number">0</span>])):</span><br><span class="line">                <span class="keyword">if</span> grid[i][j] == <span class="number">2</span>:</span><br><span class="line">                    rotlist.append([i, j])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> rotlist:  <span class="comment"># BFS循环</span></span><br><span class="line">            newrotlist = list()</span><br><span class="line">            <span class="keyword">for</span> rotorange <span class="keyword">in</span> rotlist:   <span class="comment"># 当前腐烂橘子的坐标</span></span><br><span class="line">                x0 = rotorange[<span class="number">0</span>]</span><br><span class="line">                y0 = rotorange[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):  <span class="comment"># 四个相邻方向的橘子腐烂</span></span><br><span class="line">                    x = x0 + dx[i]</span><br><span class="line">                    y = y0 + dy[i]</span><br><span class="line">                    <span class="keyword">if</span> <span class="number">0</span>&lt;=x&lt;len(grid) <span class="keyword">and</span> <span class="number">0</span>&lt;=y&lt;len(grid[<span class="number">0</span>]) <span class="keyword">and</span> grid[x][y]==<span class="number">1</span>:</span><br><span class="line">                        grid[x][y] = <span class="number">2</span></span><br><span class="line">                        newrotlist.append([x, y])</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> newrotlist:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">            minute += <span class="number">1</span></span><br><span class="line">            rotlist = newrotlist[:]     <span class="comment"># 更新腐烂队列</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> grid:</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> row:</span><br><span class="line">                    <span class="keyword">if</span> i == <span class="number">1</span>:  <span class="comment"># 还有新鲜的</span></span><br><span class="line">                        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> minute</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>PyTorch入门60题</title>
    <url>/2020/05/20/PyTorch%E5%85%A5%E9%97%A860%E9%A2%98/</url>
    <content><![CDATA[<h2 id="张量"><a href="#张量" class="headerlink" title="张量"></a>张量</h2><p>导入pytorch包</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>创建一个空的5x3张量</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = torch.empty(<span class="number">5</span>, <span class="number">3</span>)</span><br><span class="line">print(x)</span><br></pre></td></tr></table></figure>
<p>创建一个随机初始化的5x3张量</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = torch.rand(<span class="number">5</span>, <span class="number">3</span>)</span><br><span class="line">print(x)</span><br></pre></td></tr></table></figure>
<p>创建一个5x3的0张量，类型为long</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = torch.zeros(<span class="number">5</span>, <span class="number">3</span>, dtype=torch.long)</span><br><span class="line">print(x)</span><br></pre></td></tr></table></figure>
<p>直接从数组创建张量</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = torch.tensor([<span class="number">5.5</span>, <span class="number">3</span>])</span><br><span class="line">print(x)</span><br></pre></td></tr></table></figure>
<p>创建一个5x3的单位张量，类型为double</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = torch.ones(<span class="number">5</span>, <span class="number">3</span>, dtype=torch.double)</span><br><span class="line">print(x)</span><br></pre></td></tr></table></figure>
<p>从已有的张量创建相同维度的新张量，并且重新定义类型为float</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = torch.randn_like(x, dtype=torch.float)</span><br><span class="line">print(x)</span><br></pre></td></tr></table></figure>
<p>打印一个张量的维度</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(x.size())</span><br></pre></td></tr></table></figure>
<p>将两个张量相加</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">y = torch.rand(<span class="number">5</span>, <span class="number">3</span>)</span><br><span class="line">print(x + y)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法二</span></span><br><span class="line"><span class="comment"># print(torch.add(x, y))</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法三</span></span><br><span class="line"><span class="comment"># result = torch.empty(5, 3)</span></span><br><span class="line"><span class="comment"># torch.add(x, y, out=result)</span></span><br><span class="line"><span class="comment"># print(result)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法四</span></span><br><span class="line"><span class="comment"># y.add_(x)</span></span><br><span class="line"><span class="comment"># print(y)</span></span><br></pre></td></tr></table></figure>
<p>取张量的第一列</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(x[:, <span class="number">1</span>])</span><br></pre></td></tr></table></figure>
<p>将一个4x4的张量resize成一个一维张量</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = torch.randn(<span class="number">4</span>, <span class="number">4</span>)</span><br><span class="line">y = x.view(<span class="number">16</span>)</span><br><span class="line">print(x.size(),y.size())</span><br></pre></td></tr></table></figure>
<p>将一个4x4的张量，resize成一个2x8的张量</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">y = x.view(<span class="number">2</span>, <span class="number">8</span>)</span><br><span class="line">print(x.size(),y.size())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法二</span></span><br><span class="line">z = x.view(<span class="number">-1</span>, <span class="number">8</span>) <span class="comment"># 确定一个维度，-1的维度会被自动计算</span></span><br><span class="line">print(x.size(),z.size())</span><br></pre></td></tr></table></figure>
<p>从张量中取出数字</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = torch.randn(<span class="number">1</span>)</span><br><span class="line">print(x)</span><br><span class="line">print(x.item())</span><br></pre></td></tr></table></figure>
<h3 id="Numpy的操作"><a href="#Numpy的操作" class="headerlink" title="Numpy的操作"></a>Numpy的操作</h3><p>将张量装换成numpy数组</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = torch.ones(<span class="number">5</span>)</span><br><span class="line">print(a)</span><br><span class="line"></span><br><span class="line">b = a.numpy()</span><br><span class="line">print(b)</span><br></pre></td></tr></table></figure>
<p>将张量+1，并观察上题中numpy数组的变化</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a.add_(<span class="number">1</span>)</span><br><span class="line">print(a)</span><br><span class="line">print(b)</span><br></pre></td></tr></table></figure>
<p>从numpy数组创建张量</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a = np.ones(<span class="number">5</span>)</span><br><span class="line">b = torch.from_numpy(a)</span><br><span class="line">print(a)</span><br><span class="line">print(b)</span><br></pre></td></tr></table></figure>
<p>将numpy数组+1并观察上题中张量的变化</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.add(a, <span class="number">1</span>, out=a)</span><br><span class="line">print(a)</span><br><span class="line">print(b)</span><br></pre></td></tr></table></figure>
<h2 id="自动微分"><a href="#自动微分" class="headerlink" title="自动微分"></a>自动微分</h2><h3 id="张量的自动微分"><a href="#张量的自动微分" class="headerlink" title="张量的自动微分"></a>张量的自动微分</h3><p>新建一个张量，并设置<code>requires_grad=True</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = torch.ones(<span class="number">2</span>, <span class="number">2</span>, requires_grad=<span class="literal">True</span>)</span><br><span class="line">print(x)</span><br></pre></td></tr></table></figure>
<p>对张量进行任意操作（y = x + 2）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">y = x + <span class="number">2</span></span><br><span class="line">print(y)</span><br><span class="line">print(y.grad_fn) <span class="comment"># y就多了一个AddBackward</span></span><br></pre></td></tr></table></figure>
<p>再对y进行任意操作</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">z = y * y * <span class="number">3</span></span><br><span class="line">out = z.mean()</span><br><span class="line"></span><br><span class="line">print(z) <span class="comment"># z多了MulBackward</span></span><br><span class="line">print(out) <span class="comment"># out多了MeanBackward</span></span><br></pre></td></tr></table></figure>
<h3 id="梯度"><a href="#梯度" class="headerlink" title="梯度"></a>梯度</h3><p>对out进行反向传播</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">out.backward()</span><br></pre></td></tr></table></figure>
<p>打印梯度d(out)/dx</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(x.grad) <span class="comment">#out=0.25*Σ3(x+2)^2</span></span><br></pre></td></tr></table></figure>
<p>创建一个结果为矢量的计算过程（y=x*2^n）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = torch.randn(<span class="number">3</span>, requires_grad=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">y = x * <span class="number">2</span></span><br><span class="line"><span class="keyword">while</span> y.data.norm() &lt; <span class="number">1000</span>:</span><br><span class="line">    y = y * <span class="number">2</span></span><br><span class="line"></span><br><span class="line">print(y)</span><br></pre></td></tr></table></figure>
<p>计算<code>v = [0.``1, 1.0, 0.0001]</code>处的梯度</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">v = torch.tensor([<span class="number">0.1</span>, <span class="number">1.0</span>, <span class="number">0.0001</span>], dtype=torch.float)</span><br><span class="line">y.backward(v)</span><br><span class="line"></span><br><span class="line">print(x.grad)</span><br></pre></td></tr></table></figure>
<p>关闭梯度的功能</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(x.requires_grad)</span><br><span class="line">print((x ** <span class="number">2</span>).requires_grad)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> torch.no_grad():</span><br><span class="line">    print((x ** <span class="number">2</span>).requires_grad)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 方法二</span></span><br><span class="line"><span class="comment"># print(x.requires_grad)</span></span><br><span class="line"><span class="comment"># y = x.detach()</span></span><br><span class="line"><span class="comment"># print(y.requires_grad)</span></span><br><span class="line"><span class="comment"># print(x.eq(y).all())</span></span><br></pre></td></tr></table></figure>
<h2 id="神经网络"><a href="#神经网络" class="headerlink" title="神经网络"></a>神经网络</h2><p>pytorch实现LeNet5，结构如下所示</p>
<p><img src="https://img-blog.csdn.net/20171119174011391?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjg5NzM3NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Net</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super(Net, self).__init__()</span><br><span class="line">        <span class="comment"># 26.定义①的卷积层，输入为32x32的图像，卷积核大小5x5卷积核种类6</span></span><br><span class="line">        self.conv1 = nn.Conv2d(<span class="number">3</span>, <span class="number">6</span>, <span class="number">5</span>)</span><br><span class="line">        <span class="comment"># 27.定义③的卷积层，输入为前一层6个特征，卷积核大小5x5，卷积核种类16</span></span><br><span class="line">        self.conv2 = nn.Conv2d(<span class="number">6</span>, <span class="number">16</span>, <span class="number">5</span>)</span><br><span class="line">        <span class="comment"># 28.定义⑤的全链接层，输入为16*5*5，输出为120</span></span><br><span class="line">        self.fc1 = nn.Linear(<span class="number">16</span> * <span class="number">5</span> * <span class="number">5</span>, <span class="number">120</span>)  <span class="comment"># 6*6 from image dimension</span></span><br><span class="line">        <span class="comment"># 29.定义⑥的全连接层，输入为120，输出为84</span></span><br><span class="line">        self.fc2 = nn.Linear(<span class="number">120</span>, <span class="number">84</span>)</span><br><span class="line">        <span class="comment"># 30.定义⑥的全连接层，输入为84，输出为10</span></span><br><span class="line">        self.fc3 = nn.Linear(<span class="number">84</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="comment"># 31.完成input-S2，先卷积+relu，再2x2下采样</span></span><br><span class="line">        x = F.max_pool2d(F.relu(self.conv1(x)), (<span class="number">2</span>, <span class="number">2</span>))</span><br><span class="line">        <span class="comment"># 32.完成S2-S4，先卷积+relu，再2x2下采样</span></span><br><span class="line">        x = F.max_pool2d(F.relu(self.conv2(x)), <span class="number">2</span>) <span class="comment">#卷积核方形时，可以只写一个维度</span></span><br><span class="line">        <span class="comment"># 33.将特征向量扁平成列向量</span></span><br><span class="line">        x = x.view(<span class="number">-1</span>, <span class="number">16</span> * <span class="number">5</span> * <span class="number">5</span>)</span><br><span class="line">        <span class="comment"># 34.使用fc1+relu</span></span><br><span class="line">        x = F.relu(self.fc1(x))</span><br><span class="line">        <span class="comment"># 35.使用fc2+relu</span></span><br><span class="line">        x = F.relu(self.fc2(x))</span><br><span class="line">        <span class="comment"># 36.使用fc3</span></span><br><span class="line">        x = self.fc3(x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">net = Net()</span><br><span class="line">print(net)</span><br></pre></td></tr></table></figure>
<p>打印网络的参数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">params = list(net.parameters())</span><br><span class="line"><span class="comment"># print(params)</span></span><br><span class="line">print(len(params))</span><br></pre></td></tr></table></figure>
<p>打印某一层参数的形状</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(params[<span class="number">0</span>].size())</span><br></pre></td></tr></table></figure>
<p>随机输入一个向量，查看前向传播输出</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">input = torch.randn(<span class="number">1</span>, <span class="number">1</span>, <span class="number">32</span>, <span class="number">32</span>)</span><br><span class="line">out = net(input)</span><br><span class="line">print(out)</span><br></pre></td></tr></table></figure>
<p>将梯度初始化</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">net.zero_grad()</span><br></pre></td></tr></table></figure>
<p>随机一个梯度进行反向传播</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">out.backward(torch.randn(<span class="number">1</span>, <span class="number">10</span>))</span><br></pre></td></tr></table></figure>
<h3 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h3><p>用自带的MSELoss()定义损失函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">criterion = nn.MSELoss()</span><br></pre></td></tr></table></figure>
<p>随机一个真值，并用随机的输入计算损失</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">target = torch.randn(<span class="number">10</span>)  <span class="comment"># 随机真值</span></span><br><span class="line">target = target.view(<span class="number">1</span>, <span class="number">-1</span>)  <span class="comment"># 变成列向量</span></span><br><span class="line"></span><br><span class="line">output = net(input)  <span class="comment"># 用随机输入计算输出</span></span><br><span class="line"></span><br><span class="line">loss = criterion(output, target)  <span class="comment"># 计算损失</span></span><br><span class="line">print(loss)</span><br></pre></td></tr></table></figure>
<p>将梯度初始化，计算上一步中loss的反向传播</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">net.zero_grad()</span><br><span class="line"></span><br><span class="line">print(<span class="string">'conv1.bias.grad before backward'</span>)</span><br><span class="line">print(net.conv1.bias.grad)</span><br></pre></td></tr></table></figure>
<p>计算43中loss的反向传播</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">loss.backward()</span><br><span class="line"></span><br><span class="line">print(<span class="string">'conv1.bias.grad after backward'</span>)</span><br><span class="line">print(net.conv1.bias.grad)</span><br></pre></td></tr></table></figure>
<h3 id="更新权重"><a href="#更新权重" class="headerlink" title="更新权重"></a>更新权重</h3><p>定义SGD优化器算法，学习率设置为0.01</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch.optim <span class="keyword">as</span> optim</span><br><span class="line">optimizer = optim.SGD(net.parameters(), lr=<span class="number">0.01</span>)</span><br></pre></td></tr></table></figure>
<p>使用优化器更新权重</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">optimizer.zero_grad()</span><br><span class="line">output = net(input)</span><br><span class="line">loss = criterion(output, target)</span><br><span class="line">loss.backward()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新权重</span></span><br><span class="line">optimizer.step()</span><br></pre></td></tr></table></figure>
<h2 id="训练一个分类器"><a href="#训练一个分类器" class="headerlink" title="训练一个分类器"></a>训练一个分类器</h2><h3 id="读取CIFAR10数据，做标准化"><a href="#读取CIFAR10数据，做标准化" class="headerlink" title="读取CIFAR10数据，做标准化"></a>读取CIFAR10数据，做标准化</h3><p>构造一个transform，将三通道(0,1)区间的数据转换成(-1,1)的数据</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torchvision</span><br><span class="line"><span class="keyword">import</span> torchvision.transforms <span class="keyword">as</span> transforms</span><br><span class="line"></span><br><span class="line">transform = transforms.Compose(</span><br><span class="line">    [transforms.ToTensor(),</span><br><span class="line">     transforms.Normalize((<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>), (<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>))])</span><br></pre></td></tr></table></figure>
<p>读取数据集</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">trainset = cifar(root = <span class="string">'./input/cifar10'</span>, segmentation=<span class="string">'train'</span>, transforms=transform)</span><br><span class="line">testset = cifar(root = <span class="string">'./input/cifar10'</span>, segmentation=<span class="string">'test'</span>, transforms=transform)</span><br><span class="line">trainloader = torch.utils.data.DataLoader(trainset, batch_size=batch_size,shuffle=<span class="literal">True</span>, num_workers=<span class="number">2</span>)</span><br><span class="line">testloader = torch.utils.data.DataLoader(testset, batch_size=batch_size,shuffle=<span class="literal">False</span>, num_workers=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">classes = (<span class="string">'plane'</span>, <span class="string">'car'</span>, <span class="string">'bird'</span>, <span class="string">'cat'</span>,</span><br><span class="line">           <span class="string">'deer'</span>, <span class="string">'dog'</span>, <span class="string">'frog'</span>, <span class="string">'horse'</span>, <span class="string">'ship'</span>, <span class="string">'truck'</span>)</span><br></pre></td></tr></table></figure>
<h3 id="建立网络"><a href="#建立网络" class="headerlink" title="建立网络"></a>建立网络</h3><p>这部分沿用前面的网络</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">net2 = Net()</span><br></pre></td></tr></table></figure>
<h3 id="定义损失函数和优化器"><a href="#定义损失函数和优化器" class="headerlink" title="定义损失函数和优化器"></a>定义损失函数和优化器</h3><p>定义交叉熵损失函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">criterion2 = nn.CrossEntropyLoss()</span><br></pre></td></tr></table></figure>
<p>定义SGD优化器算法，学习率设置为0.001，<code>momentum=0.9</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">optimizer2 = optim.SGD(net2.parameters(), lr=<span class="number">0.001</span>, momentum=<span class="number">0.9</span>)</span><br></pre></td></tr></table></figure>
<h3 id="训练网络"><a href="#训练网络" class="headerlink" title="训练网络"></a>训练网络</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> range(<span class="number">2</span>):</span><br><span class="line"></span><br><span class="line">    running_loss = <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">for</span> i, data <span class="keyword">in</span> enumerate(trainloader, <span class="number">0</span>):</span><br><span class="line">        <span class="comment"># 获取X,y对</span></span><br><span class="line">        inputs, labels = data</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 51.初始化梯度</span></span><br><span class="line">        optimizer2.zero_grad()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 52.前馈</span></span><br><span class="line">        outputs = net2(inputs)</span><br><span class="line">        <span class="comment"># 53.计算损失</span></span><br><span class="line">        loss = criterion2(outputs, labels)</span><br><span class="line">        <span class="comment"># 54.计算梯度</span></span><br><span class="line">        loss.backward()</span><br><span class="line">        <span class="comment"># 55.更新权值</span></span><br><span class="line">        optimizer2.step()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 每2000个数据打印平均代价函数值</span></span><br><span class="line">        running_loss += loss.item()</span><br><span class="line">        <span class="keyword">if</span> i % <span class="number">2000</span> == <span class="number">1999</span>:    <span class="comment"># print every 2000 mini-batches</span></span><br><span class="line">            print(<span class="string">'[%d, %5d] loss: %.3f'</span> %</span><br><span class="line">                  (epoch + <span class="number">1</span>, i + <span class="number">1</span>, running_loss / <span class="number">2000</span>))</span><br><span class="line">            running_loss = <span class="number">0.0</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">'Finished Training'</span>)</span><br></pre></td></tr></table></figure>
<h3 id="使用模型预测"><a href="#使用模型预测" class="headerlink" title="使用模型预测"></a>使用模型预测</h3><p>取一些数据</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dataiter = iter(testloader)</span><br><span class="line">images, labels = dataiter.next()</span><br><span class="line"></span><br><span class="line"><span class="comment"># print images</span></span><br><span class="line">imshow(torchvision.utils.make_grid(images))</span><br><span class="line">print(<span class="string">'GroundTruth: '</span>, <span class="string">' '</span>.join(<span class="string">'%5s'</span> % classes[labels[j]] <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">4</span>)))</span><br></pre></td></tr></table></figure>
<p>使用模型预测</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">outputs = net2(images)</span><br><span class="line"></span><br><span class="line">_, predicted = torch.max(outputs, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'Predicted: '</span>, <span class="string">' '</span>.join(<span class="string">'%5s'</span> % classes[predicted[j]]</span><br><span class="line">                              <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">4</span>)))</span><br></pre></td></tr></table></figure>
<p>在测试集上进行打分</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">correct = <span class="number">0</span></span><br><span class="line">total = <span class="number">0</span></span><br><span class="line"><span class="keyword">with</span> torch.no_grad():</span><br><span class="line">    <span class="keyword">for</span> data <span class="keyword">in</span> testloader:</span><br><span class="line">        images, labels = data</span><br><span class="line">        outputs = net2(images)</span><br><span class="line">        _, predicted = torch.max(outputs.data, <span class="number">1</span>)</span><br><span class="line">        total += labels.size(<span class="number">0</span>)</span><br><span class="line">        correct += (predicted == labels).sum().item()</span><br><span class="line"></span><br><span class="line">print(<span class="string">'Accuracy of the network on the 10000 test images: %d %%'</span> % (</span><br><span class="line">    <span class="number">100</span> * correct / total))</span><br></pre></td></tr></table></figure>
<h3 id="存取模型"><a href="#存取模型" class="headerlink" title="存取模型"></a>存取模型</h3><p>保存训练好的模型</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">PATH = <span class="string">'./cifar_net.pth'</span></span><br><span class="line">torch.save(net.state_dict(), PATH)</span><br></pre></td></tr></table></figure>
<p>读取保存的模型</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pretrained_net = torch.load(PATH)</span><br></pre></td></tr></table></figure>
<p>加载模型</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">net3 = Net()</span><br><span class="line">net3.load_state_dict(pretrained_net)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>PyTorch</tag>
      </tags>
  </entry>
  <entry>
    <title>不经意传输（Oblivious Transfer）</title>
    <url>/2020/04/25/%E4%B8%8D%E7%BB%8F%E6%84%8F%E4%BC%A0%E8%BE%93%EF%BC%88Oblivious-Transfer%EF%BC%89/</url>
    <content><![CDATA[<p><em>设S有一个秘密，想以1/2的概率传递给R，即B有50%的机会收到这个秘密，另外50%的机会什么也没有收到，协议执行完后，B知道自己是否收到了这个秘密，但S却不知道R是否收到了这个秘密。这种协议就称为不经意传输协议。</em></p>
<a id="more"></a>
<p>​        例如A是机密的出售者，S列举了很多问题，意欲出售各个问题的答案，R想买其中一个问题的答案，但又不想让A知道自己买的是哪个问题的答案。</p>
<h2 id="1-out-of-2-OT"><a href="#1-out-of-2-OT" class="headerlink" title="1-out-of-2 OT"></a>1-out-of-2 OT</h2><p>OT最早在1981年被 Michael O. Rabin提出，在Rabin的OT协议中，发送者S发送一个信息m给接收者R，接收者R以1/2的概率接受信息m。所以在协议交互的结束的时候，S并不知道R是否接受了消息。该方案是基于RSA加密体系构造的。</p>
<p>1985年S. Even, O. Goldreich, and A. Lempel提出了1-out-2 OT,在新的方案中S每次发送2个信息 $m_0$ 和 $m_1$，而R每次输入一个选择 $b$。当协议结束的时候，S无法获得关于 $b$ 的任何有价值的信息，而R只能获得 $m_b$ ，对于 $m_{1-b}$ ，R也一无所知。<br><img src="http://images.yingwai.top/picgo/OTf1.png" alt=""></p>
<h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><p>S要传送两条信息，不妨设为两个比特 $b_0$ 和 $b_1$，而R只能选择接受其中一个比特 $b_{\theta}$。协议要保证S和R的安全，即：</p>
<ul>
<li>S不能知道任何关于 $\theta$ 的信息；</li>
<li>R不能知道任何关于 $b_{1-\theta}$ 的信息。</li>
</ul>
<p>为了达成上面两点要求，构造如下协议：</p>
<ol>
<li><p>S选择好两个比特信息 $b_0$ 和 $b_1$；</p>
</li>
<li><p>S运行密钥生成算法（例如RSA）生成公私钥对（$sk,pk$）；</p>
</li>
<li><p>S保密私钥，同时S要生成两个随机数 $x_0$ 和 $x_1$，并将这两个随机数和公钥一并传送给R；</p>
</li>
<li><p>R选择 $\theta$，并生成一个数 $r$，R用S的公钥加密 $r$，并生成信息</p>
<p>​                                <script type="math/tex">v =x_{\theta}+E_{pk}(r)</script></p>
</li>
<li><p>S在接收到 $v$ 之后，进行如下计算：</p>
<p>​                                $r_{0}=D_{s k}\left(v-x_{0}\right)$<br>​                                $r_{1}=D_{s k}\left(v-x_{1}\right)$</p>
</li>
<li><p>S进行如下计算：</p>
<p>​                                $b_{0}^{\prime}=b_{0}+r_{0}$<br>​                                $b_{1}^{\prime}=b_{1}+r_{1}$</p>
<p>并将 $b’_0$ 和 $b’_1$ 传送给R；</p>
</li>
<li><p>接收到 $b’_0$ 和 $b’_1$ 后，R进行如下计算：</p>
<p>​                                $b_\theta = b’_\theta - r$</p>
</li>
</ol>
<h3 id="正确性"><a href="#正确性" class="headerlink" title="正确性"></a>正确性</h3><p>进行如下推导：</p>
<p>​                                $b_{\theta}^{\prime}-r=b_{\theta}+r_{\theta}-r=b_{\theta}+D_{s k}\left(v-x_{\theta}\right)-r$</p>
<p>而</p>
<p>​                        $D_{s k}(v-x_\theta)=D_{s k}\left(x_\theta+E_{p k}(r)-x_{\theta}\right)=D_{s k}\left(E_{p k}(r)\right)=r$</p>
<p>因此可得</p>
<p>​                                            $b’_\theta - r = b_\theta$</p>
<h3 id="对于S的安全性"><a href="#对于S的安全性" class="headerlink" title="对于S的安全性"></a>对于S的安全性</h3><p>对于S来说，它的安全性要求R不能推断出 $b_{1-\theta}$。R得到 $b’_\theta$ 和 $b’_{1-\theta}$ 之后，由协议可知R可以正确计算 $b’_\theta$ ，下面证明R不能计算出 $b_{1-\theta}$。</p>
<p>​                        $b_{1-\theta}^{\prime}-r=b_{1-\theta}+D_{s k}\left(v-x_{\theta}\right)-r$</p>
<p>而</p>
<p>​                    $D_{s k}\left(v-x_{\theta}\right)=D_{s k}\left(x_{1-\theta}+E_{p k}(r)-x_{\theta}\right) \neq r$</p>
<p>而且根据加密的特性，$D_{s k}\left(x_{1-\theta}+E_{p k}(r)-x_{\theta}\right)-r$ 与随机数是不可区分的，所以 $b’_{1-\theta}-r$ 与随机数是不可区分的。因此协议对S是安全的。</p>
<h3 id="对于R的安全性"><a href="#对于R的安全性" class="headerlink" title="对于R的安全性"></a>对于R的安全性</h3><p>R的安全性要求S不能获得关于 $\theta$ 任何有价值的信息。</p>
<p>因为 $r$ 是随机数，所以 $E_{pk}(r)$ 与随机数是不可区分的。因此 $v$ 与随机数是不可区分的，所以S不能从 $v$ 获得关于 $\theta$ 有价值的信息。</p>
]]></content>
      <categories>
        <category>Study</category>
      </categories>
      <tags>
        <tag>密码学</tag>
        <tag>MPC</tag>
      </tags>
  </entry>
  <entry>
    <title>使用you-get下载网址视频</title>
    <url>/2020/05/20/%E4%BD%BF%E7%94%A8you-get%E4%B8%8B%E8%BD%BD%E7%BD%91%E5%9D%80%E8%A7%86%E9%A2%91/</url>
    <content><![CDATA[<p>很多时候想随时随地在线看视频不是那么容易，尤其是YouTube上的视频，所以把视频下载到本地还是有必要的，这里就介绍一个下载视频的工具——you-get。</p>
<a id="more"></a>
<p>you-get是基于Python开发的，实际它不只支持视频下载，还支持图片、音乐等。而且，只要视频的地址，一行代码即可。</p>
<h1 id="安装you-get"><a href="#安装you-get" class="headerlink" title="安装you-get"></a>安装you-get</h1><p>安装you-get的方式有很多，下面三种择其一即可。</p>
<h2 id="使用pip安装"><a href="#使用pip安装" class="headerlink" title="使用pip安装"></a>使用pip安装</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> pip3 install you-get</span></span><br></pre></td></tr></table></figure>
<p><img src="http://images.yingwai.top/picgo/yougetf1.png" alt=""></p>
<h2 id="Git克隆"><a href="#Git克隆" class="headerlink" title="Git克隆"></a>Git克隆</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> git://github.com/soimort/you-get.git</span></span><br></pre></td></tr></table></figure>
<p>然后直接运行<code>./setup.py</code>即可</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> python3 setup.py install</span></span><br></pre></td></tr></table></figure>
<h2 id="通过HomeBrew安装（Mac）"><a href="#通过HomeBrew安装（Mac）" class="headerlink" title="通过HomeBrew安装（Mac）"></a>通过HomeBrew安装（Mac）</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> brew install you-get</span></span><br></pre></td></tr></table></figure>
<h1 id="下载视频"><a href="#下载视频" class="headerlink" title="下载视频"></a>下载视频</h1><p>命令行中输入以下代码下载视频：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> you-get <span class="string">'视频地址URL'</span></span></span><br></pre></td></tr></table></figure>
<p>这里以B站某视频为例：</p>
<p><img src="http://images.yingwai.top/picgo/yougetf2.png" alt=""></p>
<p>下载好的视频存放在系统盘的用户目录下。</p>
<h1 id="查看视频信息"><a href="#查看视频信息" class="headerlink" title="查看视频信息"></a>查看视频信息</h1><p>命令行输入：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> you-get -i <span class="string">'视频地址URL'</span></span></span><br></pre></td></tr></table></figure>
<p>用刚刚下载的视频测试，结果如下：</p>
<p><img src="http://images.yingwai.top/picgo/yougetf3.png" alt=""></p>
<p>可以看到它的默认设置不是MP4格式的视频，如果想要换成这种格式，可以在命令行输入：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> you-get --itag=18 <span class="string">'视频地址URL'</span></span></span><br></pre></td></tr></table></figure>
<h1 id="支持的网站"><a href="#支持的网站" class="headerlink" title="支持的网站"></a>支持的网站</h1><p>除了B站，还可以用you-get下载国内外很多主流网站的视频、图片和音乐。</p>
<p>这里列出支持的国外网站：</p>
<p><img src="http://images.yingwai.top/picgo/yougetf4.jpg" alt=""></p>
]]></content>
      <categories>
        <category>Env</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>解决Ubuntu deepin-wine微信字体乱码</title>
    <url>/2020/04/24/%E8%A7%A3%E5%86%B3Ubuntu-deepin-wine%E5%BE%AE%E4%BF%A1%E5%AD%97%E4%BD%93%E4%B9%B1%E7%A0%81/</url>
    <content><![CDATA[<h1 id="解决乱码-修改字体-微软雅黑"><a href="#解决乱码-修改字体-微软雅黑" class="headerlink" title="解决乱码+修改字体(微软雅黑)"></a>解决乱码+修改字体(微软雅黑)</h1><p>下载微软雅黑字体,msyh.ttc</p>
<a id="more"></a>
<h2 id="添加字体"><a href="#添加字体" class="headerlink" title="添加字体"></a>添加字体</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cp msyh.ttc ~/.deepinwine/Deepin-WeChat/drive_c/windows/Fonts</span></span><br></pre></td></tr></table></figure>
<h2 id="修改系统注册表"><a href="#修改系统注册表" class="headerlink" title="修改系统注册表"></a>修改系统注册表</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gedit ~/.deepinwine/Deepin-WeChat/system.reg</span></span><br></pre></td></tr></table></figure>
<p>修改以下两行</p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line"><span class="string">"MS Shell Dlg"</span>=<span class="string">"msyh"</span></span><br><span class="line"><span class="string">"MS Shell Dlg 2"</span>=<span class="string">"msyh"</span></span><br></pre></td></tr></table></figure>
<h2 id="字体注册"><a href="#字体注册" class="headerlink" title="字体注册"></a>字体注册</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gedit msyh_config.reg</span></span><br></pre></td></tr></table></figure>
<p>内容添加</p>
<figure class="highlight moonscript"><table><tr><td class="code"><pre><span class="line">REGEDIT4</span><br><span class="line">[HKEY_LOCAL_MACHINE\Software\Microsoft\Windows NT\CurrentVersion\FontLink\SystemLink]</span><br><span class="line"><span class="string">"Lucida Sans Unicode"</span>=<span class="string">"msyh.ttc"</span></span><br><span class="line"><span class="string">"Microsoft Sans Serif"</span>=<span class="string">"msyh.ttc"</span></span><br><span class="line"><span class="string">"MS Sans Serif"</span>=<span class="string">"msyh.ttc"</span></span><br><span class="line"><span class="string">"Tahoma"</span>=<span class="string">"msyh.ttc"</span></span><br><span class="line"><span class="string">"Tahoma Bold"</span>=<span class="string">"msyhbd.ttc"</span></span><br><span class="line"><span class="string">"msyh"</span>=<span class="string">"msyh.ttc"</span></span><br><span class="line"><span class="string">"Arial"</span>=<span class="string">"msyh.ttc"</span></span><br><span class="line"><span class="string">"Arial Black"</span>=<span class="string">"msyh.ttc"</span></span><br><span class="line">#注册</span><br><span class="line">WINEPREFIX=~/.deepinwine/Deepin-WeChat deepin-wine regedit msyh_config.reg</span><br></pre></td></tr></table></figure>
<h2 id="Reboot"><a href="#Reboot" class="headerlink" title="Reboot"></a>Reboot</h2>]]></content>
      <categories>
        <category>Env</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>论文笔记 ASTRA: High Throughput 3PC over Rings with Application to Secure Prediction</title>
    <url>/2020/04/20/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0-ASTRA-High-Throughput-3PC-over-Rings-with-Application-to-Secure-Prediction/</url>
    <content><![CDATA[<p><em>Harsh Chaudhari, Ashish Choudhury, Arpita Patra, Ajith Suresh</em></p>
<p>ACM CCSW 2019</p>
<p><a href="https://eprint.iacr.org/2019/429" target="_blank" rel="noopener">https://eprint.iacr.org/2019/429</a></p>
<p><a href="https://dl.acm.org/doi/10.1145/3338466.3358922" target="_blank" rel="noopener">https://dl.acm.org/doi/10.1145/3338466.3358922</a></p>
<a id="more"></a>
<p><img src="http://images.yingwai.top/picgo/ASTRA.jpg" alt=""></p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>安全计算的具体效率一直是近年来许多工作关注的焦点。在本论文中，作者提出了一种具体有效的协议，用于模 $2^l$ 整数环上的安全三方计算（3PC），该协议具有半诚实模型和恶意模型上的安全性。由于环上的计算模拟了现实系统体系结构上的计算，所以环上的安全计算近来获得了发展势头。</p>
<p>​        在离线-在线模式中，本文的结构具体地呈现了最有效的在线阶段。在半诚实的设置下，本文的协议在在线阶段每个乘法门需要2个环元素的通信。在恶意设置下，本文的协议在在线阶段每个乘法门需要4个元素的通信，比最先进的协议需要的5个元素少。使用选择性中止和公平这两个安全概念来实现的公平恶意协议，与仅针对输出门的中止安全性的恶意协议相比，涉及的通信稍微多一些。</p>
<p>​        作者将本文的技术从3PC应用到安全的服务器辅助机器学习（ML）推理机制中，用于一系列预测函数——线性回归、线性SVM回归、Logistic回归和线性SVM分类。本文的设置考虑了拥有训练好的模型参数的模型所有者和查询的客户，后者愿意根据前者的模型参数来学习他查询的预测。输入和计算外包给一组三个非合谋的服务器。本文的构造既迎合了半诚实的世界，也迎合了恶意的世界，比现有的构造表现得更好。</p>
<h3 id="贡献"><a href="#贡献" class="headerlink" title="贡献"></a>贡献</h3><ul>
<li><p>作者遵循离线-在线模式，提出了在环 $\mathbb{Z}_{2^l}$（包括布尔环 $\mathbb{Z}_{2^1}$）上的3PC构造，具有最有效的在线阶段。</p>
<p>虽然重点放在在现阶段，但离线阶段的的成本也有注意并保持在可控范围内。</p>
</li>
<li><p>作者给出了一系列满足半诚实安全和恶意安全的构造。</p>
<p>将技术应用于外包环境中的一系列预测函数的安全预测，并构建了一些容忍半诚实和恶意对手的结构。</p>
</li>
</ul>
<p>本文所有的构建都流露出的一个共同特征：在线阶段不到三对参与者之间需要进行功能依赖的通信，从而产生更好的在线性能。</p>
<h2 id="设定"><a href="#设定" class="headerlink" title="设定"></a>设定</h2><p>本文考虑一组三方 $\mathcal{P}=\left\{P_0,P_1,P_2\right\}$，它们在同步网络中通过成对的私有和可信信道连接。要计算的函数 $f$ 被表示为环 $\mathbb{Z}_{2^l}$ 上的电路 ckt，该环由2输入加法和乘法门组成。假设 ckt 的拓扑是公知的。术语 D​ 表示 ckt 的乘法深度，而 I、O、A、M 分别表示 ckt 中的输入线、输出线、加法门和乘法门的数目。本文使用符号 $w_x$ 来表示导线 $w$，其中值 $x$ 流经它。本文使用 $g=(w_x,w_y,w_z)$ 来表示 ckt 中具有左输入线 $w_x$、右输入线 $w_y$ 和输出线 $w_z$ 的门。在本文的协议中，将 $\mathcal{P}$ 划分为互不相交的集合 $\left\{P_0\right\}$ 和 $\left\{P_1,P_2\right\}$，其中 $P_0$ 在离线阶段充当“分配器”进行“预处理”，在线阶段“评估者” $P_1$、$P_2$ 用它来评估 ckt。本文使用上标“$s$”和“$m$”分别区分半诚实和恶意设置中的协议。布尔环 $\mathbb{Z}_{2^1}$ 上的协议可以通过将算术加法$(+)$和乘法$(\times)$分别替换为异或$(\oplus)$和与$(\cdot)$来获得。</p>
<h3 id="共享密钥设置"><a href="#共享密钥设置" class="headerlink" title="共享密钥设置"></a>共享密钥设置</h3><p>为了保存双方之间的通信，使用为伪随机函数（PRF）$F$ 建立预共享随机密钥的一次性设置。在3PC设置[2，30，46]中的已知协议中已经使用了类似的设置。这里 $F:{\{0，1\}}^\kappa \times {\{0，1\}}^\kappa \to X$ 是安全的PRF，同域 $X$ 是 $\mathbb{Z}_{2^l}$。这组密钥是：</p>
<ul>
<li>每对参与方之间共享一个密钥— $k_{01}, k_{02}, k_{12}$，分别用于参与方$(P_0,P_1), (P_0,P_2), (P_1,P_2)$。</li>
<li>所有各方之间的一个共享密钥— $k_{\mathcal{p}}$。</li>
</ul>
<p>本文通过可以使用任何标准安全MPC协议实现的功能 $\mathcal{F}_{\rm setup}$ 来建立密钥设置模型。</p>
<h3 id="共享语义"><a href="#共享语义" class="headerlink" title="共享语义"></a>共享语义</h3><p>在本节中，将解释本工作中使用的秘密共享的两种变体。这两个变体都在算术（$\mathbb{Z}_{2^l}$）和布尔环（$\mathbb{Z}_{2^1}$）上运行。</p>
<p>$[\cdot]$-共享：如果 $P_1$ 和 $P_2$ 分别持有份额 $v_1$ 和 $v_2$，使得 $v=v_1+v_2$，则称值 $v$ 在$P_1,P_2$之间是 $[\cdot]$-共享的。用 $[\cdot]_{P_i}$ 表示 $P_i, i∈\{1,2\}$的 $[\cdot]$-份额。</p>
<p>$[\![\cdot]\!]$-共享：值 $v$ 在 $P_0, P_1, P_2$ 之间是$[\![\cdot]\!]$-共享的，如果</p>
<ul>
<li>存在值 $\lambda_v, m_v$ 使得 $v=m_v - \lambda_v$；</li>
<li>$P_0$ 持有 $\lambda_{v,1}$ 和 $\lambda_{v,2}$ 使得 $\lambda_{v} = \lambda_{v,1} + \lambda_{v,2}$；</li>
<li>$P_1$ 和 $P_2$ 分别持有 $(m_v, \lambda_{v,1})$ 和 $(m_v, \lambda_{v,1})$。</li>
</ul>
<p>本文将各方的$[\![\cdot]\!]$-共享表示为$[\![v]\!]_{P_0} = (\lambda_{v,1}, \lambda_{v,2}), [\![v]\!]_{P_1} = (m_v, \lambda_{v,1}) $和 $[\![v]\!]_{P_2} = (m_v, \lambda_{v,2})$。用$[\![v]\!] = (m_v, [\lambda_{v}])$表示 $v$ 的$[\![\cdot]\!]$-共享份额。</p>
<h3 id="秘密共享方案的线性"><a href="#秘密共享方案的线性" class="headerlink" title="秘密共享方案的线性"></a>秘密共享方案的线性</h3><p>给定 $x,y \in \mathbb{Z}_{2^l}$ 和公共常数 $c_1, c_2 \in \mathbb{Z}_{2^l}$的$[\cdot]$-共享，各方可以局部计算 $[c_1x+c_2y]$：</p>
<script type="math/tex; mode=display">[c_1x+c_2y]=(c_1x_1+c_2y_1, c_1x_2+c_2y_2)=c_1[x]+c_2[y]</script><p>很容易看出线性关系也扩展到$[\![\cdot]\!]$-共享。线性属性使各方能够<strong>本地</strong>执行与公共常量的加法和乘法等操作。</p>
<h2 id="3PC协议"><a href="#3PC协议" class="headerlink" title="3PC协议"></a>3PC协议</h2><h3 id="半诚实下的3PC"><a href="#半诚实下的3PC" class="headerlink" title="半诚实下的3PC"></a>半诚实下的3PC</h3><p>协议 $\prod ^{\rm s}_{\rm 3pc}$ 由三个步骤组成—输入共享、电路评估以及输出重构。所有阶段（重构输出除外）都分为离线和在线阶段，其中独立于实际输入的步骤可以在脱机阶段执行。</p>
<h4 id="输入共享"><a href="#输入共享" class="headerlink" title="输入共享"></a>输入共享</h4><p>在共享输入阶段，每一方都为自己的输入生成一个随机的$[\![\cdot]\!]$-共享。以下是初始共享协议 $\prod^{\rm s}_{\rm Sh}$：</p>
<hr>
<p><strong>Offline:</strong></p>
<ul>
<li>If $P_i = P_0$, parties $P_0, P_j$ for $j \in \{1, 2\}$ locally sample a random $\lambda_{x,j} \in \mathbb{Z}_{2^l}$. Moreover, $P_i$ sets $[\![x]\!]_{P_i} = (\lambda_{x,1}, \lambda_{x,2})$.</li>
<li>If $P_i = P_1$, parties $P_0, P_1$ sample a random $\lambda_{x,1} \in \mathbb{Z}_{2^l}$ while all the parties in $\mathcal{P}$ sample a random $\lambda_{x,2} \in \mathbb{Z}_{2^l}$.</li>
<li>If $P_i = P_2$, parties $P_0, P_2$ sample a random $\lambda_{x,2} \in \mathbb{Z}_{2^l}$ while all the parties in $\mathcal{P}$ sample a random $\lambda_{x,1} \in \mathbb{Z}_{2^l}$.</li>
</ul>
<p><strong>Online:</strong></p>
<p>​        $P_i$ computes $\lambda_x = \lambda_{x,1} + \lambda_{x,2}$ and sends $m_x = x + \lambda_x$ to every $P_j$ for $j \in \{1,2\}$ who then sets $[\![x]\!]_{P_j} = (m_x, \lambda_{x,j})$.</p>
<hr>
<p>在离线阶段根据输入方的序号，使用不同的初始化手段，生成了 $P_0$ 的份额 $[\![x]\!]_{P_0}=(\lambda_{x,1}, \lambda_{x,2})$，而不用任何交互（因为随机数都是使用服务器两两之间的公共随机源生成的，可以理解为编程语言中把同样的随机种子输入到random函数——只要随机种子一样生成的随机数序列就一样）。</p>
<h4 id="电路评估"><a href="#电路评估" class="headerlink" title="电路评估"></a>电路评估</h4><p>在电路评估阶段，各方以$[\![\cdot]\!]$-共享的方式评估 ckt。以拓扑顺序评估 ckt 中的每个门 $g$：给定 $g$ 的输入，各方为 $g$ 的输出生成$[\![\cdot]\!]$-共享。</p>
<h5 id="加法"><a href="#加法" class="headerlink" title="加法"></a>加法</h5><p>如果 $g$ 是加法门 $(w_x,w_y,w_z)$，可以利用$[\![\cdot]\!]$-共享的线性在本地完成。以下是加法协议 $\prod_{\rm Add} (w_x, w_y, w_z)$：</p>
<hr>
<p><strong>Offline:</strong></p>
<p>​        $P_0, P_1$ set $\lambda_{z,1} = \lambda_{x,1} + \lambda_{y,1}$, while $P_0, P_2$ set $\lambda_{z,2} = \lambda_{x,2} + \lambda_{y,2}$.</p>
<p><strong>Online:</strong></p>
<p>​        $P_1$ and $P_2$ set $m_z = m_x + m_y$.</p>
<hr>
<p>这里的加法协议感觉在线阶段完全可以在本地完成，可以不需要在线阶段。</p>
<h5 id="乘法"><a href="#乘法" class="headerlink" title="乘法"></a>乘法</h5><p>如果 $g=(w_x,w_y,w_z)$ 是乘法门，则运行以下乘法协议 $\prod ^{\rm s}_{\rm Mul}$：</p>
<hr>
<p><strong>Offline:</strong></p>
<ul>
<li>$P_0$ and $P_1$ locally sample random $\lambda_{z,1}, \gamma_{xy, 1} \in \mathbb{Z}_{2^l}$, while $P_0$ and $P_2$ locally sample random $\lambda_{z,2} \in \mathbb{Z}_{2^l}$.</li>
<li>$P_0$ computes $\gamma_{xy} = \lambda_x \lambda_y$ and sends $\gamma_{xy,2} = \gamma_{xy} - \gamma_{xy,1}$ to $P_2$.</li>
</ul>
<p><strong>Online:</strong></p>
<ul>
<li>$P_i$ for $i \in \{1,2\}$ locally computes $[m_z]_{P_i} = (i-1)m_xm_y - m_x[\lambda_y]_{P_i} - m_y[\lambda_x]_{P_i} + [\lambda_z]_{P_i} + [\gamma_{xy}]_{P_i}$.</li>
<li>$P_1, P_2$ mutually exchange their shares and reconstruct $m_z$.</li>
</ul>
<hr>
<p>将上面的公式相加一下即可验证其正确性。</p>
<h4 id="输出重构"><a href="#输出重构" class="headerlink" title="输出重构"></a>输出重构</h4><p>在输出重构阶段，各方重构$[\![\cdot]\!]$-共享电路输出。为了重构 $[\![y]\!]$，可以观察到每个 $P_i$ 缺失的份额都在另外两方手里。因此另外两方的其中一方将缺失的份额发送给 $P_i$ 后，通过计算 $y = m_y - \lambda_{y,1} - \lambda_{y,2}$ 即可重构输出 $y$，将其称为重构协议 $\prod ^{\rm s}_{\rm Rec}([\![y]\!], \mathcal{P})$。</p>
<p>把上面三个阶段总结起来，有以下的协议 $\prod ^{\rm s}_{\rm 3pc}$：</p>
<hr>
<p><strong>Pre-processing (Offline Phase):</strong></p>
<ul>
<li><em>Input wires:</em> For $j = 1, …,l$, corresponding to the circuit-input $x_j$, parties execute the offline steps of the instance $\prod ^{\rm s}_{\rm Sh}(P_i, x_j)$.</li>
<li>For each gate $g$ in the topological order, execute offline steps of the instance $\prod ^{\rm s}_{\rm Mul}(w_{xj}, w_{yj}, w_{zj})$ if $g$ is the $j$th multiplication gate where $j \in \{1,…,\rm M\}$ or respectively offline steps of the instance $\prod _{\rm Add}(w_{xj}, w_{yj}, w_{zj})$ if $g$ is the $j$th addition gate where $j \in \{1,…,\rm A\}$.</li>
</ul>
<p><strong>Circuit Evaluation (Online Phase):</strong></p>
<ul>
<li><em>Sharing Circuit-input Values:</em> For $j = 1, …,l$, corresponding to the circuit-input $x_j$, parties execute the online steps of the instance $\prod ^{\rm s}_{\rm Sh}(P_i, x_j)$, where $P_i$ is the party designated to provide $x_j$.</li>
<li><em>Gate Evaluation:</em> For each gate in $g$ in ckt in the topological order, $P_1, P_2$ execute the online steps of the instance $\prod ^{\rm s}_{\rm Mul}(w_{xj},w_{yj},w_{zj})$ if $g$ is the $j$th multiplication gate where $j \in \{1,…,\rm M\}$ or respectively offline steps of the instance $\prod _{\rm Add}(w_{xj}, w_{yj}, w_{zj})$ if $g$ is the $j$th addition gate where $j \in \{1,…,\rm A\}$.</li>
<li><em>Output Reconstruction:</em> Let $[\![y_1]\!],…,[\![y_\rm O]\!]$ be the shared function outputs. The parties in $\mathcal{P}$ reconstruct $y_j$ for $j = 1,…,\rm O$ by executing $\prod ^{\rm s}_{\rm Rec}([\![y_j]\!], \mathcal{P})$.</li>
</ul>
<hr>
<h3 id="恶意下的3PC"><a href="#恶意下的3PC" class="headerlink" title="恶意下的3PC"></a>恶意下的3PC</h3><p>跟半诚实设置下的一样，恶意设置下的3PC协议 $\prod ^{\rm m}_{\rm 3pc}$ 也由输入共享、电路评估和输出重构三个部分组成。</p>
<h4 id="输入共享和输出重构"><a href="#输入共享和输出重构" class="headerlink" title="输入共享和输出重构"></a>输入共享和输出重构</h4><p>在恶意的设置下，要保证服务器之间的共享份额是一致的。在 $\prod ^{\rm s}_{\rm Sh}$ 中，$\lambda$ 的共享是一致的，因为它不需要交互就可以生成。但如果一个腐败的 $P_0$ 拥有 $x$ 并且想制造一个不一致的 $[\![x]\!]$-共享，它可以分别发送两个不一样的 $m_x$ 给 $P_1$ 和 $P_2$。为了检查这种情况的发生，$P_1$ 和 $P_2$ 交换 $H(m_x)$ 并在不一致的时候中止。</p>
<p>令 $[\![y]\!]$ 为一个待重构的一致的共享，$[\![y]\!]_{P_0} = (\lambda_{y,1}, \lambda_{y,2})$、$[\![y]\!]_{P_1} = (m’_{y}, \lambda_{y,1})$ 和 $[\![y]\!]_{P_2} = (m’’_{y}, \lambda_{y,2})$ 分别为三个服务器的份额。协议 $\prod ^{\rm m}_{\rm Rec}([\![y]\!], \mathcal{P})$ 允许每一个诚实方输出 $y$ 或 $\perp$：</p>
<hr>
<p><strong>Online:</strong></p>
<ul>
<li>$P_0$ and $P_2$ send $\lambda_{y,2}$ and $H(\lambda’_{y,2})$ respectively to $P_1$.</li>
<li>$P_0$ and $P_1$ send $\lambda_{y,1}$ and $H(\lambda’_{y,1})$ respectively to $P_2$.</li>
<li>$P_1$ and $P_1$ send $m’_{y}$ and $H(m’_{y})$ respectively to $P_0$.</li>
</ul>
<p>$P_i$ for $i \in \{0,1,2\}$ abort if the received values mismatch. Else $P_i$ sets $y = m_y - \lambda_{y,1} - \lambda_{y,2}$.</p>
<hr>
<p>检查的过程中，其中一方发送哈希值可以提高效率。</p>
<h4 id="电路评估-1"><a href="#电路评估-1" class="headerlink" title="电路评估"></a>电路评估</h4><p>在恶意设置下加法协议 $\prod _{\rm Add}$ 同样是安全的，因为它只涉及本地操作。挑战在于构造乘法协议 $\prod ^{\rm m}_{\rm Mul}$，令其可以容忍其中一方腐败。可以观察到有两种情况：</p>
<ul>
<li>$P_0$ 是腐败的：在离线阶段会令 $\gamma_{xy} \neq \lambda_x \lambda_y$</li>
<li>$P_1$ 或 $P_2$ 是腐败的：会在在线阶段扰乱，使诚实的另一方重构出一个错误的 $m_z$</li>
</ul>
<p>先看下面的情况，假如 $P_1$ 现在需要验证它重构的 $m_z$ 是否是正确的，可以向 $P_0$ 求助：$P_1$ 可以发送 $m_x, m_y$ 给 $P_0$，因为 $P_0$ 在离线阶段就已经知道 $\lambda_x, \lambda_y$ 和 $\lambda_z$，因此它可以计算出 $m_z$ 并发送给 $P_1$，以此得到验证。但发送 $m_x, m_y$ 给 $P_0$ 会导致打破了原有共享的私密性，所以 $P_1$ 可以对应的值盲化后发送给 $P_0$：$m^{\star}_x = m_x + \delta_x$ 和 $m^{\star}_y = m_y + \delta_y$，然后 $P_0$ 计算 $m^{\star}_z = -m^{\star}_x \lambda_y - m^{\star}_y \lambda_x +\lambda_z + 2\gamma_{xy}$。注意到：</p>
<script type="math/tex; mode=display">
\begin{align}
m^{\star}_z &= -m^{\star}_x \lambda_y - m^{\star}_y \lambda_x +\lambda_z + 2\gamma_{xy}\\
 &= -(m_x + \delta_x) \lambda_y - (m_y + \delta_y) \lambda_x +\lambda_z + 2\gamma_{xy}\\
 &= (m_z - m_x m_y) - \chi
\end{align}</script><p>假设 $P_0$ 知道 $\chi = \delta_x \lambda_y + \delta_y \lambda_x - \gamma_{xy}$，它就可以计算出 $m^{\star}_z + \chi$ 然后发送给 $P_1$。因为 $P_1$ 知道 $m_x, m_y$ 的值，因此它可以验证它重构的 $m_z$ 的正确性，对于 $P_2$ 来说也可以这样验证。</p>
<p>现在来描述如何使 $P_0$ 获得 $\chi$：首先直接让 $P_0$ 获得 $\chi$ 会导致共享的私密性被破坏，因为 $P_0$ 知道 $\lambda_x, \lambda_y$ 和 $\gamma_{xy}$ 的值，同时在在线阶段又得到 $m_x + \delta_x$ 和 $m_y + \delta_y$，导致 $P_0$ 可以推导出 $m_x, m_y$ 之间的关系。所以还要在 $\chi$ 中加入一个随机值 $\delta_z$ 进行盲化：$\delta_x \lambda_y + \delta_y \lambda_x + \delta_z - \gamma_{xy}$。</p>
<p>生成 $\chi$ 的过程：$P_1, P_2$ 在本地生成随机数 $\delta_x, \delta_y, \delta_z \in \mathbb{Z}_{2^l}$，计算各自的 $\chi$ 的 $[\cdot]$-共享并发送给 $P_0$。对于 $i \in \{1,2 \}$，令 $[\chi]_{P_i} = \chi_i$。$P_0$ 在本地将共享的份额相加得到 $\chi$。在以上步骤中，腐败的一方可能会在执行过程中引入错误，使得 $P_0$ 获得的 $\chi$ 是错误的。</p>
<p>总而言之在离线阶段有两个问题需要解决：</p>
<ul>
<li>腐败的 $P_0$ 可以不正确地共享 $\gamma_{xy}$</li>
<li>腐败的 $P_1$ 或 $P_2$ 可以发送错误的 $\chi$ 的 $[\cdot]$-共享给 $P_0$</li>
</ul>
<p>为了解决这些问题，$P_0$ 一旦获得 $\chi$，就用下面的方式计算 $a = \delta_x - \lambda_x$、$b = \delta_y - \lambda_y$ 和 $c = (\delta_z + \delta_x \delta_y) - \chi$ 的 $[\![\cdot]\!]$-共享：</p>
<script type="math/tex; mode=display">
\begin{align*}
[\![a]\!]_{P_0} &= (\lambda_{x,1}, \lambda_{x,2}), & [\![b]\!]_{P_0} &= (\lambda_{y,1}, \lambda_{y,2}), & [\![c]\!]_{P_0} &= (\chi_{1}, \chi_{2})\\
 [\![a]\!]_{P_1} &= (\delta_x, \lambda_{x,1}), & [\![b]\!]_{P_1} &= (\delta_y, \lambda_{y,1}), & [\![c]\!]_{P_1} &= (\delta_z + \delta_x \delta_y, \chi_{1})\\
 [\![a]\!]_{P_2} &= (\delta_x, \lambda_{x,2}), & [\![b]\!]_{P_2} &= (\delta_y, \lambda_{y,2}), & [\![c]\!]_{P_2} &= (\delta_z + \delta_x \delta_y, \chi_{2})
\end{align*}</script><p>现在 $([\![a]\!], [\![b]\!], [\![c]\!])$ 是一个乘法三元组 $(c=ab)$，当且仅当 $P_0$ 正确分享了 $\gamma_{xy}$（当它腐败时）以及重构的 $\chi$ 是正确的（当 $P_1,P_2$ 其中之一腐败时），因为：</p>
<script type="math/tex; mode=display">
\begin{align}
ab &= (\delta_x - \lambda_x)(\delta_y - \lambda_y) = \delta_x \delta_y + \lambda_x \lambda_y - \delta_x \lambda_y - \delta_y \lambda_x \\
 &= (\delta_x \delta_y + \delta_z) - (\delta_x \lambda_y + \delta_y \lambda_x + \delta_z - \gamma_{xy}) \\
  &= (\delta_x \delta_y + \delta_z) - \chi = c
\end{align}</script><p>然后作者给出了一个检查乘法三元组是否正确的协议，这里需要用到另一个有效的乘法三元组 $([\![d]\!], [\![e]\!], [\![f]\!])$，它们满足以下条件：</p>
<ul>
<li>$d, e, f$ 都是随机且私密的</li>
<li>$f = d e$</li>
</ul>
<p>这里假设这个三元组是通过 $\mathcal{F}_{\rm trip}$ 生成的，在[2, 30]中有具体构造，下面是[30]中的构造：</p>
<p><img src="http://images.yingwai.top/picgo/ASTRAf1.png" alt=""></p>
<p>用  $\prod _{\rm trip}$ 表示该功能的实例化，下面是作者给出检查有效性的协议 $\prod _{\rm prc}$：</p>
<hr>
<ul>
<li>Parties locally compute $[\![\rho]\!] = [\![a]\!] - [\![d]\!]$ and $[\![\sigma]\!] = [\![b]\!] - [\![e]\!]$.</li>
<li>Parties reconstruct $\rho$ and $\sigma$ by executing $\prod ^{\rm m}_{\rm Rec}([\![\rho]\!], \mathcal{P})$ and $\prod ^{\rm m}_{\rm Rec}([\![\sigma]\!], \mathcal{P})$ respectively.</li>
<li>Parties locally compute $[\![\tau]\!] = [\![c]\!] - [\![f]\!] - \sigma [\![d]\!] - \rho [\![e]\!] - \sigma \rho$.</li>
<li>Parties reconstruct $\tau$ by executing $\prod ^{\rm m}_{\rm Rec}([\![\tau]\!], \mathcal{P})$ and output $\perp$, if $\tau \neq 0$.</li>
</ul>
<hr>
<p>协议 $\prod _{\rm prc}$ 需要两对秘密共享三元组 $(a, b, c)$ 和 $(d, e, f)$，验证前一个三元组是否满足 $c = a b$：</p>
<script type="math/tex; mode=display">
\begin{align}
\tau &= c - f - \sigma d - \rho e - \sigma \rho \\
 &= c - de - (b - e)d - (a - d)e - (b - e)(a - d) \\
 &= c - ab = \Delta
\end{align}</script><p>所以 $\tau = 0$ 时 $(a,b,c)$ 有效，反之无效。而检验 $\tau$ 是否为0只需要一方跟另外两方各通信一次即可：(1) $P_0$ 跟 $P_1$ 检查 $m_\tau - \lambda_{\tau,1}$ 跟 $\lambda_{\tau, 2}$ 是否相等；(2) $P_1$ 跟 $P_2$ 检查 $m_\tau - \lambda_{\tau,2}$ 跟 $\lambda_{\tau, 1}$ 是否相等；(3) $P_0$ 跟 $P_1$ 检查 $m_\tau - \lambda_{\tau,2}$ 跟 $\lambda_{\tau, 1}$ 是否相等，而不是 $\prod ^{\rm m}_{\rm Rec}$ 的通信三次（两次发送一次接收）。下面给出恶意设置下的乘法协议 $\prod ^{\rm m}_{\rm Mul}(w_x, w_y, w_z)$：</p>
<hr>
<p><strong>Offline:</strong></p>
<ul>
<li>Parties $P_0, P_1$ locally sample random $\lambda_{z,1}, \gamma_{xy,1} \in \mathbb{Z}_{2^l}$, while $P_0, P_2$<br>locally sample a random $\lambda_{z,2}$. $P_0$ locally computes $\gamma_{xy}= \lambda_x \lambda_y$ and<br>sends $\gamma_{xy,2} = \gamma_{xy} - \gamma_{xy,1}$ to $P_2$.</li>
<li>Parties execute $\prod _{\rm trip}$ to generate a triple $([\![d]\!], [\![e]\!], [\![f]\!])$.</li>
<li>Parties $P_1, P_2$ locally sample random $\delta_x, \delta_y, \delta_z \in \mathbb{Z}_{2^l}$ and compute<br>$[\delta_z]$ non-interactively.</li>
<li>$P_i$ for $i \in \{1, 2\}$ computes $[\chi]_{P_i} = \delta_x[\lambda_y]_{P_i} + \delta_y[\lambda_x]_{P_i} + [\delta_z]_{P_i} − [\gamma_{xy}]_{P_i}$ and sends $[\chi]_{P_i}$ to $P_0$, who computes $\chi$.</li>
<li>Parties locally compute the $[\![\cdot]\!]$-shares of the values $a = \delta_x - \lambda_x$, $b = \delta_y - \lambda_y$ and $b = (\delta_z + \delta_x \delta_y) - \chi$, as described in the text.</li>
<li>Parties execute $\prod _{\rm prc}$ on $([\![a]\!], [\![b]\!], [\![c]\!])$ and $([\![d]\!], [\![e]\!], [\![f]\!])$.</li>
</ul>
<p><strong>Online:</strong></p>
<ul>
<li>$P_i$ for $i \in \{1, 2\}$ locally computes $[m_z]_{P_i} = (i-1)m_xm_y - m_x[\lambda_y]_{P_i} - m_y[\lambda_x]_{P_i} + [\lambda_z]_{P_i} + [\gamma_{xy}]_{P_i}$. $P_1, P_2$ mutually exchange their shares and reconstruct $m_z$.</li>
<li>$P_1$ sends $m^{\star}_x = m_x + \delta_x$, $m^{\star}_y = m_y + \delta_y$ to $P_0$, while $P_2$ sends $H(m^{\star}_x || m^{\star}_{y})$ to $P_0$.$P_0$ outputs $\perp$, if the received values are inconsistent.</li>
<li>$P_0$ computes $m^{\star}_z = -m^{\star}_x \lambda_y - m^{\star}_y \lambda_x +\lambda_z + 2\gamma_{xy} + \chi$ and sends $H(m^\star_z)$ to both $P_1$ and $P_2$.</li>
<li>$P_i$ for $i \in \{1, 2\}$ abort if $H(m^\star_z) \neq H(m_z - m_x m_y + \delta_z)$.</li>
</ul>
<hr>
<p>散列值的使用提高了效率，减少了通信的开销。</p>
<p>对于正确性，首先考虑腐败的 $P_0$ 不正确地共享使得 $\gamma_{xy} = \lambda_x \lambda_y + \Delta$ 的情况，其中 $\Delta$ 是 $P_0$ 引入的不为零的干扰。这种情况在执行 $\prod _{\rm prc}$ 就会被检测到，因为最终计算出来并重构的 $\tau \neq 0$。同样的， $P_1$（或 $P_2$）在协议 $\prod ^{\rm m}_{\rm Mul}$ 离线阶段的第四步时发送 $\chi_1 + \Delta$（或 $\chi_2 + \Delta$） 给 $P_0$ 使其重构的 $\chi’ = \chi + \Delta$，也会导致 $\tau \neq 0$ 从而被诚实方发现并中止计算。</p>
<p>然后是另一种情况，假如 $P_1$（或 $P_2$）在重构 $m_z$ 时发送了错误的 $[m_z]_{P_i}$ 给另一方，会在最后一步验证哈希值是否相等的时候被检测出来；而在在线阶段第二步中 $P_0$ 对 $m^{\star}_x,m^{\star}_y$ 的一致性检查也确保了它所计算出来的 $m^{\star}_z$ 是正确的。</p>
<h4 id="公平的实现"><a href="#公平的实现" class="headerlink" title="公平的实现"></a>公平的实现</h4><p>作者通过一种公平重构协议 $\prod_{\rm fRec}$ 来重构电路输出，将 $\prod ^{\rm m}_{\rm 3pc}$ 的安全性提高到公平，保证交易的三方都不能通过损害别人的利益而得到自己不应得的利益。这里使用到了承诺方案，还是利用了服务器之间的公共随机源并使用PRF来为承诺方案引入随机性：</p>
<hr>
<p><strong>Offline:</strong></p>
<ul>
<li>Parties $P_0, P_1$ locally sample a random $r_1 \in \mathbb{Z}_{2^l}$, prepare and send commitments of $\lambda_{y,1}$ and $r_1$ to $P_2$. Similarly, parties $P_0, P_2$ locally sample a random $r_2 \in \mathbb{Z}_{2^l}$, prepare and send commitments of $\lambda_{y,2}$ and $r_2$ to $P_1$. The randomness needed for both commitments are sampled from the PRF key-setup.</li>
<li>$P_1$ (resp. $P_2$) aborts if the received commitments mismatch.</li>
</ul>
<p><strong>Online:</strong></p>
<ul>
<li>$P_1, P_2$ compute a commitment of $m_y$ using randomness sampled from their PRF key-setup and send it to $P_0$.</li>
<li>If the commitments do not match, $P_0$ sends (<strong>abort</strong>, $o_1$) to $P_2$, while it sends (<strong>abort</strong>, $o_2$) to $P_1$ and aborts, where $o_i$ denotes the opening information for the commitment of $r_i$. Else $P_0$ sends <strong>continue</strong> to both $P_1$ and $P_2$.</li>
<li>$P_1, P_2$ exchange the messages received from $P_0$.</li>
<li>$P_1$ aborts if it receives either (i) (<strong>abort</strong>, $o_2$) from $P_0$ and $o_2$ opens the commitment of $r_2$ or (ii) (<strong>abort</strong>, $o_1$) from $P_2$ and $o_1$ is the correct opening information of $r_1$. The case for $P_2$ is similar to that of $P_1$.</li>
<li>If no abort happens, parties obtain their missing share of $a$ as follows:<ul>
<li>$P_0, P_1$ open $\lambda_{y,1}$ towards $P_2$.</li>
<li>$P_0, P_2$ open $\lambda_{y,2}$ towards $P_1$.</li>
<li>$P_1, P_2$ open $m_y$ towards $P_0$.</li>
</ul>
</li>
<li>Parties reconstruct the value $y$ using missing share that matches with the agreed upon commitment.</li>
</ul>
<hr>
<p>当没有广播频道的时候，一个非常棘手的问题就会存在：一个腐败的 $P_0$ 可以发送不同的信号给 $P_1$ 和 $P_2$（一个为 abort 而另一个为 continue），以上的重构协议 $\prod_{\rm fRec}([\![y]\!], \mathcal{P})$ 解决了这个问题。在离线阶段 $P_0$ 和 $P_1$ 共同计算出一个关于 $r_1$ 的承诺发送给 $P_2$，同样地 $P_0$ 和 $P_2$ 共同计算出一个关于 $r_2$ 的承诺发送给 $P_1$。这两个承诺就可以确保 $P_1$ 跟 $P_2$ 可以验证它们收到的来自 $P_0$ 的信号是否一致：例如当 $P_1$ 收到 abort 而 $P_2$ 收到 continue，在它们交换信息时，$P_1$ 就可以利用收到的 $o_2$ 证明自己收到了 abort 信号，反过来也是一样的。同时还解决了一个问题，就是当一个腐败的 $P_1$ 收到了 $P_0$ 发送的 continue 信号，但它不能在与 $P_2$ 交换信息时宣称自己收到了 abort 信号，因为它没有 $o_2$，因此无法证明，对于 $P_2$ 腐败的情况也是一样的。</p>
<p>这里的承诺方案可以通过一个哈希函数来实现，例如：$(c, o) = (\mathcal{H}(x||r),x||r) = Com(x;r)$</p>
<h2 id="隐私保护机器学习"><a href="#隐私保护机器学习" class="headerlink" title="隐私保护机器学习"></a>隐私保护机器学习</h2><h3 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h3><p>对于每一个预测函数，模型拥有者 $\rm M$ 拥有一个训练好的参数向量，想为拥有一个查询向量的客户 $\rm C$ 提供预测服务。在服务器辅助设置中，$\rm M$ 和 $\rm C$ 以共享方式将各自的输入外包给三个不受信任但非合谋的服务器 $\{P_0, P_1, P_2\}$，这些服务器通过为本文的3PC协议开发的技术以共享方式执行计算，并将输出单独重构到客户端。客户只能知道输出，除此之外什么也不知道。</p>
<h3 id="对于ML的协议"><a href="#对于ML的协议" class="headerlink" title="对于ML的协议"></a>对于ML的协议</h3><h4 id="安全向量点积"><a href="#安全向量点积" class="headerlink" title="安全向量点积"></a>安全向量点积</h4><p>对于向量的 $[\cdot]$-共享和 $[\![\cdot]\!]$-共享，就是对应每个维度的值进行$[\cdot]$-共享和 $[\![\cdot]\!]$-共享，容易知道对于向量来说两种共享仍然是线性的。对于两个 $d$ 维向量的点积，不考虑效率的情况下可以执行 $d$ 次 $\prod ^{\rm s}_{\rm Mul}$协议，再对这 $d$ 次执行的结果简单进行相加，各方就可以得到它们的份额。在这里作者给出一个更高效率的向量点积协议 $\prod ^{\rm s}_{\rm dp}$：</p>
<hr>
<p><strong>Offline:</strong></p>
<p>​        $P_0, P_1$ sample random $\lambda_{u,1}, \gamma_{pq,1} \in \mathbb{Z}_{2^l}$, while $P_0, P_2$ sample random $\lambda_{u,2} \in \mathbb{Z}_{2^l}$. $P_0$ locally computes $\gamma_{pq} = \vec{\lambda_p} \odot \vec{\lambda_q}$, sets $\gamma_{pq,2} = \gamma_{pq} - \gamma_{pq,1}$ and sends $\gamma_{pq,2}$ to $P_2$.</p>
<p><strong>Online:</strong></p>
<ul>
<li>$P_i$ for $i \in \{1,2\}$ locally computes $[m_u]_{P_i} = \sum^d_{j=1}((i-1)m_{p_j}m_{q_j} - m_{p_j}[\lambda_{q_j}]_{P_i} - m_{q_j}[\lambda_{p_j}]_{P_i}) + [\gamma_{pq}]_{P_i} + [\lambda_u]_{P_i}$.</li>
<li>$P_1$ and $P_2$ mutually exchange their share of $[m_u]$ to reconstruct $m_u$.</li>
</ul>
<hr>
<p>上面的协议的离线阶段中，$P_0$ 仅仅共享了 $\gamma_{pq} = \vec{\lambda_p} \odot \vec{\lambda_q}$ 而不是每一个 $\lambda_{p_i} \lambda_{q_i}$；在在线阶段，$P_1, P_2$ 直接计算 $[m_u]$（其中 $u = \vec{p} \odot \vec{q}$）而不是每一个 $m_{p_i q_i}$。</p>
<p>接下来作者还对恶意设置下的点积进行了讨论：由于在乘法协议中引入了对恶意对手的额外检查，所以上面针对半诚实协议所作的优化是不适用的。对两个 $d$ 维向量的点积，只能 $d$ 次调用协议 $\prod ^{\rm m}_{\rm Mul}$。不过作者还是对在线阶段的开销进行了改进：在在线阶段 $P_1$ 并行地发送 $m^{\star}_{p_i}, m^{\star}_{q_i}$ 给 $P_0$，而 $P_2$ 则发送对应的哈希值给 $P_0$。$P_0$ 收到这些值后进行验证，若一致则将它们“结合”所有的 $m^{\star}_{p_i q_i}$ 然后发送一个单独的 $m^\star_u$ 的哈希值给 $P_1, P_2$，最后 $P_1, P_2$ 在本地验证是否与 $m_u - \sum^d_{j=1}(m_{p_j}m_{q_j} - \delta_{u_j})$。这样做的话就节省了在线阶段的开销，不用每个 $m^{\star}_{p_i}, m^{\star}_{q_i}$ 都发送一次。</p>
<h4 id="安全比较"><a href="#安全比较" class="headerlink" title="安全比较"></a>安全比较</h4><p>给定算术共享 $[\![u]\!], [\![v]\!]$，各方希望验证 $u$ 是否小于 $v$，等同于验证 $a$ 是否小于 $0$（其中 $a = u - v$），在定点表示中可以通过检查 ${\rm msb}(a)$ 来完成（二进制补码中第一位为符号位）。于是可以把在给定算术共享 $[\![a]\!]$ 的情况下生成 ${\rm msb}(a)$ 的布尔共享作为目标，在这里作者利用了秘密共享方案中的不对称性，放弃了 <em>SecureML</em>[48]和 <em>ABY3</em>[46]中的昂贵协议。</p>
<hr>
<p><strong>Offline:</strong></p>
<p>​        $P_1, P_2$ together sample a random $r, r’ \in \mathbb{Z}_{2^l}$ and set $p= \rm{msb}$$(r)$. Parties non-interactively generate Boolean share of $p$ as $[\![p]\!]^{\rm B}_{P_0} = (0,0)$, $[\![p]\!]_{P_1} = (p,0)$ and $[\![p]\!]_{P_2} = (p,0)$.</p>
<p><strong>Online:</strong></p>
<p>​        $P_1$ set $[a]_{P_1}=m_a - \lambda_{a,1}$, $P_2$ set $[a]_{P_2}=- \lambda_{a,2}$.</p>
<ul>
<li>$P_1$ sends $[ra]_{P_1} = r[a]_{P_1} + r’$ to $P_0$, while $P_2$ sends $[ra]_{P_2} = r[a]_{P_1} - r’$ to $P_0$, who adds them to obtain $ra$.</li>
<li>$P_0$ executes $\prod^{\rm s}_{\rm Sh}(P_0, q)$ over $\mathbb{Z}_{2^1}$ to generate $[\![q]\!]^{\rm B}$ where $q = {\rm msb}(ra)$.</li>
<li>Parties locally compute $[\![msb(a)]\!]^{\rm B} = [\![p]\!]^{\rm B} \oplus [\![q]\!]^{\rm B}$.</li>
</ul>
<hr>
<p>上面的协议用 $\prod ^{\rm s}_{\rm BitExt}([\![a]\!], \mathcal{P})$ 表示。这里上面用到了一个随机数 $r$ 来对 $a$ 的值进行盲化，并且可以注意到 ${\rm sign}(a \cdot r) = {\rm sign}(a) \oplus {\rm sign}(r)$，所以 $r$ 不会对生成共享份额造成影响且使得三者都不能从这个过程中知道关于 $a$ 的信息。</p>
<p>对于恶意的情况，就不能仅仅依靠 $P_0$ 来生成 $[\![{\rm msb}(ra)]\!]^{\rm B}$，下面给出了修改后的协议 $\prod ^{\rm m}_{\rm BitExt}([\![a]\!], \mathcal{P})$：</p>
<hr>
<p><strong>Offline:</strong></p>
<p>​        $P_1, P_2$ sample a random $r_1 \in \mathbb{Z}_{2^l}$ and set $p_1 = {\rm msb}(r_1)$ while $P_0, P_2$ sample a random $r_2 \in \mathbb{Z}_{2^l}$ and set $p_2 = {\rm msb}(r_2)$.</p>
<ul>
<li>Parties non-interactively generate $[\![\cdot]\!]$-shares of $r_1$ as $[\![r_1]\!]_{P_0}=(0,0)$, $[\![r_1]\!]_{P_1}=(r_1,0)$ and $[\![r_1]\!]_{P_2}=(r_1,0)$.</li>
<li>Parties non-interactively generate $[\![\cdot]\!]$-shares of $r_1$ as $[\![r_2]\!]_{P_0}=(0,-r_2)$, $[\![r_1]\!]_{P_1}=(0,0)$ and $[\![r_1]\!]_{P_2}=(0,-r_2)$.</li>
<li>Parties execute $\prod^{\rm m}_{\rm Mul}$ on $r_1$ and $r_2$ to generate $[\![r]\!] = [\![r_1 r_2]\!]$.</li>
<li>Parties non-interactively generate Boolean shares of $p_1$ as $[\![p_1]\!]^{\rm B}_{P_0}=(0,0)$, $[\![p_1]\!]^{\rm B}_{P_1}=(p_1,0)$ and $[\![p_1]\!]^{\rm B}_{P_2}=(p_1,0)$.</li>
<li>Parties non-interactively generate Boolean shares of $p_2$ as $[\![p_2]\!]^{\rm B}_{P_0}=(0,p_2)$, $[\![p_2]\!]^{\rm B}_{P_1}=(0,0)$ and $[\![p_2]\!]^{\rm B}_{P_2}=(0,p_2)$.</li>
<li>Parties locally compute $[\![p]\!]^{\rm B}=[\![p_1]\!]^{\rm B} \oplus [\![p_2]\!]^{\rm B}$.</li>
</ul>
<p><strong>Online:</strong></p>
<ul>
<li>Parties execute $\prod ^{\rm m}_{\rm Mul}$ on $[\![r]\!]$ and $[\![a]\!]$ to generate $[\![ra]\!]$ followed by enabling $P_0, P_1$ to reconstruct $ra$ (this is done by slightly modifying the protocol $\prod ^{\rm m}_{\rm Rec}$ ).</li>
<li>$P_1$ executes $\prod ^{\rm m}_{\rm Sh}(P_1, q)$ over $\mathbb{Z}_{2^1}$ to generate $[\![q]\!]^{\rm B}$ where $q = {\rm msb}(ra)$. In parallel, $P_0$ locally computes $m_q$ and sends ${\rm H}(m_q)$ to $P_2$, who abort if the value mismatches with the hash of the value $m_q$ received from $P_1$ as part of $\prod ^{\rm m}_{\rm Sh}(P_1, q)$.</li>
<li>Parties locally compute $[\![{\rm msb}(a)]\!]^{\rm B} = [\![p]\!]^{\rm B} \oplus [\![q]\!]^{\rm B}$.</li>
</ul>
<hr>
<h4 id="ML预测函数"><a href="#ML预测函数" class="headerlink" title="ML预测函数"></a>ML预测函数</h4><ul>
<li><strong>线性回归</strong>：$\rm M$ 有一个 $d$ 维的模型参数向量 $\vec{w}$ 和偏置项 $b$，$\rm C$ 有一个 $d$ 维的查询向量 $\vec{z}$。$\rm C$ 获得 $f_{\rm linr}((\vec{w}, b),\vec{z}) = \vec{w} \odot \vec{z} + b$，其中 $\vec{w} \odot \vec{z}$ 是向量 $\vec{w}$ 和向量 $\vec{z}$ 的点积；</li>
<li><strong>SVM回归</strong>：$\rm M$ 有$\{\alpha_j, y_j \}^k_{j=1}$ 和 $d$ 维的支持向量 $\{\vec{x_j}\}^k_{j=1}$，$\rm C$ 有一个 $d$ 维的查询向量 $\vec{z}$。$\rm C$ 获得 $f_{\rm svmr}((\{\alpha_j, y_j, \vec{x_j} \}^k_{j=1}, b), \vec{z}) = \sum^k_{j=1} \alpha_j y_j (\vec{x_j} \odot \vec{z}) + b$；</li>
<li><strong>逻辑回归</strong>：$\rm M$ 和 $\rm C$ 的输入和线性回归类似，$\rm M$ 还需要提供一个在 $[0,1]$ 范围内的额外输入 $t$。$\rm C$ 获得 $f_{\rm logr}((\vec{w}, b, t), \vec{z}) = {\rm sign}((\vec{w} \odot \vec{z} + b) - {\rm ln}(\frac{t}{1-t}))$，其中 ${\rm sign}(\cdot)$ 返回对象的符号位；</li>
<li><strong>SVM分类</strong>：$\rm M$ 和 $\rm C$ 的输入和SVM回归一样，但对 $\rm C$ 的输出变为 $f_{\rm svmr}((\{\alpha_j, y_j, \vec{x_j} \}^k_{j=1}, b), \vec{z}) = {\rm sign}(\sum^k_{j=1} \alpha_j y_j (\vec{x_j} \odot \vec{z}) + b)$。</li>
</ul>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1] V. A. Abril, P. Maene, N. Mertens, and N. P. Smart. 2019. <em>Bristol Fashion MPC Circuits.</em> <a href="https://homes.esat.kuleuven.be/~nsmart/MPC/" target="_blank" rel="noopener">https://homes.esat.kuleuven.be/~nsmart/MPC/</a>.<br>[2] T. Araki, A. Barak, J. Furukawa, T. Lichter, Y. Lindell, A. Nof, K. Ohara, A. Watzman, and O. Weinstein. 2017. <em>Optimized Honest-Majority MPC for Malicious Adversaries - Breaking the 1 Billion-Gate Per Second Barrier.</em> In IEEE S&amp;P. 843–862.<br>[3] T. Araki, A. Barak, J. Furukawa, Y. Lindell, A. Nof, and K. Ohara. 2016. <em>DEMO: High-Throughput Secure Three-Party Computation of Kerberos Ticket Generation.</em> In ACM CCS. 1841–1843.<br>[4] T. Araki, J. Furukawa, Y. Lindell, A. Nof, and K. Ohara. 2016. <em>High-Throughput Semi-Honest Secure Three-Party Computation with an Honest Majority.</em> In ACM CCS. 805–817.<br>[5] C. Baum, I. Damgård, T. Toft, and R. W. Zakarias. 2016. <em>Better Preprocessing for Secure Multiparty Computation.</em> In ACNS. 327–345.<br>[6] D. Beaver. 1991. <em>Efficient Multiparty Protocols Using Circuit Randomization.</em> In CRYPTO. 420–432.<br>[7] D. Beaver. 1995. <em>Precomputing Oblivious Transfer.</em> In CRYPTO. 97–109.<br>[8] Z. Beerliová-Trubíniová and M. Hirt. 2006. <em>Efficient Multi-party Computation with Dispute Control.</em> In TCC. 305–328.<br>[9] Z. Beerliová-Trubíniová and M. Hirt. 2008. <em>Perfectly-Secure MPC with Linear Communication Complexity.</em> In TCC. 213–230.<br>[10] M. Ben-Or, S. Goldwasser, and A. Wigderson. 1988. <em>Completeness Theorems for Non-Cryptographic Fault-Tolerant Distributed Computation (Extended Abstract).</em> In ACM STOC. 1–10.<br>[11] Christopher Bishop. 2006. <em>Pattern Recognition and Machine Learning.</em><br>[12] D. Bogdanov, S. Laur, and J. Willemson. 2008. <em>Sharemind: A Framework for Fast Privacy-Preserving Computations.</em> In ESORICS. 192–206.<br>[13] D. Bogdanov, R. Talviste, and J. Willemson. 2012. <em>Deploying Secure Multi-Party Computation for Financial Data Analysis.</em> In FC. 57–64.<br>[14] M. Byali, A. Joseph, A. Patra, and D. Ravi. 2018. <em>Fast Secure Computation for Small Population over the Internet.</em> ACM CCS (2018), 677–694.<br>[15] O. Catrina and S. de Hoogh. 2010. <em>Secure Multiparty Linear Programming Using Fixed-Point Arithmetic.</em> In ESORICS. 134–150.<br>[16] N. Chandran, J. A. Garay, P. Mohassel, and S. Vusirikala. 2017. <em>Efficient, Constant-Round and Actively Secure MPC: Beyond the Three-Party Case.</em> In ACM CCS. 277–294.<br>[17] H. Chaudhari, A. Choudhury, A. Patra, and A. Suresh. 2019. <em>ASTRA: High-throughput 3PC over Rings with Application to Secure Prediction.</em> <a href="https://eprint.iacr.org/2019/429" target="_blank" rel="noopener">https://eprint.iacr.org/2019/429</a>. In IACR Cryptology ePrint Archive.<br>[18] K. Chida, D. Genkin, K. Hamada, D. Ikarashi, R. Kikuchi, Y. Lindell, and A. Nof. 2018. <em>Fast Large-Scale Honest-Majority MPC for Malicious Adversaries.</em> In CRYPTO. 34–64.<br>[19] A. Choudhury and A. Patra. 2017. <em>An Efficient Framework for Unconditionally Secure Multiparty Computation.</em> IEEE Trans. Information Theory (2017), 428–468.<br>[20] R. Cleve. 1986. <em>Limits on the Security of Coin Flips when Half the Processors Are Faulty (Extended Abstract).</em> In ACM STOC. 364–369.<br>[21] R. Cramer, I. Damgård, D. Escudero, P. Scholl, and C. Xing. 2018. <em>SPDZ2k: Efficient MPC mod 2ˆk for Dishonest Majority.</em> CRYPTO (2018), 769–798.<br>[22] R. Cramer, I. Damgård, and Y. Ishai. 2005. <em>Share Conversion, Pseudorandom Secret-Sharing and Applications to Secure Computation.</em> In TCC. 342–362.<br>[23] Cryptography and Privacy Engineering Group at TU Darmstadt. 2017. ENCRYPTO Utils. <a href="https://github.com/encryptogroup/ENCRYPTO_utils" target="_blank" rel="noopener">https://github.com/encryptogroup/ENCRYPTO_utils</a>.<br>[24] M. Dahl. 2018. <em>Private Image Analysis with MPC: Training CNNs on Sensitive Data using SPDZ.</em> (2018).<br>[25] I. Damgård, C. Orlandi, and M. Simkin. 2018. <em>Yet Another Compiler for Active Security or: Efficient MPC Over Arbitrary Rings.</em> CRYPTO (2018), 799–829.<br>[26] I. Damgård, V. Pastro, N. P. Smart, and S. Zakarias. 2012. <em>Multiparty Computation from Somewhat Homomorphic Encryption.</em> In CRYPTO. 643–662.<br>[27] S. de Hoogh, B. Schoenmakers, P.Chen, and H. Akker. 2014. <em>Practical Secure Decision Tree Learning in a Teletreatment Application.</em> In FC. 179–194.<br>[28] H. Eerikson, M. Keller, C. Orlandi, P. Pullonen, J. Puura, and M. Simkin. 2019. <em>Use your Brain! Arithmetic 3PC For Any Modulus with Active Security.</em> IACR<br>Cryptology ePrint Archive (2019).<br>[29] A. Esteva, B. Kuprel, R. A. Novoa, J. Ko, S. M. Swetter, H. M. Blau, and S. Thrun. 2017. <em>Dermatologist-level classification of skin cancer with deep neural networks.</em> Nature (2017), 115–118.<br>[30] J. Furukawa, Y. Lindell, A. Nof, and O. Weinstein. 2017. <em>High-Throughput Secure Three-Party Computation for Malicious Adversaries and an Honest Majority.</em> In EUROCRYPT. 225–255.<br>[31] A. Gascón, P. Schoppmann, B. Balle, M. Raykova, J. Doerner, S. Zahur, and D. Evans. 2016. <em>Secure Linear Regression on Vertically Partitioned Datasets.</em> IACR Cryptology ePrint Archive (2016).<br>[32] M. Geisler. 2007. <em>Viff: Virtual ideal functionality framework.</em><br>[33] O. Goldreich, S. Micali, and A. Wigderson. 1987. <em>How to Play any Mental Game or A Completeness Theorem for Protocols with Honest Majority.</em> In STOC. 218–229.<br>[34] S. D. Gordon, S. Ranellucci, and X. Wang. 2018. <em>Secure Computation with Low Communication from Cross-Checking.</em> In ASIACRYPT. 59–85.<br>[35] Y. Ishai, R. Kumaresan, E. Kushilevitz, and A. Paskin-Cherniavsky. 2015. <em>Secure Computation with Minimal Interaction, Revisited.</em> In CRYPTO. 359–378.<br>[36] S. Kamara, P. Mohassel, and M. Raykova. 2011. <em>Outsourcing Multi-Party Computation.</em> IACR Cryptology ePrint Archive (2011).<br>[37] J. Katz, V. Kolesnikov, and X. Wang. 2018. <em>Improved Non-Interactive Zero Knowledge with Applications to Post-Quantum Signatures.</em> In CCS. 525–537.<br>[38] M. Keller, E. Orsini, and P. Scholl. 2016. <em>MASCOT: Faster Malicious Arithmetic Secure Computation with Oblivious Transfer.</em> In ACM CCS. 830–842.<br>[39] M. Keller, V. Pastro, and D. Rotaru. 2018. <em>Overdrive: Making SPDZ Great Again.</em> In EUROCRYPT. 158–189.<br>[40] J. Launchbury, D. Archer, T. DuBuisson, and E. Mertens. 2014. <em>Application-Scale Secure Multiparty Computation.</em> In ESOP. 8–26.<br>[41] S. Laur, H. Lipmaa, and T. Mielikäinen. 2006. <em>Cryptographically private support vector machines.</em> In ACM SIGKDD. 618–624.<br>[42] Yann LeCun and Corinna Cortes. 2010. <em>MNIST handwritten digit database.</em> (2010). <a href="http://yann.lecun.com/exdb/mnist/" target="_blank" rel="noopener">http://yann.lecun.com/exdb/mnist/</a><br>[43] Y. Lindell and A. Nof. 2017. <em>A Framework for Constructing Fast MPC over Arithmetic Circuits with Malicious Adversaries and an Honest-Majority.</em> In ACM CCS. 259–276.<br>[44] J. Liu, M. Juuti, Y. L., and N. Asokan. 2017. <em>Oblivious Neural Network Predictions via MiniONN Transformations.</em> In ACM CCS. 619–631.<br>[45] E. Makri, D. Rotaru, N. P. Smart, and F. Vercauteren. 2018. <em>EPIC: Efficient Private Image Classification (or: Learning from the Masters).</em> CT-RSA (2018), 473–492.<br>[46] P. Mohassel and P. Rindal. 2018. <em>ABY3: A Mixed Protocol Framework for Machine Learning.</em> In ACM CCS. 35–52.<br>[47] P. Mohassel, M. Rosulek, and Y. Zhang. 2015. <em>Fast and Secure Three-party Computation: Garbled Circuit Approach.</em> In CCS. 591–602.<br>[48] P. Mohassel and Y. Zhang. 2017. <em>SecureML: A System for Scalable Privacy-Preserving Machine Learning.</em> In IEEE S&amp;P. 19–38.<br>[49] V. Nikolaenko, S. Ioannidis, U. Weinsberg, M. Joye, N. Taft, and D. Boneh. 2013. <em>Privacy-preserving matrix factorization.</em> In ACM CCS. 801–812.<br>[50] V. Nikolaenko, U. Weinsberg, S. Ioannidis, M. Joye, D. Boneh, and N. Taft. 2013. <em>Privacy-Preserving Ridge Regression on Hundreds of Millions of Records.</em> In IEEE S&amp;P. 334–348.<br>[51] P. S. Nordholt and M. Veeningen. 2018. <em>Minimising Communication in Honest-Majority MPC by Batchwise Multiplication Verification.</em> In ACNS. 321–339.<br>[52] T. Orekondy, B. Schiele, and M. Fritz. 2018. <em>Knockoff Nets: Stealing Functionality of Black-Box Models.</em> CoRR (2018).<br>[53] N. Papernot, P. McDaniel, I. Goodfellow, S. Jha, Z. B. Celik, and A. Swami. 2017. <em>Practical Black-Box Attacks Against Machine Learning.</em> In ASIA CCS. 506–519.<br>[54] A. Patra and D. Ravi. 2018. <em>On the Exact Round Complexity of Secure Three-Party Computation.</em> CRYPTO (2018), 425–458.<br>[55] M. S. Riazi, C. Weinert, O. Tkachenko, E. M. Songhori, T. Schneider, and F. Koushanfar. 2018. <em>Chameleon: A Hybrid Secure Computation Framework for Machine Learning Applications.</em> In AsiaCCS. 707–721.<br>[56] F. Schroff, D. Kalenichenko, and J. Philbin. 2015. <em>FaceNet: A unified embedding for face recognition and clustering.</em> In IEEE CVPR. 815–823.<br>[57] N. P. Smart and T. Wood. 2019. <em>Error Detection in Monotone Span Programs with Application to Communication-Efficient Multi-party Computation.</em> In CT-RSA. 210–229.<br>[58] F. Tramèr, F. Zhang, A. Juels, M. K. Reiter, and T. Ristenpart. 2016. <em>Stealing Machine Learning Models via Prediction APIs.</em> In USENIX. 601–618.<br>[59] S. Wagh, D. Gupta, and N. Chandran. 2019. <em>SecureNN: 3-Party Secure Computation for Neural Network Training.</em> PoPETs (2019), 26–49.<br>[60] A. C. Yao. 1982. <em>Protocols for Secure Computations.</em> In FOCS. 160–164.</p>
]]></content>
      <categories>
        <category>Papers</category>
      </categories>
      <tags>
        <tag>密码学</tag>
        <tag>MPC</tag>
        <tag>神经网络</tag>
        <tag>隐私保护机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>论文笔记 Automatic Unit Test Generation and Execution for JavaScript Program through Symbolic Execution</title>
    <url>/2020/04/16/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0-Automatic-Unit-Test-Generation-and-Execution-for-JavaScript-Program-through-Symbolic-Execution/</url>
    <content><![CDATA[<p><a href="https://www.semanticscholar.org/author/Hideo-Tanida/2725857" target="_blank" rel="noopener">Hideo Tanida</a>, <a href="https://www.semanticscholar.org/author/Guodong-Li/1720073" target="_blank" rel="noopener">Guodong Li</a>, <a href="https://www.semanticscholar.org/author/Indradeep-Ghosh/3291522" target="_blank" rel="noopener">Indradeep Ghosh</a>, <a href="https://www.semanticscholar.org/author/Tadahiro-Uehara/3081128" target="_blank" rel="noopener">Tadahiro Uehara</a></p>
<p>Published in ICSEA 2014</p>
<p><a href="https://scholar.google.com/scholar?hl=zh-CN&amp;as_sdt=0%2C5&amp;q=Automatic+Unit+Test+Generation+and+Execution+for+JavaScript+Program+through+Symbolic+Execution&amp;btnG=" target="_blank" rel="noopener">https://scholar.google.com/scholar?hl=zh-CN&amp;as_sdt=0%2C5&amp;q=Automatic+Unit+Test+Generation+and+Execution+for+JavaScript+Program+through+Symbolic+Execution&amp;btnG=</a></p>
<a id="more"></a>
<h2 id="摘要及介绍"><a href="#摘要及介绍" class="headerlink" title="摘要及介绍"></a>摘要及介绍</h2><h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>​        考虑到对更具交互性的Web/移动应用程序的需求，JavaScript有望成为一种使用更广泛的编程语言。虽然JavaScript代码的可靠性将更加重要，但与其他语言相比，该语言的测试技术仍然不足。本文提出了一种为JavaScript代码自动生成高覆盖率单元测试的技术。该技术使用JavaScript代码的符号执行引擎，以及自动为不感兴趣的代码生成存根的存根/驱动程序生成引擎。本文的方法允许全自动生成用于高覆盖率的JavaScript代码单元测试的输入数据，从而以较少的工作量确保目标代码的质量。</p>
<h3 id="主要贡献"><a href="#主要贡献" class="headerlink" title="主要贡献"></a>主要贡献</h3><ul>
<li>本文提出了一种在工具<strong>SymJS</strong>上通过符号执行为JavaScript代码生成测试输入的技术；</li>
<li>对比现有工具，本文的约束求解器<strong>PASS</strong>[10]允许为具有各种复杂字符串操作的程序生成测试；</li>
<li>并且不需要对目标代码进行任何修改，而现有的符号执行器需要修改和多次运行，因此适用于现实中的开发；</li>
<li>本文的自动生成存根/驱动程序代码允许完全自动生成测试数据。</li>
</ul>
<h3 id="现有的工具"><a href="#现有的工具" class="headerlink" title="现有的工具"></a>现有的工具</h3><p>​        现有的JavaScript代码测试工具包括<strong>Kudzu</strong>[8]和<strong>Jalangi</strong>[9]。kudzu自动生成程序函数的输入数据，目的是自动发现目标中的安全漏洞。Jalangi允许在正常的具体执行下修改路径约束，以便获得与以前运行不同的结果。然而，由于字符串约束处理方面的限制，以及需要手动创建用于测试的驱动程序/存根，这些工具不能应用于现实中JavaScript代码的单元测试。</p>
<h2 id="背景及基础知识"><a href="#背景及基础知识" class="headerlink" title="背景及基础知识"></a>背景及基础知识</h2><h3 id="符号执行"><a href="#符号执行" class="headerlink" title="符号执行"></a>符号执行</h3><p>​        符号执行（Symbolic Execution）是一种程序分析技术，可以通过分析程序源代码来得到测试输入。通俗来讲，比如说游戏中一个角色在佩戴各种装备之后的面板数值为：攻击力xxx、防御力xxx…；此时通过佩戴装备到获得属性的过程就好比一个程序，佩戴装备的品质就是这个程序的输入，而最后获得的属性就是这个程序的输出；符号执行的过程则是进行分析，从某组给定的属性逆向推导，最后得到某组质量的装备，佩戴这组装备可以获得一开始给定的属性。</p>
<h4 id="符号执行的基本原理"><a href="#符号执行的基本原理" class="headerlink" title="符号执行的基本原理"></a>符号执行的基本原理</h4><p>​        符号执行的关键思想是把输入变为符号值，那么程序的输出值就是一个符号输入值的函数。在程序执行期间，获得每个执行路径中的变量的值要满足的约束。在获得程序内所有路径的约束之后，通过将约束提供给诸如可满足性模理论（SMT）[7]求解器之类的求解器，可以获得执行每条路径的输入变量的具体值。</p>
<p>参考：<a href="https://zhuanlan.zhihu.com/p/26927127" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/26927127</a></p>
<h4 id="通过符号执行生成测试输入"><a href="#通过符号执行生成测试输入" class="headerlink" title="通过符号执行生成测试输入"></a>通过符号执行生成测试输入</h4><p>​        在程序的符号执行期间，执行每个路径所需要满足的约束是以迭代的方式计算的。在访问程序内每条可能的路径之后，获得所有路径的约束。使用<strong>SMT</strong>等求解器可以获得满足约束条件的变量的具体值。得到的值是与约束条件相对应的，可以用来进行测试。</p>
<h3 id="SymJS"><a href="#SymJS" class="headerlink" title="SymJS"></a>SymJS</h3><p>SymJS是一个用于自动测试JavaScript Web应用程序客户端的框架，该工具包括一个用于JavaScript的符号执行引擎和一个Web页面的自动的事件资源管理器。而其中符号引擎包括一个符号虚拟机、一个字符串+数字解算器和一个符号可执行DOM模型。</p>
<p>​        SymJS解释从目标程序源代码编译的字节码。现有的符号执行器（如<strong>Klee</strong>[2]和<strong>Symbol Pathfinder</strong>[3]）都采用这种方法。处理字节码而不是源代码允许实现符号执行器，而无需处理语言的复杂语法。SymJS被实现为Rhino字节码的解释器，它在执行每条字节码指令时更新程序状态(堆/栈内容和路径条件)。在命中分支指令时，它复制程序状态并继续执行两个分支。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">Tool</th>
<th style="text-align:center">Target Lang.</th>
<th style="text-align:center">Sym.VM</th>
<th style="text-align:center">Dep./Cache Solving</th>
<th style="text-align:center">String Solving</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">SymJS</td>
<td style="text-align:center">JavaScript</td>
<td style="text-align:center">Yes</td>
<td style="text-align:center">Yes</td>
<td style="text-align:center">Yes</td>
</tr>
<tr>
<td style="text-align:center">KLEE [2]</td>
<td style="text-align:center">C</td>
<td style="text-align:center">Yes</td>
<td style="text-align:center">Yes</td>
<td style="text-align:center">No</td>
</tr>
<tr>
<td style="text-align:center">SAGE [6]</td>
<td style="text-align:center">x86 binary</td>
<td style="text-align:center">No</td>
<td style="text-align:center">Yes</td>
<td style="text-align:center">No</td>
</tr>
<tr>
<td style="text-align:center">Sym JPF [3]</td>
<td style="text-align:center">Java</td>
<td style="text-align:center">Yes</td>
<td style="text-align:center">No</td>
<td style="text-align:center">No</td>
</tr>
<tr>
<td style="text-align:center">Kudzu [8]</td>
<td style="text-align:center">JavaScript</td>
<td style="text-align:center">No</td>
<td style="text-align:center">No</td>
<td style="text-align:center">Yes</td>
</tr>
<tr>
<td style="text-align:center">Jalangi [9]</td>
<td style="text-align:center">JavaScript</td>
<td style="text-align:center">No</td>
<td style="text-align:center">No</td>
<td style="text-align:center">Limited</td>
</tr>
</tbody>
</table>
</div>
<center>
    <i>表I 符号执行器的比较</i>
</center>


<p>​        为了实现目标程序的符号执行，本文修改了原始Rhino对表II中所示指令的解释。堆栈操作、异常处理和变量范围管理的指令处理保持不变。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">操作</th>
<th style="text-align:center">指令</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Arithemetic/Logical Operations</td>
<td style="text-align:center">ADD, SUB, MUL, DIV, MOD, NEG, POS, BITNOT, BITAND, BITOR, BITXOR, LSH, RSH,URSH <em>etc.</em></td>
</tr>
<tr>
<td style="text-align:center">Comparisons</td>
<td style="text-align:center">EQ, NE, GE, GT, LE, LT, NOT, SHEQ, SHNE <em>etc.</em></td>
</tr>
<tr>
<td style="text-align:center">Branches</td>
<td style="text-align:center">IFEQ, IFNE, IFEQ_POP <em>etc.</em></td>
</tr>
<tr>
<td style="text-align:center">Function Calls</td>
<td style="text-align:center">RETURN, CALL, TAIL_CALL <em>etc.</em></td>
</tr>
<tr>
<td style="text-align:center">Object Manipulations</td>
<td style="text-align:center">NEW, REF, IN, INSTANCEOF, TYPEOF, GETNAME, SETNAME, NAME <em>etc.</em></td>
</tr>
<tr>
<td style="text-align:center">Object Accesses</td>
<td style="text-align:center">GETPROP, SETPROP, DELPROP, GETELEM, SETELEM, GETREF, SETREF <em>etc.</em></td>
</tr>
</tbody>
</table>
</div>
<center>
    <i>表II 修改后的指令解释</i>
</center>
例如，指令 `ADD op1 op2` 解释如下：

(1)从堆栈中弹出操作数 `op1` 和 `op2` 。操作数可以使用抽象的值，也可以使用具体的值。

(2)检查操作数的类型。如果两个操作数都是字符串，则计算结果是操作数的拼接。如果它们是数值，则结果是操作数的总和。否则，将**根据ECMAScript语言标准转换值**，结果是将获得的值拼接或相加。

#### 分支指令

​        比较指令之后是Rhino字节码中的分支指令。SymJS处理比较和分支指令对，如下所示：

​        首先，在进行必要的类型转换后，生成与比较结果相对应的布尔公式。假设所创建的公式由符号 $c$ 表示，我们检查 $c$ 及其否定 $\neg c$ 是否与路径条件 $pc$ 一起满足。换句话说，我们检查 $pc \land c$ 和 $pc \land \neg c$ 的可满足性。如果两者都是可满足的，我们建立对应于 $pc \land c$ 和 $pc \land \neg c$ 的状态 $s_1, s_2$，并从状态 $s_1$ 和 $s_2$ 继续执行。如果其中一个是可满足的，则选择与可满足的状态相对应的状态，并从该点继续执行。

​        SymJS支持两种方式来管理在命中分支等情况下创建的状态。第一种方法是**存储程序状态变量，包括堆/栈的内容**，如[2] [3]中所做的那样。第二种方法是**只记住在分支上走哪一侧。此方法需要在回溯时从初始状态重新执行目标程序。**但是，它得益于其简单的实现和较小的内存占用。这种方法被称为“模糊”，类似于[4] [6]中介绍的技术。但是，本文的技术是在符号执行器上实现的，不需要修改现有JavaScript工具[8] [9]所需的目标代码。

​        在通过模糊化执行程序的符号过程中，状态仅由分支上的哪一方表示和存储。该信息可用于从程序的初始状态重新执行该程序，并探索目标可能采取的状态空间。在模糊化期间，用与表I中的测试1-6相对应的路径条件符号执行图1中的目标程序之后的状态如表IV所示。符号L、R表示在分支指令上走左/右分支。

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func0</span> (<span class="params">s, a</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(””.equals(s)) &#123; <span class="comment">// block 0</span></span><br><span class="line">		s = <span class="literal">null</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (s.length &lt;= <span class="number">5</span>) &#123; <span class="comment">// block 1</span></span><br><span class="line">			a = a + status;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span>(””.equals(s)) &#123; <span class="comment">// block 2</span></span><br><span class="line">				Lib.m0(); <span class="comment">// Unreachable</span></span><br><span class="line">			&#125; <span class="keyword">else</span> &#123; <span class="comment">// block 3</span></span><br><span class="line">				Lib.m1();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (a &lt;= Lib.m2()) &#123; <span class="comment">// block A</span></span><br><span class="line">	a = <span class="number">0</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123; <span class="comment">// block B</span></span><br><span class="line">	a = a + s.length; <span class="comment">// Error with null s</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<center>
    <i>图1 一个代码框架：
    s, a, Lib.m2()可以取任意值</i>
</center>



<p><img src="http://images.yingwai.top/picgo/SymJSf2.png" alt=""></p>
<center>
    <i>图2 代码执行路径</i>
</center>



<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">Test No.</th>
<th style="text-align:left">Blocks Executed</th>
<th>State Representation</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:left">0, A</td>
<td>L;L</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:left">0, B</td>
<td>L;R</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:left">1, A</td>
<td>R;L;L</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:left">1, B</td>
<td>R;L;R</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:left">3, A</td>
<td>R;R;R;L</td>
</tr>
<tr>
<td style="text-align:center">6</td>
<td style="text-align:left">3, B</td>
<td>R;R;R;R</td>
</tr>
</tbody>
</table>
</div>
<center>
    <i>表IV 执行图1代码后的模糊表示</i>
</center>



<h4 id="PASS"><a href="#PASS" class="headerlink" title="PASS"></a>PASS</h4><p>​        对于表IV中的每个状态表示，可以获得相应的路径条件。如果有可能获得满足约束条件的解，则可以将其用作测试期间的输入。关于数值的约束可以通过SMT求解器来解决，但<strong>SMT不能处理对于字符串的约束</strong>。因此本文使用约束求解器PASS。</p>
<p>​        <strong>PASS可以处理对整数、位向量、浮点数和字符串的约束。</strong>虽然以前的支持字符串约束的约束解算器使用位向量或自动机，但通过参数化数组传递引入的建模可以实现更高效的求解。因此，它可以解决ECMAScript标准中与字符串操作相对应的大部分约束。</p>
<h4 id="符号存根及驱动程序"><a href="#符号存根及驱动程序" class="headerlink" title="符号存根及驱动程序"></a>符号存根及驱动程序</h4><p>​        符号变量是通过符号执行生成测试输入的对象。<strong>SymJS允许通过函数调用定义符号变量。</strong>下面的代码片段展示了定义符号字符串变量的例子：</p>
<p><code>var s = symjs_mk_symbol_string();</code></p>
<p>​        以上的例子定义了字符串类型的符号变量，也可以通过<code>symjs_mk_symbolic_int()</code>、<code>symjs_mk_symbolic_bool()</code>和<code>symjs_mk_symbolic_real()</code>分别定义整型、布尔型以及浮点型的符号变量。虽然SymJS只允许字符串、整数、布尔值和浮点数是符号的，但它们的约束作为更复杂的对象的组成部分保留在赋值/引用上，从而允许生成对象组成部分的值不断变化的测试。</p>
<p>​        为了确定图1中函数<code>func0()</code>的测试输入，需要额外的代码段。首先需要一个如下所示的符号驱动程序：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s = symjs_mk_symbolic_string();</span><br><span class="line"><span class="keyword">var</span> a = symjs_mk_symbolic_float();</span><br><span class="line">func0(s, a);</span><br></pre></td></tr></table></figure>
<center>
    <i>图3 用于执行图1中代码的符号驱动程序</i>
</center>

<p>驱动程序声明符号变量并将它们作为参数传递给函数。注入依赖项的存根也是必需的。如下所示的符号存根包括符号变量声明。通过存根，包含对<code>Lib.m2()</code>的函数调用的返回值，以测试SymJS获得的输入。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Lib.m2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> symjs_mk_symbolic_float();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>
    <i>图4 提供图1中代码使用的Lib.m2()的符号存根</i>
</center>

<p>函数<code>symjs_mk_symbolic_*()</code>是用于在测试生成期间定义新符号变量的表达式。<strong>SymJS允许使用生成的测试输入进行正常的具体执行。</strong>在具体执行期间，函数返回测试输入中包含的具体值。SymJS可以将测试输入导出为JavaScript Object Notation (JSON) 格式的外部文件。文件可以由测试回放库读取，该库在<code>symjs_mk_symbolic_*()</code>函数调用中返回相应的测试输入数据。加载到典型Web浏览器中的测试库可以在没有自定义JavaScript解释器的情况下执行生成的测试。</p>
<h2 id="符号存根及驱动程序的自动生成"><a href="#符号存根及驱动程序的自动生成" class="headerlink" title="符号存根及驱动程序的自动生成"></a>符号存根及驱动程序的自动生成</h2><p>​        如第2部分所述，符号存根和驱动程序需要对目标函数进行符号执行并获得测试输入。返回符号变量的符号存根用于生成从被测函数调用的函数的返回值。需要符号驱动程序来改变传递给测试函数的参数。</p>
<h3 id="生成符号存根和驱动程序的策略"><a href="#生成符号存根和驱动程序的策略" class="headerlink" title="生成符号存根和驱动程序的策略"></a>生成符号存根和驱动程序的策略</h3><p>​        本文的符号存根生成技术为指定的函数和类生成存根。本文的驱动程序生成技术发出调用指定函数的代码。</p>
<p>​        对于存根生成，生成函数根据调用者期望的返回值类型，创建和返回对象。以下是预期类型与返回对象之间的映射关系：</p>
<ul>
<li><p>字符串、整数、布尔值和浮点数这些可以被SymJS作为符号处理的类型（后面称为SymJS基础类型）：</p>
<p>新定义的相应类型的符号变量。</p>
</li>
<li><p>其他类：</p>
<p>预期类型的新实例化对象。如果该类的目标是生成存根，则返回<strong>新实例化的存根对象</strong>。</p>
</li>
<li><p>Void：不返回任何内容。</p>
</li>
</ul>
<p>​        为了创建类的存根，还需要生成构造函数的存根。在这里，本文生成空构造函数，这将导致所有无状态对象。我们的方法假设没有对存根类的字段的直接访问，并且不为字段生成存根。</p>
<p>​        注意：即使返回值类型不是SymJS的基本类型，也可能得到多个测试输入。如果在返回的对象中定义的函数返回符号变量，会出现这种情况。如果<strong>非SymJS基本类型的对象包含返回SymJS基本类型的对象的函数，并且非SymJS基本类型生成了存根</strong>，就会发生这种情况。因此可以通过调用返回非SymJS基本类型的函数来获得多组测试输入。</p>
<p>​        使用本文的技术生成的符号驱动程序具有以下功能：</p>
<ul>
<li>如果待测函数不是静态的、需要一个实例去执行，则实例化对应类的对象并调用该函数</li>
<li>如果待测函数是静态的，就直接调用函数</li>
</ul>
<p>对于传递给函数的参数，驱动程序根据预期类型提供以下对象：</p>
<ul>
<li><p>SymJS基本类型：</p>
<p>新定义的相应类型的符号变量。</p>
</li>
<li><p>其他类：</p>
<p>预期类型的新实例化对象。如果该类的目标是存根生成，则传递新实例化的存根对象。</p>
</li>
</ul>
<p>​        选择参数的方式类似于解决在符号存根中返回什么的方式。</p>
<h3 id="从注释生成符号存根和驱动程序"><a href="#从注释生成符号存根和驱动程序" class="headerlink" title="从注释生成符号存根和驱动程序"></a>从注释生成符号存根和驱动程序</h3><p>​        上一部分提出的符号存根/驱动程序生成策略需要知道来自目标代码的类型信息，生成存根需要调用方期望的返回值类型，需要传递给被测函数的参数类型才能生成驱动程序。</p>
<p>​        但是JavaScript是一种动态类型语言，在真正运行前很难确定返回值和参数的类型。很多JavaScript程序对返回值和参数的类型有一个期望，通常是在应用程序编程接口（API）等中给出的。此外，有一种方法可以<strong>用机器可读的方式表示JavaScript代码的类型信息</strong>，就是JSDoc风格的注释。本文从JSDoc3[13]约定的风格的注释中获取类型信息，生成符号存根和驱动程序。</p>
<p>​        JSDoc3主要允许通过<code>@return</code>注释声明返回值类型。为了为图1的代码片段中使用的函数<code>Lib.m2()</code>生成符号存根，需要如下所示的注释：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** <span class="doctag">@return <span class="type">&#123;Number&#125;</span> </span>m2 value */</span></span><br><span class="line">Lib.m2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; ... &#125;;</span><br></pre></td></tr></table></figure>
<p>如果将此类注释附加到函数的原始源代码，则可以确定返回值的类型。根据获得的返回值类型，可以以全自动的方式生成图4中的符号存根。该示例演示了为返回SymJS原语的函数生成符号存根。下面展示了为返回非SymJS基本类型的函数生成符号存根的示例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** <span class="doctag">@return <span class="type">&#123;tx.Data&#125;</span> </span>data */</span></span><br><span class="line">tx.Ui.getValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; ... &#125;;</span><br></pre></td></tr></table></figure>
<center>
    ↓
</center>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">tx.Ui.getValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> tx.Data();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>​        符号驱动程序的生成也是一样的。</p>
<p>​        传递给函数的参数类型通常使用JSDoc3的<code>@param</code>注释给出。函数<code>func0()</code>的符号驱动程序可以从该函数中的注释生成：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** <span class="doctag">@param <span class="type">&#123;String&#125;</span> <span class="variable">s</span></span></span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param <span class="type">&#123;Number&#125;</span> </span>a */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func0</span>(<span class="params">s, a</span>) </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>注释给出了函数的参数类型，允许生成图3中的符号驱动程序。</p>
<p>​        提出的自动生成符号存根和驱动程序的技术是作为JSDoc3的插件实现的。也可以使用其他来源的类型信息，例如API规范文档。</p>
<h2 id="Evaluation"><a href="#Evaluation" class="headerlink" title="Evaluation"></a>Evaluation</h2><p>​        本文使用一个工业JavaScript程序进行了实验。该程序对应于在本文的自定义Web应用程序实现框架上实现的Web应用程序的客户端部分。该程序调用未在我们的框架中包装的ECMAScript标准中定义的API，并且它只包含对标准API或本文的框架的调用。表V显示了目标程序的统计数据：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">#Line</th>
<th style="text-align:center">#Function</th>
<th style="text-align:center">#File</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">431</td>
<td style="text-align:center">23</td>
<td style="text-align:center">1</td>
</tr>
</tbody>
</table>
</div>
<center>
    <i>表V 目标程序的统计数据</i>
</center>

<h3 id="符号存根和驱动程序的生成"><a href="#符号存根和驱动程序的生成" class="headerlink" title="符号存根和驱动程序的生成"></a>符号存根和驱动程序的生成</h3><p>​        使用本文的方法成功地为框架中定义的所有类和函数生成存根。表VI列出了生成的存根的统计数据：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">#Line(Orig.)</th>
<th style="text-align:center">#Line(Stub)</th>
<th style="text-align:center">#Function</th>
<th style="text-align:center">#File</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">2843</td>
<td style="text-align:center">1304</td>
<td style="text-align:center">154</td>
<td style="text-align:center">13</td>
</tr>
</tbody>
</table>
</div>
<center>
    <i>表VI 用于生成存根的框架源代码和生成的存根的统计数据</i>
</center>

<h3 id="生成测试输入和执行测试"><a href="#生成测试输入和执行测试" class="headerlink" title="生成测试输入和执行测试"></a>生成测试输入和执行测试</h3><p>​        所有函数的符号执行在1秒内完成，并生成测试输入。测试输入的数量（将具体值赋给符号变量）在目标函数之间是不同的。对于没有分支的函数，只生成1个测试输入，而对于更复杂的函数，获得的测试数量变化到27个。</p>
<p>​        利用获得的测试输入来具体执行目标函数。运行在网络浏览器上的测试回放库用于重放测试。使用JSCover[14]测量测试期间的代码覆盖率，获得92%的行覆盖率。结果表明，该技术能够自动生成单元测试输入，实现高代码覆盖率。</p>
<h3 id="实验中未覆盖的代码"><a href="#实验中未覆盖的代码" class="headerlink" title="实验中未覆盖的代码"></a>实验中未覆盖的代码</h3><p>​        实验结果表明，该方法可以生成代码覆盖率较高的测试输入，但没有达到100%的覆盖率，这意味着目标程序的某些部分没有被执行。以下是使用我们的方法未执行到的代码类。</p>
<p>​        <strong>意外类型的代码处理对象没有被覆盖到。</strong>由于JavaScript是一种动态类型语言，函数可能会返回意外类型的对象。为了处理这种情况，目标程序包含类型检查和后续错误处理代码。但是，通过本文的技术生成的符号存根总是返回源代码批注中描述的类型的对象。这样的存根不能利用处理不同于注释类型的对象的代码部分。</p>
<p>​        <strong>没有对象类型前提的代码也没有被覆盖到。</strong>目标程序包含在运行时确定对象类型并相应地处理它们的代码片段。然而，本文的技术不能涵盖这样的程序。从返回值类型未知的函数中，我们生成返回默认JavaScript “Object” 的存根。因此，与自定义类的对象交互的代码没有被覆盖。</p>
<h2 id="Conclusions"><a href="#Conclusions" class="headerlink" title="Conclusions"></a>Conclusions</h2><p>​        本文提出了一种为JavaScript代码自动生成单元测试输入数据的技术。该技术使用符号执行引擎，以便在测试期间实现高代码覆盖率。该技术分为两个阶段，由以下全自动步骤组成：</p>
<ul>
<li>基于从注释获得的类型信息生成符号存根/驱动程序</li>
<li>通过目标代码的符号执行生成测试输入</li>
</ul>
<p>​        实验结果显示，该技术可以生成92%的行覆盖率的测试，表明本文的技术可以自动生成和执行JavaScript代码的单元测试。</p>
<h3 id="Future-Work"><a href="#Future-Work" class="headerlink" title="Future Work"></a>Future Work</h3><p>​        未来的方向包括更多的验证试验和各种目标程序。虽然作者已经用相对较小的程序进行了实验，但也需要在较大的目标上进行实验。</p>
<p>​        根据实验结果，需要改进符号存根。可以使用引发异常的符号存根触发代码处理异常。除了更复杂的自动存根生成策略外，手动修改自动生成的存根被认为是增加覆盖率的有效方法。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1] C. Cadar, V . Ganesh, P . M. Pawlowski, D. L. Dill, and D. R. Engler, <em>“EXE: Automatically Generating Inputs of Death,”</em> in Proceedings of the 13th ACM Conference on Computer and Communications Security, 2006, pp. 322–335.</p>
<p>[2] C. Cadar, D. Dunbar, and D. Engler, <em>“KLEE: Unassisted and Automatic Generation of High-coverage Tests for Complex Systems Programs,”</em> in Proceedings of the 8th USENIX Conference on Operating Systems Design and Implementation, 2008, pp. 209–224.</p>
<p>[3] C. S. Pǎsǎreanu and N. Rungta, <em>“Symbolic PathFinder: Symbolic Execution of Java Bytecode,”</em> in Proceedings of the IEEE/ACM International Conference on Automated Software Engineering, 2010, pp. 179–180.</p>
<p>[4] K. Sen, D. Marinov, and G. Agha, <em>“CUTE: A Concolic Unit Testing Engine for C,”</em> in Proceedings of the 10th European Software Engineering Conference, 2005, pp. 263–272.</p>
<p>[5] N. Tillmann and J. De Halleux, <em>“Pex: White Box Test Generation for .NET,”</em> in Proceedings of the 2nd International Conference on Tests and Proofs, ser. TAP’08, 2008, pp. 134–153.</p>
<p>[6] P . Godefroid, M. Y . Levin, and D. Molnar, <em>“SAGE: Whitebox Fuzzing for Security Testing,”</em> Queue, 2012, pp. 20:20–20:27.</p>
<p>[7] L. De Moura and N. Bjørner, <em>“Satisfiability Modulo Theories: Introduction and Applications,”</em> Commun. ACM, vol. 54, no. 9, 2011, pp. 69–77.</p>
<p>[8] P. Saxena, D. Akhawe, S. Hanna, F. Mao, S. McCamant, and D. Song, <em>“A Symbolic Execution Framework for JavaScript,”</em> in Proceedings of the 2010 IEEE Symposium on Security and Privacy, 2010, pp. 513–528.</p>
<p>[9] K. Sen, S. Kalasapur, T. Brutch, and S. Gibbs, <em>“Jalangi: A selective record-replay and dynamic analysis framework for javascript,”</em> in Proceedings of the 2013 9th Joint Meeting on Foundations of Software Engineering, 2013, pp. 488–498.</p>
<p>[10] G. Li and I. Ghosh, <em>“PASS: String Solving with Parameterized Array and Interval Automaton,”</em> in Proceedings of Haifa Verification Conference, 2013, pp. 15–31.</p>
<p>[11] ECMA International, Standard ECMA-262 - ECMAScript Language Specification, 5th ed., June 2011. [Online]. Available: <a href="http://www.ecma-international.org/publications/standards/Ecma-262.htm" target="_blank" rel="noopener">http://www.ecma-international.org/publications/standards/Ecma-262.htm</a></p>
<p>[12] <em>“Rhino,”</em> <a href="https://developer.mozilla.org/en-US/docs/Rhino" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Rhino</a>, [Online; accessed 2014.08.15].</p>
<p>[13] <em>“Use JSDoc,”</em> <a href="http://usejsdoc.org/index.html" target="_blank" rel="noopener">http://usejsdoc.org/index.html</a>, [Online; accessed 2014.08.15].</p>
<p>[14] <em>“JSCover - JavaScript code coverage,”</em> <a href="http://tntim96.github.io/JSCover/" target="_blank" rel="noopener">http://tntim96.github.io/JSCover/</a> <a href="http://usejsdoc.org/index.html" target="_blank" rel="noopener">http://usejsdoc.org/index.html</a>, [Online; accessed 2014.08.15].</p>
]]></content>
      <categories>
        <category>Papers</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title>论文笔记 Designing an e-commerce recommender system based on collaborative filtering using a data mining approach</title>
    <url>/2020/05/18/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0-Designing-an-e-commerce-recommender-system-based-on-collaborative-filtering-using-a-data-mining-approach/</url>
    <content><![CDATA[<p><em>Samira Khodabandehlou</em></p>
<p><a href="https://scholar.google.com/scholar?hl=zh-CN&amp;as_sdt=0%2C5&amp;q=Designing+an+e-commerce+recommender+system+based+on+collaborative+filtering+using+a+data+mining+approach&amp;btnG=" target="_blank" rel="noopener">https://scholar.google.com/scholar?hl=zh-CN&amp;as_sdt=0%2C5&amp;q=Designing+an+e-commerce+recommender+system+based+on+collaborative+filtering+using+a+data+mining+approach&amp;btnG=</a></p>
<a id="more"></a>
<p><img src="http://images.yingwai.top/picgo/Designing an e-commerce recommender system based on collaborative filtering using a data mining approach.jpg" alt=""></p>
<h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>电子商务推荐系统已经转变为客户非常重要的决策辅助工具，利用信息技术和客户信息提供在线个性化推荐。同时，协同过滤推荐系统是电子商务系统成功的关键组成部分之一。尽管有协同过滤现在的普及和成功，这些系统仍然面临着一系列严重的限制，包括冷启动、user-item矩阵稀疏、可扩展性和用户兴趣在这段时间内的变化，这些都阻碍了对客户的准确推荐。虽然已有很多研究提出了克服这些局限性的方法，但还没有提供一个全面的模型来降低这些局限性：1)在产品类别层面上基于LRFM变量进行客户细分，以评估与公司的客户关系的长度、最近程度、频率和购买产品类别的金额；2)在每个聚类级别上基于用户-类别矩阵提取关联规则；3)根据人口统计变量进行客户细分；4)改变用户-项目矩阵并降低其维数；5)通过将细分方法的结果与CF加权组合来开发新的相似度函数。根据所获得的结果，本研究提出的系统消除了传统的CF约束，为客户的偏好提供了更准确、更合适的建议。</p>
<p><strong>关键词：</strong>协同过滤；数据挖掘；电子商务；推荐系统；时态信息。</p>
<p>本研究的主要目标包括：找出传统协同过滤在向合适的用户推荐合适商品方面的局限性，提出一个全面的、全新的推荐系统来消除传统CF的局限性，用真实的数据对推荐系统进行评估，以提供更准确、更符合顾客口味的推荐。</p>
<h1 id="理论背景"><a href="#理论背景" class="headerlink" title="理论背景"></a>理论背景</h1><h2 id="推荐系统"><a href="#推荐系统" class="headerlink" title="推荐系统"></a>推荐系统</h2><p><strong>推荐系统</strong>是提高电子商务环境中决策过程质量的有用工具，因为它们通过提供必要的信息和有用的建议来帮助在线决策者选择与他们的愿望和要求一致的项目(Shambour and Lu，2015；Son，2016)。事实上，识别用户偏好的能力是个性化RS的核心(Kim等人，2011年)。Ricci等人。(2011)将RS定义为特定类型的信息系统，该信息系统：</p>
<ol>
<li>帮助客户选择他们没有亲身体验的项目；</li>
<li>向顾客推荐商品；</li>
<li>通过为客户提供信息来帮助他们决定购买哪种商品。</li>
</ol>
<p>创建推荐系统有五个阶段：收集数据、分析用户信息、计算相似度、选择邻居、预测并提出前N个项目的列表(Yahya和Al-Shamri，2016)。这些系统出现在20世纪90年代中期，通常分为三类(Lee，2010；Resnick，1994)：</p>
<ol>
<li><p><strong>协同过滤</strong>：这些系统根据一组被称为邻居的相似用户或相似项目的得分提供推荐(Kim等人，2005年)。CF是Netflix和Amazon等著名电子商务公司使用的最受欢迎的RS之一(Hernando等人，2016；Kim等人，2005年)。这些系统又根据它们用于预测用户偏好的算法类型分为两类(Ghazarian和Nematbakhsh，2014)：</p>
<ul>
<li><strong>Memory-based</strong>：这些系统使用用户项目评分矩阵和KNN算法来识别用户的邻居并预测他们的偏好(Ghazarian和Nematbakhsh，2014年；Hernando等人，2016年；Kim等人，2011年)，其中使用皮尔逊相关系数等方法计算用户之间的相似性(Bobadilla等人，2012年)。在本研究中，使用KNN算法和皮尔逊相关系数来提供建议。</li>
<li><strong>Model-based</strong>：这些系统使用分段等方法处理用户的档案数据以提供建议，从而改进计算(Ghazarian和Nematbakhsh，2014；Hernando等人，2016)。</li>
</ul>
<p>尽管CF方法很受欢迎并取得了成功，但它们仍然面临着一些严重的限制。这些限制包括：</p>
<ul>
<li><strong>冷启动</strong>：在多个用户购买某个项目之前，系统不能向某人推荐该项目。这个问题被称为冷启动。用户的冷启动是指最近加入推荐系统并且没有关于他或她的足够信息的用户(Elahi等人，2016；Hu和Pu，2011；Kim等人，2011；Lee，2010；Son，2016；Sharma和Ray，2016)。</li>
<li><strong>可伸缩性</strong>：由于客户数据和产品数据的绝对数量，系统必须花费大量的金钱和时间来提取所有客户之间的相似性，导致其生产率较低(Hu和Pu，2011；Hernando等人，2016；Keramati和Khaleghi，2014；Lee，2010)。</li>
<li><strong>user-item矩阵的稀疏性</strong>：由于用户数量巨大，一个项目通常没有足够的分数或购买，导致user-item矩阵稀疏(Adomavicius和Tuzhlin，2005；Ghazarian和Nematbakhsh，2014；Karimi Alavije等人，2015，Sharma和Ray，2016)。</li>
<li><strong>用户偏好的改变</strong>：用户的品味和偏好可能会随着时间的推移而改变。例如，一位最近生了孩子的母亲可能对购买婴儿服装感兴趣，她最近的购买可能反映了这种新的关注。这是当；她可能从来没有对这样的物品有任何兴趣(Ding等人，2006年；岩田，2008年；Lee等人，2008年)。(Ding et al.，2006；Iwata，2008；Lee et al.，2008)。</li>
</ul>
<p>上述限制可能会对RS的性能产生负面影响，从而限制系统创建有意义和准确的推荐。</p>
</li>
<li><p><strong>基于内容的过滤器(Content-Based Filter，CBF)</strong>：该方法基于这样的概念，即用户对他们以前感兴趣的项目感兴趣。因此，这些系统根据项目和产品之间的相似性提供建议(Anderson和Hiralall，2009年；Elahi等人，2016年)。因此，这种方法取决于物品的规格和与这些规格相关的用户配置文件的可用性(Anderson and Hiralall，2009)。这是因为在互联网上存储大量不同种类电子产品的目录是一项非常困难的任务(Bobadilla等人，2012年)。因此，音乐或视频文件等一些产品的内容分析非常困难；这个问题使得CF比CBF要好得多(Anderson和Hiralall，2009；Kim等人，2011)。与CBF相比，CF在电子商务中具有更高的灵活性和与RS的兼容性，使其成为最常用和最有用的RS系统之一(Burke，2002；Iwata，2008；Wang and Wu，2012)。因此，在本研究中，使用CF的概念作为主要的推荐机制。</p>
</li>
<li><p>混合方法：一些RS使用上述系统的组合来减少它们的限制；更多细节将在下面的实验背景部分提供(Burke，2002；Keramati和Khaleghi，2014)。</p>
</li>
</ol>
<h2 id="客户细分"><a href="#客户细分" class="headerlink" title="客户细分"></a>客户细分</h2><p>客户细分是一种非常有用的数据挖掘方法，用于在电子商务的RS中找到“邻居”，在电子商务中，使用特定的方法，如聚类，来选择一些用户作为邻居，以改进偏好的预测(Khodabandehlou和Niknafs，2016；Li等人，2011年)。</p>
<p>在RS中，选择合适的属性进行分割是影响系统性能的重要因素之一。最近购买、频率和货币模型(RFM)的属性是基于分析客户购买行为的一种很好的客户细分方法，它已经成功地用于许多RS(Keramati和Khaleghi，2014；Khodabandehlou和Zivari Rahman，2017；Lee，2010)。各种研究表明，在RFM模型中加入L(客户关系长度)指标将导致对客户的更准确分析，并将提高细分的质量(Li等人，2011年)。因此，在本研究中，LRFM模型被用于客户细分和识别具有相似购买行为的客户类别。</p>
<p>此外，分割算法对识别出的片段的质量起着重要的作用。在聚类算法中，K-Means算法被认为是最成功和最合适的分割方法(Khodabandehlou和Niknafs，2016)，在许多研究中证明了它与RS的兼容性(Keramati和Khaleghi，2014；Karimi Alavije等人，2015；Li等人，2011年)。K-Means是一种数据挖掘方法，它需要K的初始值，即聚类的数量，才能运行。确定最佳簇数的合适方法是自组织映射(SOM)算法。该算法是一种无监督神经网络，可以从数据中识别未知模式，并估计合适的聚类数量(Abidi和Ong，2000；Mosayebian等人，2012)。</p>
<p>相关研究建议在RS中结合K-Means和SOM算法使用两阶段分割方法，以获得更准确的结果(Keramati和Khaleghi，2014；Mosayebian等人，2012年)。因此，本研究将利用这一模式进行客户细分。</p>
<h2 id="关联规则"><a href="#关联规则" class="headerlink" title="关联规则"></a>关联规则</h2><p>关联规则是数据挖掘的重要方法之一，用于分析RS大型数据库中各种商品之间的市场篮子。分析购物篮已经成为发现用户购物车之间关系的流行系统(Hsu等人，2004；Liu and Shih，2005a)。Apriori算法是最常见的关联规则之一(Hsu等人，2004；Liu和Shih，2005a，2005b)，用于在已经购买了另一件物品时找到购买特定物品的概率模式。在RS中，已经形成了许多关于不同用户的购买行为的规则(Keramati和Khaleghi，2014；Liu和Shih，2005a，2005b)。在这些规则吸引程度的衡量标准中，我们可以提到支持性规则和置信度规则，它们分别指发现的规则的传播度和可接受性(Hsu等人，2004；Keramati和Khaleghi，2014；Karimi Alavije等人，2015；Liu和Shih，2005a，2005b)。</p>
<h1 id="评估措施"><a href="#评估措施" class="headerlink" title="评估措施"></a>评估措施</h1><p>评价推荐系统的性能是保证推荐系统通用性的重要一步。有一些评价RSS准确性或性能的众所周知的度量；诸如精确度、覆盖率和F度量(为了在这两个度量之间创建平衡)，它们可以很好地显示推荐系统的性能(Bobadilla等人，2012年；Elahi等人，2016；Ghazarian和Nematbakhsh，2014；Shambour和Lu，2015；Son，2016)。因此，为了评估所提出的研究模型的性能，采用了这些测量方法。</p>
<p>在公式(1)和(2)中，喜爱的项目是指必须推荐给用户的一组产品或项目，而推荐的项目是已经由系统推荐给用户的项目的集合。精确度表示推荐集合中正确推荐的百分比，并评估这些推荐的精确度和准确性。通过公式(1)计算：</p>
<script type="math/tex; mode=display">
{\rm Precision}=\frac{\rm Recommended \ Items\cap Favorite \  Items}{\rm Recommended \  Items} \tag{1}</script><p>覆盖率表示已经向用户建议了多少用户喜欢的项目的百分比，并使用公式(2)计算：</p>
<script type="math/tex; mode=display">
{\rm Coverage}=\frac{\rm Recommended \ Items\cap Favorite \  Items}{\rm Favorite \  Items} \tag{2}</script><p>F-MEASURE是精度和覆盖范围的调和平均值，使用公式(3)计算：</p>
<script type="math/tex; mode=display">
{\rm F - measure}=\frac{2 \times \rm Coverage \cap Precision}{\rm Coverage + Precision} \tag{3}</script><h1 id="研究框架"><a href="#研究框架" class="headerlink" title="研究框架"></a>研究框架</h1><p>在设计和开发RSS时，真实、高质量的数据是非常重要的。本研究使用的这组数据与伊朗一家销售服装的网站的真实数据相关，时间范围为2015年1月21日至2016年1月21日(12个月)。此数据集涉及2542个客户和17,000条记录。在这家商店里，产品分为女装、男装、童装、女装、男装、女包和鞋、男包和鞋等七大类。据此，本研究提出的系统框架由八个主要阶段组成。在第一阶段，准备数据。该阶段由数据清理、数据整合、数据转换三个子阶段组成。在第二阶段，基于LRFM模型进行客户细分。在阶段3，基于product category-user矩阵提取关联规则。在阶段4中，完成user-item矩阵的改变。阶段5显示了基于CF的相似度计算。在阶段6中，根据人口统计特征对客户进行细分。在阶段7中，基于新的相似性函数来确定邻居。在最后阶段，推荐是根据用户的需求和特点量身定做的。在下文中，我们将对所有这些阶段进行详细说明。建议系统的总体框架如图1所示。</p>
<p><img src="http://images.yingwai.top/picgo/derf1.png" alt=""></p>
<center>
    <i>图1 建议的研究系统的总体架构</i>
</center>


<h2 id="数据准备"><a href="#数据准备" class="headerlink" title="数据准备"></a>数据准备</h2><p>数据准备(也称为数据预处理)是RSS开发过程中不可或缺的一步，占整个RSS开发所需时间的60%-70%。此步骤包括数据清理、数据集成和数据转换三个阶段。</p>
<h3 id="数据清理"><a href="#数据清理" class="headerlink" title="数据清理"></a>数据清理</h3><p>数据清理过程包括完成缺失值、识别和消除离群值数据以及解决数据之间的冲突。此外，在此阶段，必须删除不相关或无用的字段或属性，如有必要，从初始数据集形成新的变量。在此阶段，将不完美的记录和信息不完整的客户从主数据集中剔除，数据集的记录从17,000条减少到15,386条，客户数量从2,542个减少到2,080个。为每个产品类别计算RFM变量。</p>
<h3 id="数据集成"><a href="#数据集成" class="headerlink" title="数据集成"></a>数据集成</h3><p>为了更好地理解数据，并对每个数据集中的数据进行更好的科学管理，数据集成(将两个或多个数据集合并集成在一起)是必要的，这是数据准备的第二阶段。在这一阶段，客户交易数据与他们的个人资料数据(年龄、性别、教育程度、婚姻状况和职业)集成在一起。</p>
<h3 id="数据转换"><a href="#数据转换" class="headerlink" title="数据转换"></a>数据转换</h3><p>在此阶段，必须将数据转换为适合数据挖掘和设计RS的不同形式。数据集中的字符串变量(如性别)将转换为数值变量和值。</p>
<h2 id="基于LRFM模型的分割"><a href="#基于LRFM模型的分割" class="headerlink" title="基于LRFM模型的分割"></a>基于LRFM模型的分割</h2><p>本研究采用两阶段聚类法，结合SOM(确定最佳聚类数)和K-Means(创建聚类)方法进行分割。</p>
<p>在此阶段，根据产品类别的RFM变量(每个产品类别的RFM变量的值分别计算)和L变量(客户关系的长度)进行客户细分。对于给定的客户，表1中给出了这些变量的样本，根据这些变量进行了细分。</p>
<p>在本研究中，将LRFM模型用于产品类别层面的客户细分有三个原因，包括以下几个方面：</p>
<ol>
<li>通过减少user-item矩阵中的客户数量，提高了该方法的生产率和效率，从而降低了矩阵的可扩展性和稀疏性问题。</li>
<li>这个模型不仅决定了顾客的价值，而且可以清楚地反映顾客的兴趣和偏好，例如，如果某一种产品的购买频率对于两个给定的顾客来说是相似的，可以推断这两个人对购买这两种商品的兴趣是一样的。M和R的变量也是以相同的方式推导出来的。</li>
<li>模型中的产品类别变量R涉及客户最近的品味和偏好，由于最近的购买更能反映客户当前的兴趣和偏好，它将提供更准确的推荐，更符合客户当前的兴趣。</li>
</ol>
<p><img src="http://images.yingwai.top/picgo/dert1.png" alt=""></p>
<center>
    <i>表1 基于LRFM模型的客户细分属性</i>
</center>



<h2 id="基于product-category-user矩阵的关联规则提取"><a href="#基于product-category-user矩阵的关联规则提取" class="headerlink" title="基于product category-user矩阵的关联规则提取"></a>基于product category-user矩阵的关联规则提取</h2><p>为了提取关联规则，本研究使用了Apriori算法。在此阶段，使用product category-user矩阵(客户从单个产品类别购买的次数)的交易数据在前一阶段的每个聚类的级别提取关联规则。提取的规则用于确定每个目标客户的前N个推荐产品类别的列表。推荐的每个产品类别的优先级取决于其规则的可信度和支持措施。信任度和支持度值越大的产品类别，推荐优先级越高。此阶段中提取的规则的输出(即每个目标客户的预测产品类别)将作为下一阶段的输入。产品类别级规则提取的目的是减少user-item矩阵中的产品数量，有效缓解矩阵的可扩展性和稀疏性问题。</p>
<h2 id="更改user-item矩阵"><a href="#更改user-item矩阵" class="headerlink" title="更改user-item矩阵"></a>更改user-item矩阵</h2><p>在CF系统中，user-item矩阵(包括购买/不购买项目的二进制数据或用户给予项目的分数)是关于购买偏好对客户进行聚类并确定目标客户的邻居的基础。然而，由于电子商务中商品种类繁多，该矩阵经常面临数据稀疏的问题。研究表明，推荐质量取决于user-item矩阵的密度。</p>
<p>为了使该矩阵更加密集，以这样的方式使用分段和关联规则阶段的结果，即在用于确定目标客户的邻居的user-item矩阵中，他或她将仅与他或她的集群中的用户进行比较，并且项目将限于为目标客户预测的项目。由于减少了用户数和项目数，缓解了可伸缩性问题，提高了RS的速度和准确性。</p>
<p>在他们的研究中，Lee等人。(2008)证明，最近进行的购买更能反映用户当前的偏好，最近添加到网站上出售的项目对用户更具吸引力。因此，基于表2，对于每个项目，考虑用户购买项目的时间(PT)和项目已经可供购买的时间(LT)(启动时间)的两个参数，并且改变user-item矩阵。</p>
<p><img src="http://images.yingwai.top/picgo/dert2.png" alt=""></p>
<center>
    <i>表2 基于时间信息更改user-item矩阵</i>
</center>





<p>为了确定PT和LT变量的得分，在这个改变的矩阵中，首先根据这两个参数的潜伏期将这两个参数分为五类。因此，PT参数的分数包括过去购买(分数1)、过去购买(分数2)、最近购买(分数3)、最近购买(分数4)和最近购买(分数5)。对于LT参数，得分类似。根据表3，在user-item矩阵中，对于用户给出的分数，使用组合分数。例如，对于(2，5)的组合，分数将等于7(5+2)。在计算混合得分时，这两个参数的权重都是相同的。</p>
<p><img src="http://images.yingwai.top/picgo/dert3.png" alt=""></p>
<center>
    <i>表3 对LT和PT参数进行评分</i>
</center>


<p>因此，创建了25(5×5)个双重组合，其中所有客户由55、54、53、…的组合表示。，11，其中，客户最好的类别是组合55(最近购买时间和最近上线时间的类别)和得分10，而客户最差的类别用11(最老的购买时间和最老的上线时间)表示，得分为2。根据这种评分方法，可以将客户划分为集群，并计算其相似度。创建这个新的user-item矩阵的目的是考虑用户随时间的喜好，从而提高推荐的准确性。</p>
<h2 id="基于CF的相似度计算"><a href="#基于CF的相似度计算" class="headerlink" title="基于CF的相似度计算"></a>基于CF的相似度计算</h2><p>在CF系统中，计算每个目标客户与其他客户之间的相似度的方法有很多。最流行的方法之一是使用皮尔逊相关系数，与其他传统的统计方法相比，它提供了最好的预测和推荐结果(Bobadilla等人)。(2012年)。在皮尔逊的相关方法中，使用公式(4)测量两个给定客户$u$和$u’$之间的相似性：</p>
<script type="math/tex; mode=display">
Sim(u, u') = \frac{\sum^n_{i=1}(r_{ui}-\bar{r}_u)(r_{u'i}-\bar{r}_{u'})}{\sqrt{\sum^n_{i=1}(r_{ui}-\bar{r}_u)^2\sum^n_{i=1}(r_{u'i}-\bar{r}_{u'})^2}} \tag{4}</script><p>在这个等式中，$n$是两个用户得分的项目数，$i$是两个用户得分的项目集合，$r_{ui}$是用户$u$给出的项目$i$的得分，$\bar{r}_u$是用户的平均得分。在本研究中，使用基于新的user-item矩阵的Pearson相关方法，计算客户偏好之间的相似度，然后将该阶段的结果(基于CF的相似度)用于预测客户的偏好。</p>
<h2 id="基于人口统计属性的细分"><a href="#基于人口统计属性的细分" class="headerlink" title="基于人口统计属性的细分"></a>基于人口统计属性的细分</h2><p>在这个阶段，使用两阶段聚类方法，根据年龄、性别、教育程度、婚姻状况和职业等人口统计变量对客户进行细分，然后计算他们的簇内相似度。因此，如果两个客户具有相似的人口统计属性，他们对某些项目的态度会相似，这在CF方法中没有反映出来。在本研究中，基于这些变量进行客户细分的目的是为了更好地选择新用户的邻居，通过克服冷启动问题有效改善推荐过程。</p>
<h2 id="基于新的相似度函数确定邻域"><a href="#基于新的相似度函数确定邻域" class="headerlink" title="基于新的相似度函数确定邻域"></a>基于新的相似度函数确定邻域</h2><p>在此阶段，将前一阶段得到的聚类相似度(基于人口统计属性)和CF相似度合并到一个新的相似度函数中，以缓解冷启动问题。因为在用户最近加入系统的情况下，新的相似性函数并不完全依赖于user-item矩阵。通过该函数可以得到相似度。相似度函数(Hsim)通过簇内相似度(ClusSim)和基于CF的相似度(Sim)的加权和计算如下(5)：</p>
<script type="math/tex; mode=display">
Hsim(u,u')=(1-\alpha) \times Sim(u,u') + \alpha \times clusSim(u,u') \tag{5}</script><p>在利用上述公式计算客户之间的相似度后，选择与目标客户相似度最高的K个客户作为该客户的邻居。</p>
<h2 id="提供推荐"><a href="#提供推荐" class="headerlink" title="提供推荐"></a>提供推荐</h2><p>在识别前一阶段目标客户的邻居后，通过计算这些邻居给出的得分的加权平均，预测目标客户的偏好。基于公式(6)，利用邻居得分的加权平均值$(r_{u’,i})$，预测用户$u$对于项目$i$，$(r_{u,i})$的得分如下：</p>
<script type="math/tex; mode=display">
r_{u,i} = \frac{1}{n} \sum_{u' \in U} Hsim(u,u') \times r_{u',i} \tag{6}</script><p>$U$表示评价项目$i$的用户$u$的邻居。用户$u$和$u’$，$(r_{u’,i})$越相似，将以更高的加权比率用于预测$(r_{u,i})$。最后，将预测评分最高的$N$个项目推荐给目标用户。</p>
<h1 id="评估提出的推荐方法"><a href="#评估提出的推荐方法" class="headerlink" title="评估提出的推荐方法"></a>评估提出的推荐方法</h1><p>为了评估结果，将使用的数据集分为训练集和测试集。训练数据用于推荐系统，测试数据用于评估系统结果的准确性。训练数据涵盖2015年1月25日至11月16日期间，包括2015年11月16日至2016年1月21日期间交易的测试数据。</p>
<p><img src="http://images.yingwai.top/picgo/dert4.png" alt=""></p>
<center>
    <i>表4 传统CF推荐系统与提出的CF推荐系统的评价方法比较</i>
</center>



<p>在此阶段，将比较所提出的方法与传统CF推荐系统在不同N值(推荐项目数)下以及基于使用精确度、覆盖率和F度量的测试数据的结果的准确性。</p>
<p>基于SOM算法，基于LRFM变量的最优聚类数为6个，基于人口统计变量的最优聚类数为5个。表4列出了基于不同N值的评估措施的传统方法和提出的方法的准确性。对于所有这些方法，参数K(邻居数目)的值都等于40。</p>
<p>根据表4的结果，在每个准则下，所提出的系统都比传统系统具有更好的性能。事实上，传统系统(基于F-Measure)在5个推荐项目上的准确率为43.27%，而在所提出的系统中，该准确率为55.59%。在20个推荐项目中，传统方法的准确率为62.43%，其推荐系统的准确率为81.4%。在30个项目中，传统系统的准确率为68.54%，在提出的系统中，准确率为96.59%，表明该系统在30个项目上的准确率比传统系统提高了约28%。</p>
<p><img src="http://images.yingwai.top/picgo/derf2.png" alt=""></p>
<center>
    <i>图2 比较传统方法和建议方法在不同N值下的性能(颜色请参见在线版本)</i>
</center>


<p><img src="http://images.yingwai.top/picgo/derf3.png" alt=""></p>
<center>
    <i>图3 评估不同K值对建议方法性能的影响(有关颜色，请参阅在线版本)</i>
</center>


<p>在此基础上，将推荐项数增加到N=30，两种方法的性能都有所提高。然而，增加数据数量并不会导致结果准确性的显著变化和提高。因此，将推荐项目的数量增加到某个阈值可以提高建议推荐的质量；该阈值等于N=30。为了更好地比较这两种方法的性能，图2描述了F-Measure准则的变化趋势。</p>
<p>为了评估参数K的变化在所建议的研究方法的性能中的作用，图3中描述了三个不同N值的F测量值。基于图3，对于N参数的所有三个值，将邻居数增加到K=40将提高所提出的方法的性能。但是，进一步增加该参数会降低方法的精确度，从而对推荐质量产生负面影响。</p>
<h1 id="结论及建议"><a href="#结论及建议" class="headerlink" title="结论及建议"></a>结论及建议</h1><p>本研究从冷启动、可扩展性、稀疏用户-项目矩阵以及用户兴趣的变化等方面考虑了电子商务中RS的基本和常见限制，以期解决或缓解这些限制。因此，为了克服这些局限性，人们利用一套数据挖掘方法，提出了一个综合性的电子商务推荐系统。综合研究结果，该系统的性能优于传统的CF系统。研究的总体结果表明，与传统系统相比，新的推荐系统的准确率有了显着的提高。因此，该系统对30个项目的推荐准确率比传统系统提高了约28%。此外，根据结果，系统在推荐30个项目时的准确率达到了最高水平；因此，当推荐项目数量超过30个时，传统系统和所提出的系统的准确率都没有明显的变化，因此，当推荐项目的数量超过30时，传统系统和本文提出的系统的准确率都没有明显的变化。例如，当推荐50个项目时，传统系统的准确率为68/84，新建议系统的准确率为94/45，这表明推荐项目的数量从30个增加到50个，准确率略有下降。因此，建议推荐项目的最大值为30个，因为这可能会导致计算和项目选择的复杂性。下面简要介绍一下研究成果和研究创新之处：</p>
<ul>
<li>在RS的开发过程中，在产品类别层面采用基于LRFM变量的细分方法，可以改进客户间相似度的确定方法，从而更准确、更恰当地选择目标客户的邻居。由于LRFM模型是识别客户购买行为和反映其偏好的合适方法之一，因此基于该模型在产品类别层次上进行细分，可以区分客户在购买产品类别时的偏好，并将具有相似品味和兴趣的客户归入同一聚类。例如，如果两个给定客户购买商品的频率相似，则可以得出结论，这两个客户对购买该产品类别中的商品表现出相同的兴趣水平。R和M的变量可以以相同的方式推断。另一方面，在产品类别水平上的变量R考虑了客户的利益，并且由于最近的购买更能反映客户的偏好，这将导致更准确的推荐。由于用户的喜好会随着时间的推移而改变，因此RS提供与客户当前兴趣相容的项目的能力会受到影响，这有时会导致推荐与客户当前喜好完全无关的项目。此外，在用户-项目矩阵中使用该分割的结果将降低矩阵的维数，将缓解KNN算法的稀疏矩阵和可伸缩性问题，这导致KNN算法的性能提高，因为在这种情况下，目标客户仅与用户-项目矩阵中他或她自己的集群内的客户相比较。因此，通过减少矩阵中的用户数，提高了KNN算法的速度和精度，改善了RS的整体性能。根据这一讨论和研究结果，可以安全地得出结论，使用LRFM模型可以加快提供建议的过程，并允许创建符合客户当前利益的准确建议。</li>
<li>基于product category-user矩阵的关联规则提取提高了推荐方法的性能。这些规则通过评估产品类别之间的关系，预测他们购买的概率，并向目标客户推荐一套产品类别。将user-item矩阵限制为这些推荐产品类别中的项将降低矩阵的维数，有效地缓解了KNN算法的稀疏矩阵和可伸缩性问题。在该方法中，仅从从这些规则获得的产品类别中向目标客户提供推荐项目。结果表明，该方法通过减少矩阵中的项数，提高了KNN算法的速度和精度，有效地改善了RS的整体性能，研究结果表明该方法具有较好的性能。</li>
<li>在RS的设计过程中考虑商品的购买时间以及它们在电子商务网站上的上线时间，将会提高推荐的质量。换言之，比起过去的购买，多留意顾客最近的购买，以及比起其他商品，多留意最近在网站上推出的商品，便可以更了解顾客现时的喜好，帮助他们找到更吸引人、更合意的商品。考虑到这些问题，RS才能更好地实现他们的最终目标，即向适当的个人提供适当的物品。在本研究中，这两个变量被用来创建一个新的用户-项目矩阵，并在表4和图2的基础上取得了很好的结果。</li>
<li>为了更好地使推荐与用户的喜好相一致，人口特征的作用是无可否认的，因为大多数个人购买都取决于他们的年龄、性别、教育水平等。当它与其他变量如购买行为变量(包括LRFM和user-item矩阵)一起考虑时，这一作用更为显著，这是本研究通过定义一个新的相似性函数得出的。</li>
</ul>
<p>考虑到上述问题，本研究通过关注这些问题，利用各种数据挖掘方法，试图改进和完善以往关于CF系统的研究，以期提出一个准确率和性能最高的电子商务推荐系统。</p>
<p>以下是对未来研究的一些建议：</p>
<ol>
<li>将CF方法和CBF方法相结合，开发了所提出的模型。</li>
<li>研究基于个性特征的客户细分、其他人口统计变量(如地址和收入)以及其他行为变量(如购买商品的总数)对建议系统性能的影响。</li>
<li>将所提出的方法应用于其他行业的数据集，以提供更强的通用性。</li>
<li>使用大数据对提出的模型进行进一步评估，这些数据可以从大型网店获得。</li>
</ol>
<p>与过去的大多数研究一样，这项研究在实施和评估方面存在一些局限性，包括：</p>
<ol>
<li>使用的数据集的时间段限制为一年；</li>
<li>研究数据仅限于一家网上服装店；</li>
<li>正在研究的商店顾客数量有限。</li>
</ol>
]]></content>
      <categories>
        <category>Papers</category>
      </categories>
      <tags>
        <tag>数据挖掘</tag>
        <tag>推荐系统</tag>
      </tags>
  </entry>
  <entry>
    <title>论文笔记 EaSTFLy: Efficient and secure ternary federated learning</title>
    <url>/2020/04/20/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0-EaSTFLy-Efficient-and-secure-ternary-fe-derate-d-learning/</url>
    <content><![CDATA[<p><em>Ye Dong, Xiaojun Chen, Liyan Shen, Dakui Wang</em></p>
<p><a href="https://www.sciencedirect.com/science/journal/01674048" target="_blank" rel="noopener">Computers &amp; Security</a>   <a href="https://www.sciencedirect.com/science/journal/01674048/94/supp/C" target="_blank" rel="noopener">Volume 94</a>, July 2020, 101824</p>
<p><a href="https://www.sciencedirect.com/science/article/pii/S0167404820300985" target="_blank" rel="noopener">https://www.sciencedirect.com/science/article/pii/S0167404820300985</a></p>
<a id="more"></a>
<h2 id="摘要及介绍"><a href="#摘要及介绍" class="headerlink" title="摘要及介绍"></a>摘要及介绍</h2><h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3>]]></content>
      <categories>
        <category>Papers</category>
      </categories>
      <tags>
        <tag>密码学</tag>
        <tag>隐私保护机器学习</tag>
        <tag>联邦学习</tag>
      </tags>
  </entry>
  <entry>
    <title>论文笔记 Eﬀicient Multi-Key Homomorphic Encryption with Packed Ciphertexts with Application to Oblivious Neural Network Inference</title>
    <url>/2020/04/19/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0-E%EF%AC%80icient-Multi-Key-Homomorphic-Encryption-with-Packed-Ciphertexts-with-Application-to-Oblivious-Neural-Network-Inference/</url>
    <content><![CDATA[<p><em>Hao Chen, Wei Dai, Miran Kim, Yongsoo Song</em></p>
<p>CCS 2019</p>
<p><a href="https://dl.acm.org/doi/10.1145/3319535.3363207" target="_blank" rel="noopener">https://dl.acm.org/doi/10.1145/3319535.3363207</a></p>
<p><a href="https://eprint.iacr.org/2019/524" target="_blank" rel="noopener">https://eprint.iacr.org/2019/524</a></p>
<a id="more"></a>
<h2 id="摘要及介绍"><a href="#摘要及介绍" class="headerlink" title="摘要及介绍"></a>摘要及介绍</h2><h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>​        <em>同态加密（Homomorphic Encryption）</em>是一种<strong>支持对加密数据进行计算的密码系统</strong>。López-Alt等人（STOC 2012）提出了一种广义的HE概念，称为多密钥同态加密(MKHE)，它能够对用不同密钥加密的密文进行算术运算。</p>
<p>​        在这篇文章中，作者提出了<strong>两个打包密文的HE方案的多密钥变体</strong>。本文提出了新的<strong>重新线性化算法</strong>，这些算法比Chen等人（TCC 2017）的方法更简单、更快。然后，本文推广了HE的自举技术，以获得多密钥完全同态加密方案。本文使用Microsoft SEAL提供了这两个MKHE方案的概念验证实现。例如，当基环的维度为8192时，四方之间的多密钥BFV（resp. CKKS）密文做同态乘法，然后重新线性化所花的时间约为116（resp. 67）毫秒。</p>
<p>​        本文的MKHE方案在多个数据提供者之间的安全计算中有广泛的应用。作为基准，本文使用预先训练好的神经网络模型对图像进行同态分类，其中输入数据和模型在不同的密钥下加密。我们的实现大约需要1.8秒来评估来自MNIST数据集的加密图像上的一个卷积层和两个全连接层。</p>
<h4 id="关键词"><a href="#关键词" class="headerlink" title="关键词"></a>关键词</h4><p><em>多密钥同态加密；打包密文；LWE困难问题；神经网络</em></p>
<h3 id="早期研究"><a href="#早期研究" class="headerlink" title="早期研究"></a>早期研究</h3><p>​        <strong>同态加密</strong>是一种密码系统，它允许在<strong>不解密的情况下对加密数据进行计算</strong>，从而能够在不受信任的云中安全地外包计算。在Gentry的第一次构造之后，HE已经有了重大的技术进步[24]。例如，可以将多个明文值加密成单个打包密文，并使用单指令多数据（SIMD）技术并行地对这些值执行操作[26，48]。因此，具有打包技术的HE方案[6，7，16，22]具有良好的明文值摊销复杂度，并已被应用于隐私保护的大数据分析[11，37，39]。然而，传统的HE方案只允许对可在相同密钥下解密的密文进行计算。因此，HE自然不支持涉及多个数据提供商、每个数据提供商都提供自己的密钥的安全计算应用程序。</p>
<p>​        López-Alt等人[43]提出了一种多密钥同态加密（MKHE）方案，该方案是一种支持对密文进行算术运算的密码协议，密文不一定可以解密到同一密钥。除了解决上述HE问题外，MKHE还可以用来设计通信开销最小的高效MPC协议[45]。此外，MKHE的MPC协议满足即时MPC[43]属性，其中，在数据提供商上传其加密数据后，可以动态决定要评估的电路。</p>
<p>​        尽管MKHE具有多功能性，但在实践中很少使用。早期研究[19，45，46]使用了GSW方案的多密钥变体[28]。使用这些方法构造的密文很大，并且它们的性能不能很好地随参与方的数量而变化。以前的工作[8，10]提出了具有短密文的MKHE方案，但一个密文只能加密一个比特。现有的唯一具有打包密文的MKHE方案[13，41]是BGV方案[7]的多密钥变体。请注意，所有上述研究都是纯粹抽象的，没有给出实现，支持SIMD操作的MKHE方案是否实用仍然是一个悬而未决的问题。</p>
<h3 id="贡献"><a href="#贡献" class="headerlink" title="贡献"></a>贡献</h3><ul>
<li>设计了BFV[6, 22]和CKKS[16]方案的多密钥变体；</li>
<li>提出了一种新的生成重线性化密钥的方法，与[13]中的技术相比更简单而且更快；</li>
<li>将[9, 12, 14]的最新自举算法应用于多密钥场景；</li>
<li>使用Microsoft SEAL[47]给出了方案的概念验证实现，是支持打包密文的MKHE方案的第一个实际实现</li>
</ul>
<p>本文还提出了MKHE的第一个可行的应用，它安全地评估了预先训练的卷积神经网络（CNN）模型。本文构建了一个高效的协议，云服务器使用模型提供者提供的分类器为数据所有者提供在线预测服务，同时使用MKHE保护数据和模型的隐私。如图1所示，我们的方案支持多密钥操作，使得以较低的端到端延迟和接近最佳的数据和模型提供者成本来实现这一点。服务器可以存储以不同密钥加密的大量密文，但是特定任务的计算成本仅取决于与电路相关的各方的数量。我们注意到，我们的解决方案比单密钥HE更有优势，因为ML模型提供者不需要将未加密的模型发送到服务器。</p>
<p><img src="http://images.yingwai.top/picgo/EMKHEf1.png" alt=""></p>
<center>
    <i>图1 不经意神经网络预测的概述</i>
</center>

]]></content>
      <categories>
        <category>Papers</category>
      </categories>
      <tags>
        <tag>密码学</tag>
        <tag>神经网络</tag>
        <tag>隐私保护机器学习</tag>
        <tag>同态加密</tag>
      </tags>
  </entry>
  <entry>
    <title>论文笔记 Oblivious Neural Network Predictions via MiniONN Transformations</title>
    <url>/2020/05/26/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0-Oblivious-Neural-Network-Predictions-via-MiniONN-Transformations/</url>
    <content><![CDATA[<p><em>Jian Liu, Mika Juuti, Yao Lu, N. Asokan</em></p>
<p>CCS 2017</p>
<p><a href="https://dl.acm.org/doi/10.1145/3133956.3134056" target="_blank" rel="noopener">https://dl.acm.org/doi/10.1145/3133956.3134056</a></p>
<a id="more"></a>
<h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>托管在云服务中的机器学习模型越来越受欢迎，但存在隐私风险：向该服务发送预测请求的客户端需要披露潜在的敏感信息。在本文中，我们探讨了隐私保护预测问题：在每次预测之后，服务器对客户端的输入一无所知，客户端对模型一无所知。</p>
<p>我们提出了MiniONN，这是第一种将现有的神经网络转换为不经意的神经网络的方法，该网络以合理的效率支持隐私保护预测。与以前的工作不同，MiniONN不需要改变模型的训练方式。为此，我们为神经网络预测模型中常用的操作设计了健忘协议。我们证明了MiniONN在响应延迟和消息大小方面优于现有的工作。通过对标准数据集训练的几种典型神经网络模型的变换，证明了MiniONN的广泛适用性。</p>
<p><strong>关键词</strong>：隐私；机器学习；神经网络预测；安全两方计算</p>
<h2 id="贡献"><a href="#贡献" class="headerlink" title="贡献"></a>贡献</h2><ul>
<li>提出了MiniONN，这是第一个<strong>可以将任何普通神经网络模型转换为不经意神经网络</strong>的技术，而不需要对训练阶段进行任何修改。</li>
<li><strong>为神经网络预测中的常见操作设计了不经意的协议</strong>。特别地，作者<strong>使非线性函数(例如，Sigmoid和tanh)服从于作者的ONN变换</strong>，而精确度损失可以忽略不计。</li>
<li>构建了<strong>MiniONN的完整实现</strong>，并通过使用它来<strong>转换从几个标准数据集训练</strong>的神经网络模型来展示其广泛的适用性。特别是，对于从MNIST数据集[38]训练的相同模型，MiniONN的性能<strong>明显</strong>好于以前的工作[28, 44]。</li>
<li>分析了<strong>模型复杂性对转换后的ONN的预测精度和计算/通信开销的影响</strong>。讨论了神经网络设计者如何在预测精度和开销之间选择合适的折衷方案。</li>
</ul>
<h1 id="BACKGROUND-AND-PRELIMINARIES"><a href="#BACKGROUND-AND-PRELIMINARIES" class="headerlink" title="BACKGROUND AND PRELIMINARIES"></a>BACKGROUND AND PRELIMINARIES</h1><p><img src="http://images.yingwai.top/picgo/minionnt1.png" alt=""></p>
<center>
    <i>表1 符号表示</i>
</center>



<h1 id="MiniONN概述"><a href="#MiniONN概述" class="headerlink" title="MiniONN概述"></a>MiniONN概述</h1><p>在本节中，通过转换以下形式的神经网络来解释MiniONN的基本思想：</p>
<script type="math/tex; mode=display">
\mathbf{z} := \mathbf{W'} \cdot f(\mathbf{W} \cdot \mathbf{x} + \mathbf{b}) + \mathbf{b'} \tag{4}</script><p>其中$\mathbf{x} = \left[ \begin{matrix} x_1\\ x_2 \end{matrix} \right]$，$\mathbf{W} = \left[ \begin{matrix} w_{1,1} &amp; w_{1,2}\\ w_{2,1} &amp; w_{2,2} \end{matrix} \right]$，$\mathbf{b} = \left[ \begin{matrix} b_1\\ b_2 \end{matrix} \right]$，$\mathbf{W’} = \left[ \begin{matrix} w’_{1,1} &amp; w’_{1,2}\\ w’_{2,1} &amp; w’_{2,2} \end{matrix} \right]$ 以及 $\mathbf{b’} = \left[ \begin{matrix} b’_1\\ b’_2 \end{matrix} \right]$。</p>
<p>MiniONN的核心思想是让 $\mathcal{S}$ 和 $\mathcal{C}$ 加法共享神经网络每一层的输入和输出值。也就是说，在每一层的开始，$\mathcal{S}$ 和 $\mathcal{C}$ 将各自持有一份“份额”，使得份额的模加等于该神经网络的非不经意版本中对该层的输入。输出值将用作下一层的输入。</p>
<p>为此，让 $\mathcal{S}$ 和 $\mathcal{C}$ 首先进入预计算阶段(该阶段独立于 $\mathcal{C}$ 的输入$\mathbf{x}$)，在该阶段中，它们为权重矩阵的每一行(在本例中为 $\mathbf{W}$ 和 $\mathbf{W’}$)联合生成一组点积三元组 $\left \langle u,v,\mathbf{w} \cdot \mathbf{r} \right \rangle$。具体地说，对于 $\mathbf{w}$的每一行，$\mathcal{S}$ 和 $\mathcal{C}$，运行一个协议，该协议安全地实现理想功能 $\mathcal{F}$ 三元组(在图1中)，以生成点积三元组，从而：</p>
<script type="math/tex; mode=display">
\begin{align}
u_1 + v_1 (\bmod N) &= w_{1,1} r_1 + w_{1,2} r_2,\\
u_2 + v_2 (\bmod N) &= w_{2,1} r_1 + w_{2,2} r_2,\\
u'_1 + v'_1 (\bmod N) &= w'_{1,1} r'_1 + w'_{1,2} r'_2,\\
u'_2 + v'_2 (\bmod N) &= w'_{2,1} r'_1 + w'_{2,2} r'_2.
\end{align}</script><p><img src="http://images.yingwai.top/picgo/minionnf1.png" alt=""></p>
<center>
    <i>图1 理想的生成点积三元组的功能</i>
</center>

<p>当 $\mathcal{C}$ 想要请求 $\mathcal{S}$ 计算向量 $\mathbf{x}=[x_1,x_2]$ 的预测时，对于每个 $x_i$，$\mathcal{C}$ 选择在预计算阶段中生成的三元组，并使用它的 $r_i$ 来盲化 $x_i$。</p>
<script type="math/tex; mode=display">
\begin{align}
x_1^{\mathcal{C}} &:= r_1, x_1^{\mathcal{S}} := x_1 - r_1 (\bmod N),\\
x_2^{\mathcal{C}} &:= r_2, x_2^{\mathcal{S}} := x_2 - r_2 (\bmod N).
\end{align}</script><p>然后 $\mathcal{C}$ 然后发送 $\mathbf{x}^{\mathcal{S}}$ 给 $\mathcal{S}$，$\mathcal{S}$ 计算</p>
<script type="math/tex; mode=display">
\begin{align}
y_1^{\mathcal{S}} &:= w_{1,1} x_1^{\mathcal{S}} + w_{1,2} x_2^{\mathcal{S}} + b_1 + u_1 (\bmod N),\\
y_2^{\mathcal{S}} &:= w_{2,1} x_1^{\mathcal{S}} + w_{2,2} x_2^{\mathcal{S}} + b_2 + u_2 (\bmod N).
\end{align}</script><p>同时，$\mathcal{C}$ 设：</p>
<script type="math/tex; mode=display">
\begin{align}
y_1^{\mathcal{C}} &:= v_1 (\bmod N),\\
y_2^{\mathcal{C}} &:= v_2 (\bmod N).
\end{align}</script><p>显然</p>
<script type="math/tex; mode=display">
\begin{align}
y_1^{\mathcal{C}} + y_1^{\mathcal{S}} &= w_{1,1} x_1 + w_{1,2} x_2 + b_1 (\bmod N),\\
y_2^{\mathcal{C}} + y_2^{\mathcal{S}} &= w_{2,1} x_1 + w_{2,2} x_2 + b_2 (\bmod N).
\end{align}</script><p>因此，在此交互结束时，$\mathcal{S}$ 和 $\mathcal{C}$ 相加地共享由层1中的线性变换产生的输出值 $\mathbf{y}$，而不需要 $\mathcal{S}$ 学习输入 $\mathbf{x}$，任何一方都不学习 $\mathbf{y}$。</p>
<p>对于激活/池化操作 $f()$，$\mathcal{S}$ 和 $\mathcal{C}$ 运行安全地实现图2中的理想功能的协议，该协议隐式地重构每个 $y_i := y^{\mathcal{C}}_i + y^{\mathcal{S}}_i (\bmod N)$ 并返回 $x^{\mathcal{S}}_i := f(y_i) - x^{\mathcal{C}}_i$ 给 $\mathcal{S}$，其中 $x^{\mathcal{C}}_i$ 是来自预计算阶段的先前共享的三元组的 $\mathcal{C}$ 分量，即 $x_1^{\mathcal{C}} := r’_1$ 和 $x_2^{\mathcal{C}} := r’_2$。</p>
<p><img src="http://images.yingwai.top/picgo/minionnf2.png" alt=""></p>
<center>
    <i>图2 理想的不经意激活/池化f()的功能</i>
</center>

<p>最后一层的变换与第一层相同。也就是说，$\mathcal{S}$ 计算：</p>
<script type="math/tex; mode=display">
\begin{align}
y_1^{\mathcal{S}} &:= w'_{1,1} x_1^{\mathcal{S}} + w'_{1,2} x_2^{\mathcal{S}} + b'_1 + u'_1 (\bmod N),\\
y_2^{\mathcal{S}} &:= w'_{2,1} x_1^{\mathcal{S}} + w'_{2,2} x_2^{\mathcal{S}} + b'_2 + u'_2 (\bmod N);
\end{align}</script><p>$\mathcal{C}$ 设：</p>
<script type="math/tex; mode=display">
\begin{align}
y_1^{\mathcal{C}} &:= v'_1 (\bmod N),\\
y_2^{\mathcal{C}} &:= v'_2 (\bmod N),
\end{align}</script><p>最后，$\mathcal{S}$ 将 $[y_1^{\mathcal{S}}, y_2^{\mathcal{S}}]$ 返回给 $\mathcal{C}$，$\mathcal{C}$ 输出最终预测：</p>
<script type="math/tex; mode=display">
\begin{align}
z_1 &:= y_1^{\mathcal{C}} + y_1^{\mathcal{S}},\\
z_2 &:= y_2^{\mathcal{C}} + y_2^{\mathcal{S}}.
\end{align}</script><p>注意到MiniONN在 $\mathbb{Z}_N$ 中工作，而神经网络需要浮点计算。一种简单地解决办法是把神经网络中的值与一个固定的常数相乘，将小数部分放大到整数。一种类似的技术被用来减少神经网络预测中的存储器需求，而精确度损失可以忽略不计[42]。必须确保任何(中间)结果的绝对值不会超过 $\lfloor N/2 \rfloor$。</p>
]]></content>
      <categories>
        <category>Papers</category>
      </categories>
      <tags>
        <tag>密码学</tag>
        <tag>MPC</tag>
        <tag>神经网络</tag>
        <tag>隐私保护机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>论文笔记 High-Throughput Semi-Honest Secure Three-Party Computation with an Honest Majority</title>
    <url>/2020/06/10/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0-High-Throughput-Semi-Honest-Secure-Three-Party-Computation-with-an-Honest-Majority/</url>
    <content><![CDATA[<p><em>Toshinori Araki, Jun Furukawa, Yehuda Lindell, Ariel Nof, Kazuma Ohara</em></p>
<p>CCS 2016</p>
<p><a href="https://dl.acm.org/doi/10.1145/2976749.2978331" target="_blank" rel="noopener">https://dl.acm.org/doi/10.1145/2976749.2978331</a></p>
<a id="more"></a>
<h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>在这篇文章中，作者描述了一个新的信息论协议(和一个计算安全的变体)，用于诚实多数的安全三方计算。该协议的计算量和通信量非常小；对于布尔电路，每一方只为每个与门发送一位(对于异或门则不发送任何内容)。本文的协议在半诚实的攻击者面前是(基于模拟的)安全的，在恶意攻击者面前实现了客户机/服务器模型下的隐私。</p>
<p>在具有10Gbps连接的三个20核服务器的集群上，本文的协议的实现每秒执行超过130万次AES计算，涉及每秒处理超过70亿个门。此外，作者还开发了一个Kerberos扩展，它使用服务器之间共享的密钥/密码，用本文的协议取代了MIT-Kerberos中密钥分发中心(KDC)上的票证授予-票证加密。这样可以在保护密码的同时使用Kerberos。本文的实现能够支持每秒超过35,000个登录的登录风暴，即使对于非常大的组织也足够了。本文的工作证明了在标准硬件上实现高通量安全计算是可能的。</p>
<h1 id="THE-NEW-PROTOCOL"><a href="#THE-NEW-PROTOCOL" class="headerlink" title="THE NEW PROTOCOL"></a>THE NEW PROTOCOL</h1><h2 id="Securely-Computing-Boolean-Circuits"><a href="#Securely-Computing-Boolean-Circuits" class="headerlink" title="Securely Computing Boolean Circuits"></a>Securely Computing Boolean Circuits</h2><p>为了简化说明，首先描述具有与和异或门的布尔电路的特殊情况的协议。假设各方 $P_1,P_2,P_3$ 能够获得随机的 $x_1, x_2, x_3 \in \{0,1 \}$，使得 $x_1 \oplus x_2 \oplus x_3 = 0$。</p>
<p><strong>秘密共享。</strong>作者定义了一个3取2的秘密共享方案，记为$\left( \begin{array}{c} 3\\2 \end{array} \right)$-共享，如下所示。为了共享比特 $v$，分发者在 $x_1 \oplus x_2 \oplus x_3 = 0$ 的约束下选择三个随机比特 $x_1, x_2, x_3 \in \{0,1 \}$。然后：</p>
<ul>
<li>$P_1$ 的份额为 $(x_1, a_1)$，其中 $a_1 = x_3 \oplus v$；</li>
<li>$P_2$ 的份额为 $(x_2, a_2)$，其中 $a_2 = x_1 \oplus v$；</li>
<li>$P_3$ 的份额为 $(x_3, a_3)$，其中 $a_3 = x_2 \oplus v$。</li>
</ul>
<p>很明显，任何一方的份额都不能揭示关于v的任何信息。此外，任何两个份额都足以获得 $v$；例如，给定 $x_1,x_2,a_1,a_2$，我们可以计算 $v = a_2 \oplus x_1$。</p>
<p><strong>异或(加法)门。</strong>设 $(x_1,a_1),(x_2,a_2),(x_3,a_3)$ 是 $v_1$ 的秘密共享，$(y_1,b_1),(y_2,b_2),(y_3,b_3)$ 是 $v_2$ 的秘密共享。然后，为了计算 $v_1$ 和 $v_2$ 的秘密共享，每个 $P_i$ 在本地计算 $z_i = x_i \oplus y_i$ 和 $c_i = a_i \oplus b_i$ 得到 $(z_i, c_i)$ (不需要通信)。为了查看结果是否构成 $v_1 \oplus v_2$ 的有效$\left( \begin{array}{c} 3\\2 \end{array} \right)$-共享，首先注意到 $z_1 \oplus z_2 \oplus z_3 = 0$ (因为 $x_1 \oplus x_2 \oplus x_3 = 0$ 和 $y_1 \oplus y_2 \oplus y_3 = 0$)。接下来，观察到对于每个 $i \in \{1,2,3\}$，它持有 $c_i = z_{i−1} \oplus (v_1 \oplus v_2)$，其中 $i=1$ 时 $i−1=3$；例如，我们有 $c_1=a_1 \oplus b_1$ $=x_3 \oplus v_1 \oplus y_3 \oplus v_2$ $=(x_3 \oplus y_3)\oplus (v_1 \oplus v_2)$ $=z_3\oplus (v_1 \oplus v_2)$。因此，这构成具有随机性 $z_1,z_2,z_3$ 的 $v_1 \oplus v_2$ 的共享。</p>
<p><strong>与(乘法)门。</strong>现在展示各方如何计算与(乘法)门；此子协议要求每一方只发送单个比特。该协议分两个阶段工作：第一阶段双方计算输入位的与的简单$\left( \begin{array}{c} 3\\3 \end{array} \right)$异或-共享，第二阶段将$\left( \begin{array}{c} 3\\3 \end{array} \right)$-共享转换为上述定义的$\left( \begin{array}{c} 3\\2 \end{array} \right)$-共享。</p>
<p>设 $(x_1,a_1),(x_2,a_2),(x_3,a_3)$ 是 $v_1$ 的秘密共享，$(y_1,b_1),(y_2,b_2),(y_3,b_3)$ 是 $v_2$ 的秘密共享。假设各方 $P_1,P_2,P_3$ 分别具有相关随机性 $\alpha, \beta, \gamma$，其中 $\alpha \oplus \beta \oplus \gamma = 0$。双方计算 $v_1 \cdot v_2 = v_1 \wedge v_2$ 的$\left( \begin{array}{c} 3\\2 \end{array} \right)$-份额如下(从这里开始，将简单地将 $a$ 和 $b$ 的积表示为 $ab$)：</p>
<ol>
<li><p>第一步——计算$\left( \begin{array}{c} 3\\3 \end{array} \right)$-共享：</p>
<ul>
<li>$P_1$ 计算 $r_1 = x_1 y_1 \oplus a_1 b_1 \oplus \alpha$，然后发送 $r_1$ 给 $P_2$；</li>
<li>$P_2$ 计算 $r_2 = x_2 y_2 \oplus a_2 b_2 \oplus \beta$，然后发送 $r_2$ 给 $P_3$；</li>
<li>$P_3$ 计算 $r_3 = x_3 y_3 \oplus a_3 b_3 \oplus \gamma$，然后发送 $r_3$ 给 $P_1$。</li>
</ul>
<p>这些消息是并行地计算和发送的。</p>
</li>
<li><p>第二步——计算$\left( \begin{array}{c} 3\\2 \end{array} \right)$-共享：在此步骤中，各方根据其给定的$\left( \begin{array}{c} 3\\3 \end{array} \right)$-共享和上一步中发送的消息构建$\left( \begin{array}{c} 3\\2 \end{array} \right)$-共享，只需要本地计算。</p>
<ul>
<li>$P_1$ 存储 $(z_1, c_1)$，其中 $z_1 = r_1 \oplus r_3$，以及 $c_1 = r_1$；</li>
<li>$P_2$ 存储 $(z_2, c_2)$，其中 $z_2 = r_2 \oplus r_1$，以及 $c_2 = r_2$；</li>
<li>$P_3$ 存储 $(z_3, c_3)$，其中 $z_3 = r_3 \oplus r_2$，以及 $c_3 = r_3$；</li>
</ul>
</li>
</ol>
<p><strong>对第一步的解释：</strong>证明第一步中，$r_1 \oplus r_2 \oplus r_3 = v_1 \wedge v_2$。首先注意到：</p>
<script type="math/tex; mode=display">
a_1 b_1 = (x_3 \oplus v_1) (y_3 \oplus v_2) = x_3 y_3 \oplus x_3 v_2 \oplus y_3 v_1 \oplus v_1 v_2 \tag{1}</script><p>类似地有 $a_2 b_2 = x_1 y_1 \oplus x_1 v_2 \oplus y_1 v_1 \oplus v_1 v_2$ 和 $a_3 b_3 = x_2 y_2 \oplus x_2 v_2 \oplus y_2 v_1 \oplus v_1 v_2$。因此，</p>
<script type="math/tex; mode=display">
\begin{align}
r_1 &\oplus r_2 \oplus r_3 \\
 &= (x_1 y_1 \oplus a_1 b_1 \oplus \alpha) \oplus (x_2 y_2 \oplus a_2 b_2 \oplus \beta) \oplus (x_3 y_3 \oplus a_3 b_3 \oplus \gamma) \\
 &= x_1 y_1 \oplus x_2 y_2 \oplus x_3 y_3 \oplus b_1 a_1 \oplus a_2 b_2 \oplus a_3 b_3 \\
 &= x_1 y_1 \oplus x_2 y_2 \oplus x_3  y_3 \oplus (x_3 y_3 \oplus x_3 v_2 \oplus y_3 v_1 \oplus v_1 v_2) \\
 & \qquad \qquad \qquad \qquad \quad  \oplus (x_1 y_1 \oplus x_1 v_2 \oplus y_1 v_1 \oplus v_1 v_2) \\
 & \qquad \qquad \qquad \qquad \quad  \oplus (x_2 y_2 \oplus x_2 v_2 \oplus y_2 v_1 \oplus v_1 v_2) \\
 &= (x_1 \oplus x_2 \oplus x_3) v_2 \oplus (y_1 \oplus y_2 \oplus y_3) v_1 \oplus v_1 v_2 = v_1 v_2
\end{align}</script><p>第二个等号成立是因为 $\alpha \oplus \beta \oplus \gamma = 0$，第三个等号成立是因为公式 $(1)$，第四个等号成立就是简单的删除重复元素，最后一个等号成立是因为 $x_1 \oplus x_2 \oplus x_3 = y_1 \oplus y_2 \oplus y_3 = 0$。</p>
<p><strong>对第二步的解释：</strong>根据定义，为了证明结果是有效的 $v_1v_2$ 的$\left( \begin{array}{c} 3\\2 \end{array} \right)$-共享，我们需要证明 $z_1,z_2,z_3$ 使得 $z_1 \oplus z_2 \oplus z_3 = 0$，并且 $c_1,c_2,c_3$ 是所定义的形式。</p>
<p>首先，$z_1 \oplus z_2 \oplus z_3 = (r_1 \oplus r_3) \oplus (r_2 \oplus r_1) \oplus (r_3 \oplus r_2) = 0$。其次，注意到$c_1 \oplus c_2 \oplus c_3 = r_1 \oplus r_2 \oplus r_3 = v_1 v_2$，移项得 $c_1 = r_1 = v_1 v_2 \oplus r_2 \oplus r_3$。又因为 $r_2 \oplus r_3 = z_3$，于是 $c_1 = v_1 v_2 \oplus z_3$，得证。对于 $c_2, c_3$ 也可以同样证明。</p>
<p><strong>协议。</strong>完整的三方协议以自然的方式工作。各方首先使用秘密共享方法共享其输入。然后，它们根据电路的预定拓扑顺序计算电路中的每个XOR与AND门。最后，各方在输出线上重建其输出。(在客户端/服务器模型中，外部客户端将其输入的共享发送给三方，然后三方根据收到的共享以相同的方式计算电路。)</p>
<p>请注意，每一方只与另一方进行通信。这一性质也适用于Sharemind的协议。然而，本文的秘密共享方案和乘法协议是完全不同的。</p>
<h2 id="Generating-Correlated-Randomness"><a href="#Generating-Correlated-Randomness" class="headerlink" title="Generating Correlated Randomness"></a>Generating Correlated Randomness</h2><p>这里将说明如何高效地为每个与门生成随机比特 $\alpha, \beta, \gamma \in \{0, 1\}$ ，满足 $\alpha \oplus \beta \oplus \gamma = 0$。</p>
<p><strong>信息论相关随机性。</strong>通过使每一方 $P_i$ 简单地选择随机 $\rho_i \in \{0,1\}$ 并将其发送到 $P_{i+1}$ (其中 $P_3$ 发送到 $P_1$)，可以安全地生成具有完美安全性的相关随机性。然后，每一方将其随机比特作为其选择的比特与其接收的比特的异或：$P_1$ 计算 $\alpha = \rho_3 \oplus \rho_1$，$P_2$ 计算 $\beta = \rho_1 \oplus \rho_2$ 以及 $P_3$ 计算 $\gamma = \rho_2 \oplus \rho_3$。观察到 $\alpha + \beta + \gamma = 0$ 满足要求。此外，如果 $P_1$ 损坏，则它除了知道 $\beta \oplus \gamma = \alpha$ 之外，对 $\beta$ 和 $\gamma$ 一无所知。这是因为 $\beta$ 和 $\gamma$ 在他们的计算中都包含了 $\rho_2$，而这对于 $P_1$ 是未知的。类似的论点也适用于损坏的 $P_2$ 或 $P_3$。尽管此解决方案既优雅又简单，但作者使用了不同的方法。这是因为这将使每个与门的通信增加一倍；确实，这仍然是非常少的通信。但是，考虑到通信是瓶颈，这将使吞吐量减半。</p>
<p><strong>计算相关随机性。</strong>接下来作者展示了如何通过计算安全地计算相关随机性，而不需要除短初始设置之外的任何交互。这使我们能够维持各方只需要在每个与门传输单个比特的当前情况。设 $\kappa$ 为安全参数，$F: \{0,1\}^{\kappa} \times \{0,1\}^{\kappa} \rightarrow \{0,1\}$ 为输出单比特的伪随机函数。</p>
<ol>
<li><p><strong>Init：</strong></p>
<ul>
<li>每个 $P_i$ 选择一个随机的 $k_i \in \{0,1\}^{\kappa}$；</li>
<li>$P_1$ 发送 $k_1$ 给 $P_3$，$P_2$ 发送 $k_2$ 给 $P_1$，$P_3$ 发送 $k_3$ 给 $P_2$。</li>
</ul>
<p>$P_1$ 持有 $k_1, k_2$，$P_1$ 持有 $k_2, k_3$，$P_1$ 持有 $k_3, k_1$。</p>
</li>
<li><p><strong>GetNextBit：</strong>给定唯一标识符 $id \in \{0,1\}^{\kappa}$，</p>
<ul>
<li>$P_1$ 计算 $\alpha = F_{k_1}(id) \oplus F_{k_2}(id)$；</li>
<li>$P_2$ 计算 $\beta = F_{k_2}(id) \oplus F_{k_3}(id)$；</li>
<li>$P_3$ 计算 $\gamma = F_{k_3}(id) \oplus F_{k_1}(id)$。</li>
</ul>
</li>
</ol>
<p>注意到 $\alpha \oplus \beta \oplus \gamma = 0$。此外，$P_1$ 不知道用于生成 $\beta$ 和 $\gamma$ 的 $k_3$。因此，在 $\beta$ 和 $\gamma$ 的约束下，$\beta \oplus \gamma = \alpha$ 对 $P_1$ 是伪随机的。实际上，$id$ 可以是所有各方在每次调用 <strong>GetNextBit</strong> 时本地递增的计数器。</p>
<h2 id="The-Ring-Modulo-2-n-and-Fields"><a href="#The-Ring-Modulo-2-n-and-Fields" class="headerlink" title="The Ring Modulo $2^n$ and Fields"></a>The Ring Modulo $2^n$ and Fields</h2><p>上一节讲到的是布尔电路下的协议，接下来将其推广到模 $2^n$ 的环和大于 $2$ 的任意域的一般情况。当取 $n=1$ 时，加法(和减法)与异或相同，乘法与与相同。在这种情况下，这里的协议与第2.1节中描述的协议完全相同。</p>
<p>$\left( \begin{array}{c} 3\\2 \end{array} \right)$<strong>-共享。</strong>为了共享一个元素 $v \bmod 2^n$，分发者选择三个满足约束 $x_1 + x_2 + x_3 = 0$ 的随机元素 $x_1, x_2, x_3 \in \mathbb{Z}_{2^n}$。然后 $P_1$ 的份额为 $(x_1, a_1)$，其中 $a_1 = x_3 - v$；$P_2$ 的份额为 $(x_2, a_2)$，其中 $a_2 = x_1 - v$；$P_3$ 的份额为 $(x_3, a_3)$，其中 $a_3 = x_2 - v$。跟布尔电路的情况一样，每一方的份额都没有暴露关于 $v$ 的信息，而且任意两方可以重构 $v$。</p>
<p><strong>加法门。</strong>与布尔电路的情况一样，各方在本地将对应的份额进行相加模 $2^n$ 即可。</p>
<p><strong>乘法门。</strong>设 $(x_1,a_1),(x_2,a_2),(x_3,a_3)$ 是 $v_1$ 的秘密共享，$(y_1,b_1),(y_2,b_2),(y_3,b_3)$ 是 $v_2$ 的秘密共享。假设各方 $P_1,P_2,P_3$ 分别有 $\alpha, \beta, \gamma \in \mathbb{Z}_{2^n}$，其中 $\alpha + \beta + \gamma = 0$。为了计算两个值的积的$\left( \begin{array}{c} 3\\2 \end{array} \right)$-份额，各方计算：</p>
<ol>
<li>$P_1$ 计算 $r_1 = \frac{a_1 b_1 - x_1 y_1 + \alpha}{3}$，然后发送 $r_1$ 给 $P_2$；</li>
<li>$P_2$ 计算 $r_2 = \frac{a_2 b_2 - x_2 y_2 + \beta}{3}$，然后发送 $r_2$ 给 $P_3$；</li>
<li>$P_3$ 计算 $r_3 = \frac{a_3 b_3 - x_3 y_3 + \gamma}{3}$，然后发送 $r_3$ 给 $P_1$；</li>
<li>$P_1$ 将它的份额定义为 $z_1 = r_3 - r_1$ 和 $c_1 = -2r_3 - r_1$；</li>
<li>$P_2$ 将它的份额定义为 $z_2 = r_1 - r_2$ 和 $c_2 = -2r_1 - r_2$；</li>
<li>$P_3$ 将它的份额定义为 $z_3 = r_2 - r_3$ 和 $c_3 = -2r_2 - r_3$。</li>
</ol>
<p>上面的计算是合法的，因为 $3$ 与 $2^n$ 是互质的；因此，$3$ 是可逆的。此外，上述结果在3个以上元素的有限域上都成立。</p>
<p>为了验证 $r_1 + r_2 + r_3 = v_1 v_2$，首先观察到</p>
<script type="math/tex; mode=display">
a_1 b_1  = (x_3 - v_1)(y_3 - v_2) = x_3 y_3 - x_3 v_2 - y_3 v_1 + v_1 v_2 \tag{2}</script><p>类似地，$a_2 b_2 = x_1 y_1 - x_1 v_2 - y_1 v_1 + v_1 v_2$，$a_3 b_3 = x_2 y_2 - x_2 v_2 - y_2 v_1 + v_1 v_2$。然后</p>
<script type="math/tex; mode=display">
\begin{align}
3(&r_1 + r_2 + r_3) \\
&= a_1 b_1 - x_1 y_1 + \alpha + a_2 b_2 - x_2 y_2 + \beta + a_3 b_3 - x_3 y_3 + \gamma \\
&= a_1 b_1 + a_2 b_2 + a_3 b_3 - x_1 y_1 - x_2 y_2 - x_3 y_3 \\
&= 3v_1 v_2 - v_1(y_1 + y_2 + y_3) - v_2(x_1 + x_2 + x_3) = 3v_1 v_2
\end{align}</script><p>接下来证明各方的$\left( \begin{array}{c} 3\\2 \end{array} \right)$-份额是有效的：根据定义，各方的份额为 $(z_1, z_3 - v_1 v_2), (z_2, z_1 - v_1 v_2)$ 和 $(z_3, z_2 - v_1 v_2)$，其中 $z_1 + z_2 + z_3 = 0 \bmod 2^n$。首先后者很容易看出来是成立的，根据 $z_1, z_2, z_3$ 的定义。其次，$P_1$ 持有 $c_1$ $= -2 r_3 - r_1$ $= -r_3 - r_3 - r_1 - r_2 + r_2$ $=(r_2 - r_3)-(r_1 + r_2 + r_3)$ $=z_3 - v_1 v_2$，满足要求。对于 $P_2$ 和 $P_3$ 的情况同样成立。</p>
<p><strong>生成相关随机性。</strong>各方使用与第2.2节所述相同的(计算)方法，但有以下不同之处。首先，我们假设 $F_k$ 是将字符串映射到 $\mathbb{Z}_{2^n}$ (或等价于 $\{0,1\}^n$)的伪随机函数。其次，$P_1$计算 $\alpha = F_{k_1}(id) - F_{k_2}(id)$，$P_2$计算 $\beta = F_{k_2}(id) - F_{k_3}(id)$，$P_3$计算 $\gamma = F_{k_3}(id) - F_{k_1}(id)$。</p>
]]></content>
      <categories>
        <category>Papers</category>
      </categories>
      <tags>
        <tag>密码学</tag>
        <tag>MPC</tag>
      </tags>
  </entry>
  <entry>
    <title>论文笔记 ABY - A Framework for Efficient Mixed-Protocol Secure Two-Party Computation</title>
    <url>/2020/06/11/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0-ABY-A-Framework-for-Efficient-Mixed-Protocol-Secure-Two-Party-Computation/</url>
    <content><![CDATA[<p><em>Daniel Demmler, Thomas Schneider, Michael Zohner</em></p>
<p><a href="https://dblp.uni-trier.de/db/conf/ndss/ndss2015.html#Demmler0Z15" target="_blank" rel="noopener">NDSS 2015</a></p>
<p><a href="https://www.ndss-symposium.org/ndss2015/ndss-2015-programme/aby-framework-efficient-mixed-protocol-secure-two-party-computation/" target="_blank" rel="noopener">https://www.ndss-symposium.org/ndss2015/ndss-2015-programme/aby-framework-efficient-mixed-protocol-secure-two-party-computation/</a></p>
<a id="more"></a>
<h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>安全计算使相互不信任的各方能够在其私有输入上联合计算函数，而不会泄露函数的输出以外的任何信息。半诚实模型中的通用安全计算协议已经被广泛研究，并形成了几个最佳实践。在这项工作中，我们设计并实现了一个混合协议框架，称为Aby，它有效地结合了基于算术共享、布尔共享和姚的乱码电路的安全计算方案，并为安全两方计算提供了最佳实践方案。我们的框架允许预计算几乎所有的密码运算，并基于预计算的不经意传输扩展在安全计算方案之间提供新颖、高效的转换。ABY支持多种标准操作，我们在本地网络和公共洲际云上执行基准测试。从我们的基准测试中，我们对安全计算协议的高效设计有了新的见解，最突出的是，基于不经意传输的乘法比基于同态加密的乘法要高效得多。我们使用ABY为三个示例应用(私有集合交集、生物特征匹配和模幂运算)构建混合协议，并表明它们比使用单一协议更有效。</p>
<p><strong>关键词</strong>：安全的两方计算；混合协议；高效的协议设计</p>
<h1 id="INTRODUCTION"><a href="#INTRODUCTION" class="headerlink" title="INTRODUCTION"></a>INTRODUCTION</h1><p>在这项工作中，作者提出了Aby(用于算术、布尔和Yao共享)，这是一个新的框架，用于开发高效的混合协议，允许灵活的设计过程。作者在安全计算中使用了几种最先进的技术，并以一种新颖的方式应用了现有的协议，从而设计了一个安全协议。我们优化子例程，并对基元操作执行详细的基准测试。从这些结果中，得到了设计高效安全计算协议的新见解。应用这些见解，并通过实现三个隐私保护应用程序来展示ABY的设计灵活性：模幂运算、私有集交集和生物特征匹配。ABY旨在作为隐私保护应用程序性能的基准，因为它结合了安全计算中的几种最先进的技术和最佳实践。可以从 <a href="http://encrypto.de/code/ABY" target="_blank" rel="noopener">http://encrypto.de/code/ABY</a> 获得ABY的源代码。</p>
<p><strong>Aby框架</strong>。在非常高的级别上，本文的框架的工作方式类似于从底层安全计算协议中抽象出来的虚拟机(类似于从底层系统体系结构中抽象出来的Java虚拟机)。本文的虚拟机操作给定位长的数据类型(类似于C编程语言中的16位短或32位长数据类型)。变量要么是明文的(意味着一方知道变量的值，这是计算的输入和输出所需的)，要么是双方共享的秘密(意味着每一方都持有一份份额，不能从中推导出有关该值的信息)。本文的框架目前支持三种不同类型的共享(算术、布尔和姚)，并允许在它们之间进行有效的转换。图1.共享支持与CPU指令集类似的不同类型的标准操作，如加法、乘法、比较或按位操作。对共享的操作使用高效的安全计算协议来执行：对于算术共享的操作，我们使用基于Beaver乘法三元组的协议[4]，对于布尔共享的操作，本文使用Goldreich-Micali-Wigderson(GMW)协议[34]，对于姚共享的操作，本文使用姚的乱码电路协议[74]。</p>
<p><img src="http://images.yingwai.top/picgo/aby2f1.png" alt=""></p>
<center>
    <i>图1 Aby框架概览，该框架允许在明文和三种类型的共享之间进行高效转换：算术、布尔和姚。</i>
</center>




<p><strong>灵活的设计流程</strong>。本文框架的一个主要目标是允许安全计算协议的灵活设计。</p>
<ol>
<li>作者从协议特定的功能表示中抽象出来，取而代之的是使用标准操作。这允许混合几个协议，甚至具有不同的表示，并允许设计者以标准操作的形式来表达功能，如C或Java等高级编程语言中已知的那样。以前，设计者必须手动编写(或自动生成)特定协议的紧凑表示，例如，姚的协议的小布尔电路。当我们专注于标准操作时，高级语言可以编译到本文的框架中，它可以用作现有的几个安全计算工具的后端，例如L1[44]、[71]、[72]、Secrec[11]、[12]或Picco[75]。</li>
<li>通过混合安全计算协议，本文的框架能够根据给定部署场景中可用的资源定制结果协议。例如，GMW协议允许预计算所有密码操作，但在线阶段需要几轮交互(这不利于延迟较高的网络)，而姚的协议轮数不变，但在线阶段需要对称密码操作。</li>
</ol>
<p><strong>高效实例化和改进</strong>。每种安全计算技术都是使用最新的优化和最佳实践(例如昂贵的密码操作的批量预计算[19]、[27]、[69])来实现的。对于算术共享(§III-A4)，本文使用填充[62]、[66]的Paillier生成乘法三元组，或者使用完全解密的DGK生成乘法三元组[22]、[32]，对于布尔共享(§III-B)，本文使用[54]和OT扩展[1]、[41]的多路复用器，而对于Yao共享(§III-C)，本文使用固定密钥AES乱码[7]。作为对高效协议设计的最先进技术的新贡献和进步，作者以一种新颖的方式结合了现有的方法。对于算术共享，作者展示了如何使用对称密钥加密来乘值，它允许更快地乘以一到三个数量级(§III-A5)。本文概述了如何分别从布尔共享高效地转换为算术共享(§IV-E和§IV-F)，并展示了如何结合布尔共享和Yao共享以获得比纯布尔或Yao实例化更好的运行时间(§VI-B)。最后，本文概述了如何修改[7]中的固定密钥AES乱码，以获得更好的OT扩展性能(§V-A)。</p>
<p><strong>关于高效协议设计的反馈</strong>。作者对他们的框架进行了基准测试，从中得出了高效安全计算协议的新的最佳实践。证明了对于乘法，使用OT扩展来预计算乘法三元组比使用同态加密(§V-C)更有效。使用本文的基于OT的转换协议，不同共享表示之间的转换比以前工作中使用的方法(例如[35]、[44])要便宜得多，并且随着安全参数的增加而很好地扩展。事实上，在低等待时间网络上，不同共享表示之间的转换成本非常便宜，以至于对于单个乘法来说，将其转换成更合适的表示、执行乘法并将其转换回源表示已经是值得的。</p>
<p><strong>应用</strong>。作者展示了他们的Aby框架和技术可以用来实现和提高几个隐私保护应用程序的性能。更具体地说，本文提出了模幂运算的混合协议，其中作者组合了所有三个共享并显示了相应的功能描述(§VI-A)，用于私有集交集(§VI-B)(首次将YOO与布尔共享相结合)，以及用于生物特征匹配(分别将算术与布尔和姚共享相结合)，其总运行时间比使用单一协议快13倍(§VI-C)。</p>
<h1 id="PRELIMINARIES"><a href="#PRELIMINARIES" class="headerlink" title="PRELIMINARIES"></a>PRELIMINARIES</h1><h2 id="设定"><a href="#设定" class="headerlink" title="设定"></a>设定</h2><p>在这项工作中，作者考虑可用于各种隐私保护应用的安全两方计算协议，如下所述。</p>
<p>自然，这样的协议可以用于客户端-服务器应用，其中双方都提供他们的私人输入(例如，用于因特网上的服务)。</p>
<p>然而，协议也可以用于多方应用，其中任意数量的输入玩家提供他们的机密输入，并且任意数量的输出玩家接收安全计算的输出(例如，用于拍卖、调查等)，参见[30]。为此，每个输入播放器在两个计算服务器(假设不串通)之间秘密共享其输入。然后，两个计算服务器在输入共享上运行安全计算协议，在此期间它们不学习任何中间信息。最后，他们将输出份额发送给可以重构输出的输出播放器。</p>
<p>由于本文的Aby框架中的所有协议都在共享上操作，这也允许反应式计算，其中两个计算服务器在多次执行中保存安全的状态信息(例如，对于安全的数据库系统)。</p>
<h2 id="抵御半诚实的对手的安全"><a href="#抵御半诚实的对手的安全" class="headerlink" title="抵御半诚实的对手的安全"></a>抵御半诚实的对手的安全</h2><p>本文使用半诚实(被动)对手模型，在该模型中，作者假设有一个计算受限的对手，他试图从协议执行期间看到的消息中学习额外的信息。与更强的恶意(主动)对手相比，半诚实的对手不允许偏离协议。尽管比恶意模型有更多的限制，半诚实模型具有许多应用，例如，保护免受管理员或政府机构的被动内部攻击，或者在可以信任各方不会主动行为不当的情况下。半诚实模型使得开发高效的安全计算协议成为可能，因此被广泛用于实现隐私保护应用。本文的工作集中在半诚实对手模型下高效混合协议安全两方计算的设计与实现。</p>
<h2 id="记号法"><a href="#记号法" class="headerlink" title="记号法"></a>记号法</h2><p>本文将运行安全计算协议的双方分别表示为 $P_0$ 和 $P_1$。</p>
<p>本文用 $x \oplus y$ 表示按位异或，$x \wedge y$ 表示按位与。我们使用列表运算符 $x[i]$ 来引用列表 $x$ 的第 $i$ 个元素。特别地，如果 $x$ 是位序列，则 $x[i]$ 是 $x$ 的第 $i$ 位，$x[0]$ 是 $x$ 的最低有效位。</p>
<p>$\kappa$ 表示对称安全参数，$\phi$ 表示公钥安全参数，根据NIST[61]的建议，$\kappa \in \{80,112,128\}$ 和$ \phi \in \{1024,2048,3072\}$ 用于传统(直到2010年)、中等(2011年-2030年)和长期(2030年之后)安全。本文将统计安全参数 $\sigma$ 设置为 $40$。本文将使用 $P_i$ 的公钥的公钥加密表示为 $c= {\rm Enc}_i(m)$，并且相应的解密运算表示为 $m= {\rm Dec}_i(c)$，其中$m= {\rm Dec}_i({\rm Enc}_i(c))$。</p>
<p>本文将共享变量 $x$ 表示为 $\langle x \rangle ^t$。上标 $t \in \{A,B,Y\}$ 表示共享的类型，其中 $A$ 表示算术共享，$B$ 表示布尔共享，$Y$ 表示Yao共享。不同共享类型和操作的语义在§III中定义。本文将由 $P_i$ 方持有的 $\langle x \rangle ^t$ 的单独份额称为 $\langle x \rangle ^t_i$。以类似的方式，我们定义了共享运算符 $\langle x \rangle ^t = {\rm Shr}^t_i(x)$，表示 $P_i$ 将其输入值 $x$ 与 $P_{1−i}$ 共享，以及重构运算符 $x={\rm Rec}^t_i(\langle x \rangle ^t)$，表示 $P_i$ 获得 $x$ 的值作为输出。当双方都获得 $x$ 的值时，本文写作 ${\rm Rec}^t(\langle x \rangle ^t)$。本文用 $s,d \in \{A,B,Y\}$ 和$s  \neq d$ 表示 $\langle x \rangle ^s$ 的共享到另一表示 $\langle x \rangle ^c$ 的转换为 $\langle x \rangle ^d = s2d(\langle x \rangle ^s)$，例如，$\rm A2B$ 将算术共享转换为布尔共享。请注意，我们要求在此转换过程中，任何一方都不能了解有关 $x$ 的任何附加信息。在份额上执行操作 $\odot$ 时，本文记作 $\langle z \rangle ^t = \langle x \rangle ^t$，其中$\odot: \langle x \rangle ^t \times \langle y \rangle ^t \mapsto \langle z \rangle ^t$ 和 $t \in {A,B,Y}$，例如 $\langle z \rangle ^ A = \langle x \rangle ^ A + \langle y \rangle ^ A$ 把两个算术份额相加并返回算术份额。</p>
<h2 id="不经意传输"><a href="#不经意传输" class="headerlink" title="不经意传输"></a>不经意传输</h2><p>本文在工作中使用的主要构件是不经意传输(OT)。我们使用2取1 OT，其中发送者输入两个 $l$ 位比特串$(s_0,s_1)$，接收者输入比特 $c \in \{0, 1 \}$，并且不经意地获得输出 $s_c$，使得接收者不学习关于 $s_{1-c}$ 的信息，并且发送者不学习关于 $c$ 的信息。</p>
<p>为了最大化在线阶段的性能，我们的实现使用OT预计算[5]。虽然OT协议需要昂贵的公钥密码术，但OT扩展[1]、[6]、[41]允许仅使用对称密码原语和恒定轮数来扩展几个基本OT(我们在实验中使用[56])。为了进一步提高效率，引入了特殊的OT形式，如相关OT(C-OT)[1]和随机OT(R-OT)[1]、[58]。在C-OT中，发送方输入相关函数 $f_{\Delta}(\cdot)$，并获得随机 $s_0$ 和相关的 $s_1=f_{\Delta}(s_0)$。在R-OT中，发送方没有输入并获得随机 $(s_0,s_1)$。C-OT中的随机 $s_0$ 和 $(s_0,s_1)$ 由相关稳健单向函数 $H$ 输出[41]，该函数可以使用散列函数实例化。在整篇论文中，我们使用缩写 ${\rm OT}^n_l$ (分别为 $\rm C$-${\rm OT}^n_l$，$\rm R$-${\rm OT}^n_l$)来引用 $l$ 位字符串上的 $n$ 个并行$(\rm C$-$\backslash \rm R$-$){\rm OT}^n_l$。对于OT扩展，${\rm OT}^n_l$、$\rm C$-${\rm OT}^n_l$ 和 $\rm R$-${\rm OT}^n_l$ 的通信分别为 $n(\kappa + 2l)$、$n(\kappa + l)$ 和 $n \kappa$ 比特，这在文献[1]中被认为是主要的性能瓶颈。对于 ${\rm OT}^n_l$、$\rm C$-${\rm OT}^n_l$ 和 $\rm R$-${\rm OT}^n_l$ 的计算是对每一方的对称密码原语的 $3n$ 次评估。</p>
<h1 id="共享类型"><a href="#共享类型" class="headerlink" title="共享类型"></a>共享类型</h1><p>在本节中，详细介绍作者的Aby框架使用的共享类型：算术共享(§III-A)、布尔共享(§III-B)和姚共享(§III-C)。对于每种共享类型，本文将在各自的小节中描述共享的语义、标准操作和最新技术。</p>
<h2 id="算术共享"><a href="#算术共享" class="headerlink" title="算术共享"></a>算术共享</h2><p>对于算术共享，在环 $\mathbb{Z}_{2^l}$(整数模 $2^l$)中相加地共享 $l$ 位值 $x$ 作为两个值的和。以下描述的协议基于[2]、[44]、[67]。首先，作者定义了共享语义(§III-A1)和操作(§III-A2)，并概述了基于算术共享的安全计算的相关工作(§III-A3)。然后，作者详细介绍了如何使用同态加密(§III-A4)或OT(§III-A5)生成算术乘法三元组；作者在§V-C后面的部分对这两种方法的性能进行了实验比较。在下面，作者假设要在环Z2‘中执行的所有算术运算，即所有运算都是($\bmod 2^l$)。</p>
<h3 id="共享语义"><a href="#共享语义" class="headerlink" title="共享语义"></a>共享语义</h3><p>算术共享基于在各方之间附加共享私有值，如下所示：</p>
<ul>
<li><strong>被共享的值。</strong>对于一个 $l$ 位的 $x$ 的算术共享 $\langle x \rangle ^ A$，有 $\langle x \rangle ^A_0 + \langle x \rangle ^A_1 \equiv x (\bmod 2^l)$，其中 $\langle x \rangle ^ A_0, \langle x \rangle ^A_1 \in \mathbb{Z}_{2^l}$。</li>
<li><strong>共享。</strong>$\mathsf{Shr}^A_i(x)$：$P_i$ 选择 $r \in_R \mathbb{Z}_{2^l}$，设 $\langle x \rangle^A_i = x - r$，然后发送 $r$ 给 $P_{1-i}$，后者设 $\langle x \rangle^A_{1-i} = r$。</li>
<li><strong>重构。</strong>$\mathsf{Rec}^A_i(x)$：$P_{1-i}$ 发送它的份额 $\langle x \rangle^A_{1-i}$ 给 $P_i$，后者计算 $x = \langle x \rangle ^A_0 + \langle x \rangle ^A_1$。</li>
</ul>
<h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><p>每个算术电路都是一系列加法和乘法门，评估如下：</p>
<ul>
<li><strong>加法。</strong>$\langle z \rangle ^ A = \langle x \rangle ^ A + \langle y \rangle ^ A$：$P_i$ 在本地计算 $\langle z \rangle ^ A_i = \langle x \rangle ^ A_i + \langle y \rangle ^ A_i$。</li>
<li><strong>乘法。</strong>$\langle z \rangle ^ A = \langle x \rangle ^ A \cdot \langle y \rangle ^ A$：乘法使用形式为 $\langle c \rangle ^ A = \langle a \rangle ^ A \cdot \langle b \rangle ^ A$ 的预计算算术乘法三元组[4]：$P_i$ 设 $\langle e \rangle ^A_i = \langle x \rangle ^A_i - \langle a \rangle ^A_i$ 和 $\langle f \rangle ^A_i = \langle y \rangle ^A_i - \langle b \rangle ^A_i$，双方执行 $\mathsf{Rec}^A(e)$ 和 <script type="math/tex">\mathsf{Rec}^A(f)</script>，然后 $P_i$ 设 $\langle z \rangle ^ A_i = i \cdot e \cdot f + f \cdot \langle a \rangle ^ A_i + e \cdot \langle b \rangle ^ A_i + \langle c \rangle ^ A_i$。本文给出了预计算算术乘法的协议。</li>
</ul>
<h3 id="最先进的技术"><a href="#最先进的技术" class="headerlink" title="最先进的技术"></a>最先进的技术</h3><p>本文在算术共享中采用的协议在环 $\mathbb{Z}_{2^l}$ 中使用加性共享。它们在[2]、[44]、[67]中进行了描述，并在半诚实的设置中提供了安全性。BGW协议[9]是用于算术电路的安全多方计算的第一个协议，该协议对于多达 $t&lt;n/2$ 个腐败方是针对半诚实方的安全的，并且对于多达 $t&lt;n/3$ 个腐败方的针对恶意攻击者是安全的。虚拟理想函数框架(VIFF)[24]是用于异步网络中的安全计算方案的通用软件框架，并且使用预计算的算术乘法三元组来实现安全计算。SPDZ协议[27]、[28]允许在恶意模型中存在 $t=n−1$ 被破坏方的情况下进行安全计算；在[42]中给出了SPDZ协议的运行时环境。在[17]、[18]中已经提出了用于计算各种基元的算术电路。</p>
<h3 id="利用加性同态加密生成算术乘法三元组"><a href="#利用加性同态加密生成算术乘法三元组" class="headerlink" title="利用加性同态加密生成算术乘法三元组"></a>利用加性同态加密生成算术乘法三元组</h3><p>通常，$\langle a \rangle ^ A \cdot \langle b \rangle ^ A = \langle c \rangle ^ A$ 形式的算术乘法三元组在设置阶段使用如协议1所示的加法同态加密方案来生成。该用于生成乘法三元组的协议在[2，附录A]中被提到为“众所周知的民间传说”。对于同态加密，我们使用Paillier[25]、[26]、[62]的密码系统，或者使用Damgard-Geisler-Krøigaard(DGK)[22]、[23]的密码系统，并使用如[10]、[32]、[52]中描述的Pohlig-Hellman算法[65]进行完全解密。在Paillier加密中，明文空间为 $Z_N$，使用参数为 $r$ 的统计盲化；在DGK加密中，将明文空间设置为 $\mathbb{Z}_{2^{2l+1}}$，使用参数为 $r$ 的完全盲化。关于安全性和正确性的证明，请参阅[67]和[66]。</p>
<p><strong>复杂度。</strong>为了生成 $l$ 位乘法三元组，$P_0$ 和 $P_1$ 交换 $3$ 个密文，对于Paillier每个密文长度为 $2\varphi$ 比特(而DGK为 $\varphi$ 比特)，导致总共6个 $\varphi$ 比特的通信(对应的3个 $\varphi$ 比特)。对于Paillier加密，我们还使用了[67]中描述的打包优化，该优化将从 $P_1$ 到 $P_0$ 的多个消息打包成单个密文，从而减少解密次数，并将每个乘法三倍的通信量减少到 $4 \varphi + 2 \varphi / \lfloor \varphi / (2l+1+ \sigma) \rfloor$ 比特。</p>
<p><img src="http://images.yingwai.top/picgo/aby2p1.png" alt=""></p>
<h3 id="通过不经意传输生成算术乘法三元组"><a href="#通过不经意传输生成算术乘法三元组" class="headerlink" title="通过不经意传输生成算术乘法三元组"></a>通过不经意传输生成算术乘法三元组</h3><p>可以基于OT扩展生成算术乘法三元组，而不是使用同态加密。该议定书是在[33，Sect. 4.1]中提出的，并在[15]中使用。它允许使用OT有效地计算两个秘密共享值的乘积。在下面，本文将描述使用更有效的相关OT扩展的协议的一个微小变体。总体而言，可以在 $l$ 位串上使用 $2l$ 个相关的OT，即 C-OT$^{2l}_l$ (或者甚至在更短的串上，如下所述)来生成 $l$ 位乘法三元组。</p>
<h2 id="布尔共享"><a href="#布尔共享" class="headerlink" title="布尔共享"></a>布尔共享</h2><p>布尔共享使用基于异或的秘密共享方案。为了简化表示，假定使用单个比特值；对于 $l$ 比特的值，每个操作都并行执行多次。</p>
<h3 id="共享语义-1"><a href="#共享语义-1" class="headerlink" title="共享语义"></a>共享语义</h3><ul>
<li><strong>被共享的值。</strong>如果有 $\langle x \rangle ^B_0 \oplus \langle x \rangle ^B_1 = x$，其中 $\langle x \rangle ^B_0, \langle x \rangle ^B_1 \in \mathbb{Z}_2$，那么就说比特 $x$ 的布尔共享 $\langle x \rangle ^B$ 是在两方之间共享的。</li>
<li><strong>共享。</strong>$\mathsf{Shr}_i^B(x)$：$P_i$ 选择 $r \in_R \{0,1\}$，计算 $\langle x \rangle ^B_i = x \oplus r$，然后发送 $r$ 给 $P_{1-i}$，后者设 $\langle x \rangle ^B_{1-i} = r$。</li>
<li><strong>重构。</strong>$\mathsf{Rec}_i^B(x)$：$P_{1-i}$ 发送它的份额 $\langle x \rangle ^B_{1-i}$ 给 $P_i$，后者计算 $x = \langle x \rangle ^B_0 \oplus \langle x \rangle ^B_1$。</li>
</ul>
<h3 id="操作-1"><a href="#操作-1" class="headerlink" title="操作"></a>操作</h3><p>每个有效计算的函数都可以表示为一个由异或门和与门组成的布尔电路，本文将在下面详细说明对它的求值。</p>
<ul>
<li><strong>异或。</strong>$\langle z \rangle ^B = \langle x \rangle ^B \oplus \langle y \rangle ^B$：$P_i$ 本地计算 $\langle z \rangle ^B_i = \langle x \rangle ^B_i \oplus \langle y \rangle ^B_i$。</li>
<li><strong>与。</strong>$\langle z \rangle ^B = \langle x \rangle ^B \wedge \langle y \rangle ^B$：与使用预计算布尔乘法三元组 $\langle c \rangle ^B = \langle a \rangle ^B \wedge \langle b \rangle ^B$ 进行评估，如下所示：$P_i$ 计算 $\langle e \rangle ^B_i = \langle a \rangle ^B_i \oplus \langle x \rangle ^B_i$ 和 $\langle f \rangle ^B_i = \langle b \rangle ^B_i \oplus \langle y \rangle ^B_i$，双方执行 $\mathsf{Rec}^B(e)$ 和 $\mathsf{Rec}^B(f)$，然后 $P_i$ 设 $\langle z \rangle ^B_i = i \cdot e \cdot f \oplus f \cdot \langle a \rangle ^B_i \oplus e \cdot \langle b \rangle ^B_i \oplus \langle c \rangle ^B_i$。如文献[1]所述，使用 R-OT$^2_1$ 可以有效地预计算布尔乘法三元组。</li>
<li><strong>多路复用。</strong>对于多路复用器操作，本文使用[54]中提出的协议，该协议只需要 R-OT$^2_l$，而评估具有 $l$ 个与门的多路复用电路需要 R-OT$^{2l}_1$(参见[64]中的向量乘法三元组)。</li>
<li><strong>其它。</strong>对于标准功能，本文使用[69]中总结的深度优化电路结构。</li>
</ul>
<h3 id="最先进的技术-1"><a href="#最先进的技术-1" class="headerlink" title="最先进的技术"></a>最先进的技术</h3><p>在[19]中给出了GMW协议的第一个实现，该协议用于多方并且在半诚实模型中具有安全性。在[69]中提出了针对两方设置的该框架的优化，并且在[1]中给出了使用R-OT扩展来有效地预计算乘法三元组的进一步改进。这些工作表明，GMW协议在低延迟网络中取得了良好的性能。TinyOT[50]，[58]将GMW协议扩展到隐蔽的恶意模型。</p>
<h2 id="姚氏共享"><a href="#姚氏共享" class="headerlink" title="姚氏共享"></a>姚氏共享</h2><p>在Yao用于安全两方计算的乱码电路协议[74]中，一方(称为Garbler)将布尔函数加密为乱码电路，由另一方(称为赋值器)进行评估。更详细地，加布勒将要计算的函数表示为布尔电路，并将满足 $k_0^w, k_0^w \in \{0,1\}^{\kappa}$ 的两个线密钥 $(k_0^w, k_0^w)$ 分配给每条线 $w$。然后，Garbler使用加密函数 $\mathsf{Gb}$ 对两个输入线密钥的所有可能组合上的每个门的输出线密钥进行加密(详情见§III-C2中的共享)。然后，他将损坏的电路(由所有损坏的门组成)连同电路的相应输入键一起发送给评估器(参见§III-C1的共享)。评估者使用门的输入线路密钥迭代地解密每个乱码的门，以获得输出线路密钥(参见§III-C2中的与)，并最终重构电路的明文输出(参见§III-C1中的重构)。</p>
<p>在下面，我们假设 $P_0$ 充当Garbler，$P_1$ 充当评估者，并详细说明Yao共享，假设使用free-XOR[47]和点置换[53]优化的乱码方案。使用这些技术，Garbler随机选择 $R[0]=1$ 的全局 $\kappa$ 位串 $R$。对于每根导线 $w$，线密钥分别为 $k^w_0 \in_R \{0,1\}^{\kappa}$ 和 $k^w_1 = k^w_0 \oplus R$。最低有效位 $k^w_0[0]$、$k^w_1[0]=1 − k^w_0[0]$ 称为置换位。作者指出，YAO共享也可以与其他改进方案一起实例化。</p>
<h3 id="共享语义-2"><a href="#共享语义-2" class="headerlink" title="共享语义"></a>共享语义</h3><p>直观地，对于每根导线 $w$，$P_0$ 持有两个键 $k_0^w$ 和 $k_1^w$，以及 $P_1$ 持有这些键中的一个，而不知道它对应于两个明文值中的哪一个。为了简化表示，我们假定使用单个比特值；对于 $l$ 比特的值，每个操作都并行执行多次。</p>
<ul>
<li><strong>被共享的值。</strong>值 $x$ 的乱码电路共享 $\langle x \rangle ^Y$ 被共享为 $\langle x \rangle ^Y_0 = k_0$ 和 $\langle x \rangle ^Y_1 = k_x = k_0 \oplus xR$。</li>
<li><strong>共享。</strong>$\mathsf{Shr}^Y_0(x)$：$P_0$ 取随机值 $\langle x \rangle ^Y_0 = k_0 \in_R \{0,1\}^{\kappa}$ 然后发送 $k_x = k_0 \oplus xR$ 给 $P_1$。</li>
<li><strong>重构。</strong>$\mathsf{Rec}^Y_i (x)$：$P_{1-i}$ 发送它的置换位 $\pi = \langle x \rangle ^Y_{1-i}[0]$ 给 $P_i$，后者计算 $x = \pi \oplus \langle x \rangle ^Y_i[0]$。</li>
</ul>
<h3 id="操作-2"><a href="#操作-2" class="headerlink" title="操作"></a>操作</h3><p>使用姚氏共享，由XOR和AND门组成的布尔电路评估如下：</p>
<ul>
<li><strong>异或。</strong>$\langle z \rangle ^Y = \langle x \rangle ^Y \oplus \langle y \rangle ^Y$ 使用 free-XOR 技术[47]进行评估：$P_i$ 本地计算 $\langle z \rangle ^Y_i = \langle x \rangle ^Y_i \oplus \langle y \rangle ^Y_i$。</li>
<li><strong>与。</strong>$\langle z \rangle ^Y = \langle x \rangle ^Y \wedge \langle y \rangle ^Y$ 评估如下：$P_0$ 使用 $\mathsf{Gb}_{\langle z \rangle ^Y_0}(\langle x \rangle ^Y_0, \langle y \rangle ^Y_0)$ 生成乱码表，其中 $\mathsf{Gb}$ 是[7]中定义的乱码函数。$P_0$ 发送该表给 $P_1$，后者使用它的密钥 $\langle x \rangle ^Y_1$ 和 $\langle y \rangle ^Y_1$ 进行解密。</li>
<li><strong>其它。</strong>对于标准功能，本文使用[45]中总结的尺寸优化的电路结构。</li>
</ul>
<h3 id="最先进的技术-2"><a href="#最先进的技术-2" class="headerlink" title="最先进的技术"></a>最先进的技术</h3><p>除了上面提到的优化之外，对姚的乱码电路协议还有几个进一步的改进：乱码行减少[57]、[63]和流水线[38]，其中乱码表格在在线阶段被发送。文献[38]中给出了半诚实模型中Yao的乱码电路协议的一种流行实现。在[7]中给出了乱码方案的形式化定义，以及使用固定密钥AES的GB的有效实例化。在本文的实现中，除了流水线之外，作者使用了姚的乱码电路协议的这些最先进的优化(想要最小化在线阶段的复杂性，从而在设置阶段生成和传输乱码电路)。为了实现针对隐蔽和恶意攻击者的安全，一些实现使用剪切选择技术，例如[16]、[49]、[73]。</p>
<h1 id="共享转换"><a href="#共享转换" class="headerlink" title="共享转换"></a>共享转换</h1><p>在本节中，将详细介绍在不同共享之间进行转换的方法。首先解释已经存在的或直接的转换：Y2B(§IV-A)、B2Y(§IV-B)、A2Y(§IV-C)和A2B(§IV-D)。然后，我们详细说明了B2A(§IV-E)和Y 2A(§IV-F)的改进结构。作者将共享、重构和转换操作的复杂性总结在表1。</p>
<p><img src="http://images.yingwai.top/picgo/aby2t1.png" alt=""></p>
<center>
    <i>表1 用于l比特的值的共享、重构和转换操作的在线阶段的总计算(对称密码操作数)、通信和消息数。κ是对称安全参数。</i>
</center>




<h2 id="姚氏到布尔共享-Y2B"><a href="#姚氏到布尔共享-Y2B" class="headerlink" title="姚氏到布尔共享(Y2B)"></a>姚氏到布尔共享(Y2B)</h2><p>将姚共享 $\langle x \rangle ^Y$ 转换为布尔共享 $\langle x \rangle ^B$ 是最简单的转换，基本上是免费的。关键的发现是 $\langle x \rangle ^Y_0$ 和 $\langle x \rangle ^Y_1$ 的排列位已经形成了 $x$ 的有效布尔共享。因此，$P_i$ 在本地设置 $\langle x \rangle ^B_i = Y2B(\langle x \rangle ^Y_i) = \langle x \rangle ^Y_i[0]$。</p>
<h2 id="布尔到姚氏共享-B2Y"><a href="#布尔到姚氏共享-B2Y" class="headerlink" title="布尔到姚氏共享(B2Y)"></a>布尔到姚氏共享(B2Y)</h2><p>将布尔共享 $\langle x \rangle ^B$ 转换为姚共享 $\langle x \rangle ^Y$ 非常类似于 $\mathsf{Shr}^Y_1$ 操作(参见§III-C1)：在下文中，我们假设 $x$ 是1比特；对于 $l$ 比特的值，每个运算都并行完成 $l$ 次。设 $x_0 = \langle x \rangle ^B_0$ 和 $x_1 = \langle x \rangle ^B_1$。$P_0$ 选取 $\langle x \rangle ^Y_0 = k_0 \in_R \{0,1\}^{\kappa}$。双方执行 OT$^1_{\kappa}$，其中 $P_0$ 作为具有输入的发送方 $(k_0 \oplus x_0 \cdot R;k_0 \oplus (1−x_0) \cdot R)$，而 $P_1$ 作为具有选择位 $x_1$ 的接收方，并且不经意地获得 $\langle x \rangle ^Y_1 = k_0 \oplus (x_0 \oplus x_1) \cdot R = k_x$。</p>
<h2 id="算术到姚氏共享-A2Y"><a href="#算术到姚氏共享-A2Y" class="headerlink" title="算术到姚氏共享(A2Y)"></a>算术到姚氏共享(A2Y)</h2><p>算术共享 $\langle x \rangle ^A$ 到Yao共享 $\langle x \rangle ^Y$ 的转换在[35]、[44]、[46]中概述，并且可以通过安全地评估加法电路来完成。更准确地说，各方秘密地将他们的算术份额 $x_0 = \langle x \rangle ^A_0$ 和 $x_1 = \langle x \rangle ^A_1$ 共享为 $\langle x_0 \rangle ^Y = \mathsf{Shr}^Y_0(x_0)$ 和 $\langle x_1 \rangle ^Y = \mathsf{Shr}^Y_1(x_1)$，并计算 $\langle x \rangle ^Y = \langle x_0 \rangle ^Y + \langle x_1 \rangle ^Y$。</p>
<h2 id="算术到布尔共享-A2B"><a href="#算术到布尔共享-A2B" class="headerlink" title="算术到布尔共享(A2B)"></a>算术到布尔共享(A2B)</h2><p>可以使用布尔加法电路(类似于§IV-C中描述的A2Y转换)或通过使用算术位提取电路[17]、[18]、[21]、[70]来完成将算术共享 $\langle x \rangle ^A$ 转换为布尔共享 $\langle x \rangle ^B$。如在[69]中总结的，布尔加法电路可以被实例化为大小优化的随 $O(l)$ 大小和深度变化的变量，或者实例化为随 $O(l\log_2l)$ 大小和 $O(\log_2l)$ 深度变化的深度优化的变量。在本文的框架中，$Y2B$ 转换是免费的，我们简单地计算 $\langle x \rangle ^B = A2B(\langle x \rangle ^A) = Y2B(A2Y(\langle x \rangle ^A))$，因为我们在§V-D中的评估表明，Yao共享中的加法比布尔共享中的加法更有效。</p>
<h2 id="布尔到算术共享-B2A"><a href="#布尔到算术共享-B2A" class="headerlink" title="布尔到算术共享(B2A)"></a>布尔到算术共享(B2A)</h2><p>将 $l$ 比特布尔共享 $\langle x \rangle ^B$ 转换为算术共享 $\langle x \rangle ^A$ 的简单解决方案是评估布尔减法电路，其中 $P_0$ 输入 $\langle x \rangle ^B_0$ 和随机数 $r \in_R \{0,1\}^l$，并且设置 $\langle x \rangle ^A_0 = r$，然后 $P_1$ 输入 $\langle x \rangle ^B_1$ 并获得 $\langle x \rangle ^A_1 = x - r$。然而，评估这样的布尔减法电路将具有 $O(l)$ 大小和深度或者 $O(l \log_2 l)$ 大小和 $O(\log_2 l)$ 深度[69]。</p>
<p>为了提高转换的性能，可以使用与§III-A5中描述的算术乘法三次生成类似的技术。一般的想法是对每个比特执行OT，其中我们不经意地转移了两个值，这两个值被2的幂相加相关。接收方可以获得这些值中的一个，并且通过将它们相加，各方获得有效的算术份额。</p>
<p>更详细地说，在OT协议中，$P_0$ 充当发送者，$P_1$ 充当接收者。在第 $i$ 个OT中，$P_0$ 随机选择 $r_i \in_R \{0, 1\}^l$ 以及输入 $(s_{i,0}, s_{i_1})$，其中 $s_{i,0} = (1 - \langle x \rangle^B_0[i]) \cdot 2^i - r_i$ 以及 $s_{i,1} = \langle x \rangle^B_0[i] \cdot 2^i - r_i$，而 $P_1$ 输入 $\langle x \rangle^B_1[i]$ 作为选择位，收到输出 $s_{\langle x \rangle ^B_1[i]} = (\langle x \rangle^B_0[i] \oplus \langle x \rangle^B_1[i]) \cdot 2^i - r_i$。最后，$P_0$ 计算 $\langle x \rangle^A_0 = \sum^l_{i=1}r_i$，$P_1$ 计算 $\langle x \rangle^A_1$ $=\sum^l_{i=1}s_{\langle x \rangle^B_1[i]}$ $=\sum^l_{i=1}(\langle x \rangle^B_0[i] \oplus \langle x \rangle^B_1[i]) \cdot$ $2^i-\sum^l_{i=1}r_i$ $=\sum^l_{i=1}x[i] \cdot 2^i -$ $\sum^l_{i=1}r_i$ $=x - \langle x \rangle^A_0$。安全性和正确性类似于§III-A5的协议。</p>
<p><strong>复杂度。</strong>观察到，由于我们传输一个随机元素和另一个作为相关性，并且只需要第 $i$ 个OT中的 $l-i$ 个最低有效位，所以我们可以使用C-OT和§III-A5中概述的相同技巧，导致(平均)C-OT$^l_{(l+1)/2}$ 和恒定轮数。相比之下，当使用布尔共享评估减法电路时，对于深度为 $O(\log_2l)$ 的电路各方将需要评估 $O(l \log_2 l)$次R-OT或对于深度为 $l$ 的电路评估 $2l$ 次ROT。本文的转换方法也比转换成姚共享(这已经需要 $2l$ OT)并在乱码电路中进行减法运算。</p>
<h2 id="姚氏到算术共享-Y2A"><a href="#姚氏到算术共享-Y2A" class="headerlink" title="姚氏到算术共享(Y2A)"></a>姚氏到算术共享(Y2A)</h2><p>在[35]，[44]，[46]中描述了从姚共享 $\langle x \rangle ^Y$ 到算术共享 $\langle x \rangle ^A$ 的转换：$P_0$ 随机选择 $r \in_R \mathbb{Z}_{2^l}$，执行 $\mathsf{Shr}^Y_0$，然后双方评估布尔减法电路 $\langle d \rangle ^Y = \langle x \rangle ^Y - \langle r \rangle ^Y$，以获得它们的算术份额为 $\langle x \rangle ^A_0 = r$ 和 $\langle x \rangle ^A_1 = \mathsf{Rec}^Y_1(\langle d \rangle ^Y)$。</p>
<p>然而，由于我们免费执行 $Y2B$，而 $B2A$ 在计算和通信方面更便宜，我们建议计算 $\langle x \rangle ^A = Y2A(\langle x \rangle ^Y) = B2A(Y2B(\langle x \rangle ^Y))$。</p>
]]></content>
      <categories>
        <category>Papers</category>
      </categories>
      <tags>
        <tag>密码学</tag>
        <tag>MPC</tag>
        <tag>隐私保护机器学习</tag>
      </tags>
  </entry>
</search>
