<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hexo博客NexT主题使用不蒜子统计访客数</title>
    <url>/2020/05/08/Hexo%E5%8D%9A%E5%AE%A2NexT%E4%B8%BB%E9%A2%98%E4%BD%BF%E7%94%A8%E4%B8%8D%E8%92%9C%E5%AD%90%E7%BB%9F%E8%AE%A1%E8%AE%BF%E5%AE%A2%E6%95%B0/</url>
    <content><![CDATA[<p>想为自己的博客添加访问统计，经过一番查阅，找到了好用又方便的不蒜子统计，不蒜子是一个极简的网页计数器。</p>
<a id="more"></a>
<h1 id="安装NexT"><a href="#安装NexT" class="headerlink" title="安装NexT"></a>安装NexT</h1><p>参考 <a href="http://theme-next.iissnan.com/getting-started.html" target="_blank" rel="noopener">http://theme-next.iissnan.com/getting-started.html</a></p>
<h1 id="打开不蒜子统计开关"><a href="#打开不蒜子统计开关" class="headerlink" title="打开不蒜子统计开关"></a>打开不蒜子统计开关</h1><p>新版的next主题已经把不蒜子集成进去，只需要打开开关即可：</p>
<ol>
<li><p>编辑<code>\themes\next\_config.yml</code>，找到里面的<code>busuanzi_count</code>配置项，将<code>enable</code>设为<code>true</code>：</p>
<p><img src="http://images.yingwai.top/picgo/busuanzif1.png" alt=""></p>
<p>当<code>enable: true</code>时，代表开启全局开关。若<code>site_uv</code>、<code>site_pv</code>、<code>page_pv</code>的值均为<code>false</code>时，不蒜子仅作记录而不会在页面上显示。</p>
</li>
<li><p>打开对应的站点配置：当<code>site_uv: true</code>时，代表在页面底部显示站点的UV值；当<code>site_pv: true</code>时，代表在页面底部显示站点的PV值。</p>
</li>
</ol>
<h1 id="不蒜子统计不显示的问题"><a href="#不蒜子统计不显示的问题" class="headerlink" title="不蒜子统计不显示的问题"></a>不蒜子统计不显示的问题</h1><p>完成上面的步骤后，进入博客，发现统计人数显示不出来：</p>
<p><img src="http://images.yingwai.top/picgo/busuanzif2.png" alt=""></p>
<p><strong>原因：不蒜子的域名更换了，但是next主题里面写进去的域名还是以前的。</strong></p>
<p><a href="http://busuanzi.ibruce.info/" target="_blank" rel="noopener">不蒜子官网</a>：</p>
<p><img src="http://images.yingwai.top/picgo/busuanzif3.png" alt=""></p>
<p><strong>解决方法：</strong></p>
<p>打开<code>\themes\next\layout\_third-party\analytics</code>文件夹里面的<code>busuanzi-counter.swig</code>文件，将旧的域名更换为新的域名：</p>
<p>原来的域名：</p>
<p><img src="http://images.yingwai.top/picgo/busuanzif4.png" alt=""></p>
<p>更换后：</p>
<p><img src="http://images.yingwai.top/picgo/busuanzif5.png" alt=""></p>
<p>此时博客的访客数就可以正常显示了。</p>
]]></content>
      <categories>
        <category>Env</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>不蒜子</tag>
      </tags>
  </entry>
  <entry>
    <title>CCF推荐国际学术会议和期刊目录（网络与信息安全）</title>
    <url>/2020/04/20/CCF%E6%8E%A8%E8%8D%90%E5%9B%BD%E9%99%85%E5%AD%A6%E6%9C%AF%E4%BC%9A%E8%AE%AE%E5%92%8C%E6%9C%9F%E5%88%8A%E7%9B%AE%E5%BD%95%EF%BC%88%E7%BD%91%E7%BB%9C%E4%B8%8E%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%EF%BC%89/</url>
    <content><![CDATA[<p><a href="https://www.ccf.org.cn/c/2019-04-25/663625.shtml" target="_blank" rel="noopener">https://www.ccf.org.cn/c/2019-04-25/663625.shtml</a></p>
<a id="more"></a>
<h2 id="中国计算机学会推荐国际学术期刊（网络与信息安全）"><a href="#中国计算机学会推荐国际学术期刊（网络与信息安全）" class="headerlink" title="中国计算机学会推荐国际学术期刊（网络与信息安全）"></a>中国计算机学会推荐国际学术期刊（网络与信息安全）</h2><h3 id="A类"><a href="#A类" class="headerlink" title="A类"></a>A类</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">序号</th>
<th style="text-align:center">刊物简称</th>
<th style="text-align:center">刊物全称</th>
<th style="text-align:center">出版社</th>
<th style="text-align:center">网址</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">TDSC</td>
<td style="text-align:center">IEEE Transactions on Dependable and Secure Computing</td>
<td style="text-align:center">IEEE</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/journals/tdsc/" target="_blank" rel="noopener">http://dblp.uni-trier.de/db/journals/tdsc/</a></td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">TIFS</td>
<td style="text-align:center">IEEE Transactions on Information Forensics and Security</td>
<td style="text-align:center">IEEE</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/journals/tifs/" target="_blank" rel="noopener">http://dblp.uni-trier.de/db/journals/tifs/</a></td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center"></td>
<td style="text-align:center">Journal of Cryptology</td>
<td style="text-align:center">Springer</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/journals/joc/" target="_blank" rel="noopener">http://dblp.uni-trier.de/db/journals/joc/</a></td>
</tr>
</tbody>
</table>
</div>
<h3 id="B类"><a href="#B类" class="headerlink" title="B类"></a>B类</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">序号</th>
<th style="text-align:center">刊物简称</th>
<th style="text-align:center">刊物全称</th>
<th style="text-align:center">出版社</th>
<th style="text-align:center">网址</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">TOPS</td>
<td style="text-align:center">ACM Transactions on Privacy and Security</td>
<td style="text-align:center">ACM</td>
<td style="text-align:center"><a href="https://tops.acm.org/" target="_blank" rel="noopener">https://tops.acm.org/</a></td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center"></td>
<td style="text-align:center">Computers &amp; Security</td>
<td style="text-align:center">Elsevier</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/journals/compsec/" target="_blank" rel="noopener">http://dblp.uni-trier.de/db/journals/compsec/</a></td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center"></td>
<td style="text-align:center">Designs, Codes and Cryptography</td>
<td style="text-align:center">Springer</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/journals/dcc/" target="_blank" rel="noopener">http://dblp.uni-trier.de/db/journals/dcc/</a></td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">JCS</td>
<td style="text-align:center">Journal of Computer Security</td>
<td style="text-align:center">IOS Press</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/journals/jcs/" target="_blank" rel="noopener">http://dblp.uni-trier.de/db/journals/jcs/</a></td>
</tr>
</tbody>
</table>
</div>
<h3 id="C类"><a href="#C类" class="headerlink" title="C类"></a>C类</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">序号</th>
<th style="text-align:center">刊物简称</th>
<th style="text-align:center">刊物全称</th>
<th style="text-align:center">出版社</th>
<th style="text-align:center">网址</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">CLSR</td>
<td style="text-align:center">Computer Law and Security Review</td>
<td style="text-align:center">Elsevier</td>
<td style="text-align:center"><a href="http://www.journals.elsevier.com/computer-law-and-security-review/" target="_blank" rel="noopener">http://www.journals.elsevier.com/computer-law-and-security-review/</a></td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center"></td>
<td style="text-align:center">EURASIP Journal on Information Security</td>
<td style="text-align:center">Springer</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/journals/ejisec/" target="_blank" rel="noopener">http://dblp.uni-trier.de/db/journals/ejisec/</a></td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center"></td>
<td style="text-align:center">IET Information Security</td>
<td style="text-align:center">IET</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/journals/iet-ifs/" target="_blank" rel="noopener">http://dblp.uni-trier.de/db/journals/iet-ifs/</a></td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">IMCS</td>
<td style="text-align:center">Information Management &amp; Computer Security</td>
<td style="text-align:center">Emerald</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/journals/imcs/" target="_blank" rel="noopener">http://dblp.uni-trier.de/db/journals/imcs/</a></td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center">IJICS</td>
<td style="text-align:center">International Journal of Information and Computer Security</td>
<td style="text-align:center">Inderscience</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/journals/ijics/" target="_blank" rel="noopener">http://dblp.uni-trier.de/db/journals/ijics/</a></td>
</tr>
<tr>
<td style="text-align:center">6</td>
<td style="text-align:center">IJISP</td>
<td style="text-align:center">International Journal of Information Security and Privacy</td>
<td style="text-align:center">Idea Group Inc</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/journals/ijisp/" target="_blank" rel="noopener">http://dblp.uni-trier.de/db/journals/ijisp/</a></td>
</tr>
<tr>
<td style="text-align:center">7</td>
<td style="text-align:center">JISA</td>
<td style="text-align:center">Journal of Information Security and Application</td>
<td style="text-align:center">Elsevier</td>
<td style="text-align:center"><a href="https://dblp.uni-trier.de/db/journals/istr/" target="_blank" rel="noopener">https://dblp.uni-trier.de/db/journals/istr/</a></td>
</tr>
<tr>
<td style="text-align:center">8</td>
<td style="text-align:center">SCN</td>
<td style="text-align:center">Security and Communication Networks</td>
<td style="text-align:center">Wiley</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/journals/scn/" target="_blank" rel="noopener">http://dblp.uni-trier.de/db/journals/scn/</a></td>
</tr>
</tbody>
</table>
</div>
<h2 id="中国计算机学会推荐国际学术会议（网络与信息安全）"><a href="#中国计算机学会推荐国际学术会议（网络与信息安全）" class="headerlink" title="中国计算机学会推荐国际学术会议（网络与信息安全）"></a>中国计算机学会推荐国际学术会议（网络与信息安全）</h2><h3 id="A类-1"><a href="#A类-1" class="headerlink" title="A类"></a>A类</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">序号</th>
<th style="text-align:center">会议简称</th>
<th style="text-align:center">会议全称</th>
<th style="text-align:center">出版社</th>
<th style="text-align:center">网址</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">CCS</td>
<td style="text-align:center">ACM Conference on Computer and Communications Security</td>
<td style="text-align:center">ACM</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/conf/ccs/" target="_blank" rel="noopener">http://dblp.uni-trier.de/db/conf/ccs/</a></td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">EUROCRYPT</td>
<td style="text-align:center">European Cryptology Conference</td>
<td style="text-align:center">Springer</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/conf/eurocrypt/" target="_blank" rel="noopener">http://dblp.uni-trier.de/db/conf/eurocrypt/</a></td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">S&amp;P</td>
<td style="text-align:center">IEEE Symposium on Security and Privacy</td>
<td style="text-align:center">IEEE</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/conf/sp/" target="_blank" rel="noopener">http://dblp.uni-trier.de/db/conf/sp/</a></td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">CRYPTO</td>
<td style="text-align:center">International Cryptology Conference</td>
<td style="text-align:center">Springer</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/conf/crypto/" target="_blank" rel="noopener">http://dblp.uni-trier.de/db/conf/crypto/</a></td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center">USENIX Security</td>
<td style="text-align:center">Usenix Security Symposium</td>
<td style="text-align:center">USENIX Association</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/conf/uss/" target="_blank" rel="noopener">http://dblp.uni-trier.de/db/conf/uss/</a></td>
</tr>
</tbody>
</table>
</div>
<h3 id="B类-1"><a href="#B类-1" class="headerlink" title="B类"></a>B类</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">序号</th>
<th style="text-align:center">会议简称</th>
<th style="text-align:center">会议全称</th>
<th style="text-align:center">出版社</th>
<th style="text-align:center">网址</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">ACSAC</td>
<td style="text-align:center">Annual Computer Security Applications Conference</td>
<td style="text-align:center">IEEE</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/conf/acsac/" target="_blank" rel="noopener">http://dblp.uni-trier.de/db/conf/acsac/</a></td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">ASIACRYPT</td>
<td style="text-align:center">Annual International Conference on the Theory and Application of Cryptology and Information Security</td>
<td style="text-align:center">Springer</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/conf/asiacrypt/" target="_blank" rel="noopener">http://dblp.uni-trier.de/db/conf/asiacrypt/</a></td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">ESORICS</td>
<td style="text-align:center">European Symposium on Research in Computer Security</td>
<td style="text-align:center">Springer</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/conf/esorics/" target="_blank" rel="noopener">http://dblp.uni-trier.de/db/conf/esorics/</a></td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">FSE</td>
<td style="text-align:center">Fast Software Encryption</td>
<td style="text-align:center">Springer</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/conf/fse/" target="_blank" rel="noopener">http://dblp.uni-trier.de/db/conf/fse/</a></td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center">CSFW</td>
<td style="text-align:center">IEEE Computer Security Foundations Workshop</td>
<td style="text-align:center">IEEE</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/conf/csfw/" target="_blank" rel="noopener">http://dblp.uni-trier.de/db/conf/csfw/</a></td>
</tr>
<tr>
<td style="text-align:center">6</td>
<td style="text-align:center">SRDS</td>
<td style="text-align:center">IEEE International Symposium on Reliable Distributed Systems</td>
<td style="text-align:center">IEEE</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/conf/srds/" target="_blank" rel="noopener">http://dblp.uni-trier.de/db/conf/srds/</a></td>
</tr>
<tr>
<td style="text-align:center">7</td>
<td style="text-align:center">CHES</td>
<td style="text-align:center">International Conference on Cryptographic Hardware and Embedded Systems</td>
<td style="text-align:center">Springer</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/conf/ches/" target="_blank" rel="noopener">http://dblp.uni-trier.de/db/conf/ches/</a></td>
</tr>
<tr>
<td style="text-align:center">8</td>
<td style="text-align:center">DSN</td>
<td style="text-align:center">International Conference on Dependable Systems and Networks</td>
<td style="text-align:center">IEEE/IFIP</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/conf/dsn/" target="_blank" rel="noopener">http://dblp.uni-trier.de/db/conf/dsn/</a></td>
</tr>
<tr>
<td style="text-align:center">9</td>
<td style="text-align:center">RAID</td>
<td style="text-align:center">International Symposium on Recent Advances in Intrusion Detection</td>
<td style="text-align:center">Springer</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/conf/raid/" target="_blank" rel="noopener">http://dblp.uni-trier.de/db/conf/raid/</a></td>
</tr>
<tr>
<td style="text-align:center">10</td>
<td style="text-align:center">PKC</td>
<td style="text-align:center">International Workshop on Practice and Theory in Public Key Cryptography</td>
<td style="text-align:center">Springer</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/conf/pkc/" target="_blank" rel="noopener">http://dblp.uni-trier.de/db/conf/pkc/</a></td>
</tr>
<tr>
<td style="text-align:center">11</td>
<td style="text-align:center">NDSS</td>
<td style="text-align:center">ISOC Network and Distributed System Security Symposium</td>
<td style="text-align:center">ISOC</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/conf/ndss/" target="_blank" rel="noopener">http://dblp.uni-trier.de/db/conf/ndss/</a></td>
</tr>
<tr>
<td style="text-align:center">12</td>
<td style="text-align:center">TCC</td>
<td style="text-align:center">Theory of Cryptography Conference</td>
<td style="text-align:center">Springer</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/conf/tcc/" target="_blank" rel="noopener">http://dblp.uni-trier.de/db/conf/tcc/</a></td>
</tr>
</tbody>
</table>
</div>
<h3 id="C类-1"><a href="#C类-1" class="headerlink" title="C类"></a>C类</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">序号</th>
<th style="text-align:center">会议简称</th>
<th style="text-align:center">会议全称</th>
<th style="text-align:center">出版社</th>
<th style="text-align:center">网址</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">WiSec</td>
<td style="text-align:center">ACM Conference on Security and Privacy in Wireless and Mobile Networks</td>
<td style="text-align:center">ACM</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/conf/wisec/" target="_blank" rel="noopener">http://dblp.uni-trier.de/db/conf/wisec/</a></td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">SACMAT</td>
<td style="text-align:center">ACM Symposium on Access Control Models and Technologies</td>
<td style="text-align:center">ACM</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/conf/sacmat/" target="_blank" rel="noopener">http://dblp.uni-trier.de/db/conf/sacmat/</a></td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">DRM</td>
<td style="text-align:center">ACM Workshop on Digital Rights Management</td>
<td style="text-align:center">ACM</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/conf/drm/" target="_blank" rel="noopener">http://dblp.uni-trier.de/db/conf/drm/</a></td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">IH&amp;MMSec</td>
<td style="text-align:center">ACM Workshop on Information Hiding and Multimedia Security</td>
<td style="text-align:center">ACM</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/conf/ih/" target="_blank" rel="noopener">http://dblp.uni-trier.de/db/conf/ih/</a></td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center">ACNS</td>
<td style="text-align:center">Applied Cryptography and Network Security</td>
<td style="text-align:center">Springer</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/conf/acns/" target="_blank" rel="noopener">http://dblp.uni-trier.de/db/conf/acns/</a></td>
</tr>
<tr>
<td style="text-align:center">6</td>
<td style="text-align:center">AsiaCCS</td>
<td style="text-align:center">Asia Conference on Computer and Communications Security</td>
<td style="text-align:center">ACM</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/conf/ccs/" target="_blank" rel="noopener">http://dblp.uni-trier.de/db/conf/ccs/</a></td>
</tr>
<tr>
<td style="text-align:center">7</td>
<td style="text-align:center">ACISP</td>
<td style="text-align:center">Australasia Conference on Information Security and Privacy</td>
<td style="text-align:center">Springer</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/conf/acisp/" target="_blank" rel="noopener">http://dblp.uni-trier.de/db/conf/acisp/</a></td>
</tr>
<tr>
<td style="text-align:center">8</td>
<td style="text-align:center">CT-RSA</td>
<td style="text-align:center">Cryptographer’s Track at RSA Conference</td>
<td style="text-align:center">Springer</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/conf/ctrsa/" target="_blank" rel="noopener">http://dblp.uni-trier.de/db/conf/ctrsa/</a></td>
</tr>
<tr>
<td style="text-align:center">9</td>
<td style="text-align:center">DIMVA</td>
<td style="text-align:center">Detection of Intrusions and Malware &amp; Vulnerability Assessment</td>
<td style="text-align:center"></td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/conf/dimva/" target="_blank" rel="noopener">http://dblp.uni-trier.de/db/conf/dimva/</a></td>
</tr>
<tr>
<td style="text-align:center">10</td>
<td style="text-align:center">DFRWS</td>
<td style="text-align:center">Digital Forensic Research Workshop</td>
<td style="text-align:center">Elsevier</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/conf/dfrws/" target="_blank" rel="noopener">http://dblp.uni-trier.de/db/conf/dfrws/</a></td>
</tr>
<tr>
<td style="text-align:center">11</td>
<td style="text-align:center">FC</td>
<td style="text-align:center">Financial Cryptography and Data Security</td>
<td style="text-align:center">Springer</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/conf/fc/" target="_blank" rel="noopener">http://dblp.uni-trier.de/db/conf/fc/</a></td>
</tr>
<tr>
<td style="text-align:center">12</td>
<td style="text-align:center">TrustCom</td>
<td style="text-align:center">IEEE International Conference on Trust, Security and Privacy in Computing and Communications</td>
<td style="text-align:center">IEEE</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/conf/trustcom/" target="_blank" rel="noopener">http://dblp.uni-trier.de/db/conf/trustcom/</a></td>
</tr>
<tr>
<td style="text-align:center">13</td>
<td style="text-align:center">SEC</td>
<td style="text-align:center">IFIP International Information Security Conference</td>
<td style="text-align:center">Springer</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/conf/sec/" target="_blank" rel="noopener">http://dblp.uni-trier.de/db/conf/sec/</a></td>
</tr>
<tr>
<td style="text-align:center">14</td>
<td style="text-align:center">IFIP WG 11.9</td>
<td style="text-align:center">IFIP WG 11.9 International Conference on Digital Forensics</td>
<td style="text-align:center">Springer</td>
<td style="text-align:center">*<a href="http://www.ifip119.org/Conferences/" target="_blank" rel="noopener">http://www.ifip119.org/Conferences/</a></td>
</tr>
<tr>
<td style="text-align:center">15</td>
<td style="text-align:center">ISC</td>
<td style="text-align:center">Information Security Conference</td>
<td style="text-align:center">Springer</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/conf/isw/" target="_blank" rel="noopener">http://dblp.uni-trier.de/db/conf/isw/</a></td>
</tr>
<tr>
<td style="text-align:center">16</td>
<td style="text-align:center">ICDF2C</td>
<td style="text-align:center">International Conference on Digital Forensics &amp; Cyber Crime</td>
<td style="text-align:center">Springer</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/conf/icdf2c/" target="_blank" rel="noopener">http://dblp.uni-trier.de/db/conf/icdf2c/</a></td>
</tr>
<tr>
<td style="text-align:center">17</td>
<td style="text-align:center">ICICS</td>
<td style="text-align:center">International Conference on Information and Communications Security</td>
<td style="text-align:center">Springer</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/conf/icics/" target="_blank" rel="noopener">http://dblp.uni-trier.de/db/conf/icics/</a></td>
</tr>
<tr>
<td style="text-align:center">18</td>
<td style="text-align:center">SecureComm</td>
<td style="text-align:center">International Conference on Security and Privacy in Communication Networks</td>
<td style="text-align:center">ACM</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/conf/securecomm/" target="_blank" rel="noopener">http://dblp.uni-trier.de/db/conf/securecomm/</a></td>
</tr>
<tr>
<td style="text-align:center">19</td>
<td style="text-align:center">NSPW</td>
<td style="text-align:center">New Security Paradigms Workshop</td>
<td style="text-align:center">ACM</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/conf/nspw/" target="_blank" rel="noopener">http://dblp.uni-trier.de/db/conf/nspw/</a></td>
</tr>
<tr>
<td style="text-align:center">20</td>
<td style="text-align:center">PAM</td>
<td style="text-align:center">Passive and Active Measurement Conference</td>
<td style="text-align:center">Springer</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/conf/pam/" target="_blank" rel="noopener">http://dblp.uni-trier.de/db/conf/pam/</a></td>
</tr>
<tr>
<td style="text-align:center">21</td>
<td style="text-align:center">PETS</td>
<td style="text-align:center">Privacy Enhancing Technologies Symposium</td>
<td style="text-align:center">Springer</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/conf/pet/" target="_blank" rel="noopener">http://dblp.uni-trier.de/db/conf/pet/</a></td>
</tr>
<tr>
<td style="text-align:center">22</td>
<td style="text-align:center">SAC</td>
<td style="text-align:center">Selected Areas in Cryptography</td>
<td style="text-align:center">Springer</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/conf/sacrypt/" target="_blank" rel="noopener">http://dblp.uni-trier.de/db/conf/sacrypt/</a></td>
</tr>
<tr>
<td style="text-align:center">23</td>
<td style="text-align:center">SOUPS</td>
<td style="text-align:center">Symposium On Usable Privacy and Security</td>
<td style="text-align:center">USENIX</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/conf/soups/" target="_blank" rel="noopener">http://dblp.uni-trier.de/db/conf/soups/</a></td>
</tr>
<tr>
<td style="text-align:center">24</td>
<td style="text-align:center">HotSec</td>
<td style="text-align:center">USENIX Workshop on Hot Topics in Security</td>
<td style="text-align:center">USENIX</td>
<td style="text-align:center">*<a href="http://www.usenix.org/events/" target="_blank" rel="noopener">http://www.usenix.org/events/</a></td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <categories>
        <category>Papers</category>
      </categories>
      <tags>
        <tag>密码学</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo博客NexT主题点击侧边栏日志出现问题的解决办法</title>
    <url>/2020/05/10/Hexo%E5%8D%9A%E5%AE%A2NexT%E4%B8%BB%E9%A2%98%E7%82%B9%E5%87%BB%E4%BE%A7%E8%BE%B9%E6%A0%8F%E6%97%A5%E5%BF%97%E5%87%BA%E7%8E%B0%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
    <content><![CDATA[<p>部署好博客并安装了NexT主题后，发现一个问题：侧边栏头像下面的日志点击是404的页面。于是到网上搜索，发现是符号转码的问题。</p>
<a id="more"></a>
<p><strong>解决方法：</strong></p>
<p>到<code>\themes\next\layout\_macro</code>目录下找到<code>sidebar.swig</code>文件，打开找到这一行：</p>
<p><img src="http://images.yingwai.top/picgo/nextsidebarrizhif1.png" alt=""></p>
<p>将<code>theme.menu.archives</code>后面的括号更换一下位置即可：</p>
<p><img src="http://images.yingwai.top/picgo/nextsidebarrizhif2.png" alt=""></p>
<p>这时候点击日志就会自动跳转到归档页。</p>
]]></content>
      <categories>
        <category>Env</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>JupyterLab安装</title>
    <url>/2020/05/01/JupyterLab%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<p>JupyterLab 是一个交互式的开发环境，是 Jupyter notebook 的下一代产品，集成了更多的功能，十分好用。</p>
<a id="more"></a>
<h1 id="安装Miniconda"><a href="#安装Miniconda" class="headerlink" title="安装Miniconda"></a>安装Miniconda</h1><p>1、进入清华大学开源软件镜像站找到Miniconda: <a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/miniconda/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/anaconda/miniconda/</a></p>
<p><img src="http://images.yingwai.top/picgo/jupyterinstallf1.png" alt=""></p>
<p>2、找到Miniconda的Linux版本，右键复制链接地址，然后在服务器中下载：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> wget -c https://mirrors.tuna.tsinghua.edu.cn/anaconda/miniconda/Miniconda3-py37_4.8.2-Linux-x86_64.sh</span></span><br></pre></td></tr></table></figure>
<p>3、安装刚刚下载的Miniconda：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> bash Miniconda3-py37_4.8.2-Linux-x86_64.sh</span></span><br></pre></td></tr></table></figure>
<p>根据提示按enter键或输入yes即可。</p>
<p>4、安装成功后，会在当前用户目录下生成一个miniconda3文件夹。</p>
<h2 id="安装pip"><a href="#安装pip" class="headerlink" title="安装pip"></a>安装pip</h2><p>在终端中输入以下命令安装pip：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> conda install pip</span></span><br></pre></td></tr></table></figure>
<h3 id="添加清华源"><a href="#添加清华源" class="headerlink" title="添加清华源"></a>添加清华源</h3><p>如果下载速度太慢，可以将conda默认的软件源更换为国内的清华源：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> conda config --<span class="built_in">set</span> show_channel_urls yes</span></span><br></pre></td></tr></table></figure>
<p>添加完成后可以使用<code>conda info</code>命令查看是否添加成功。</p>
<h1 id="安装并配置JupyterLab"><a href="#安装并配置JupyterLab" class="headerlink" title="安装并配置JupyterLab"></a>安装并配置JupyterLab</h1><p>准备工作完成后，就可以开始安装Jupyterlab。</p>
<h2 id="安装JupyterLab"><a href="#安装JupyterLab" class="headerlink" title="安装JupyterLab"></a>安装JupyterLab</h2><p>在终端中输入：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> pip install jupyterlab</span></span><br></pre></td></tr></table></figure>
<h2 id="远程访问配置"><a href="#远程访问配置" class="headerlink" title="远程访问配置"></a>远程访问配置</h2><p>在终端中打开ipython：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ipython</span></span><br><span class="line"></span><br><span class="line">In [1]: from notebook.auth import passwd</span><br><span class="line"></span><br><span class="line">In [2]: passwd()</span><br><span class="line">Enter password:		# 输入你要设置的密码</span><br><span class="line">Verify password:</span><br><span class="line">Out[2]: 'xxxxx...'</span><br></pre></td></tr></table></figure>
<p>这里输出的字符串要复制下来。</p>
<p>执行完上面的命令后，退出ipython，然后在终端中输入：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> jupyter lab --generate-config</span></span><br></pre></td></tr></table></figure>
<p>修改配置文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> vi .jupyter/jupyter_notebook_config.py</span></span><br></pre></td></tr></table></figure>
<p>更改内容如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 将ip设置为*，意味允许任何IP访问</span></span><br><span class="line">c.NotebookApp.ip = '*'</span><br><span class="line"><span class="meta">#</span><span class="bash"> 这里的密码就是上面生成的那一串</span></span><br><span class="line">c.NotebookApp.password = 'xxxxx...' </span><br><span class="line"><span class="meta">#</span><span class="bash"> 服务器上并没有浏览器可以供Jupyter打开 </span></span><br><span class="line">c.NotebookApp.open_browser = False </span><br><span class="line"><span class="meta">#</span><span class="bash"> 监听端口设置为8888或其他自己喜欢的端口 </span></span><br><span class="line">c.NotebookApp.port = 8888</span><br><span class="line"><span class="meta">#</span><span class="bash"> 允许远程访问 </span></span><br><span class="line">c.NotebookApp.allow_remote_access = True</span><br></pre></td></tr></table></figure>
<p>启动jupyter服务：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> jupyter lab --allow-root</span></span><br></pre></td></tr></table></figure>
<p>此时在浏览器搜索框中输入<code>你的服务器ip:你设置的端口</code>，然后在打开的页面中输入密码就可以进入jupyterlab：</p>
<p><img src="http://images.yingwai.top/picgo/jupyterinstallf2.png" alt=""></p>
<h2 id="后台运行JupyterLab程序"><a href="#后台运行JupyterLab程序" class="headerlink" title="后台运行JupyterLab程序"></a>后台运行JupyterLab程序</h2><p>JupyterLab启动后占用了一个终端窗口，可以用<code>nohup</code>命令使JupyterLab在后台运行，并且关闭当前终端也不会停止运行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> nohup jupyter lab &amp;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>nohup</code>命令</p>
<p>用途：Run COMMAND, ignoring hangup signals.</p>
<p>输出文件：程序的输出默认重定向到当前文件夹下的<code>nohup.out</code>文件中。也可以通过<code>nohup COMMAND &gt; FILE</code>命令的方式将输出文件重定位到指定的<code>FILE</code>文件中。如果要查看JupyterLab的日志文件，可以打开<code>nohup.out</code>文件进行查看。</p>
</li>
<li><p><code>&amp;</code>命令</p>
<p>作用：在后台运行程序</p>
</li>
</ul>
<h2 id="查看、关闭后台运行进程"><a href="#查看、关闭后台运行进程" class="headerlink" title="查看、关闭后台运行进程"></a>查看、关闭后台运行进程</h2><p><code>job -l</code>命令查看当前终端中后台运行的进程，如果关闭终端后不能显示，需要使用<code>ps</code>命令。</p>
<p><code>ps -aux | grep jupyter</code>查看运行的<code>jupyter</code>进程：</p>
<p><img src="http://images.yingwai.top/picgo/jupyterinstallf3.png" alt=""></p>
<p>用户名后面的数字就是JupyterLab的pid，使用<code>kill -9 pid</code>命令关闭运行中的JupyterLab。</p>
]]></content>
      <categories>
        <category>Env</category>
      </categories>
      <tags>
        <tag>Jupyter</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo博客搭建</title>
    <url>/2020/05/08/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h2 id="Hexo简介"><a href="#Hexo简介" class="headerlink" title="Hexo简介"></a>Hexo简介</h2><p>​    Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 <a href="http://daringfireball.net/projects/markdown/" target="_blank" rel="noopener">Markdown</a>（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p>
<a id="more"></a>
<h2 id="搭建流程（Windows）"><a href="#搭建流程（Windows）" class="headerlink" title="搭建流程（Windows）"></a>搭建流程（Windows）</h2><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><h4 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h4><p>到 <a href="https://git-scm.com/download" target="_blank" rel="noopener">https://git-scm.com/download</a> 选择对应的平台进行下载安装即可。</p>
<h4 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h4><p>到 <a href="https://nodejs.org/en/" target="_blank" rel="noopener">https://nodejs.org/en/</a> 下载安装即可。（Node.js 版本需不低于 8.10，建议使用 Node.js 10.0 及以上版本）</p>
<h3 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h3><p>安装需要借助npm包管理器，由于在国内这个镜像源很慢，因此可以利用npm安装cnpm淘宝镜像源，在命令行中输入：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm install -g cnpm --registry=https://registry.npm.taobao.org</span></span><br></pre></td></tr></table></figure>
<p>安装完后就可以使用cnpm安装hexo：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cnpm install -g hexo-cli</span></span><br></pre></td></tr></table></figure>
<p>可以用<code>hexo -v</code>来验证是否安装成功。</p>
<h3 id="正式搭建"><a href="#正式搭建" class="headerlink" title="正式搭建"></a>正式搭建</h3><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>建立一个名为 <em>Blog</em> 的文件夹，在命令行中进入这个文件夹，在命令行中输入：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> hexo init</span></span><br></pre></td></tr></table></figure>
<p>初始化完成后，在命令行中输入<code>hexo s</code>，此时在浏览器中输入<code>localhost:4000</code>就可以看到博客已经创建好了，并且默认创建了一篇文章。</p>
<p>确认过后，键盘按 <em>Ctrl + C</em> 即可停止服务。</p>
<h4 id="部署到Github"><a href="#部署到Github" class="headerlink" title="部署到Github"></a>部署到Github</h4><p>首先登陆到<a href="https://github.com/" target="_blank" rel="noopener">Github</a>，新建一个仓库，命名为 “<strong>你的Github昵称.github.io</strong>“。</p>
<p>然后需要安装一个git部署插件，在命令行中打开 <em>Blog</em> 目录，输入：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cnpm install --save hexo-deployer-git</span></span><br></pre></td></tr></table></figure>
<p>打开 <em>Blog</em> 目录下的站点配置文件，在文件最后的 <strong><em>repo</em></strong> 处输入刚刚创建的仓库的地址并在下方添加一行：</p>
<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="meta"># Deployment</span></span><br><span class="line"><span class="meta">## Docs: https:<span class="comment">//hexo.io/docs/deployment.html</span></span></span><br><span class="line"><span class="symbol">deploy:</span></span><br><span class="line"><span class="symbol">  type:</span> git</span><br><span class="line"><span class="symbol">  repo:</span> https:<span class="comment">//github.com/xxx/xxx.github.io.git</span></span><br><span class="line"><span class="symbol">  branch:</span> master	<span class="meta"># 指定分支，不填默认为master</span></span><br></pre></td></tr></table></figure>
<p>保存退出后，在命令行中输入：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> hexo d</span></span><br></pre></td></tr></table></figure>
<p>部署到远端，此时刷新一下自己的Github仓库页面，会发现多了很多文件。在浏览器中访问 <strong>xxx.github.io</strong>，就可以看到博客已经成功部署。</p>
<h2 id="使用Hexo"><a href="#使用Hexo" class="headerlink" title="使用Hexo"></a>使用Hexo</h2><h3 id="新建文章"><a href="#新建文章" class="headerlink" title="新建文章"></a>新建文章</h3><p>在命令行中输入：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> hexo n <span class="string">"文章标题"</span></span></span><br></pre></td></tr></table></figure>
<p>会在博客目录的<code>/source/_posts</code>目录下生成一个markdown文件，使用编辑器打开即可编辑这篇文章。</p>
<h3 id="发布文章"><a href="#发布文章" class="headerlink" title="发布文章"></a>发布文章</h3><p>在命令行中依次输入：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> hexo clean	<span class="comment"># 清理缓存文件和已生成的静态文件</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> hexo g	<span class="comment"># 生成静态文件</span></span></span><br></pre></td></tr></table></figure>
<p>再使用<code>hexo s</code>命令就可以在<code>localhost:4000</code>页面看到新生成的文章已经发布到了博客上面。</p>
]]></content>
      <categories>
        <category>Env</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>LaTeX常用符号表示方法</title>
    <url>/2020/04/26/LaTeX%E5%B8%B8%E7%94%A8%E7%AC%A6%E5%8F%B7%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>图片来源：<a href="https://blog.csdn.net/caiandyong/article/details/53351737" target="_blank" rel="noopener">https://blog.csdn.net/caiandyong/article/details/53351737</a></p>
<a id="more"></a>
<h1 id="希腊字母、数学构造、定界符、大型运算符以及标准函数名"><a href="#希腊字母、数学构造、定界符、大型运算符以及标准函数名" class="headerlink" title="希腊字母、数学构造、定界符、大型运算符以及标准函数名"></a>希腊字母、数学构造、定界符、大型运算符以及标准函数名</h1><p><img src="http://images.yingwai.top/picgo/latexf1.jpg" alt=""></p>
<h1 id="二元运算、关系符"><a href="#二元运算、关系符" class="headerlink" title="二元运算、关系符"></a>二元运算、关系符</h1><p><img src="http://images.yingwai.top/picgo/latexf2.jpg" alt=""></p>
<h1 id="箭头符号、各种符号以及数学模式重音符"><a href="#箭头符号、各种符号以及数学模式重音符" class="headerlink" title="箭头符号、各种符号以及数学模式重音符"></a>箭头符号、各种符号以及数学模式重音符</h1><p><img src="http://images.yingwai.top/picgo/latexf3.jpg" alt=""></p>
<h1 id="数列环境、其它风格的字体以及字体大小"><a href="#数列环境、其它风格的字体以及字体大小" class="headerlink" title="数列环境、其它风格的字体以及字体大小"></a>数列环境、其它风格的字体以及字体大小</h1><p><img src="http://images.yingwai.top/picgo/latexf4.jpg" alt=""></p>
]]></content>
      <categories>
        <category>Env</category>
      </categories>
      <tags>
        <tag>LaTeX</tag>
      </tags>
  </entry>
  <entry>
    <title>PyTorch入门60题</title>
    <url>/2020/04/15/PyTorch%E5%85%A5%E9%97%A860%E9%A2%98/</url>
    <content><![CDATA[<h2 id="张量"><a href="#张量" class="headerlink" title="张量"></a>张量</h2><p>导入pytorch包</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>创建一个空的5x3张量</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = torch.empty(<span class="number">5</span>, <span class="number">3</span>)</span><br><span class="line">print(x)</span><br></pre></td></tr></table></figure>
<p>创建一个随机初始化的5x3张量</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = torch.rand(<span class="number">5</span>, <span class="number">3</span>)</span><br><span class="line">print(x)</span><br></pre></td></tr></table></figure>
<p>创建一个5x3的0张量，类型为long</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = torch.zeros(<span class="number">5</span>, <span class="number">3</span>, dtype=torch.long)</span><br><span class="line">print(x)</span><br></pre></td></tr></table></figure>
<p>直接从数组创建张量</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = torch.tensor([<span class="number">5.5</span>, <span class="number">3</span>])</span><br><span class="line">print(x)</span><br></pre></td></tr></table></figure>
<p>创建一个5x3的单位张量，类型为double</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = torch.ones(<span class="number">5</span>, <span class="number">3</span>, dtype=torch.double)</span><br><span class="line">print(x)</span><br></pre></td></tr></table></figure>
<p>从已有的张量创建相同维度的新张量，并且重新定义类型为float</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = torch.randn_like(x, dtype=torch.float)</span><br><span class="line">print(x)</span><br></pre></td></tr></table></figure>
<p>打印一个张量的维度</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(x.size())</span><br></pre></td></tr></table></figure>
<p>将两个张量相加</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">y = torch.rand(<span class="number">5</span>, <span class="number">3</span>)</span><br><span class="line">print(x + y)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法二</span></span><br><span class="line"><span class="comment"># print(torch.add(x, y))</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法三</span></span><br><span class="line"><span class="comment"># result = torch.empty(5, 3)</span></span><br><span class="line"><span class="comment"># torch.add(x, y, out=result)</span></span><br><span class="line"><span class="comment"># print(result)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法四</span></span><br><span class="line"><span class="comment"># y.add_(x)</span></span><br><span class="line"><span class="comment"># print(y)</span></span><br></pre></td></tr></table></figure>
<p>取张量的第一列</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(x[:, <span class="number">1</span>])</span><br></pre></td></tr></table></figure>
<p>将一个4x4的张量resize成一个一维张量</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = torch.randn(<span class="number">4</span>, <span class="number">4</span>)</span><br><span class="line">y = x.view(<span class="number">16</span>)</span><br><span class="line">print(x.size(),y.size())</span><br></pre></td></tr></table></figure>
<p>将一个4x4的张量，resize成一个2x8的张量</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">y = x.view(<span class="number">2</span>, <span class="number">8</span>)</span><br><span class="line">print(x.size(),y.size())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法二</span></span><br><span class="line">z = x.view(<span class="number">-1</span>, <span class="number">8</span>) <span class="comment"># 确定一个维度，-1的维度会被自动计算</span></span><br><span class="line">print(x.size(),z.size())</span><br></pre></td></tr></table></figure>
<p>从张量中取出数字</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = torch.randn(<span class="number">1</span>)</span><br><span class="line">print(x)</span><br><span class="line">print(x.item())</span><br></pre></td></tr></table></figure>
<h3 id="Numpy的操作"><a href="#Numpy的操作" class="headerlink" title="Numpy的操作"></a>Numpy的操作</h3><p>将张量装换成numpy数组</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = torch.ones(<span class="number">5</span>)</span><br><span class="line">print(a)</span><br><span class="line"></span><br><span class="line">b = a.numpy()</span><br><span class="line">print(b)</span><br></pre></td></tr></table></figure>
<p>将张量+1，并观察上题中numpy数组的变化</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a.add_(<span class="number">1</span>)</span><br><span class="line">print(a)</span><br><span class="line">print(b)</span><br></pre></td></tr></table></figure>
<p>从numpy数组创建张量</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a = np.ones(<span class="number">5</span>)</span><br><span class="line">b = torch.from_numpy(a)</span><br><span class="line">print(a)</span><br><span class="line">print(b)</span><br></pre></td></tr></table></figure>
<p>将numpy数组+1并观察上题中张量的变化</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.add(a, <span class="number">1</span>, out=a)</span><br><span class="line">print(a)</span><br><span class="line">print(b)</span><br></pre></td></tr></table></figure>
<h2 id="自动微分"><a href="#自动微分" class="headerlink" title="自动微分"></a>自动微分</h2><h3 id="张量的自动微分"><a href="#张量的自动微分" class="headerlink" title="张量的自动微分"></a>张量的自动微分</h3><p>新建一个张量，并设置<code>requires_grad=True</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = torch.ones(<span class="number">2</span>, <span class="number">2</span>, requires_grad=<span class="literal">True</span>)</span><br><span class="line">print(x)</span><br></pre></td></tr></table></figure>
<p>对张量进行任意操作（y = x + 2）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">y = x + <span class="number">2</span></span><br><span class="line">print(y)</span><br><span class="line">print(y.grad_fn) <span class="comment"># y就多了一个AddBackward</span></span><br></pre></td></tr></table></figure>
<p>再对y进行任意操作</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">z = y * y * <span class="number">3</span></span><br><span class="line">out = z.mean()</span><br><span class="line"></span><br><span class="line">print(z) <span class="comment"># z多了MulBackward</span></span><br><span class="line">print(out) <span class="comment"># out多了MeanBackward</span></span><br></pre></td></tr></table></figure>
<h3 id="梯度"><a href="#梯度" class="headerlink" title="梯度"></a>梯度</h3><p>对out进行反向传播</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">out.backward()</span><br></pre></td></tr></table></figure>
<p>打印梯度d(out)/dx</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(x.grad) <span class="comment">#out=0.25*Σ3(x+2)^2</span></span><br></pre></td></tr></table></figure>
<p>创建一个结果为矢量的计算过程（y=x*2^n）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = torch.randn(<span class="number">3</span>, requires_grad=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">y = x * <span class="number">2</span></span><br><span class="line"><span class="keyword">while</span> y.data.norm() &lt; <span class="number">1000</span>:</span><br><span class="line">    y = y * <span class="number">2</span></span><br><span class="line"></span><br><span class="line">print(y)</span><br></pre></td></tr></table></figure>
<p>计算<code>v = [0.``1, 1.0, 0.0001]</code>处的梯度</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">v = torch.tensor([<span class="number">0.1</span>, <span class="number">1.0</span>, <span class="number">0.0001</span>], dtype=torch.float)</span><br><span class="line">y.backward(v)</span><br><span class="line"></span><br><span class="line">print(x.grad)</span><br></pre></td></tr></table></figure>
<p>关闭梯度的功能</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(x.requires_grad)</span><br><span class="line">print((x ** <span class="number">2</span>).requires_grad)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> torch.no_grad():</span><br><span class="line">    print((x ** <span class="number">2</span>).requires_grad)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 方法二</span></span><br><span class="line"><span class="comment"># print(x.requires_grad)</span></span><br><span class="line"><span class="comment"># y = x.detach()</span></span><br><span class="line"><span class="comment"># print(y.requires_grad)</span></span><br><span class="line"><span class="comment"># print(x.eq(y).all())</span></span><br></pre></td></tr></table></figure>
<h2 id="神经网络"><a href="#神经网络" class="headerlink" title="神经网络"></a>神经网络</h2><p>pytorch实现LeNet5，结构如下所示</p>
<p><img src="https://img-blog.csdn.net/20171119174011391?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjg5NzM3NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Net</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super(Net, self).__init__()</span><br><span class="line">        <span class="comment"># 26.定义①的卷积层，输入为32x32的图像，卷积核大小5x5卷积核种类6</span></span><br><span class="line">        self.conv1 = nn.Conv2d(<span class="number">3</span>, <span class="number">6</span>, <span class="number">5</span>)</span><br><span class="line">        <span class="comment"># 27.定义③的卷积层，输入为前一层6个特征，卷积核大小5x5，卷积核种类16</span></span><br><span class="line">        self.conv2 = nn.Conv2d(<span class="number">6</span>, <span class="number">16</span>, <span class="number">5</span>)</span><br><span class="line">        <span class="comment"># 28.定义⑤的全链接层，输入为16*5*5，输出为120</span></span><br><span class="line">        self.fc1 = nn.Linear(<span class="number">16</span> * <span class="number">5</span> * <span class="number">5</span>, <span class="number">120</span>)  <span class="comment"># 6*6 from image dimension</span></span><br><span class="line">        <span class="comment"># 29.定义⑥的全连接层，输入为120，输出为84</span></span><br><span class="line">        self.fc2 = nn.Linear(<span class="number">120</span>, <span class="number">84</span>)</span><br><span class="line">        <span class="comment"># 30.定义⑥的全连接层，输入为84，输出为10</span></span><br><span class="line">        self.fc3 = nn.Linear(<span class="number">84</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="comment"># 31.完成input-S2，先卷积+relu，再2x2下采样</span></span><br><span class="line">        x = F.max_pool2d(F.relu(self.conv1(x)), (<span class="number">2</span>, <span class="number">2</span>))</span><br><span class="line">        <span class="comment"># 32.完成S2-S4，先卷积+relu，再2x2下采样</span></span><br><span class="line">        x = F.max_pool2d(F.relu(self.conv2(x)), <span class="number">2</span>) <span class="comment">#卷积核方形时，可以只写一个维度</span></span><br><span class="line">        <span class="comment"># 33.将特征向量扁平成列向量</span></span><br><span class="line">        x = x.view(<span class="number">-1</span>, <span class="number">16</span> * <span class="number">5</span> * <span class="number">5</span>)</span><br><span class="line">        <span class="comment"># 34.使用fc1+relu</span></span><br><span class="line">        x = F.relu(self.fc1(x))</span><br><span class="line">        <span class="comment"># 35.使用fc2+relu</span></span><br><span class="line">        x = F.relu(self.fc2(x))</span><br><span class="line">        <span class="comment"># 36.使用fc3</span></span><br><span class="line">        x = self.fc3(x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">net = Net()</span><br><span class="line">print(net)</span><br></pre></td></tr></table></figure>
<p>打印网络的参数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">params = list(net.parameters())</span><br><span class="line"><span class="comment"># print(params)</span></span><br><span class="line">print(len(params))</span><br></pre></td></tr></table></figure>
<p>打印某一层参数的形状</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(params[<span class="number">0</span>].size())</span><br></pre></td></tr></table></figure>
<p>随机输入一个向量，查看前向传播输出</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">input = torch.randn(<span class="number">1</span>, <span class="number">1</span>, <span class="number">32</span>, <span class="number">32</span>)</span><br><span class="line">out = net(input)</span><br><span class="line">print(out)</span><br></pre></td></tr></table></figure>
<p>将梯度初始化</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">net.zero_grad()</span><br></pre></td></tr></table></figure>
<p>随机一个梯度进行反向传播</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">out.backward(torch.randn(<span class="number">1</span>, <span class="number">10</span>))</span><br></pre></td></tr></table></figure>
<h3 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h3><p>用自带的MSELoss()定义损失函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">criterion = nn.MSELoss()</span><br></pre></td></tr></table></figure>
<p>随机一个真值，并用随机的输入计算损失</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">target = torch.randn(<span class="number">10</span>)  <span class="comment"># 随机真值</span></span><br><span class="line">target = target.view(<span class="number">1</span>, <span class="number">-1</span>)  <span class="comment"># 变成列向量</span></span><br><span class="line"></span><br><span class="line">output = net(input)  <span class="comment"># 用随机输入计算输出</span></span><br><span class="line"></span><br><span class="line">loss = criterion(output, target)  <span class="comment"># 计算损失</span></span><br><span class="line">print(loss)</span><br></pre></td></tr></table></figure>
<p>将梯度初始化，计算上一步中loss的反向传播</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">net.zero_grad()</span><br><span class="line"></span><br><span class="line">print(<span class="string">'conv1.bias.grad before backward'</span>)</span><br><span class="line">print(net.conv1.bias.grad)</span><br></pre></td></tr></table></figure>
<p>计算43中loss的反向传播</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">loss.backward()</span><br><span class="line"></span><br><span class="line">print(<span class="string">'conv1.bias.grad after backward'</span>)</span><br><span class="line">print(net.conv1.bias.grad)</span><br></pre></td></tr></table></figure>
<h3 id="更新权重"><a href="#更新权重" class="headerlink" title="更新权重"></a>更新权重</h3><p>定义SGD优化器算法，学习率设置为0.01</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch.optim <span class="keyword">as</span> optim</span><br><span class="line">optimizer = optim.SGD(net.parameters(), lr=<span class="number">0.01</span>)</span><br></pre></td></tr></table></figure>
<p>使用优化器更新权重</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">optimizer.zero_grad()</span><br><span class="line">output = net(input)</span><br><span class="line">loss = criterion(output, target)</span><br><span class="line">loss.backward()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新权重</span></span><br><span class="line">optimizer.step()</span><br></pre></td></tr></table></figure>
<h2 id="训练一个分类器"><a href="#训练一个分类器" class="headerlink" title="训练一个分类器"></a>训练一个分类器</h2><h3 id="读取CIFAR10数据，做标准化"><a href="#读取CIFAR10数据，做标准化" class="headerlink" title="读取CIFAR10数据，做标准化"></a>读取CIFAR10数据，做标准化</h3><p>构造一个transform，将三通道(0,1)区间的数据转换成(-1,1)的数据</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torchvision</span><br><span class="line"><span class="keyword">import</span> torchvision.transforms <span class="keyword">as</span> transforms</span><br><span class="line"></span><br><span class="line">transform = transforms.Compose(</span><br><span class="line">    [transforms.ToTensor(),</span><br><span class="line">     transforms.Normalize((<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>), (<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>))])</span><br></pre></td></tr></table></figure>
<p>读取数据集</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">trainset = cifar(root = <span class="string">'./input/cifar10'</span>, segmentation=<span class="string">'train'</span>, transforms=transform)</span><br><span class="line">testset = cifar(root = <span class="string">'./input/cifar10'</span>, segmentation=<span class="string">'test'</span>, transforms=transform)</span><br><span class="line">trainloader = torch.utils.data.DataLoader(trainset, batch_size=batch_size,shuffle=<span class="literal">True</span>, num_workers=<span class="number">2</span>)</span><br><span class="line">testloader = torch.utils.data.DataLoader(testset, batch_size=batch_size,shuffle=<span class="literal">False</span>, num_workers=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">classes = (<span class="string">'plane'</span>, <span class="string">'car'</span>, <span class="string">'bird'</span>, <span class="string">'cat'</span>,</span><br><span class="line">           <span class="string">'deer'</span>, <span class="string">'dog'</span>, <span class="string">'frog'</span>, <span class="string">'horse'</span>, <span class="string">'ship'</span>, <span class="string">'truck'</span>)</span><br></pre></td></tr></table></figure>
<h3 id="建立网络"><a href="#建立网络" class="headerlink" title="建立网络"></a>建立网络</h3><p>这部分沿用前面的网络</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">net2 = Net()</span><br></pre></td></tr></table></figure>
<h3 id="定义损失函数和优化器"><a href="#定义损失函数和优化器" class="headerlink" title="定义损失函数和优化器"></a>定义损失函数和优化器</h3><p>定义交叉熵损失函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">criterion2 = nn.CrossEntropyLoss()</span><br></pre></td></tr></table></figure>
<p>定义SGD优化器算法，学习率设置为0.001，<code>momentum=0.9</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">optimizer2 = optim.SGD(net2.parameters(), lr=<span class="number">0.001</span>, momentum=<span class="number">0.9</span>)</span><br></pre></td></tr></table></figure>
<h3 id="训练网络"><a href="#训练网络" class="headerlink" title="训练网络"></a>训练网络</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> range(<span class="number">2</span>):</span><br><span class="line"></span><br><span class="line">    running_loss = <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">for</span> i, data <span class="keyword">in</span> enumerate(trainloader, <span class="number">0</span>):</span><br><span class="line">        <span class="comment"># 获取X,y对</span></span><br><span class="line">        inputs, labels = data</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 51.初始化梯度</span></span><br><span class="line">        optimizer2.zero_grad()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 52.前馈</span></span><br><span class="line">        outputs = net2(inputs)</span><br><span class="line">        <span class="comment"># 53.计算损失</span></span><br><span class="line">        loss = criterion2(outputs, labels)</span><br><span class="line">        <span class="comment"># 54.计算梯度</span></span><br><span class="line">        loss.backward()</span><br><span class="line">        <span class="comment"># 55.更新权值</span></span><br><span class="line">        optimizer2.step()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 每2000个数据打印平均代价函数值</span></span><br><span class="line">        running_loss += loss.item()</span><br><span class="line">        <span class="keyword">if</span> i % <span class="number">2000</span> == <span class="number">1999</span>:    <span class="comment"># print every 2000 mini-batches</span></span><br><span class="line">            print(<span class="string">'[%d, %5d] loss: %.3f'</span> %</span><br><span class="line">                  (epoch + <span class="number">1</span>, i + <span class="number">1</span>, running_loss / <span class="number">2000</span>))</span><br><span class="line">            running_loss = <span class="number">0.0</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">'Finished Training'</span>)</span><br></pre></td></tr></table></figure>
<h3 id="使用模型预测"><a href="#使用模型预测" class="headerlink" title="使用模型预测"></a>使用模型预测</h3><p>取一些数据</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dataiter = iter(testloader)</span><br><span class="line">images, labels = dataiter.next()</span><br><span class="line"></span><br><span class="line"><span class="comment"># print images</span></span><br><span class="line">imshow(torchvision.utils.make_grid(images))</span><br><span class="line">print(<span class="string">'GroundTruth: '</span>, <span class="string">' '</span>.join(<span class="string">'%5s'</span> % classes[labels[j]] <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">4</span>)))</span><br></pre></td></tr></table></figure>
<p>使用模型预测</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">outputs = net2(images)</span><br><span class="line"></span><br><span class="line">_, predicted = torch.max(outputs, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'Predicted: '</span>, <span class="string">' '</span>.join(<span class="string">'%5s'</span> % classes[predicted[j]]</span><br><span class="line">                              <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">4</span>)))</span><br></pre></td></tr></table></figure>
<p>在测试集上进行打分</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">correct = <span class="number">0</span></span><br><span class="line">total = <span class="number">0</span></span><br><span class="line"><span class="keyword">with</span> torch.no_grad():</span><br><span class="line">    <span class="keyword">for</span> data <span class="keyword">in</span> testloader:</span><br><span class="line">        images, labels = data</span><br><span class="line">        outputs = net2(images)</span><br><span class="line">        _, predicted = torch.max(outputs.data, <span class="number">1</span>)</span><br><span class="line">        total += labels.size(<span class="number">0</span>)</span><br><span class="line">        correct += (predicted == labels).sum().item()</span><br><span class="line"></span><br><span class="line">print(<span class="string">'Accuracy of the network on the 10000 test images: %d %%'</span> % (</span><br><span class="line">    <span class="number">100</span> * correct / total))</span><br></pre></td></tr></table></figure>
<h3 id="存取模型"><a href="#存取模型" class="headerlink" title="存取模型"></a>存取模型</h3><p>保存训练好的模型</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">PATH = <span class="string">'./cifar_net.pth'</span></span><br><span class="line">torch.save(net.state_dict(), PATH)</span><br></pre></td></tr></table></figure>
<p>读取保存的模型</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pretrained_net = torch.load(PATH)</span><br></pre></td></tr></table></figure>
<p>加载模型</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">net3 = Net()</span><br><span class="line">net3.load_state_dict(pretrained_net)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>PyTorch</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>不经意传输（Oblivious Transfer）</title>
    <url>/2020/04/25/%E4%B8%8D%E7%BB%8F%E6%84%8F%E4%BC%A0%E8%BE%93%EF%BC%88Oblivious-Transfer%EF%BC%89/</url>
    <content><![CDATA[<p><em>设S有一个秘密，想以1/2的概率传递给R，即B有50%的机会收到这个秘密，另外50%的机会什么也没有收到，协议执行完后，B知道自己是否收到了这个秘密，但S却不知道R是否收到了这个秘密。这种协议就称为不经意传输协议。</em></p>
<a id="more"></a>
<p>​        例如A是机密的出售者，S列举了很多问题，意欲出售各个问题的答案，R想买其中一个问题的答案，但又不想让A知道自己买的是哪个问题的答案。</p>
<h2 id="1-out-of-2-OT"><a href="#1-out-of-2-OT" class="headerlink" title="1-out-of-2 OT"></a>1-out-of-2 OT</h2><p>OT最早在1981年被 Michael O. Rabin提出，在Rabin的OT协议中，发送者S发送一个信息m给接收者R，接收者R以1/2的概率接受信息m。所以在协议交互的结束的时候，S并不知道R是否接受了消息。该方案是基于RSA加密体系构造的。</p>
<p>1985年S. Even, O. Goldreich, and A. Lempel提出了1-out-2 OT,在新的方案中S每次发送2个信息 $m_0$ 和 $m_1$，而R每次输入一个选择 $b$。当协议结束的时候，S无法获得关于 $b$ 的任何有价值的信息，而R只能获得 $m_b$ ，对于 $m_{1-b}$ ，R也一无所知。<br><img src="http://images.yingwai.top/picgo/OTf1.png" alt=""></p>
<h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><p>S要传送两条信息，不妨设为两个比特 $b_0$ 和 $b_1$，而R只能选择接受其中一个比特 $b_{\theta}$。协议要保证S和R的安全，即：</p>
<ul>
<li>S不能知道任何关于 $\theta$ 的信息；</li>
<li>R不能知道任何关于 $b_{1-\theta}$ 的信息。</li>
</ul>
<p>为了达成上面两点要求，构造如下协议：</p>
<ol>
<li><p>S选择好两个比特信息 $b_0$ 和 $b_1$；</p>
</li>
<li><p>S运行密钥生成算法（例如RSA）生成公私钥对（$sk,pk$）；</p>
</li>
<li><p>S保密私钥，同时S要生成两个随机数 $x_0$ 和 $x_1$，并将这两个随机数和公钥一并传送给R；</p>
</li>
<li><p>R选择 $\theta$，并生成一个数 $r$，R用S的公钥加密 $r$，并生成信息</p>
<p>​                                <script type="math/tex">v =x_{\theta}+E_{pk}(r)</script></p>
</li>
<li><p>S在接收到 $v$ 之后，进行如下计算：</p>
<p>​                                $r_{0}=D_{s k}\left(v-x_{0}\right)$<br>​                                $r_{1}=D_{s k}\left(v-x_{1}\right)$</p>
</li>
<li><p>S进行如下计算：</p>
<p>​                                $b_{0}^{\prime}=b_{0}+r_{0}$<br>​                                $b_{1}^{\prime}=b_{1}+r_{1}$</p>
<p>并将 $b’_0$ 和 $b’_1$ 传送给R；</p>
</li>
<li><p>接收到 $b’_0$ 和 $b’_1$ 后，R进行如下计算：</p>
<p>​                                $b_\theta = b’_\theta - r$</p>
</li>
</ol>
<h3 id="正确性"><a href="#正确性" class="headerlink" title="正确性"></a>正确性</h3><p>进行如下推导：</p>
<p>​                                $b_{\theta}^{\prime}-r=b_{\theta}+r_{\theta}-r=b_{\theta}+D_{s k}\left(v-x_{\theta}\right)-r$</p>
<p>而</p>
<p>​                        $D_{s k}(v-x_\theta)=D_{s k}\left(x_\theta+E_{p k}(r)-x_{\theta}\right)=D_{s k}\left(E_{p k}(r)\right)=r$</p>
<p>因此可得</p>
<p>​                                            $b’_\theta - r = b_\theta$</p>
<h3 id="对于S的安全性"><a href="#对于S的安全性" class="headerlink" title="对于S的安全性"></a>对于S的安全性</h3><p>对于S来说，它的安全性要求R不能推断出 $b_{1-\theta}$。R得到 $b’_\theta$ 和 $b’_{1-\theta}$ 之后，由协议可知R可以正确计算 $b’_\theta$ ，下面证明R不能计算出 $b_{1-\theta}$。</p>
<p>​                        $b_{1-\theta}^{\prime}-r=b_{1-\theta}+D_{s k}\left(v-x_{\theta}\right)-r$</p>
<p>而</p>
<p>​                    $D_{s k}\left(v-x_{\theta}\right)=D_{s k}\left(x_{1-\theta}+E_{p k}(r)-x_{\theta}\right) \neq r$</p>
<p>而且根据加密的特性，$D_{s k}\left(x_{1-\theta}+E_{p k}(r)-x_{\theta}\right)-r$ 与随机数是不可区分的，所以 $b’_{1-\theta}-r$ 与随机数是不可区分的。因此协议对S是安全的。</p>
<h3 id="对于R的安全性"><a href="#对于R的安全性" class="headerlink" title="对于R的安全性"></a>对于R的安全性</h3><p>R的安全性要求S不能获得关于 $\theta$ 任何有价值的信息。</p>
<p>因为 $r$ 是随机数，所以 $E_{pk}(r)$ 与随机数是不可区分的。因此 $v$ 与随机数是不可区分的，所以S不能从 $v$ 获得关于 $\theta$ 有价值的信息。</p>
]]></content>
      <categories>
        <category>Study</category>
      </categories>
      <tags>
        <tag>密码学</tag>
        <tag>MPC</tag>
      </tags>
  </entry>
  <entry>
    <title>解决Ubuntu deepin-wine微信字体乱码</title>
    <url>/2020/04/24/%E8%A7%A3%E5%86%B3Ubuntu-deepin-wine%E5%BE%AE%E4%BF%A1%E5%AD%97%E4%BD%93%E4%B9%B1%E7%A0%81/</url>
    <content><![CDATA[<h1 id="解决乱码-修改字体-微软雅黑"><a href="#解决乱码-修改字体-微软雅黑" class="headerlink" title="解决乱码+修改字体(微软雅黑)"></a>解决乱码+修改字体(微软雅黑)</h1><p>下载微软雅黑字体,msyh.ttc</p>
<a id="more"></a>
<h2 id="添加字体"><a href="#添加字体" class="headerlink" title="添加字体"></a>添加字体</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cp msyh.ttc ~/.deepinwine/Deepin-WeChat/drive_c/windows/Fonts</span></span><br></pre></td></tr></table></figure>
<h2 id="修改系统注册表"><a href="#修改系统注册表" class="headerlink" title="修改系统注册表"></a>修改系统注册表</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gedit ~/.deepinwine/Deepin-WeChat/system.reg</span></span><br></pre></td></tr></table></figure>
<p>修改以下两行</p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line"><span class="string">"MS Shell Dlg"</span>=<span class="string">"msyh"</span></span><br><span class="line"><span class="string">"MS Shell Dlg 2"</span>=<span class="string">"msyh"</span></span><br></pre></td></tr></table></figure>
<h2 id="字体注册"><a href="#字体注册" class="headerlink" title="字体注册"></a>字体注册</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gedit msyh_config.reg</span></span><br></pre></td></tr></table></figure>
<p>内容添加</p>
<figure class="highlight moonscript"><table><tr><td class="code"><pre><span class="line">REGEDIT4</span><br><span class="line">[HKEY_LOCAL_MACHINE\Software\Microsoft\Windows NT\CurrentVersion\FontLink\SystemLink]</span><br><span class="line"><span class="string">"Lucida Sans Unicode"</span>=<span class="string">"msyh.ttc"</span></span><br><span class="line"><span class="string">"Microsoft Sans Serif"</span>=<span class="string">"msyh.ttc"</span></span><br><span class="line"><span class="string">"MS Sans Serif"</span>=<span class="string">"msyh.ttc"</span></span><br><span class="line"><span class="string">"Tahoma"</span>=<span class="string">"msyh.ttc"</span></span><br><span class="line"><span class="string">"Tahoma Bold"</span>=<span class="string">"msyhbd.ttc"</span></span><br><span class="line"><span class="string">"msyh"</span>=<span class="string">"msyh.ttc"</span></span><br><span class="line"><span class="string">"Arial"</span>=<span class="string">"msyh.ttc"</span></span><br><span class="line"><span class="string">"Arial Black"</span>=<span class="string">"msyh.ttc"</span></span><br><span class="line">#注册</span><br><span class="line">WINEPREFIX=~/.deepinwine/Deepin-WeChat deepin-wine regedit msyh_config.reg</span><br></pre></td></tr></table></figure>
<h2 id="Reboot"><a href="#Reboot" class="headerlink" title="Reboot"></a>Reboot</h2>]]></content>
      <categories>
        <category>Env</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>论文笔记 ASTRA: High Throughput 3PC over Rings with Application to Secure Prediction</title>
    <url>/2020/04/20/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0-ASTRA-High-Throughput-3PC-over-Rings-with-Application-to-Secure-Prediction/</url>
    <content><![CDATA[<p><em>Harsh Chaudhari, Ashish Choudhury, Arpita Patra, Ajith Suresh</em></p>
<p>ACM CCSW 2019</p>
<p><a href="https://eprint.iacr.org/2019/429" target="_blank" rel="noopener">https://eprint.iacr.org/2019/429</a></p>
<p><a href="https://dl.acm.org/doi/10.1145/3338466.3358922" target="_blank" rel="noopener">https://dl.acm.org/doi/10.1145/3338466.3358922</a></p>
<a id="more"></a>
<p><img src="http://images.yingwai.top/picgo/ASTRA.jpg" alt=""></p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>安全计算的具体效率一直是近年来许多工作关注的焦点。在本论文中，作者提出了一种具体有效的协议，用于模 $2^l$ 整数环上的安全三方计算（3PC），该协议具有半诚实模型和恶意模型上的安全性。由于环上的计算模拟了现实系统体系结构上的计算，所以环上的安全计算近来获得了发展势头。</p>
<p>​        在离线-在线模式中，本文的结构具体地呈现了最有效的在线阶段。在半诚实的设置下，本文的协议在在线阶段每个乘法门需要2个环元素的通信。在恶意设置下，本文的协议在在线阶段每个乘法门需要4个元素的通信，比最先进的协议需要的5个元素少。使用选择性中止和公平这两个安全概念来实现的公平恶意协议，与仅针对输出门的中止安全性的恶意协议相比，涉及的通信稍微多一些。</p>
<p>​        作者将本文的技术从3PC应用到安全的服务器辅助机器学习（ML）推理机制中，用于一系列预测函数——线性回归、线性SVM回归、Logistic回归和线性SVM分类。本文的设置考虑了拥有训练好的模型参数的模型所有者和查询的客户，后者愿意根据前者的模型参数来学习他查询的预测。输入和计算外包给一组三个非合谋的服务器。本文的构造既迎合了半诚实的世界，也迎合了恶意的世界，比现有的构造表现得更好。</p>
<h3 id="贡献"><a href="#贡献" class="headerlink" title="贡献"></a>贡献</h3><ul>
<li><p>作者遵循离线-在线模式，提出了在环 $\mathbb{Z}_{2^l}$（包括布尔环 $\mathbb{Z}_{2^1}$）上的3PC构造，具有最有效的在线阶段。</p>
<p>虽然重点放在在现阶段，但离线阶段的的成本也有注意并保持在可控范围内。</p>
</li>
<li><p>作者给出了一系列满足半诚实安全和恶意安全的构造。</p>
<p>将技术应用于外包环境中的一系列预测函数的安全预测，并构建了一些容忍半诚实和恶意对手的结构。</p>
</li>
</ul>
<p>本文所有的构建都流露出的一个共同特征：在线阶段不到三对参与者之间需要进行功能依赖的通信，从而产生更好的在线性能。</p>
<h2 id="设定"><a href="#设定" class="headerlink" title="设定"></a>设定</h2><p>本文考虑一组三方 $\mathcal{P}=\left\{P_0,P_1,P_2\right\}$，它们在同步网络中通过成对的私有和可信信道连接。要计算的函数 $f$ 被表示为环 $\mathbb{Z}_{2^l}$ 上的电路 ckt，该环由2输入加法和乘法门组成。假设 ckt 的拓扑是公知的。术语 D​ 表示 ckt 的乘法深度，而 I、O、A、M 分别表示 ckt 中的输入线、输出线、加法门和乘法门的数目。本文使用符号 $w_x$ 来表示导线 $w$，其中值 $x$ 流经它。本文使用 $g=(w_x,w_y,w_z)$ 来表示 ckt 中具有左输入线 $w_x$、右输入线 $w_y$ 和输出线 $w_z$ 的门。在本文的协议中，将 $\mathcal{P}$ 划分为互不相交的集合 $\left\{P_0\right\}$ 和 $\left\{P_1,P_2\right\}$，其中 $P_0$ 在离线阶段充当“分配器”进行“预处理”，在线阶段“评估者” $P_1$、$P_2$ 用它来评估 ckt。本文使用上标“$s$”和“$m$”分别区分半诚实和恶意设置中的协议。布尔环 $\mathbb{Z}_{2^1}$ 上的协议可以通过将算术加法$(+)$和乘法$(\times)$分别替换为异或$(\oplus)$和与$(\cdot)$来获得。</p>
<h3 id="共享密钥设置"><a href="#共享密钥设置" class="headerlink" title="共享密钥设置"></a>共享密钥设置</h3><p>为了保存双方之间的通信，使用为伪随机函数（PRF）$F$ 建立预共享随机密钥的一次性设置。在3PC设置[2，30，46]中的已知协议中已经使用了类似的设置。这里 $F:{\{0，1\}}^\kappa \times {\{0，1\}}^\kappa \to X$ 是安全的PRF，同域 $X$ 是 $\mathbb{Z}_{2^l}$。这组密钥是：</p>
<ul>
<li>每对参与方之间共享一个密钥— $k_{01}, k_{02}, k_{12}$，分别用于参与方$(P_0,P_1), (P_0,P_2), (P_1,P_2)$。</li>
<li>所有各方之间的一个共享密钥— $k_{\mathcal{p}}$。</li>
</ul>
<p>本文通过可以使用任何标准安全MPC协议实现的功能 $\mathcal{F}_{\rm setup}$ 来建立密钥设置模型。</p>
<h3 id="共享语义"><a href="#共享语义" class="headerlink" title="共享语义"></a>共享语义</h3><p>在本节中，将解释本工作中使用的秘密共享的两种变体。这两个变体都在算术（$\mathbb{Z}_{2^l}$）和布尔环（$\mathbb{Z}_{2^1}$）上运行。</p>
<p>$[\cdot]$-共享：如果 $P_1$ 和 $P_2$ 分别持有份额 $v_1$ 和 $v_2$，使得 $v=v_1+v_2$，则称值 $v$ 在$P_1,P_2$之间是 $[\cdot]$-共享的。用 $[\cdot]_{P_i}$ 表示 $P_i, i∈\{1,2\}$的 $[\cdot]$-份额。</p>
<p>$[\![\cdot]\!]$-共享：值 $v$ 在 $P_0, P_1, P_2$ 之间是$[\![\cdot]\!]$-共享的，如果</p>
<ul>
<li>存在值 $\lambda_v, m_v$ 使得 $v=m_v - \lambda_v$；</li>
<li>$P_0$ 持有 $\lambda_{v,1}$ 和 $\lambda_{v,2}$ 使得 $\lambda_{v} = \lambda_{v,1} + \lambda_{v,2}$；</li>
<li>$P_1$ 和 $P_2$ 分别持有 $(m_v, \lambda_{v,1})$ 和 $(m_v, \lambda_{v,1})$。</li>
</ul>
<p>本文将各方的$[\![\cdot]\!]$-共享表示为$[\![v]\!]_{P_0} = (\lambda_{v,1}, \lambda_{v,2}), [\![v]\!]_{P_1} = (m_v, \lambda_{v,1}) $和 $[\![v]\!]_{P_2} = (m_v, \lambda_{v,2})$。用$[\![v]\!] = (m_v, [\lambda_{v}])$表示 $v$ 的$[\![\cdot]\!]$-共享份额。</p>
<h3 id="秘密共享方案的线性"><a href="#秘密共享方案的线性" class="headerlink" title="秘密共享方案的线性"></a>秘密共享方案的线性</h3><p>给定 $x,y \in \mathbb{Z}_{2^l}$ 和公共常数 $c_1, c_2 \in \mathbb{Z}_{2^l}$的$[\cdot]$-共享，各方可以局部计算 $[c_1x+c_2y]$：</p>
<script type="math/tex; mode=display">[c_1x+c_2y]=(c_1x_1+c_2y_1, c_1x_2+c_2y_2)=c_1[x]+c_2[y]</script><p>很容易看出线性关系也扩展到$[\![\cdot]\!]$-共享。线性属性使各方能够<strong>本地</strong>执行与公共常量的加法和乘法等操作。</p>
<h2 id="3PC协议"><a href="#3PC协议" class="headerlink" title="3PC协议"></a>3PC协议</h2><h3 id="半诚实下的3PC"><a href="#半诚实下的3PC" class="headerlink" title="半诚实下的3PC"></a>半诚实下的3PC</h3><p>协议 $\prod ^{\rm s}_{\rm 3pc}$ 由三个步骤组成—输入共享、电路评估以及输出重构。所有阶段（重构输出除外）都分为离线和在线阶段，其中独立于实际输入的步骤可以在脱机阶段执行。</p>
<h4 id="输入共享"><a href="#输入共享" class="headerlink" title="输入共享"></a>输入共享</h4><p>在共享输入阶段，每一方都为自己的输入生成一个随机的$[\![\cdot]\!]$-共享。以下是初始共享协议 $\prod^{\rm s}_{\rm Sh}$：</p>
<hr>
<p><strong>Offline:</strong></p>
<ul>
<li>If $P_i = P_0$, parties $P_0, P_j$ for $j \in \{1, 2\}$ locally sample a random $\lambda_{x,j} \in \mathbb{Z}_{2^l}$. Moreover, $P_i$ sets $[\![x]\!]_{P_i} = (\lambda_{x,1}, \lambda_{x,2})$.</li>
<li>If $P_i = P_1$, parties $P_0, P_1$ sample a random $\lambda_{x,1} \in \mathbb{Z}_{2^l}$ while all the parties in $\mathcal{P}$ sample a random $\lambda_{x,2} \in \mathbb{Z}_{2^l}$.</li>
<li>If $P_i = P_2$, parties $P_0, P_2$ sample a random $\lambda_{x,2} \in \mathbb{Z}_{2^l}$ while all the parties in $\mathcal{P}$ sample a random $\lambda_{x,1} \in \mathbb{Z}_{2^l}$.</li>
</ul>
<p><strong>Online:</strong></p>
<p>​        $P_i$ computes $\lambda_x = \lambda_{x,1} + \lambda_{x,2}$ and sends $m_x = x + \lambda_x$ to every $P_j$ for $j \in \{1,2\}$ who then sets $[\![x]\!]_{P_j} = (m_x, \lambda_{x,j})$.</p>
<hr>
<p>在离线阶段根据输入方的序号，使用不同的初始化手段，生成了 $P_0$ 的份额 $[\![x]\!]_{P_0}=(\lambda_{x,1}, \lambda_{x,2})$，而不用任何交互（因为随机数都是使用服务器两两之间的公共随机源生成的，可以理解为编程语言中把同样的随机种子输入到random函数——只要随机种子一样生成的随机数序列就一样）。</p>
<h4 id="电路评估"><a href="#电路评估" class="headerlink" title="电路评估"></a>电路评估</h4><p>在电路评估阶段，各方以$[\![\cdot]\!]$-共享的方式评估 ckt。以拓扑顺序评估 ckt 中的每个门 $g$：给定 $g$ 的输入，各方为 $g$ 的输出生成$[\![\cdot]\!]$-共享。</p>
<h5 id="加法"><a href="#加法" class="headerlink" title="加法"></a>加法</h5><p>如果 $g$ 是加法门 $(w_x,w_y,w_z)$，可以利用$[\![\cdot]\!]$-共享的线性在本地完成。以下是加法协议 $\prod_{\rm Add} (w_x, w_y, w_z)$：</p>
<hr>
<p><strong>Offline:</strong></p>
<p>​        $P_0, P_1$ set $\lambda_{z,1} = \lambda_{x,1} + \lambda_{y,1}$, while $P_0, P_2$ set $\lambda_{z,2} = \lambda_{x,2} + \lambda_{y,2}$.</p>
<p><strong>Online:</strong></p>
<p>​        $P_1$ and $P_2$ set $m_z = m_x + m_y$.</p>
<hr>
<p>这里的加法协议感觉在线阶段完全可以在本地完成，可以不需要在线阶段。</p>
<h5 id="乘法"><a href="#乘法" class="headerlink" title="乘法"></a>乘法</h5><p>如果 $g=(w_x,w_y,w_z)$ 是乘法门，则运行以下乘法协议 $\prod ^{\rm s}_{\rm Mul}$：</p>
<hr>
<p><strong>Offline:</strong></p>
<ul>
<li>$P_0$ and $P_1$ locally sample random $\lambda_{z,1}, \gamma_{xy, 1} \in \mathbb{Z}_{2^l}$, while $P_0$ and $P_2$ locally sample random $\lambda_{z,2} \in \mathbb{Z}_{2^l}$.</li>
<li>$P_0$ computes $\gamma_{xy} = \lambda_x \lambda_y$ and sends $\gamma_{xy,2} = \gamma_{xy} - \gamma_{xy,1}$ to $P_2$.</li>
</ul>
<p><strong>Online:</strong></p>
<ul>
<li>$P_i$ for $i \in \{1,2\}$ locally computes $[m_z]_{P_i} = (i-1)m_xm_y - m_x[\lambda_y]_{P_i} - m_y[\lambda_x]_{P_i} + [\lambda_z]_{P_i} + [\gamma_{xy}]_{P_i}$.</li>
<li>$P_1, P_2$ mutually exchange their shares and reconstruct $m_z$.</li>
</ul>
<hr>
<p>将上面的公式相加一下即可验证其正确性。</p>
<h4 id="输出重构"><a href="#输出重构" class="headerlink" title="输出重构"></a>输出重构</h4><p>在输出重构阶段，各方重构$[\![\cdot]\!]$-共享电路输出。为了重构 $[\![y]\!]$，可以观察到每个 $P_i$ 缺失的份额都在另外两方手里。因此另外两方的其中一方将缺失的份额发送给 $P_i$ 后，通过计算 $y = m_y - \lambda_{y,1} - \lambda_{y,2}$ 即可重构输出 $y$，将其称为重构协议 $\prod ^{\rm s}_{\rm Rec}([\![y]\!], \mathcal{P})$。</p>
<p>把上面三个阶段总结起来，有以下的协议 $\prod ^{\rm s}_{\rm 3pc}$：</p>
<hr>
<p><strong>Pre-processing (Offline Phase):</strong></p>
<ul>
<li><em>Input wires:</em> For $j = 1, …,l$, corresponding to the circuit-input $x_j$, parties execute the offline steps of the instance $\prod ^{\rm s}_{\rm Sh}(P_i, x_j)$.</li>
<li>For each gate $g$ in the topological order, execute offline steps of the instance $\prod ^{\rm s}_{\rm Mul}(w_{xj}, w_{yj}, w_{zj})$ if $g$ is the $j$th multiplication gate where $j \in \{1,…,\rm M\}$ or respectively offline steps of the instance $\prod _{\rm Add}(w_{xj}, w_{yj}, w_{zj})$ if $g$ is the $j$th addition gate where $j \in \{1,…,\rm A\}$.</li>
</ul>
<p><strong>Circuit Evaluation (Online Phase):</strong></p>
<ul>
<li><em>Sharing Circuit-input Values:</em> For $j = 1, …,l$, corresponding to the circuit-input $x_j$, parties execute the online steps of the instance $\prod ^{\rm s}_{\rm Sh}(P_i, x_j)$, where $P_i$ is the party designated to provide $x_j$.</li>
<li><em>Gate Evaluation:</em> For each gate in $g$ in ckt in the topological order, $P_1, P_2$ execute the online steps of the instance $\prod ^{\rm s}_{\rm Mul}(w_{xj},w_{yj},w_{zj})$ if $g$ is the $j$th multiplication gate where $j \in \{1,…,\rm M\}$ or respectively offline steps of the instance $\prod _{\rm Add}(w_{xj}, w_{yj}, w_{zj})$ if $g$ is the $j$th addition gate where $j \in \{1,…,\rm A\}$.</li>
<li><em>Output Reconstruction:</em> Let $[\![y_1]\!],…,[\![y_\rm O]\!]$ be the shared function outputs. The parties in $\mathcal{P}$ reconstruct $y_j$ for $j = 1,…,\rm O$ by executing $\prod ^{\rm s}_{\rm Rec}([\![y_j]\!], \mathcal{P})$.</li>
</ul>
<hr>
<h3 id="恶意下的3PC"><a href="#恶意下的3PC" class="headerlink" title="恶意下的3PC"></a>恶意下的3PC</h3><p>跟半诚实设置下的一样，恶意设置下的3PC协议 $\prod ^{\rm m}_{\rm 3pc}$ 也由输入共享、电路评估和输出重构三个部分组成。</p>
<h4 id="输入共享和输出重构"><a href="#输入共享和输出重构" class="headerlink" title="输入共享和输出重构"></a>输入共享和输出重构</h4><p>在恶意的设置下，要保证服务器之间的共享份额是一致的。在 $\prod ^{\rm s}_{\rm Sh}$ 中，$\lambda$ 的共享是一致的，因为它不需要交互就可以生成。但如果一个腐败的 $P_0$ 拥有 $x$ 并且想制造一个不一致的 $[\![x]\!]$-共享，它可以分别发送两个不一样的 $m_x$ 给 $P_1$ 和 $P_2$。为了检查这种情况的发生，$P_1$ 和 $P_2$ 交换 $H(m_x)$ 并在不一致的时候中止。</p>
<p>令 $[\![y]\!]$ 为一个待重构的一致的共享，$[\![y]\!]_{P_0} = (\lambda_{y,1}, \lambda_{y,2})$、$[\![y]\!]_{P_1} = (m’_{y}, \lambda_{y,1})$ 和 $[\![y]\!]_{P_2} = (m’’_{y}, \lambda_{y,2})$ 分别为三个服务器的份额。协议 $\prod ^{\rm m}_{\rm Rec}([\![y]\!], \mathcal{P})$ 允许每一个诚实方输出 $y$ 或 $\perp$：</p>
<hr>
<p><strong>Online:</strong></p>
<ul>
<li>$P_0$ and $P_2$ send $\lambda_{y,2}$ and $H(\lambda’_{y,2})$ respectively to $P_1$.</li>
<li>$P_0$ and $P_1$ send $\lambda_{y,1}$ and $H(\lambda’_{y,1})$ respectively to $P_2$.</li>
<li>$P_1$ and $P_1$ send $m’_{y}$ and $H(m’_{y})$ respectively to $P_0$.</li>
</ul>
<p>$P_i$ for $i \in \{0,1,2\}$ abort if the received values mismatch. Else $P_i$ sets $y = m_y - \lambda_{y,1} - \lambda_{y,2}$.</p>
<hr>
<p>检查的过程中，其中一方发送哈希值可以提高效率。</p>
<h4 id="电路评估-1"><a href="#电路评估-1" class="headerlink" title="电路评估"></a>电路评估</h4><p>在恶意设置下加法协议 $\prod _{\rm Add}$ 同样是安全的，因为它只涉及本地操作。挑战在于构造乘法协议 $\prod ^{\rm m}_{\rm Mul}$，令其可以容忍其中一方腐败。可以观察到有两种情况：</p>
<ul>
<li>$P_0$ 是腐败的：在离线阶段会令 $\gamma_{xy} \neq \lambda_x \lambda_y$</li>
<li>$P_1$ 或 $P_2$ 是腐败的：会在在线阶段扰乱，使诚实的另一方重构出一个错误的 $m_z$</li>
</ul>
<p>先看下面的情况，假如 $P_1$ 现在需要验证它重构的 $m_z$ 是否是正确的，可以向 $P_0$ 求助：$P_1$ 可以发送 $m_x, m_y$ 给 $P_0$，因为 $P_0$ 在离线阶段就已经知道 $\lambda_x, \lambda_y$ 和 $\lambda_z$，因此它可以计算出 $m_z$ 并发送给 $P_1$，以此得到验证。但发送 $m_x, m_y$ 给 $P_0$ 会导致打破了原有共享的私密性，所以 $P_1$ 可以对应的值盲化后发送给 $P_0$：$m^{\star}_x = m_x + \delta_x$ 和 $m^{\star}_y = m_y + \delta_y$，然后 $P_0$ 计算 $m^{\star}_z = -m^{\star}_x \lambda_y - m^{\star}_y \lambda_x +\lambda_z + 2\gamma_{xy}$。注意到：</p>
<script type="math/tex; mode=display">
\begin{align}
m^{\star}_z &= -m^{\star}_x \lambda_y - m^{\star}_y \lambda_x +\lambda_z + 2\gamma_{xy}\\
 &= -(m_x + \delta_x) \lambda_y - (m_y + \delta_y) \lambda_x +\lambda_z + 2\gamma_{xy}\\
 &= (m_z - m_x m_y) - \chi
\end{align}</script><p>假设 $P_0$ 知道 $\chi = \delta_x \lambda_y + \delta_y \lambda_x - \gamma_{xy}$，它就可以计算出 $m^{\star}_z + \chi$ 然后发送给 $P_1$。因为 $P_1$ 知道 $m_x, m_y$ 的值，因此它可以验证它重构的 $m_z$ 的正确性，对于 $P_2$ 来说也可以这样验证。</p>
<p>现在来描述如何使 $P_0$ 获得 $\chi$：首先直接让 $P_0$ 获得 $\chi$ 会导致共享的私密性被破坏，因为 $P_0$ 知道 $\lambda_x, \lambda_y$ 和 $\gamma_{xy}$ 的值，同时在在线阶段又得到 $m_x + \delta_x$ 和 $m_y + \delta_y$，导致 $P_0$ 可以推导出 $m_x, m_y$ 之间的关系。所以还要在 $\chi$ 中加入一个随机值 $\delta_z$ 进行盲化：$\delta_x \lambda_y + \delta_y \lambda_x + \delta_z - \gamma_{xy}$。</p>
<p>生成 $\chi$ 的过程：$P_1, P_2$ 在本地生成随机数 $\delta_x, \delta_y, \delta_z \in \mathbb{Z}_{2^l}$，计算各自的 $\chi$ 的 $[\cdot]$-共享并发送给 $P_0$。对于 $i \in \{1,2 \}$，令 $[\chi]_{P_i} = \chi_i$。$P_0$ 在本地将共享的份额相加得到 $\chi$。在以上步骤中，腐败的一方可能会在执行过程中引入错误，使得 $P_0$ 获得的 $\chi$ 是错误的。</p>
<p>总而言之在离线阶段有两个问题需要解决：</p>
<ul>
<li>腐败的 $P_0$ 可以不正确地共享 $\gamma_{xy}$</li>
<li>腐败的 $P_1$ 或 $P_2$ 可以发送错误的 $\chi$ 的 $[\cdot]$-共享给 $P_0$</li>
</ul>
<p>为了解决这些问题，$P_0$ 一旦获得 $\chi$，就用下面的方式计算 $a = \delta_x - \lambda_x$、$b = \delta_y - \lambda_y$ 和 $c = (\delta_z + \delta_x \delta_y) - \chi$ 的 $[\![\cdot]\!]$-共享：</p>
<script type="math/tex; mode=display">
\begin{align*}
[\![a]\!]_{P_0} &= (\lambda_{x,1}, \lambda_{x,2}), & [\![b]\!]_{P_0} &= (\lambda_{y,1}, \lambda_{y,2}), & [\![c]\!]_{P_0} &= (\chi_{1}, \chi_{2})\\
 [\![a]\!]_{P_1} &= (\delta_x, \lambda_{x,1}), & [\![b]\!]_{P_1} &= (\delta_y, \lambda_{y,1}), & [\![c]\!]_{P_1} &= (\delta_z + \delta_x \delta_y, \chi_{1})\\
 [\![a]\!]_{P_2} &= (\delta_x, \lambda_{x,2}), & [\![b]\!]_{P_2} &= (\delta_y, \lambda_{y,2}), & [\![c]\!]_{P_2} &= (\delta_z + \delta_x \delta_y, \chi_{2})
\end{align*}</script><p>现在 $([\![a]\!], [\![b]\!], [\![c]\!])$ 是一个乘法三元组 $(c=ab)$，当且仅当 $P_0$ 正确分享了 $\gamma_{xy}$（当它腐败时）以及重构的 $\chi$ 是正确的（当 $P_1,P_2$ 其中之一腐败时），因为：</p>
<script type="math/tex; mode=display">
\begin{align}
ab &= (\delta_x - \lambda_x)(\delta_y - \lambda_y) = \delta_x \delta_y + \lambda_x \lambda_y - \delta_x \lambda_y - \delta_y \lambda_x \\
 &= (\delta_x \delta_y + \delta_z) - (\delta_x \lambda_y + \delta_y \lambda_x + \delta_z - \gamma_{xy}) \\
  &= (\delta_x \delta_y + \delta_z) - \chi = c
\end{align}</script><p>然后作者给出了一个检查乘法三元组是否正确的协议，这里需要用到另一个有效的乘法三元组 $([\![d]\!], [\![e]\!], [\![f]\!])$，它们满足以下条件：</p>
<ul>
<li>$d, e, f$ 都是随机且私密的</li>
<li>$f = d e$</li>
</ul>
<p>这里假设这个三元组是通过 $\mathcal{F}_{\rm trip}$ 生成的，在[2, 30]中有具体构造，下面是[30]中的构造：</p>
<p><img src="http://images.yingwai.top/picgo/ASTRAf1.png" alt=""></p>
<p>用  $\prod _{\rm trip}$ 表示该功能的实例化，下面是作者给出检查有效性的协议 $\prod _{\rm prc}$：</p>
<hr>
<ul>
<li>Parties locally compute $[\![\rho]\!] = [\![a]\!] - [\![d]\!]$ and $[\![\sigma]\!] = [\![b]\!] - [\![e]\!]$.</li>
<li>Parties reconstruct $\rho$ and $\sigma$ by executing $\prod ^{\rm m}_{\rm Rec}([\![\rho]\!], \mathcal{P})$ and $\prod ^{\rm m}_{\rm Rec}([\![\sigma]\!], \mathcal{P})$ respectively.</li>
<li>Parties locally compute $[\![\tau]\!] = [\![c]\!] - [\![f]\!] - \sigma [\![d]\!] - \rho [\![e]\!] - \sigma \rho$.</li>
<li>Parties reconstruct $\tau$ by executing $\prod ^{\rm m}_{\rm Rec}([\![\tau]\!], \mathcal{P})$ and output $\perp$, if $\tau \neq 0$.</li>
</ul>
<hr>
<p>协议 $\prod _{\rm prc}$ 需要两对秘密共享三元组 $(a, b, c)$ 和 $(d, e, f)$，验证前一个三元组是否满足 $c = a b$：</p>
<script type="math/tex; mode=display">
\begin{align}
\tau &= c - f - \sigma d - \rho e - \sigma \rho \\
 &= c - de - (b - e)d - (a - d)e - (b - e)(a - d) \\
 &= c - ab = \Delta
\end{align}</script><p>所以 $\tau = 0$ 时 $(a,b,c)$ 有效，反之无效。而检验 $\tau$ 是否为0只需要一方跟另外两方各通信一次即可：(1) $P_0$ 跟 $P_1$ 检查 $m_\tau - \lambda_{\tau,1}$ 跟 $\lambda_{\tau, 2}$ 是否相等；(2) $P_1$ 跟 $P_2$ 检查 $m_\tau - \lambda_{\tau,2}$ 跟 $\lambda_{\tau, 1}$ 是否相等；(3) $P_0$ 跟 $P_1$ 检查 $m_\tau - \lambda_{\tau,2}$ 跟 $\lambda_{\tau, 1}$ 是否相等，而不是 $\prod ^{\rm m}_{\rm Rec}$ 的通信三次（两次发送一次接收）。下面给出恶意设置下的乘法协议 $\prod ^{\rm m}_{\rm Mul}(w_x, w_y, w_z)$：</p>
<hr>
<p><strong>Offline:</strong></p>
<ul>
<li>Parties $P_0, P_1$ locally sample random $\lambda_{z,1}, \gamma_{xy,1} \in \mathbb{Z}_{2^l}$, while $P_0, P_2$<br>locally sample a random $\lambda_{z,2}$. $P_0$ locally computes $\gamma_{xy}= \lambda_x \lambda_y$ and<br>sends $\gamma_{xy,2} = \gamma_{xy} - \gamma_{xy,1}$ to $P_2$.</li>
<li>Parties execute $\prod _{\rm trip}$ to generate a triple $([\![d]\!], [\![e]\!], [\![f]\!])$.</li>
<li>Parties $P_1, P_2$ locally sample random $\delta_x, \delta_y, \delta_z \in \mathbb{Z}_{2^l}$ and compute<br>$[\delta_z]$ non-interactively.</li>
<li>$P_i$ for $i \in \{1, 2\}$ computes $[\chi]_{P_i} = \delta_x[\lambda_y]_{P_i} + \delta_y[\lambda_x]_{P_i} + [\delta_z]_{P_i} − [\gamma_{xy}]_{P_i}$ and sends $[\chi]_{P_i}$ to $P_0$, who computes $\chi$.</li>
<li>Parties locally compute the $[\![\cdot]\!]$-shares of the values $a = \delta_x - \lambda_x$, $b = \delta_y - \lambda_y$ and $b = (\delta_z + \delta_x \delta_y) - \chi$, as described in the text.</li>
<li>Parties execute $\prod _{\rm prc}$ on $([\![a]\!], [\![b]\!], [\![c]\!])$ and $([\![d]\!], [\![e]\!], [\![f]\!])$.</li>
</ul>
<p><strong>Online:</strong></p>
<ul>
<li>$P_i$ for $i \in \{1, 2\}$ locally computes $[m_z]_{P_i} = (i-1)m_xm_y - m_x[\lambda_y]_{P_i} - m_y[\lambda_x]_{P_i} + [\lambda_z]_{P_i} + [\gamma_{xy}]_{P_i}$. $P_1, P_2$ mutually exchange their shares and reconstruct $m_z$.</li>
<li>$P_1$ sends $m^{\star}_x = m_x + \delta_x$, $m^{\star}_y = m_y + \delta_y$ to $P_0$, while $P_2$ sends $H(m^{\star}_x || m^{\star}_{y})$ to $P_0$.$P_0$ outputs $\perp$, if the received values are inconsistent.</li>
<li>$P_0$ computes $m^{\star}_z = -m^{\star}_x \lambda_y - m^{\star}_y \lambda_x +\lambda_z + 2\gamma_{xy} + \chi$ and sends $H(m^\star_z)$ to both $P_1$ and $P_2$.</li>
<li>$P_i$ for $i \in \{1, 2\}$ abort if $H(m^\star_z) \neq H(m_z - m_x m_y + \delta_z)$.</li>
</ul>
<hr>
<p>散列值的使用提高了效率，减少了通信的开销。</p>
<p>对于正确性，首先考虑腐败的 $P_0$ 不正确地共享使得 $\gamma_{xy} = \lambda_x \lambda_y + \Delta$ 的情况，其中 $\Delta$ 是 $P_0$ 引入的不为零的干扰。这种情况在执行 $\prod _{\rm prc}$ 就会被检测到，因为最终计算出来并重构的 $\tau \neq 0$。同样的， $P_1$（或 $P_2$）在协议 $\prod ^{\rm m}_{\rm Mul}$ 离线阶段的第四步时发送 $\chi_1 + \Delta$（或 $\chi_2 + \Delta$） 给 $P_0$ 使其重构的 $\chi’ = \chi + \Delta$，也会导致 $\tau \neq 0$ 从而被诚实方发现并中止计算。</p>
<p>然后是另一种情况，假如 $P_1$（或 $P_2$）在重构 $m_z$ 时发送了错误的 $[m_z]_{P_i}$ 给另一方，会在最后一步验证哈希值是否相等的时候被检测出来；而在在线阶段第二步中 $P_0$ 对 $m^{\star}_x,m^{\star}_y$ 的一致性检查也确保了它所计算出来的 $m^{\star}_z$ 是正确的。</p>
<h4 id="公平的实现"><a href="#公平的实现" class="headerlink" title="公平的实现"></a>公平的实现</h4><p>作者通过一种公平重构协议 $\prod_{\rm fRec}$ 来重构电路输出，将 $\prod ^{\rm m}_{\rm 3pc}$ 的安全性提高到公平，保证交易的三方都不能通过损害别人的利益而得到自己不应得的利益。这里使用到了承诺方案，还是利用了服务器之间的公共随机源并使用PRF来为承诺方案引入随机性：</p>
<hr>
<p><strong>Offline:</strong></p>
<ul>
<li>Parties $P_0, P_1$ locally sample a random $r_1 \in \mathbb{Z}_{2^l}$, prepare and send commitments of $\lambda_{y,1}$ and $r_1$ to $P_2$. Similarly, parties $P_0, P_2$ locally sample a random $r_2 \in \mathbb{Z}_{2^l}$, prepare and send commitments of $\lambda_{y,2}$ and $r_2$ to $P_1$. The randomness needed for both commitments are sampled from the PRF key-setup.</li>
<li>$P_1$ (resp. $P_2$) aborts if the received commitments mismatch.</li>
</ul>
<p><strong>Online:</strong></p>
<ul>
<li>$P_1, P_2$ compute a commitment of $m_y$ using randomness sampled from their PRF key-setup and send it to $P_0$.</li>
<li>If the commitments do not match, $P_0$ sends (<strong>abort</strong>, $o_1$) to $P_2$, while it sends (<strong>abort</strong>, $o_2$) to $P_1$ and aborts, where $o_i$ denotes the opening information for the commitment of $r_i$. Else $P_0$ sends <strong>continue</strong> to both $P_1$ and $P_2$.</li>
<li>$P_1, P_2$ exchange the messages received from $P_0$.</li>
<li>$P_1$ aborts if it receives either (i) (<strong>abort</strong>, $o_2$) from $P_0$ and $o_2$ opens the commitment of $r_2$ or (ii) (<strong>abort</strong>, $o_1$) from $P_2$ and $o_1$ is the correct opening information of $r_1$. The case for $P_2$ is similar to that of $P_1$.</li>
<li>If no abort happens, parties obtain their missing share of $a$ as follows:<ul>
<li>$P_0, P_1$ open $\lambda_{y,1}$ towards $P_2$.</li>
<li>$P_0, P_2$ open $\lambda_{y,2}$ towards $P_1$.</li>
<li>$P_1, P_2$ open $m_y$ towards $P_0$.</li>
</ul>
</li>
<li>Parties reconstruct the value $y$ using missing share that matches with the agreed upon commitment.</li>
</ul>
<hr>
<p>当没有广播频道的时候，一个非常棘手的问题就会存在：一个腐败的 $P_0$ 可以发送不同的信号给 $P_1$ 和 $P_2$（一个为 abort 而另一个为 continue），以上的重构协议 $\prod_{\rm fRec}([\![y]\!], \mathcal{P})$ 解决了这个问题。在离线阶段 $P_0$ 和 $P_1$ 共同计算出一个关于 $r_1$ 的承诺发送给 $P_2$，同样地 $P_0$ 和 $P_2$ 共同计算出一个关于 $r_2$ 的承诺发送给 $P_1$。这两个承诺就可以确保 $P_1$ 跟 $P_2$ 可以验证它们收到的来自 $P_0$ 的信号是否一致：例如当 $P_1$ 收到 abort 而 $P_2$ 收到 continue，在它们交换信息时，$P_1$ 就可以利用收到的 $o_2$ 证明自己收到了 abort 信号，反过来也是一样的。同时还解决了一个问题，就是当一个腐败的 $P_1$ 收到了 $P_0$ 发送的 continue 信号，但它不能在与 $P_2$ 交换信息时宣称自己收到了 abort 信号，因为它没有 $o_2$，因此无法证明，对于 $P_2$ 腐败的情况也是一样的。</p>
<p>这里的承诺方案可以通过一个哈希函数来实现，例如：$(c, o) = (\mathcal{H}(x||r),x||r) = Com(x;r)$</p>
<h2 id="隐私保护机器学习"><a href="#隐私保护机器学习" class="headerlink" title="隐私保护机器学习"></a>隐私保护机器学习</h2><h3 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h3><p>对于每一个预测函数，模型拥有者 $\rm M$ 拥有一个训练好的参数向量，想为拥有一个查询向量的客户 $\rm C$ 提供预测服务。在服务器辅助设置中，$\rm M$ 和 $\rm C$ 以共享方式将各自的输入外包给三个不受信任但非合谋的服务器 $\{P_0, P_1, P_2\}$，这些服务器通过为本文的3PC协议开发的技术以共享方式执行计算，并将输出单独重构到客户端。客户只能知道输出，除此之外什么也不知道。</p>
<h3 id="对于ML的协议"><a href="#对于ML的协议" class="headerlink" title="对于ML的协议"></a>对于ML的协议</h3><h4 id="安全向量点积"><a href="#安全向量点积" class="headerlink" title="安全向量点积"></a>安全向量点积</h4><p>对于向量的 $[\cdot]$-共享和 $[\![\cdot]\!]$-共享，就是对应每个维度的值进行$[\cdot]$-共享和 $[\![\cdot]\!]$-共享，容易知道对于向量来说两种共享仍然是线性的。对于两个 $d$ 维向量的点积，不考虑效率的情况下可以执行 $d$ 次 $\prod ^{\rm s}_{\rm Mul}$协议，再对这 $d$ 次执行的结果简单进行相加，各方就可以得到它们的份额。在这里作者给出一个更高效率的向量点积协议 $\prod ^{\rm s}_{\rm dp}$：</p>
<hr>
<p><strong>Offline:</strong></p>
<p>​        $P_0, P_1$ sample random $\lambda_{u,1}, \gamma_{pq,1} \in \mathbb{Z}_{2^l}$, while $P_0, P_2$ sample random $\lambda_{u,2} \in \mathbb{Z}_{2^l}$. $P_0$ locally computes $\gamma_{pq} = \vec{\lambda_p} \odot \vec{\lambda_q}$, sets $\gamma_{pq,2} = \gamma_{pq} - \gamma_{pq,1}$ and sends $\gamma_{pq,2}$ to $P_2$.</p>
<p><strong>Online:</strong></p>
<ul>
<li>$P_i$ for $i \in \{1,2\}$ locally computes $[m_u]_{P_i} = \sum^d_{j=1}((i-1)m_{p_j}m_{q_j} - m_{p_j}[\lambda_{q_j}]_{P_i} - m_{q_j}[\lambda_{p_j}]_{P_i}) + [\gamma_{pq}]_{P_i} + [\lambda_u]_{P_i}$.</li>
<li>$P_1$ and $P_2$ mutually exchange their share of $[m_u]$ to reconstruct $m_u$.</li>
</ul>
<hr>
<p>上面的协议的离线阶段中，$P_0$ 仅仅共享了 $\gamma_{pq} = \vec{\lambda_p} \odot \vec{\lambda_q}$ 而不是每一个 $\lambda_{p_i} \lambda_{q_i}$；在在线阶段，$P_1, P_2$ 直接计算 $[m_u]$（其中 $u = \vec{p} \odot \vec{q}$）而不是每一个 $m_{p_i q_i}$。</p>
<p>接下来作者还对恶意设置下的点积进行了讨论：由于在乘法协议中引入了对恶意对手的额外检查，所以上面针对半诚实协议所作的优化是不适用的。对两个 $d$ 维向量的点积，只能 $d$ 次调用协议 $\prod ^{\rm m}_{\rm Mul}$。不过作者还是对在线阶段的开销进行了改进：在在线阶段 $P_1$ 并行地发送 $m^{\star}_{p_i}, m^{\star}_{q_i}$ 给 $P_0$，而 $P_2$ 则发送对应的哈希值给 $P_0$。$P_0$ 收到这些值后进行验证，若一致则将它们“结合”所有的 $m^{\star}_{p_i q_i}$ 然后发送一个单独的 $m^\star_u$ 的哈希值给 $P_1, P_2$，最后 $P_1, P_2$ 在本地验证是否与 $m_u - \sum^d_{j=1}(m_{p_j}m_{q_j} - \delta_{u_j})$。这样做的话就节省了在线阶段的开销，不用每个 $m^{\star}_{p_i}, m^{\star}_{q_i}$ 都发送一次。</p>
<h4 id="安全比较"><a href="#安全比较" class="headerlink" title="安全比较"></a>安全比较</h4><p>给定算术共享 $[\![u]\!], [\![v]\!]$，各方希望验证 $u$ 是否小于 $v$，等同于验证 $a$ 是否小于 $0$（其中 $a = u - v$），在定点表示中可以通过检查 ${\rm msb}(a)$ 来完成（二进制补码中第一位为符号位）。于是可以把在给定算术共享 $[\![a]\!]$ 的情况下生成 ${\rm msb}(a)$ 的布尔共享作为目标，在这里作者利用了秘密共享方案中的不对称性，放弃了 <em>SecureML</em>[48]和 <em>ABY3</em>[46]中的昂贵协议。</p>
<hr>
<p><strong>Offline:</strong></p>
<p>​        $P_1, P_2$ together sample a random $r, r’ \in \mathbb{Z}_{2^l}$ and set $p= \rm{msb}$$(r)$. Parties non-interactively generate Boolean share of $p$ as $[\![p]\!]^{\rm B}_{P_0} = (0,0)$, $[\![p]\!]_{P_1} = (p,0)$ and $[\![p]\!]_{P_2} = (p,0)$.</p>
<p><strong>Online:</strong></p>
<p>​        $P_1$ set $[a]_{P_1}=m_a - \lambda_{a,1}$, $P_2$ set $[a]_{P_2}=- \lambda_{a,2}$.</p>
<ul>
<li>$P_1$ sends $[ra]_{P_1} = r[a]_{P_1} + r’$ to $P_0$, while $P_2$ sends $[ra]_{P_2} = r[a]_{P_1} - r’$ to $P_0$, who adds them to obtain $ra$.</li>
<li>$P_0$ executes $\prod^{\rm s}_{\rm Sh}(P_0, q)$ over $\mathbb{Z}_{2^1}$ to generate $[\![q]\!]^{\rm B}$ where $q = {\rm msb}(ra)$.</li>
<li>Parties locally compute $[\![msb(a)]\!]^{\rm B} = [\![p]\!]^{\rm B} \oplus [\![q]\!]^{\rm B}$.</li>
</ul>
<hr>
<p>上面的协议用 $\prod ^{\rm s}_{\rm BitExt}([\![a]\!], \mathcal{P})$ 表示。这里上面用到了一个随机数 $r$ 来对 $a$ 的值进行盲化，并且可以注意到 ${\rm sign}(a \cdot r) = {\rm sign}(a) \oplus {\rm sign}(r)$，所以 $r$ 不会对生成共享份额造成影响且使得三者都不能从这个过程中知道关于 $a$ 的信息。</p>
<p>对于恶意的情况，就不能仅仅依靠 $P_0$ 来生成 $[\![{\rm msb}(ra)]\!]^{\rm B}$，下面给出了修改后的协议 $\prod ^{\rm m}_{\rm BitExt}([\![a]\!], \mathcal{P})$：</p>
<hr>
<p><strong>Offline:</strong></p>
<p>​        $P_1, P_2$ sample a random $r_1 \in \mathbb{Z}_{2^l}$ and set $p_1 = {\rm msb}(r_1)$ while $P_0, P_2$ sample a random $r_2 \in \mathbb{Z}_{2^l}$ and set $p_2 = {\rm msb}(r_2)$.</p>
<ul>
<li>Parties non-interactively generate $[\![\cdot]\!]$-shares of $r_1$ as $[\![r_1]\!]_{P_0}=(0,0)$, $[\![r_1]\!]_{P_1}=(r_1,0)$ and $[\![r_1]\!]_{P_2}=(r_1,0)$.</li>
<li>Parties non-interactively generate $[\![\cdot]\!]$-shares of $r_1$ as $[\![r_2]\!]_{P_0}=(0,-r_2)$, $[\![r_1]\!]_{P_1}=(0,0)$ and $[\![r_1]\!]_{P_2}=(0,-r_2)$.</li>
<li>Parties execute $\prod^{\rm m}_{\rm Mul}$ on $r_1$ and $r_2$ to generate $[\![r]\!] = [\![r_1 r_2]\!]$.</li>
<li>Parties non-interactively generate Boolean shares of $p_1$ as $[\![p_1]\!]^{\rm B}_{P_0}=(0,0)$, $[\![p_1]\!]^{\rm B}_{P_1}=(p_1,0)$ and $[\![p_1]\!]^{\rm B}_{P_2}=(p_1,0)$.</li>
<li>Parties non-interactively generate Boolean shares of $p_2$ as $[\![p_2]\!]^{\rm B}_{P_0}=(0,p_2)$, $[\![p_2]\!]^{\rm B}_{P_1}=(0,0)$ and $[\![p_2]\!]^{\rm B}_{P_2}=(0,p_2)$.</li>
<li>Parties locally compute $[\![p]\!]^{\rm B}=[\![p_1]\!]^{\rm B} \oplus [\![p_2]\!]^{\rm B}$.</li>
</ul>
<p><strong>Online:</strong></p>
<ul>
<li>Parties execute $\prod ^{\rm m}_{\rm Mul}$ on $[\![r]\!]$ and $[\![a]\!]$ to generate $[\![ra]\!]$ followed by enabling $P_0, P_1$ to reconstruct $ra$ (this is done by slightly modifying the protocol $\prod ^{\rm m}_{\rm Rec}$ ).</li>
<li>$P_1$ executes $\prod ^{\rm m}_{\rm Sh}(P_1, q)$ over $\mathbb{Z}_{2^1}$ to generate $[\![q]\!]^{\rm B}$ where $q = {\rm msb}(ra)$. In parallel, $P_0$ locally computes $m_q$ and sends ${\rm H}(m_q)$ to $P_2$, who abort if the value mismatches with the hash of the value $m_q$ received from $P_1$ as part of $\prod ^{\rm m}_{\rm Sh}(P_1, q)$.</li>
<li>Parties locally compute $[\![{\rm msb}(a)]\!]^{\rm B} = [\![p]\!]^{\rm B} \oplus [\![q]\!]^{\rm B}$.</li>
</ul>
<hr>
<h4 id="ML预测函数"><a href="#ML预测函数" class="headerlink" title="ML预测函数"></a>ML预测函数</h4><ul>
<li><strong>线性回归</strong>：$\rm M$ 有一个 $d$ 维的模型参数向量 $\vec{w}$ 和偏置项 $b$，$\rm C$ 有一个 $d$ 维的查询向量 $\vec{z}$。$\rm C$ 获得 $f_{\rm linr}((\vec{w}, b),\vec{z}) = \vec{w} \odot \vec{z} + b$，其中 $\vec{w} \odot \vec{z}$ 是向量 $\vec{w}$ 和向量 $\vec{z}$ 的点积；</li>
<li><strong>SVM回归</strong>：$\rm M$ 有$\{\alpha_j, y_j \}^k_{j=1}$ 和 $d$ 维的支持向量 $\{\vec{x_j}\}^k_{j=1}$，$\rm C$ 有一个 $d$ 维的查询向量 $\vec{z}$。$\rm C$ 获得 $f_{\rm svmr}((\{\alpha_j, y_j, \vec{x_j} \}^k_{j=1}, b), \vec{z}) = \sum^k_{j=1} \alpha_j y_j (\vec{x_j} \odot \vec{z}) + b$；</li>
<li><strong>逻辑回归</strong>：$\rm M$ 和 $\rm C$ 的输入和线性回归类似，$\rm M$ 还需要提供一个在 $[0,1]$ 范围内的额外输入 $t$。$\rm C$ 获得 $f_{\rm logr}((\vec{w}, b, t), \vec{z}) = {\rm sign}((\vec{w} \odot \vec{z} + b) - {\rm ln}(\frac{t}{1-t}))$，其中 ${\rm sign}(\cdot)$ 返回对象的符号位；</li>
<li><strong>SVM分类</strong>：$\rm M$ 和 $\rm C$ 的输入和SVM回归一样，但对 $\rm C$ 的输出变为 $f_{\rm svmr}((\{\alpha_j, y_j, \vec{x_j} \}^k_{j=1}, b), \vec{z}) = {\rm sign}(\sum^k_{j=1} \alpha_j y_j (\vec{x_j} \odot \vec{z}) + b)$。</li>
</ul>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1] V. A. Abril, P. Maene, N. Mertens, and N. P. Smart. 2019. <em>Bristol Fashion MPC Circuits.</em> <a href="https://homes.esat.kuleuven.be/~nsmart/MPC/" target="_blank" rel="noopener">https://homes.esat.kuleuven.be/~nsmart/MPC/</a>.<br>[2] T. Araki, A. Barak, J. Furukawa, T. Lichter, Y. Lindell, A. Nof, K. Ohara, A. Watzman, and O. Weinstein. 2017. <em>Optimized Honest-Majority MPC for Malicious Adversaries - Breaking the 1 Billion-Gate Per Second Barrier.</em> In IEEE S&amp;P. 843–862.<br>[3] T. Araki, A. Barak, J. Furukawa, Y. Lindell, A. Nof, and K. Ohara. 2016. <em>DEMO: High-Throughput Secure Three-Party Computation of Kerberos Ticket Generation.</em> In ACM CCS. 1841–1843.<br>[4] T. Araki, J. Furukawa, Y. Lindell, A. Nof, and K. Ohara. 2016. <em>High-Throughput Semi-Honest Secure Three-Party Computation with an Honest Majority.</em> In ACM CCS. 805–817.<br>[5] C. Baum, I. Damgård, T. Toft, and R. W. Zakarias. 2016. <em>Better Preprocessing for Secure Multiparty Computation.</em> In ACNS. 327–345.<br>[6] D. Beaver. 1991. <em>Efficient Multiparty Protocols Using Circuit Randomization.</em> In CRYPTO. 420–432.<br>[7] D. Beaver. 1995. <em>Precomputing Oblivious Transfer.</em> In CRYPTO. 97–109.<br>[8] Z. Beerliová-Trubíniová and M. Hirt. 2006. <em>Efficient Multi-party Computation with Dispute Control.</em> In TCC. 305–328.<br>[9] Z. Beerliová-Trubíniová and M. Hirt. 2008. <em>Perfectly-Secure MPC with Linear Communication Complexity.</em> In TCC. 213–230.<br>[10] M. Ben-Or, S. Goldwasser, and A. Wigderson. 1988. <em>Completeness Theorems for Non-Cryptographic Fault-Tolerant Distributed Computation (Extended Abstract).</em> In ACM STOC. 1–10.<br>[11] Christopher Bishop. 2006. <em>Pattern Recognition and Machine Learning.</em><br>[12] D. Bogdanov, S. Laur, and J. Willemson. 2008. <em>Sharemind: A Framework for Fast Privacy-Preserving Computations.</em> In ESORICS. 192–206.<br>[13] D. Bogdanov, R. Talviste, and J. Willemson. 2012. <em>Deploying Secure Multi-Party Computation for Financial Data Analysis.</em> In FC. 57–64.<br>[14] M. Byali, A. Joseph, A. Patra, and D. Ravi. 2018. <em>Fast Secure Computation for Small Population over the Internet.</em> ACM CCS (2018), 677–694.<br>[15] O. Catrina and S. de Hoogh. 2010. <em>Secure Multiparty Linear Programming Using Fixed-Point Arithmetic.</em> In ESORICS. 134–150.<br>[16] N. Chandran, J. A. Garay, P. Mohassel, and S. Vusirikala. 2017. <em>Efficient, Constant-Round and Actively Secure MPC: Beyond the Three-Party Case.</em> In ACM CCS. 277–294.<br>[17] H. Chaudhari, A. Choudhury, A. Patra, and A. Suresh. 2019. <em>ASTRA: High-throughput 3PC over Rings with Application to Secure Prediction.</em> <a href="https://eprint.iacr.org/2019/429" target="_blank" rel="noopener">https://eprint.iacr.org/2019/429</a>. In IACR Cryptology ePrint Archive.<br>[18] K. Chida, D. Genkin, K. Hamada, D. Ikarashi, R. Kikuchi, Y. Lindell, and A. Nof. 2018. <em>Fast Large-Scale Honest-Majority MPC for Malicious Adversaries.</em> In CRYPTO. 34–64.<br>[19] A. Choudhury and A. Patra. 2017. <em>An Efficient Framework for Unconditionally Secure Multiparty Computation.</em> IEEE Trans. Information Theory (2017), 428–468.<br>[20] R. Cleve. 1986. <em>Limits on the Security of Coin Flips when Half the Processors Are Faulty (Extended Abstract).</em> In ACM STOC. 364–369.<br>[21] R. Cramer, I. Damgård, D. Escudero, P. Scholl, and C. Xing. 2018. <em>SPDZ2k: Efficient MPC mod 2ˆk for Dishonest Majority.</em> CRYPTO (2018), 769–798.<br>[22] R. Cramer, I. Damgård, and Y. Ishai. 2005. <em>Share Conversion, Pseudorandom Secret-Sharing and Applications to Secure Computation.</em> In TCC. 342–362.<br>[23] Cryptography and Privacy Engineering Group at TU Darmstadt. 2017. ENCRYPTO Utils. <a href="https://github.com/encryptogroup/ENCRYPTO_utils" target="_blank" rel="noopener">https://github.com/encryptogroup/ENCRYPTO_utils</a>.<br>[24] M. Dahl. 2018. <em>Private Image Analysis with MPC: Training CNNs on Sensitive Data using SPDZ.</em> (2018).<br>[25] I. Damgård, C. Orlandi, and M. Simkin. 2018. <em>Yet Another Compiler for Active Security or: Efficient MPC Over Arbitrary Rings.</em> CRYPTO (2018), 799–829.<br>[26] I. Damgård, V. Pastro, N. P. Smart, and S. Zakarias. 2012. <em>Multiparty Computation from Somewhat Homomorphic Encryption.</em> In CRYPTO. 643–662.<br>[27] S. de Hoogh, B. Schoenmakers, P.Chen, and H. Akker. 2014. <em>Practical Secure Decision Tree Learning in a Teletreatment Application.</em> In FC. 179–194.<br>[28] H. Eerikson, M. Keller, C. Orlandi, P. Pullonen, J. Puura, and M. Simkin. 2019. <em>Use your Brain! Arithmetic 3PC For Any Modulus with Active Security.</em> IACR<br>Cryptology ePrint Archive (2019).<br>[29] A. Esteva, B. Kuprel, R. A. Novoa, J. Ko, S. M. Swetter, H. M. Blau, and S. Thrun. 2017. <em>Dermatologist-level classification of skin cancer with deep neural networks.</em> Nature (2017), 115–118.<br>[30] J. Furukawa, Y. Lindell, A. Nof, and O. Weinstein. 2017. <em>High-Throughput Secure Three-Party Computation for Malicious Adversaries and an Honest Majority.</em> In EUROCRYPT. 225–255.<br>[31] A. Gascón, P. Schoppmann, B. Balle, M. Raykova, J. Doerner, S. Zahur, and D. Evans. 2016. <em>Secure Linear Regression on Vertically Partitioned Datasets.</em> IACR Cryptology ePrint Archive (2016).<br>[32] M. Geisler. 2007. <em>Viff: Virtual ideal functionality framework.</em><br>[33] O. Goldreich, S. Micali, and A. Wigderson. 1987. <em>How to Play any Mental Game or A Completeness Theorem for Protocols with Honest Majority.</em> In STOC. 218–229.<br>[34] S. D. Gordon, S. Ranellucci, and X. Wang. 2018. <em>Secure Computation with Low Communication from Cross-Checking.</em> In ASIACRYPT. 59–85.<br>[35] Y. Ishai, R. Kumaresan, E. Kushilevitz, and A. Paskin-Cherniavsky. 2015. <em>Secure Computation with Minimal Interaction, Revisited.</em> In CRYPTO. 359–378.<br>[36] S. Kamara, P. Mohassel, and M. Raykova. 2011. <em>Outsourcing Multi-Party Computation.</em> IACR Cryptology ePrint Archive (2011).<br>[37] J. Katz, V. Kolesnikov, and X. Wang. 2018. <em>Improved Non-Interactive Zero Knowledge with Applications to Post-Quantum Signatures.</em> In CCS. 525–537.<br>[38] M. Keller, E. Orsini, and P. Scholl. 2016. <em>MASCOT: Faster Malicious Arithmetic Secure Computation with Oblivious Transfer.</em> In ACM CCS. 830–842.<br>[39] M. Keller, V. Pastro, and D. Rotaru. 2018. <em>Overdrive: Making SPDZ Great Again.</em> In EUROCRYPT. 158–189.<br>[40] J. Launchbury, D. Archer, T. DuBuisson, and E. Mertens. 2014. <em>Application-Scale Secure Multiparty Computation.</em> In ESOP. 8–26.<br>[41] S. Laur, H. Lipmaa, and T. Mielikäinen. 2006. <em>Cryptographically private support vector machines.</em> In ACM SIGKDD. 618–624.<br>[42] Yann LeCun and Corinna Cortes. 2010. <em>MNIST handwritten digit database.</em> (2010). <a href="http://yann.lecun.com/exdb/mnist/" target="_blank" rel="noopener">http://yann.lecun.com/exdb/mnist/</a><br>[43] Y. Lindell and A. Nof. 2017. <em>A Framework for Constructing Fast MPC over Arithmetic Circuits with Malicious Adversaries and an Honest-Majority.</em> In ACM CCS. 259–276.<br>[44] J. Liu, M. Juuti, Y. L., and N. Asokan. 2017. <em>Oblivious Neural Network Predictions via MiniONN Transformations.</em> In ACM CCS. 619–631.<br>[45] E. Makri, D. Rotaru, N. P. Smart, and F. Vercauteren. 2018. <em>EPIC: Efficient Private Image Classification (or: Learning from the Masters).</em> CT-RSA (2018), 473–492.<br>[46] P. Mohassel and P. Rindal. 2018. <em>ABY3: A Mixed Protocol Framework for Machine Learning.</em> In ACM CCS. 35–52.<br>[47] P. Mohassel, M. Rosulek, and Y. Zhang. 2015. <em>Fast and Secure Three-party Computation: Garbled Circuit Approach.</em> In CCS. 591–602.<br>[48] P. Mohassel and Y. Zhang. 2017. <em>SecureML: A System for Scalable Privacy-Preserving Machine Learning.</em> In IEEE S&amp;P. 19–38.<br>[49] V. Nikolaenko, S. Ioannidis, U. Weinsberg, M. Joye, N. Taft, and D. Boneh. 2013. <em>Privacy-preserving matrix factorization.</em> In ACM CCS. 801–812.<br>[50] V. Nikolaenko, U. Weinsberg, S. Ioannidis, M. Joye, D. Boneh, and N. Taft. 2013. <em>Privacy-Preserving Ridge Regression on Hundreds of Millions of Records.</em> In IEEE S&amp;P. 334–348.<br>[51] P. S. Nordholt and M. Veeningen. 2018. <em>Minimising Communication in Honest-Majority MPC by Batchwise Multiplication Verification.</em> In ACNS. 321–339.<br>[52] T. Orekondy, B. Schiele, and M. Fritz. 2018. <em>Knockoff Nets: Stealing Functionality of Black-Box Models.</em> CoRR (2018).<br>[53] N. Papernot, P. McDaniel, I. Goodfellow, S. Jha, Z. B. Celik, and A. Swami. 2017. <em>Practical Black-Box Attacks Against Machine Learning.</em> In ASIA CCS. 506–519.<br>[54] A. Patra and D. Ravi. 2018. <em>On the Exact Round Complexity of Secure Three-Party Computation.</em> CRYPTO (2018), 425–458.<br>[55] M. S. Riazi, C. Weinert, O. Tkachenko, E. M. Songhori, T. Schneider, and F. Koushanfar. 2018. <em>Chameleon: A Hybrid Secure Computation Framework for Machine Learning Applications.</em> In AsiaCCS. 707–721.<br>[56] F. Schroff, D. Kalenichenko, and J. Philbin. 2015. <em>FaceNet: A unified embedding for face recognition and clustering.</em> In IEEE CVPR. 815–823.<br>[57] N. P. Smart and T. Wood. 2019. <em>Error Detection in Monotone Span Programs with Application to Communication-Efficient Multi-party Computation.</em> In CT-RSA. 210–229.<br>[58] F. Tramèr, F. Zhang, A. Juels, M. K. Reiter, and T. Ristenpart. 2016. <em>Stealing Machine Learning Models via Prediction APIs.</em> In USENIX. 601–618.<br>[59] S. Wagh, D. Gupta, and N. Chandran. 2019. <em>SecureNN: 3-Party Secure Computation for Neural Network Training.</em> PoPETs (2019), 26–49.<br>[60] A. C. Yao. 1982. <em>Protocols for Secure Computations.</em> In FOCS. 160–164.</p>
]]></content>
      <categories>
        <category>Papers</category>
      </categories>
      <tags>
        <tag>密码学</tag>
        <tag>MPC</tag>
        <tag>神经网络</tag>
        <tag>加密机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>论文笔记 Automatic Unit Test Generation and Execution for JavaScript Program through Symbolic Execution</title>
    <url>/2020/04/16/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0-Automatic-Unit-Test-Generation-and-Execution-for-JavaScript-Program-through-Symbolic-Execution/</url>
    <content><![CDATA[<p><a href="https://www.semanticscholar.org/author/Hideo-Tanida/2725857" target="_blank" rel="noopener">Hideo Tanida</a>, <a href="https://www.semanticscholar.org/author/Guodong-Li/1720073" target="_blank" rel="noopener">Guodong Li</a>, <a href="https://www.semanticscholar.org/author/Indradeep-Ghosh/3291522" target="_blank" rel="noopener">Indradeep Ghosh</a>, <a href="https://www.semanticscholar.org/author/Tadahiro-Uehara/3081128" target="_blank" rel="noopener">Tadahiro Uehara</a></p>
<p>Published in ICSEA 2014</p>
<p><a href="https://scholar.google.com/scholar?hl=zh-CN&amp;as_sdt=0%2C5&amp;q=Automatic+Unit+Test+Generation+and+Execution+for+JavaScript+Program+through+Symbolic+Execution&amp;btnG=" target="_blank" rel="noopener">https://scholar.google.com/scholar?hl=zh-CN&amp;as_sdt=0%2C5&amp;q=Automatic+Unit+Test+Generation+and+Execution+for+JavaScript+Program+through+Symbolic+Execution&amp;btnG=</a></p>
<a id="more"></a>
<h2 id="摘要及介绍"><a href="#摘要及介绍" class="headerlink" title="摘要及介绍"></a>摘要及介绍</h2><h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>​        考虑到对更具交互性的Web/移动应用程序的需求，JavaScript有望成为一种使用更广泛的编程语言。虽然JavaScript代码的可靠性将更加重要，但与其他语言相比，该语言的测试技术仍然不足。本文提出了一种为JavaScript代码自动生成高覆盖率单元测试的技术。该技术使用JavaScript代码的符号执行引擎，以及自动为不感兴趣的代码生成存根的存根/驱动程序生成引擎。本文的方法允许全自动生成用于高覆盖率的JavaScript代码单元测试的输入数据，从而以较少的工作量确保目标代码的质量。</p>
<h3 id="主要贡献"><a href="#主要贡献" class="headerlink" title="主要贡献"></a>主要贡献</h3><ul>
<li>本文提出了一种在工具<strong>SymJS</strong>上通过符号执行为JavaScript代码生成测试输入的技术；</li>
<li>对比现有工具，本文的约束求解器<strong>PASS</strong>[10]允许为具有各种复杂字符串操作的程序生成测试；</li>
<li>并且不需要对目标代码进行任何修改，而现有的符号执行器需要修改和多次运行，因此适用于现实中的开发；</li>
<li>本文的自动生成存根/驱动程序代码允许完全自动生成测试数据。</li>
</ul>
<h3 id="现有的工具"><a href="#现有的工具" class="headerlink" title="现有的工具"></a>现有的工具</h3><p>​        现有的JavaScript代码测试工具包括<strong>Kudzu</strong>[8]和<strong>Jalangi</strong>[9]。kudzu自动生成程序函数的输入数据，目的是自动发现目标中的安全漏洞。Jalangi允许在正常的具体执行下修改路径约束，以便获得与以前运行不同的结果。然而，由于字符串约束处理方面的限制，以及需要手动创建用于测试的驱动程序/存根，这些工具不能应用于现实中JavaScript代码的单元测试。</p>
<h2 id="背景及基础知识"><a href="#背景及基础知识" class="headerlink" title="背景及基础知识"></a>背景及基础知识</h2><h3 id="符号执行"><a href="#符号执行" class="headerlink" title="符号执行"></a>符号执行</h3><p>​        符号执行（Symbolic Execution）是一种程序分析技术，可以通过分析程序源代码来得到测试输入。通俗来讲，比如说游戏中一个角色在佩戴各种装备之后的面板数值为：攻击力xxx、防御力xxx…；此时通过佩戴装备到获得属性的过程就好比一个程序，佩戴装备的品质就是这个程序的输入，而最后获得的属性就是这个程序的输出；符号执行的过程则是进行分析，从某组给定的属性逆向推导，最后得到某组质量的装备，佩戴这组装备可以获得一开始给定的属性。</p>
<h4 id="符号执行的基本原理"><a href="#符号执行的基本原理" class="headerlink" title="符号执行的基本原理"></a>符号执行的基本原理</h4><p>​        符号执行的关键思想是把输入变为符号值，那么程序的输出值就是一个符号输入值的函数。在程序执行期间，获得每个执行路径中的变量的值要满足的约束。在获得程序内所有路径的约束之后，通过将约束提供给诸如可满足性模理论（SMT）[7]求解器之类的求解器，可以获得执行每条路径的输入变量的具体值。</p>
<p>参考：<a href="https://zhuanlan.zhihu.com/p/26927127" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/26927127</a></p>
<h4 id="通过符号执行生成测试输入"><a href="#通过符号执行生成测试输入" class="headerlink" title="通过符号执行生成测试输入"></a>通过符号执行生成测试输入</h4><p>​        在程序的符号执行期间，执行每个路径所需要满足的约束是以迭代的方式计算的。在访问程序内每条可能的路径之后，获得所有路径的约束。使用<strong>SMT</strong>等求解器可以获得满足约束条件的变量的具体值。得到的值是与约束条件相对应的，可以用来进行测试。</p>
<h3 id="SymJS"><a href="#SymJS" class="headerlink" title="SymJS"></a>SymJS</h3><p>SymJS是一个用于自动测试JavaScript Web应用程序客户端的框架，该工具包括一个用于JavaScript的符号执行引擎和一个Web页面的自动的事件资源管理器。而其中符号引擎包括一个符号虚拟机、一个字符串+数字解算器和一个符号可执行DOM模型。</p>
<p>​        SymJS解释从目标程序源代码编译的字节码。现有的符号执行器（如<strong>Klee</strong>[2]和<strong>Symbol Pathfinder</strong>[3]）都采用这种方法。处理字节码而不是源代码允许实现符号执行器，而无需处理语言的复杂语法。SymJS被实现为Rhino字节码的解释器，它在执行每条字节码指令时更新程序状态(堆/栈内容和路径条件)。在命中分支指令时，它复制程序状态并继续执行两个分支。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">Tool</th>
<th style="text-align:center">Target Lang.</th>
<th style="text-align:center">Sym.VM</th>
<th style="text-align:center">Dep./Cache Solving</th>
<th style="text-align:center">String Solving</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">SymJS</td>
<td style="text-align:center">JavaScript</td>
<td style="text-align:center">Yes</td>
<td style="text-align:center">Yes</td>
<td style="text-align:center">Yes</td>
</tr>
<tr>
<td style="text-align:center">KLEE [2]</td>
<td style="text-align:center">C</td>
<td style="text-align:center">Yes</td>
<td style="text-align:center">Yes</td>
<td style="text-align:center">No</td>
</tr>
<tr>
<td style="text-align:center">SAGE [6]</td>
<td style="text-align:center">x86 binary</td>
<td style="text-align:center">No</td>
<td style="text-align:center">Yes</td>
<td style="text-align:center">No</td>
</tr>
<tr>
<td style="text-align:center">Sym JPF [3]</td>
<td style="text-align:center">Java</td>
<td style="text-align:center">Yes</td>
<td style="text-align:center">No</td>
<td style="text-align:center">No</td>
</tr>
<tr>
<td style="text-align:center">Kudzu [8]</td>
<td style="text-align:center">JavaScript</td>
<td style="text-align:center">No</td>
<td style="text-align:center">No</td>
<td style="text-align:center">Yes</td>
</tr>
<tr>
<td style="text-align:center">Jalangi [9]</td>
<td style="text-align:center">JavaScript</td>
<td style="text-align:center">No</td>
<td style="text-align:center">No</td>
<td style="text-align:center">Limited</td>
</tr>
</tbody>
</table>
</div>
<center>
    <i>表I 符号执行器的比较</i>
</center>


<p>​        为了实现目标程序的符号执行，本文修改了原始Rhino对表II中所示指令的解释。堆栈操作、异常处理和变量范围管理的指令处理保持不变。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">操作</th>
<th style="text-align:center">指令</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Arithemetic/Logical Operations</td>
<td style="text-align:center">ADD, SUB, MUL, DIV, MOD, NEG, POS, BITNOT, BITAND, BITOR, BITXOR, LSH, RSH,URSH <em>etc.</em></td>
</tr>
<tr>
<td style="text-align:center">Comparisons</td>
<td style="text-align:center">EQ, NE, GE, GT, LE, LT, NOT, SHEQ, SHNE <em>etc.</em></td>
</tr>
<tr>
<td style="text-align:center">Branches</td>
<td style="text-align:center">IFEQ, IFNE, IFEQ_POP <em>etc.</em></td>
</tr>
<tr>
<td style="text-align:center">Function Calls</td>
<td style="text-align:center">RETURN, CALL, TAIL_CALL <em>etc.</em></td>
</tr>
<tr>
<td style="text-align:center">Object Manipulations</td>
<td style="text-align:center">NEW, REF, IN, INSTANCEOF, TYPEOF, GETNAME, SETNAME, NAME <em>etc.</em></td>
</tr>
<tr>
<td style="text-align:center">Object Accesses</td>
<td style="text-align:center">GETPROP, SETPROP, DELPROP, GETELEM, SETELEM, GETREF, SETREF <em>etc.</em></td>
</tr>
</tbody>
</table>
</div>
<center>
    <i>表II 修改后的指令解释</i>
</center>
例如，指令 `ADD op1 op2` 解释如下：

(1)从堆栈中弹出操作数 `op1` 和 `op2` 。操作数可以使用抽象的值，也可以使用具体的值。

(2)检查操作数的类型。如果两个操作数都是字符串，则计算结果是操作数的拼接。如果它们是数值，则结果是操作数的总和。否则，将**根据ECMAScript语言标准转换值**，结果是将获得的值拼接或相加。

#### 分支指令

​        比较指令之后是Rhino字节码中的分支指令。SymJS处理比较和分支指令对，如下所示：

​        首先，在进行必要的类型转换后，生成与比较结果相对应的布尔公式。假设所创建的公式由符号 $c$ 表示，我们检查 $c$ 及其否定 $\neg c$ 是否与路径条件 $pc$ 一起满足。换句话说，我们检查 $pc \land c$ 和 $pc \land \neg c$ 的可满足性。如果两者都是可满足的，我们建立对应于 $pc \land c$ 和 $pc \land \neg c$ 的状态 $s_1, s_2$，并从状态 $s_1$ 和 $s_2$ 继续执行。如果其中一个是可满足的，则选择与可满足的状态相对应的状态，并从该点继续执行。

​        SymJS支持两种方式来管理在命中分支等情况下创建的状态。第一种方法是**存储程序状态变量，包括堆/栈的内容**，如[2] [3]中所做的那样。第二种方法是**只记住在分支上走哪一侧。此方法需要在回溯时从初始状态重新执行目标程序。**但是，它得益于其简单的实现和较小的内存占用。这种方法被称为“模糊”，类似于[4] [6]中介绍的技术。但是，本文的技术是在符号执行器上实现的，不需要修改现有JavaScript工具[8] [9]所需的目标代码。

​        在通过模糊化执行程序的符号过程中，状态仅由分支上的哪一方表示和存储。该信息可用于从程序的初始状态重新执行该程序，并探索目标可能采取的状态空间。在模糊化期间，用与表I中的测试1-6相对应的路径条件符号执行图1中的目标程序之后的状态如表IV所示。符号L、R表示在分支指令上走左/右分支。

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func0</span> (<span class="params">s, a</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(””.equals(s)) &#123; <span class="comment">// block 0</span></span><br><span class="line">		s = <span class="literal">null</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (s.length &lt;= <span class="number">5</span>) &#123; <span class="comment">// block 1</span></span><br><span class="line">			a = a + status;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span>(””.equals(s)) &#123; <span class="comment">// block 2</span></span><br><span class="line">				Lib.m0(); <span class="comment">// Unreachable</span></span><br><span class="line">			&#125; <span class="keyword">else</span> &#123; <span class="comment">// block 3</span></span><br><span class="line">				Lib.m1();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (a &lt;= Lib.m2()) &#123; <span class="comment">// block A</span></span><br><span class="line">	a = <span class="number">0</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123; <span class="comment">// block B</span></span><br><span class="line">	a = a + s.length; <span class="comment">// Error with null s</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<center>
    <i>图1 一个代码框架：
    s, a, Lib.m2()可以取任意值</i>
</center>



<p><img src="http://images.yingwai.top/picgo/SymJSf2.png" alt=""></p>
<center>
    <i>图2 代码执行路径</i>
</center>



<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">Test No.</th>
<th style="text-align:left">Blocks Executed</th>
<th>State Representation</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:left">0, A</td>
<td>L;L</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:left">0, B</td>
<td>L;R</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:left">1, A</td>
<td>R;L;L</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:left">1, B</td>
<td>R;L;R</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:left">3, A</td>
<td>R;R;R;L</td>
</tr>
<tr>
<td style="text-align:center">6</td>
<td style="text-align:left">3, B</td>
<td>R;R;R;R</td>
</tr>
</tbody>
</table>
</div>
<center>
    <i>表IV 执行图1代码后的模糊表示</i>
</center>



<h4 id="PASS"><a href="#PASS" class="headerlink" title="PASS"></a>PASS</h4><p>​        对于表IV中的每个状态表示，可以获得相应的路径条件。如果有可能获得满足约束条件的解，则可以将其用作测试期间的输入。关于数值的约束可以通过SMT求解器来解决，但<strong>SMT不能处理对于字符串的约束</strong>。因此本文使用约束求解器PASS。</p>
<p>​        <strong>PASS可以处理对整数、位向量、浮点数和字符串的约束。</strong>虽然以前的支持字符串约束的约束解算器使用位向量或自动机，但通过参数化数组传递引入的建模可以实现更高效的求解。因此，它可以解决ECMAScript标准中与字符串操作相对应的大部分约束。</p>
<h4 id="符号存根及驱动程序"><a href="#符号存根及驱动程序" class="headerlink" title="符号存根及驱动程序"></a>符号存根及驱动程序</h4><p>​        符号变量是通过符号执行生成测试输入的对象。<strong>SymJS允许通过函数调用定义符号变量。</strong>下面的代码片段展示了定义符号字符串变量的例子：</p>
<p><code>var s = symjs_mk_symbol_string();</code></p>
<p>​        以上的例子定义了字符串类型的符号变量，也可以通过<code>symjs_mk_symbolic_int()</code>、<code>symjs_mk_symbolic_bool()</code>和<code>symjs_mk_symbolic_real()</code>分别定义整型、布尔型以及浮点型的符号变量。虽然SymJS只允许字符串、整数、布尔值和浮点数是符号的，但它们的约束作为更复杂的对象的组成部分保留在赋值/引用上，从而允许生成对象组成部分的值不断变化的测试。</p>
<p>​        为了确定图1中函数<code>func0()</code>的测试输入，需要额外的代码段。首先需要一个如下所示的符号驱动程序：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s = symjs_mk_symbolic_string();</span><br><span class="line"><span class="keyword">var</span> a = symjs_mk_symbolic_float();</span><br><span class="line">func0(s, a);</span><br></pre></td></tr></table></figure>
<center>
    <i>图3 用于执行图1中代码的符号驱动程序</i>
</center>

<p>驱动程序声明符号变量并将它们作为参数传递给函数。注入依赖项的存根也是必需的。如下所示的符号存根包括符号变量声明。通过存根，包含对<code>Lib.m2()</code>的函数调用的返回值，以测试SymJS获得的输入。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Lib.m2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> symjs_mk_symbolic_float();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>
    <i>图4 提供图1中代码使用的Lib.m2()的符号存根</i>
</center>

<p>函数<code>symjs_mk_symbolic_*()</code>是用于在测试生成期间定义新符号变量的表达式。<strong>SymJS允许使用生成的测试输入进行正常的具体执行。</strong>在具体执行期间，函数返回测试输入中包含的具体值。SymJS可以将测试输入导出为JavaScript Object Notation (JSON) 格式的外部文件。文件可以由测试回放库读取，该库在<code>symjs_mk_symbolic_*()</code>函数调用中返回相应的测试输入数据。加载到典型Web浏览器中的测试库可以在没有自定义JavaScript解释器的情况下执行生成的测试。</p>
<h2 id="符号存根及驱动程序的自动生成"><a href="#符号存根及驱动程序的自动生成" class="headerlink" title="符号存根及驱动程序的自动生成"></a>符号存根及驱动程序的自动生成</h2><p>​        如第2部分所述，符号存根和驱动程序需要对目标函数进行符号执行并获得测试输入。返回符号变量的符号存根用于生成从被测函数调用的函数的返回值。需要符号驱动程序来改变传递给测试函数的参数。</p>
<h3 id="生成符号存根和驱动程序的策略"><a href="#生成符号存根和驱动程序的策略" class="headerlink" title="生成符号存根和驱动程序的策略"></a>生成符号存根和驱动程序的策略</h3><p>​        本文的符号存根生成技术为指定的函数和类生成存根。本文的驱动程序生成技术发出调用指定函数的代码。</p>
<p>​        对于存根生成，生成函数根据调用者期望的返回值类型，创建和返回对象。以下是预期类型与返回对象之间的映射关系：</p>
<ul>
<li><p>字符串、整数、布尔值和浮点数这些可以被SymJS作为符号处理的类型（后面称为SymJS基础类型）：</p>
<p>新定义的相应类型的符号变量。</p>
</li>
<li><p>其他类：</p>
<p>预期类型的新实例化对象。如果该类的目标是生成存根，则返回<strong>新实例化的存根对象</strong>。</p>
</li>
<li><p>Void：不返回任何内容。</p>
</li>
</ul>
<p>​        为了创建类的存根，还需要生成构造函数的存根。在这里，本文生成空构造函数，这将导致所有无状态对象。我们的方法假设没有对存根类的字段的直接访问，并且不为字段生成存根。</p>
<p>​        注意：即使返回值类型不是SymJS的基本类型，也可能得到多个测试输入。如果在返回的对象中定义的函数返回符号变量，会出现这种情况。如果<strong>非SymJS基本类型的对象包含返回SymJS基本类型的对象的函数，并且非SymJS基本类型生成了存根</strong>，就会发生这种情况。因此可以通过调用返回非SymJS基本类型的函数来获得多组测试输入。</p>
<p>​        使用本文的技术生成的符号驱动程序具有以下功能：</p>
<ul>
<li>如果待测函数不是静态的、需要一个实例去执行，则实例化对应类的对象并调用该函数</li>
<li>如果待测函数是静态的，就直接调用函数</li>
</ul>
<p>对于传递给函数的参数，驱动程序根据预期类型提供以下对象：</p>
<ul>
<li><p>SymJS基本类型：</p>
<p>新定义的相应类型的符号变量。</p>
</li>
<li><p>其他类：</p>
<p>预期类型的新实例化对象。如果该类的目标是存根生成，则传递新实例化的存根对象。</p>
</li>
</ul>
<p>​        选择参数的方式类似于解决在符号存根中返回什么的方式。</p>
<h3 id="从注释生成符号存根和驱动程序"><a href="#从注释生成符号存根和驱动程序" class="headerlink" title="从注释生成符号存根和驱动程序"></a>从注释生成符号存根和驱动程序</h3><p>​        上一部分提出的符号存根/驱动程序生成策略需要知道来自目标代码的类型信息，生成存根需要调用方期望的返回值类型，需要传递给被测函数的参数类型才能生成驱动程序。</p>
<p>​        但是JavaScript是一种动态类型语言，在真正运行前很难确定返回值和参数的类型。很多JavaScript程序对返回值和参数的类型有一个期望，通常是在应用程序编程接口（API）等中给出的。此外，有一种方法可以<strong>用机器可读的方式表示JavaScript代码的类型信息</strong>，就是JSDoc风格的注释。本文从JSDoc3[13]约定的风格的注释中获取类型信息，生成符号存根和驱动程序。</p>
<p>​        JSDoc3主要允许通过<code>@return</code>注释声明返回值类型。为了为图1的代码片段中使用的函数<code>Lib.m2()</code>生成符号存根，需要如下所示的注释：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** <span class="doctag">@return <span class="type">&#123;Number&#125;</span> </span>m2 value */</span></span><br><span class="line">Lib.m2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; ... &#125;;</span><br></pre></td></tr></table></figure>
<p>如果将此类注释附加到函数的原始源代码，则可以确定返回值的类型。根据获得的返回值类型，可以以全自动的方式生成图4中的符号存根。该示例演示了为返回SymJS原语的函数生成符号存根。下面展示了为返回非SymJS基本类型的函数生成符号存根的示例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** <span class="doctag">@return <span class="type">&#123;tx.Data&#125;</span> </span>data */</span></span><br><span class="line">tx.Ui.getValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; ... &#125;;</span><br></pre></td></tr></table></figure>
<center>
    ↓
</center>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">tx.Ui.getValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> tx.Data();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>​        符号驱动程序的生成也是一样的。</p>
<p>​        传递给函数的参数类型通常使用JSDoc3的<code>@param</code>注释给出。函数<code>func0()</code>的符号驱动程序可以从该函数中的注释生成：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** <span class="doctag">@param <span class="type">&#123;String&#125;</span> <span class="variable">s</span></span></span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param <span class="type">&#123;Number&#125;</span> </span>a */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func0</span>(<span class="params">s, a</span>) </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>注释给出了函数的参数类型，允许生成图3中的符号驱动程序。</p>
<p>​        提出的自动生成符号存根和驱动程序的技术是作为JSDoc3的插件实现的。也可以使用其他来源的类型信息，例如API规范文档。</p>
<h2 id="Evaluation"><a href="#Evaluation" class="headerlink" title="Evaluation"></a>Evaluation</h2><p>​        本文使用一个工业JavaScript程序进行了实验。该程序对应于在本文的自定义Web应用程序实现框架上实现的Web应用程序的客户端部分。该程序调用未在我们的框架中包装的ECMAScript标准中定义的API，并且它只包含对标准API或本文的框架的调用。表V显示了目标程序的统计数据：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">#Line</th>
<th style="text-align:center">#Function</th>
<th style="text-align:center">#File</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">431</td>
<td style="text-align:center">23</td>
<td style="text-align:center">1</td>
</tr>
</tbody>
</table>
</div>
<center>
    <i>表V 目标程序的统计数据</i>
</center>

<h3 id="符号存根和驱动程序的生成"><a href="#符号存根和驱动程序的生成" class="headerlink" title="符号存根和驱动程序的生成"></a>符号存根和驱动程序的生成</h3><p>​        使用本文的方法成功地为框架中定义的所有类和函数生成存根。表VI列出了生成的存根的统计数据：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">#Line(Orig.)</th>
<th style="text-align:center">#Line(Stub)</th>
<th style="text-align:center">#Function</th>
<th style="text-align:center">#File</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">2843</td>
<td style="text-align:center">1304</td>
<td style="text-align:center">154</td>
<td style="text-align:center">13</td>
</tr>
</tbody>
</table>
</div>
<center>
    <i>表VI 用于生成存根的框架源代码和生成的存根的统计数据</i>
</center>

<h3 id="生成测试输入和执行测试"><a href="#生成测试输入和执行测试" class="headerlink" title="生成测试输入和执行测试"></a>生成测试输入和执行测试</h3><p>​        所有函数的符号执行在1秒内完成，并生成测试输入。测试输入的数量（将具体值赋给符号变量）在目标函数之间是不同的。对于没有分支的函数，只生成1个测试输入，而对于更复杂的函数，获得的测试数量变化到27个。</p>
<p>​        利用获得的测试输入来具体执行目标函数。运行在网络浏览器上的测试回放库用于重放测试。使用JSCover[14]测量测试期间的代码覆盖率，获得92%的行覆盖率。结果表明，该技术能够自动生成单元测试输入，实现高代码覆盖率。</p>
<h3 id="实验中未覆盖的代码"><a href="#实验中未覆盖的代码" class="headerlink" title="实验中未覆盖的代码"></a>实验中未覆盖的代码</h3><p>​        实验结果表明，该方法可以生成代码覆盖率较高的测试输入，但没有达到100%的覆盖率，这意味着目标程序的某些部分没有被执行。以下是使用我们的方法未执行到的代码类。</p>
<p>​        <strong>意外类型的代码处理对象没有被覆盖到。</strong>由于JavaScript是一种动态类型语言，函数可能会返回意外类型的对象。为了处理这种情况，目标程序包含类型检查和后续错误处理代码。但是，通过本文的技术生成的符号存根总是返回源代码批注中描述的类型的对象。这样的存根不能利用处理不同于注释类型的对象的代码部分。</p>
<p>​        <strong>没有对象类型前提的代码也没有被覆盖到。</strong>目标程序包含在运行时确定对象类型并相应地处理它们的代码片段。然而，本文的技术不能涵盖这样的程序。从返回值类型未知的函数中，我们生成返回默认JavaScript “Object” 的存根。因此，与自定义类的对象交互的代码没有被覆盖。</p>
<h2 id="Conclusions"><a href="#Conclusions" class="headerlink" title="Conclusions"></a>Conclusions</h2><p>​        本文提出了一种为JavaScript代码自动生成单元测试输入数据的技术。该技术使用符号执行引擎，以便在测试期间实现高代码覆盖率。该技术分为两个阶段，由以下全自动步骤组成：</p>
<ul>
<li>基于从注释获得的类型信息生成符号存根/驱动程序</li>
<li>通过目标代码的符号执行生成测试输入</li>
</ul>
<p>​        实验结果显示，该技术可以生成92%的行覆盖率的测试，表明本文的技术可以自动生成和执行JavaScript代码的单元测试。</p>
<h3 id="Future-Work"><a href="#Future-Work" class="headerlink" title="Future Work"></a>Future Work</h3><p>​        未来的方向包括更多的验证试验和各种目标程序。虽然作者已经用相对较小的程序进行了实验，但也需要在较大的目标上进行实验。</p>
<p>​        根据实验结果，需要改进符号存根。可以使用引发异常的符号存根触发代码处理异常。除了更复杂的自动存根生成策略外，手动修改自动生成的存根被认为是增加覆盖率的有效方法。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1] C. Cadar, V . Ganesh, P . M. Pawlowski, D. L. Dill, and D. R. Engler, <em>“EXE: Automatically Generating Inputs of Death,”</em> in Proceedings of the 13th ACM Conference on Computer and Communications Security, 2006, pp. 322–335.</p>
<p>[2] C. Cadar, D. Dunbar, and D. Engler, <em>“KLEE: Unassisted and Automatic Generation of High-coverage Tests for Complex Systems Programs,”</em> in Proceedings of the 8th USENIX Conference on Operating Systems Design and Implementation, 2008, pp. 209–224.</p>
<p>[3] C. S. Pǎsǎreanu and N. Rungta, <em>“Symbolic PathFinder: Symbolic Execution of Java Bytecode,”</em> in Proceedings of the IEEE/ACM International Conference on Automated Software Engineering, 2010, pp. 179–180.</p>
<p>[4] K. Sen, D. Marinov, and G. Agha, <em>“CUTE: A Concolic Unit Testing Engine for C,”</em> in Proceedings of the 10th European Software Engineering Conference, 2005, pp. 263–272.</p>
<p>[5] N. Tillmann and J. De Halleux, <em>“Pex: White Box Test Generation for .NET,”</em> in Proceedings of the 2nd International Conference on Tests and Proofs, ser. TAP’08, 2008, pp. 134–153.</p>
<p>[6] P . Godefroid, M. Y . Levin, and D. Molnar, <em>“SAGE: Whitebox Fuzzing for Security Testing,”</em> Queue, 2012, pp. 20:20–20:27.</p>
<p>[7] L. De Moura and N. Bjørner, <em>“Satisfiability Modulo Theories: Introduction and Applications,”</em> Commun. ACM, vol. 54, no. 9, 2011, pp. 69–77.</p>
<p>[8] P. Saxena, D. Akhawe, S. Hanna, F. Mao, S. McCamant, and D. Song, <em>“A Symbolic Execution Framework for JavaScript,”</em> in Proceedings of the 2010 IEEE Symposium on Security and Privacy, 2010, pp. 513–528.</p>
<p>[9] K. Sen, S. Kalasapur, T. Brutch, and S. Gibbs, <em>“Jalangi: A selective record-replay and dynamic analysis framework for javascript,”</em> in Proceedings of the 2013 9th Joint Meeting on Foundations of Software Engineering, 2013, pp. 488–498.</p>
<p>[10] G. Li and I. Ghosh, <em>“PASS: String Solving with Parameterized Array and Interval Automaton,”</em> in Proceedings of Haifa Verification Conference, 2013, pp. 15–31.</p>
<p>[11] ECMA International, Standard ECMA-262 - ECMAScript Language Specification, 5th ed., June 2011. [Online]. Available: <a href="http://www.ecma-international.org/publications/standards/Ecma-262.htm" target="_blank" rel="noopener">http://www.ecma-international.org/publications/standards/Ecma-262.htm</a></p>
<p>[12] <em>“Rhino,”</em> <a href="https://developer.mozilla.org/en-US/docs/Rhino" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Rhino</a>, [Online; accessed 2014.08.15].</p>
<p>[13] <em>“Use JSDoc,”</em> <a href="http://usejsdoc.org/index.html" target="_blank" rel="noopener">http://usejsdoc.org/index.html</a>, [Online; accessed 2014.08.15].</p>
<p>[14] <em>“JSCover - JavaScript code coverage,”</em> <a href="http://tntim96.github.io/JSCover/" target="_blank" rel="noopener">http://tntim96.github.io/JSCover/</a> <a href="http://usejsdoc.org/index.html" target="_blank" rel="noopener">http://usejsdoc.org/index.html</a>, [Online; accessed 2014.08.15].</p>
]]></content>
      <categories>
        <category>Papers</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title>论文笔记 EaSTFLy: Efficient and secure ternary federated learning</title>
    <url>/2020/04/20/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0-EaSTFLy-Efficient-and-secure-ternary-fe-derate-d-learning/</url>
    <content><![CDATA[<p><em>Ye Dong, Xiaojun Chen, Liyan Shen, Dakui Wang</em></p>
<p><a href="https://www.sciencedirect.com/science/journal/01674048" target="_blank" rel="noopener">Computers &amp; Security</a>   <a href="https://www.sciencedirect.com/science/journal/01674048/94/supp/C" target="_blank" rel="noopener">Volume 94</a>, July 2020, 101824</p>
<p><a href="https://www.sciencedirect.com/science/article/pii/S0167404820300985" target="_blank" rel="noopener">https://www.sciencedirect.com/science/article/pii/S0167404820300985</a></p>
<a id="more"></a>
<h2 id="摘要及介绍"><a href="#摘要及介绍" class="headerlink" title="摘要及介绍"></a>摘要及介绍</h2><h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3>]]></content>
      <categories>
        <category>Papers</category>
      </categories>
      <tags>
        <tag>密码学</tag>
        <tag>加密机器学习</tag>
        <tag>联邦学习</tag>
      </tags>
  </entry>
  <entry>
    <title>论文笔记 Eﬀicient Multi-Key Homomorphic Encryption with Packed Ciphertexts with Application to Oblivious Neural Network Inference</title>
    <url>/2020/04/19/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0-E%EF%AC%80icient-Multi-Key-Homomorphic-Encryption-with-Packed-Ciphertexts-with-Application-to-Oblivious-Neural-Network-Inference/</url>
    <content><![CDATA[<p><em>Hao Chen, Wei Dai, Miran Kim, Yongsoo Song</em></p>
<p>CCS 2019</p>
<p><a href="https://dl.acm.org/doi/10.1145/3319535.3363207" target="_blank" rel="noopener">https://dl.acm.org/doi/10.1145/3319535.3363207</a></p>
<p><a href="https://eprint.iacr.org/2019/524" target="_blank" rel="noopener">https://eprint.iacr.org/2019/524</a></p>
<a id="more"></a>
<h2 id="摘要及介绍"><a href="#摘要及介绍" class="headerlink" title="摘要及介绍"></a>摘要及介绍</h2><h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>​        <em>同态加密（Homomorphic Encryption）</em>是一种<strong>支持对加密数据进行计算的密码系统</strong>。López-Alt等人（STOC 2012）提出了一种广义的HE概念，称为多密钥同态加密(MKHE)，它能够对用不同密钥加密的密文进行算术运算。</p>
<p>​        在这篇文章中，作者提出了<strong>两个打包密文的HE方案的多密钥变体</strong>。本文提出了新的<strong>重新线性化算法</strong>，这些算法比Chen等人（TCC 2017）的方法更简单、更快。然后，本文推广了HE的自举技术，以获得多密钥完全同态加密方案。本文使用Microsoft SEAL提供了这两个MKHE方案的概念验证实现。例如，当基环的维度为8192时，四方之间的多密钥BFV（resp. CKKS）密文做同态乘法，然后重新线性化所花的时间约为116（resp. 67）毫秒。</p>
<p>​        本文的MKHE方案在多个数据提供者之间的安全计算中有广泛的应用。作为基准，本文使用预先训练好的神经网络模型对图像进行同态分类，其中输入数据和模型在不同的密钥下加密。我们的实现大约需要1.8秒来评估来自MNIST数据集的加密图像上的一个卷积层和两个全连接层。</p>
<h4 id="关键词"><a href="#关键词" class="headerlink" title="关键词"></a>关键词</h4><p><em>多密钥同态加密；打包密文；LWE困难问题；神经网络</em></p>
<h3 id="早期研究"><a href="#早期研究" class="headerlink" title="早期研究"></a>早期研究</h3><p>​        <strong>同态加密</strong>是一种密码系统，它允许在<strong>不解密的情况下对加密数据进行计算</strong>，从而能够在不受信任的云中安全地外包计算。在Gentry的第一次构造之后，HE已经有了重大的技术进步[24]。例如，可以将多个明文值加密成单个打包密文，并使用单指令多数据（SIMD）技术并行地对这些值执行操作[26，48]。因此，具有打包技术的HE方案[6，7，16，22]具有良好的明文值摊销复杂度，并已被应用于隐私保护的大数据分析[11，37，39]。然而，传统的HE方案只允许对可在相同密钥下解密的密文进行计算。因此，HE自然不支持涉及多个数据提供商、每个数据提供商都提供自己的密钥的安全计算应用程序。</p>
<p>​        López-Alt等人[43]提出了一种多密钥同态加密（MKHE）方案，该方案是一种支持对密文进行算术运算的密码协议，密文不一定可以解密到同一密钥。除了解决上述HE问题外，MKHE还可以用来设计通信开销最小的高效MPC协议[45]。此外，MKHE的MPC协议满足即时MPC[43]属性，其中，在数据提供商上传其加密数据后，可以动态决定要评估的电路。</p>
<p>​        尽管MKHE具有多功能性，但在实践中很少使用。早期研究[19，45，46]使用了GSW方案的多密钥变体[28]。使用这些方法构造的密文很大，并且它们的性能不能很好地随参与方的数量而变化。以前的工作[8，10]提出了具有短密文的MKHE方案，但一个密文只能加密一个比特。现有的唯一具有打包密文的MKHE方案[13，41]是BGV方案[7]的多密钥变体。请注意，所有上述研究都是纯粹抽象的，没有给出实现，支持SIMD操作的MKHE方案是否实用仍然是一个悬而未决的问题。</p>
<h3 id="贡献"><a href="#贡献" class="headerlink" title="贡献"></a>贡献</h3><ul>
<li>设计了BFV[6, 22]和CKKS[16]方案的多密钥变体；</li>
<li>提出了一种新的生成重线性化密钥的方法，与[13]中的技术相比更简单而且更快；</li>
<li>将[9, 12, 14]的最新自举算法应用于多密钥场景；</li>
<li>使用Microsoft SEAL[47]给出了方案的概念验证实现，是支持打包密文的MKHE方案的第一个实际实现</li>
</ul>
<p>本文还提出了MKHE的第一个可行的应用，它安全地评估了预先训练的卷积神经网络（CNN）模型。本文构建了一个高效的协议，云服务器使用模型提供者提供的分类器为数据所有者提供在线预测服务，同时使用MKHE保护数据和模型的隐私。如图1所示，我们的方案支持多密钥操作，使得以较低的端到端延迟和接近最佳的数据和模型提供者成本来实现这一点。服务器可以存储以不同密钥加密的大量密文，但是特定任务的计算成本仅取决于与电路相关的各方的数量。我们注意到，我们的解决方案比单密钥HE更有优势，因为ML模型提供者不需要将未加密的模型发送到服务器。</p>
<p><img src="http://images.yingwai.top/picgo/EMKHEf1.png" alt=""></p>
<center>
    <i>图1 不经意神经网络预测的概述</i>
</center>

]]></content>
      <categories>
        <category>Papers</category>
      </categories>
      <tags>
        <tag>密码学</tag>
        <tag>神经网络</tag>
        <tag>加密机器学习</tag>
        <tag>同态加密</tag>
      </tags>
  </entry>
</search>
