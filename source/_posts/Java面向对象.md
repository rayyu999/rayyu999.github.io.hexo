---
title: Java面向对象
date: 2020-08-27 11:05:17
categories: Coding
tags: [Java, 面向对象]
---

----

<!--more-->

# Java面向对象

## 继承

* 继承：是指在一个现有类的基础上去构建一个新的类，构建出来的新类被称作子类，现有类被称作父类，子类会自动拥有父类所有。

* 继承的好处：可继承的属性和方法。

  * 提高了代表的可维护性
  * 提高了代码的复用性
  * 让类与类之间产生了继承关系

* 继承的弊端：

  * 类与类之间的耦合度过高

* 继承特点：

  * java中类只能够单继承，不能多继承，可以多层继承

    ```java
    class Yy extends Object {}
    
    class Fu extends Yy{}
    
    class Zi extends Fu {}
    ```

    所有的类都直接或者间接的继承了 Object类，Object类称为祖宗类

* 继承的注意事项：

  1. 使用关键字 `extends` 让类与类之间 产生继承关系

  2. 父类私有的成员，子类不能继承，因为根本看不到

  3. 不能为了继承某个功能而随意进行继承操作， 必须要符合 is a 的关系

     苹果 is a 水果

     男人 is a 人

     狗  is a 人 ， 这种情况就不能继承了

* 继承中的成员变量关系：

  * 不同名的变量：

    子类直接继承使用

  * 同名的变量：

    默认访问的是子类自己的成员变量, 想访问父类中的同名变量，请使用 `super.成员变量;`

* 继承中的成员方法关系：

  * 不同名的方法：

    子类直接继承使用

  * 同名的方法：

    默认访问的是子类自己的成员方法，想访问父类中的同名方法，请使用 super.成员方法();



* super:用来表示当前对象中包含的父类对象空间的引用

  * 调用父类的成员变量：

    `super.成员变量;`

  * 调用方法的成员方法:

    `super.成员方法();`

* 方法重写(override)：指在子父类中，出现了方法声明相同的情况，也叫做方法覆盖，方法复写

  * 方法重写的注意事项：
    1. 子类的方法声明要与父类相同
    2. 子类要重写方法的方法，方法的权限修饰符不能比父类的更低
    3. 父类私有的方法，子类不能够进行方法重写

* 方法重载(overload)：指 在同一个类中，多个方法名称相同，它们的参数列表不同(个数不同，数据类型不同)



## 抽象

* 抽象方法： 方法只有声明部分，没有方法体

* 抽象类： 包含抽象方法的类，一定是抽象类

  使用 `abstract` 修饰的类，是抽象类

* 抽象类的特点：

  1. 抽象类与抽象方法都必须使用 `abstract` 来修饰
  2. 抽象类不能直接创建对象
  3. 抽象类中可以有抽象方法，也可以没有抽象方法
  4. 抽象类的子类
     * 实现了抽象方法的具体类
     * 抽象类

* 抽象类面试题：

  1. 抽象类中是否可以没有抽象方法？如果可以，那么，该类还定义成抽象类有意义吗？为什么？
  2. 可以没有抽象方法，有意义，不会让其他人直接创建该类对象



## 接口

接口是功能的集合，同样可看做是一种数据类型，是比抽象类更为抽象的”类”。
接口只描述所应该具备的方法，并没有具体实现，具体的实现由接口的实现类(相当于接口的子类)来完成。这样将功能的定义与实现分离，优化了程序设计。
请记住：一切事物均有功能，即一切事物均有接口。

接口的出现避免了单继承的局限性。父类中定义的事物的基本功能。接口中定义的事物的扩展功能。



### 接口的特点

1. 定义一个接口用 `interface` 关键字：

   ```java
   public interface 接口名 {
       抽象方法1;
       抽象方法2;
   }
   ```

2. 一个类实现一个接口，实现 `implements` 关键字：

   ```java
   class 类名 implements 接口名 {
       
   }
   ```

3. 接口不能直接创建对象

   通过多态的方式，由子类来创建对象，接口多态。



### 接口中的成员特点

* 成员变量：

  只能是 `final` 修饰的常量

  默认修饰符：`public static final`

* 构造方法：

  无

* 成员方法：

  只能是抽象方法

  默认修饰符：`public abstract`



### 类与类、类与接口、接口与接口之间的关系

* 类与类：

  继承关系，单继承，可以是多层继承

* 类与接口：

  实现关系，单实现，也可以多实现（因为没有方法冲突的问题）

* 接口与接口：

  继承关系，单继承，也可以是多继承

Java中的类可以继承一个父类的同时，实现多个接口



## 多态

多态是继封装、继承之后，面向对象的第三大特性。

现实事物经常会体现出多种形态，如学生，学生是人的一种，则一个具体的同学张三既是学生也是人，即出现两种形态。

Java作为面向对象的语言，同样可以描述一个事物的多种形态。如Student类继承了Person类，一个Student的对象便既是Student，又是Person。

Java中多态的代码体现在一个子类对象(实现类对象)既可以给这个子类(实现类对象)引用变量赋值，又可以给这个子类(实现类对象)的父类(接口)变量赋值。

如Student类可以为Person类的子类。那么一个Student对象既可以赋值给一个Student类型的引用，也可以赋值给一个Person类型的引用。

最终多态体现为父类引用变量可以指向子类对象。

多态的前提是必须有子父类关系或者类实现接口关系，否则无法完成多态。

在使用多态后的父类引用变量调用方法时，会调用子类重写后的方法。



### 多态使用的前提

1. 有继承或者实现关系
2. 要方法重写
3. 父类引用指向子类对象



### 多态的成员访问特点

方法的运行看右边（子类，若为静态方法则为父类），其它（例如成员变量）都看左边（父类）。



### 多态的利弊

好处：提高了程序的扩展性

弊端：不能访问子类特有的功能



### 多态的分类

* 类的多态

  ```java
  abstract class Fu {
      public abstract void method();
  }
  class Zi extends Fu {
  	public void method(){
  		System.out.println(“重写父类抽象方法”);
  	}
  }
  //类的多态使用
  Fu fu= new Zi();
  ```

* 接口的多态

  ```java
  interface Fu {
  	public abstract void method();
  }
  class Zi implements Fu {
  	public void method(){
          System.out.println(“重写接口抽象方法”);
  }
  }
  //接口的多态使用
  Fu fu = new Zi();
  ```



## `instanceof` 关键字

格式：`对象名 instanceof 类名`

返回值：`true, false`

作用：判断指定的对象是否为给定类创建的对象



## `this` 关键字

`this` 关键字，本类对象的引用

* `this` 是在方法中使用的，哪个对象调用了该方法，那么 `this` 就代表调用该方法的对象引用

* `this` 什么时候存在的？当创建对象的时候，`this` 存在的

* `this` 的作用：用来区别同名的成员变量与局部变量（`this.成员变量`）

  ```java
  public void setName(String name) {
      this.name = name;
  }
  ```



## 构造方法

用来给类的成员进行初始化操作

* 格式：

  ```java
  修饰符 类名 (参数列表) {
      ...
  }
  ```

* 构造方法的特点：

  1. 方法名与类名想同
  2. 没有返回值，也没有返回值类型，连 `void` 也没有

* 构造方法什么时候会被调用执行？

  只有在创建对象的时候才可以被调用



## `super` 关键字

指的是父类的存储空间（理解为父类的引用）

* 调用父类的成员变量：

  `super.成员变量;`

* 调用父类的构造方法：

  `super(参数);`

* 调用方法的成员方法：

  `super.成员方法();`



## 继承中的构造方法注意事项

1. 如果我们手动给出了构造方法，编译器不会再给我们提供默认的空参数构造方法；

   如果我们没有写任何的构造方法，编译器提供给我们一个空参数构造方法

2. 在构造方法中，默认的第一条语句为 `super();`

   它是用来访问父类中的空参数构造方法，进行父类成员的初始化操作

3. 当父类中没有空参数构造方法的时候，怎么办？

   * 通过 `super(参数);` 访问父类有参数的构造方法

   * 通过 `this(参数);` 访问本类中其他构造方法

     注意：*本类中的其他构造方法已经能够正常访问父类构造方法*

4. `super(参数);` 与 `this(参数);` 不能同时在构造方法中存在



## `final`

关键字，最终的意思。

* `final` 修饰的类：最终的类，不能被继承。
* `final` 修饰的变量：相当于是一个常量，在编译生成 .class 文件后，该变量未常量值。
* `final` 修饰的方法：最终的方法，子类不能重写，可以继承过来使用。



## `static` 

关键字，静态的意思。

可以用来修饰类中的成员（成员变量，成员方法）

注意：也可以用来修饰成员内部类

* 特点：

  被静态所修饰的成员，会被所有的对象所共享

  被静态所修饰的成员，可以通过类名直接调用，方便

  * `Person.county = "中国";`
  * `Person.method();`

* 注意事项：

  静态的成员，随着类的加载而加载，优先于对象存在

  在静态方法中，没有 `this` 关键字

  静态方法中，只能调用静态的成员（静态成员变量，静态成员方法）

![静态的共享数据](http://images.yingwai.top/picgo/JavaSE13f2.JPG)

<center>
    <i>静态的共享数据</i>
</center>





![静态的内存图](http://images.yingwai.top/picgo/JavaSE13f1.JPG)

<center>
    <i>静态的内存图</i>
</center>





## 匿名对象

一个没有名字的对象。

* 特点：

  创建匿名对象直接使用，没有对象名

  匿名对象在没有指定其引用变量时，只能使用一次

  匿名对象可以作为方法接收得参数、方法返回值使用



## 内部类

在一个类中，定义了一个新类，这个新的类就是内部类。

```java
class A { // 外部类
    class B { // 内部类
    }
}
```

* 特点

  内部类可以直接访问外部类的成员，包含私有的成员



## 包的声明与访问

* 类中包的声明格式：

  `package 包名.包名.包名…;`

* 带有包的类，创建对象格式：`包名.类名 变量名 = new 包名.类名();`

  `cn.itcast.Demo d = new cn.itcast.Demo();`

* 导包的格式：

  `import 包名.类名;`



## 权限修饰符

`public`：公共的

`protected`：受保护的

`default`：默认的（可以不写）

`private`：私有的

|                  | `public` | `protected` | `default` | `private` |
| ---------------- | :------: | :---------: | :-------: | :-------: |
| 在当前类中       | $\surd$  |   $\surd$   |  $\surd$  |  $\surd$  |
| 同一包中的其他类 | $\surd$  |   $\surd$   |  $\surd$  |           |
| 不同包中的子类   | $\surd$  |   $\surd$   |           |           |
| 不同包中的其他类 | $\surd$  |             |           |           |



## 代码块

局部代码块：定义在方法中的，用来限制变量的作用范围

构造代码块：定义在类中方法外，用来给对象中的成员初始化赋值

静态代码块：定义在类中方法外，用来给类的静态成员初始化赋值



## 不同修饰符的使用

* 类，最常使用 `public` 修饰
* 成员变量，最常使用 `private` 修饰
* 成员方法，最常使用 `public` 修饰



## 自定义数据类型的使用

* 类作为方法参数时，说明要向方法中传入该类的对象
* 类作为方法返回值时，说明该方法要返回一个该类的对象
* 抽象类作为方法参数时，说明要传入一个实现抽象类所有抽象方法的子类对象
* 抽象类作为方法返回值时，说明需要返回一个实现抽象类所有抽象方法的子类对象
* 接口作为方法参数时，说明该方法要传入一个接口实现类的对象
* 接口作为方法返回值时，说明该方法需要返回一个接口实现类对象