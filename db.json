{"meta":{"version":1,"warehouse":"3.0.2"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"source/images/jm.png","path":"images/jm.png","modified":0,"renderable":0},{"_id":"source/images/jm16.ico","path":"images/jm16.ico","modified":0,"renderable":0},{"_id":"source/images/jm32.ico","path":"images/jm32.ico","modified":0,"renderable":0},{"_id":"source/images/20200417221334.jpg","path":"images/20200417221334.jpg","modified":0,"renderable":0},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/exturl.js","path":"js/src/exturl.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/js.cookie.js","path":"js/src/js.cookie.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scroll-cookie.js","path":"js/src/scroll-cookie.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","path":"lib/algolia-instant-search/instantsearch.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","path":"lib/canvas-nest/canvas-nest.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","path":"lib/canvas-ribbon/canvas-ribbon.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/LICENSE","path":"lib/fastclick/LICENSE","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/bower.json","path":"lib/fastclick/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/README.md","path":"lib/fastclick/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","path":"lib/pace/pace-theme-barber-shop.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","path":"lib/pace/pace-theme-big-counter.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","path":"lib/pace/pace-theme-bounce.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","path":"lib/pace/pace-theme-center-atom.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","path":"lib/pace/pace-theme-center-radar.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","path":"lib/pace/pace-theme-center-circle.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","path":"lib/pace/pace-theme-center-simple.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","path":"lib/pace/pace-theme-corner-indicator.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","path":"lib/pace/pace-theme-fill-left.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","path":"lib/pace/pace-theme-loading-bar.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","path":"lib/pace/pace-theme-mac-osx.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","path":"lib/pace/pace-theme-minimal.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace.min.js","path":"lib/pace/pace.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/font-embedded.css","path":"lib/needsharebutton/font-embedded.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","path":"lib/needsharebutton/needsharebutton.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","path":"lib/needsharebutton/needsharebutton.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","path":"lib/three/canvas_lines.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","path":"lib/three/canvas_sphere.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/three-waves.min.js","path":"lib/three/three-waves.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","path":"lib/pace/pace-theme-flash.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","path":"lib/jquery_lazyload/CONTRIBUTING.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","path":"lib/jquery_lazyload/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","path":"lib/jquery_lazyload/jquery.lazyload.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","path":"lib/jquery_lazyload/jquery.scrollstop.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","path":"lib/jquery_lazyload/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/bower.json","path":"lib/velocity/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.js","path":"lib/Han/dist/han.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","path":"lib/fancybox/source/blank.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","path":"lib/fancybox/source/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","path":"lib/fancybox/source/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","path":"lib/fancybox/source/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","path":"lib/fancybox/source/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","path":"lib/fancybox/source/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","path":"lib/fancybox/source/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","path":"lib/fancybox/source/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","path":"lib/fancybox/source/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","path":"lib/fastclick/lib/fastclick.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","path":"lib/fastclick/lib/fastclick.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.css","path":"lib/Han/dist/han.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.css","path":"lib/Han/dist/han.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","path":"lib/Han/dist/font/han-space.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","path":"lib/Han/dist/font/han-space.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","path":"lib/Han/dist/font/han.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","path":"lib/Han/dist/font/han.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","path":"lib/Han/dist/font/han.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.js","path":"lib/Han/dist/han.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","path":"lib/fancybox/source/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","path":"lib/fancybox/source/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","path":"lib/font-awesome/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","path":"lib/font-awesome/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","path":"lib/algolia-instant-search/instantsearch.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/three.min.js","path":"lib/three/three.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","path":"lib/font-awesome/fonts/fontawesome-webfont.svg","modified":0,"renderable":1}],"Cache":[{"_id":"source/CNAME","hash":"b486611401bdc3e310f128972b45650b2f15a8dc","modified":1598193217426},{"_id":"themes/next/.bowerrc","hash":"334da94ca6f024d60d012cc26ea655681e724ad8","modified":1598193217480},{"_id":"themes/next/.editorconfig","hash":"211d2c92bfdddb3e81ea946f4ca7a539f150f4da","modified":1598193217480},{"_id":"themes/next/.gitattributes","hash":"8454b9313cb1a97b63fb87e2d29daee497ce6249","modified":1598193217480},{"_id":"themes/next/.gitignore","hash":"ee0b13c268cc8695d3883a5da84930af02d4ed08","modified":1598193217482},{"_id":"themes/next/.hound.yml","hash":"289dcf5bfe92dbd680d54d6e0668f41c9c9c0c78","modified":1598193217483},{"_id":"themes/next/.javascript_ignore","hash":"cd250ad74ca22bd2c054476456a73d9687f05f87","modified":1598193217483},{"_id":"themes/next/.travis.yml","hash":"6674fbdfe0d0c03b8a04527ffb8ab66a94253acd","modified":1598193217484},{"_id":"themes/next/.stylintrc","hash":"3b7f9785e9ad0dab764e1c535b40df02f4ff5fd6","modified":1598193217484},{"_id":"themes/next/.jshintrc","hash":"b7d23f2ce8d99fa073f22f9960605f318acd7710","modified":1598193217483},{"_id":"themes/next/LICENSE","hash":"ec44503d7e617144909e54533754f0147845f0c5","modified":1598193217484},{"_id":"themes/next/gulpfile.coffee","hash":"412defab3d93d404b7c26aaa0279e2e586e97454","modified":1598193217486},{"_id":"themes/next/README.cn.md","hash":"b764aae78ffa561a9a68fdee4c6f21c3ce260fbb","modified":1598193217484},{"_id":"themes/next/bower.json","hash":"486ebd72068848c97def75f36b71cbec9bb359c5","modified":1598193217486},{"_id":"themes/next/README.md","hash":"4e276fb9a3c31f1259df3ea9a4b92f4a8d72714d","modified":1598193217485},{"_id":"themes/next/_config.yml","hash":"c121cb8814db877d5fcbf037127327e0a25295af","modified":1598193217485},{"_id":"themes/next/package.json","hash":"3963ad558a24c78a3fd4ef23cf5f73f421854627","modified":1598193217521},{"_id":"source/_posts/C-环境设置.md","hash":"6beecb458fe7f126181f4f47d1fb8bcb8278d27e","modified":1598193217427},{"_id":"source/_posts/CCF推荐国际学术会议和期刊目录（网络与信息安全）.md","hash":"30f6e62ebda69d7f658a10df91055e53a474bcfd","modified":1598193217427},{"_id":"source/_posts/Hexo博客NexT主题使用不蒜子统计访客数.md","hash":"8c0f005f1423bc4dfb50c169a92b338b50f7e379","modified":1598193217428},{"_id":"source/_posts/Hexo博客NexT主题点击侧边栏日志出现问题的解决办法.md","hash":"80d7c957e018cb5aa1cf30b8168594ef47a22665","modified":1598193217428},{"_id":"source/_posts/Hexo博客NexT主题翻页按钮显示不正常的解决方法.md","hash":"9b626c2f5b8dd7847961e6c75cc0b9fa1ddfcac4","modified":1598193217428},{"_id":"source/_posts/Hexo博客搭建.md","hash":"80920a3e3e997f9a0b3a7f1799cfc4169b096a9c","modified":1598193217429},{"_id":"source/_posts/JupyterLab安装.md","hash":"46319f2096e9d8ac1ea3773f801e085918c6ab23","modified":1598193217429},{"_id":"source/_posts/LaTeX常用符号表示方法.md","hash":"a348afd07624d956f78387978d571d3f34edfe13","modified":1598193217429},{"_id":"source/_posts/PPML中的2PC对比3PC.md","hash":"17728f809b66fca0501d5e8979f7cf2e196f9604","modified":1598193217430},{"_id":"source/_posts/PyTorch入门60题.md","hash":"466010d0b138ad028ffe2849b302da6ecb435e8b","modified":1598193217430},{"_id":"source/_posts/Zotero的附件同步.md","hash":"be9b5f32f5533c8735b0a6400cf6ddffdd6be57d","modified":1598193217431},{"_id":"source/_posts/不经意传输（Oblivious-Transfer）.md","hash":"3cd5dd5e7343c5978b7f7b7673fb24f039a3acc2","modified":1598193217431},{"_id":"source/_posts/使用you-get下载网址视频.md","hash":"8ad55f10a496d8e4846251f4e073adb4d029302e","modified":1598193217431},{"_id":"source/_posts/全同态加密算法深入解析.md","hash":"13fca68ec344ed5b95c099c4cbf2d5188808ce3f","modified":1598193217432},{"_id":"source/_posts/在不同的电脑上更新Hexo博客.md","hash":"2dd2ec510046944335c28f5b75cef0bcf4aeb6f3","modified":1598197670415},{"_id":"source/_posts/群与环的概念.md","hash":"b7d63b72e3200d66a81720f4c9a46091a0620074","modified":1598193217432},{"_id":"source/_posts/解决Ubuntu-deepin-wine微信字体乱码.md","hash":"4d1b389bedc1ee94f631360251a705a528f472d8","modified":1598193217432},{"_id":"source/_posts/论文笔记-ABY-A-Framework-for-Efficient-Mixed-Protocol-Secure-Two-Party-Computation.md","hash":"c085e188204ef53adceee8a2ed57496918997314","modified":1598193217433},{"_id":"source/_posts/论文笔记-ASTRA-High-Throughput-3PC-over-Rings-with-Application-to-Secure-Prediction.md","hash":"c1c99dc1b25b314eedb45f6b67efc0aa790f4134","modified":1598193217434},{"_id":"source/_posts/论文笔记-Designing-an-e-commerce-recommender-system-based-on-collaborative-filtering-using-a-data-mining-approach.md","hash":"3d08340db53b0b19c374e308f116650884cff2fd","modified":1598193217434},{"_id":"source/_posts/论文笔记-ABY3-A-Mixed-Protocol-Framework-for-Machine-Learning.md","hash":"115e30cd7d1791f79c81efdf169ba17d5d2502c2","modified":1598193217433},{"_id":"source/_posts/论文笔记-Automatic-Unit-Test-Generation-and-Execution-for-JavaScript-Program-through-Symbolic-Execution.md","hash":"a792fa72698afa7d186acce266882095c8c4960e","modified":1598193217434},{"_id":"source/_posts/论文笔记-Efficient-Multi-Key-Homomorphic-Encryption-with-Packed-Ciphertexts-with-Application-to-Oblivious-Neural-Network-Inference.md","hash":"08a90b51292d692c92d912ba89d3ebaa257efd61","modified":1598193217435},{"_id":"source/_posts/论文笔记-High-Throughput-Semi-Honest-Secure-Three-Party-Computation-with-an-Honest-Majority.md","hash":"c07d4565246d277cfeaff9b8af9f83a185714298","modified":1598193217435},{"_id":"source/_posts/论文笔记-Improved-Garbled-Circuit-Free-XOR-Gates-and-Applications.md","hash":"67bd74ccd5cb27acfc27004c4275398979df68c5","modified":1598193217436},{"_id":"source/_posts/论文笔记-Linear-Regression-on-Packed-Encrypted-Data-in-the-Two-Server-Model.md","hash":"6ef67e042fa16395d50d6ffb4ddb9285f5f55518","modified":1598193217436},{"_id":"source/_posts/论文笔记-Oblivious-Neural-Network-Predictions-via-MiniONN-Transformations.md","hash":"c69b04af16b2e37ad0643faddb9ba01fae51546b","modified":1598193217437},{"_id":"source/_posts/论文笔记-Privacy-Preserving-Ridge-Regression-with-only-Linearly-Homomorphic-Encryption.md","hash":"2bd3c0e5e82edd9e1a6ee15c6386508151247fa8","modified":1598193217437},{"_id":"source/_posts/论文笔记-Privacy-preserving-SVM-on-Outsourced-Genomic-Data-via-Secure-Multi-party-Computation.md","hash":"42c11b12f17b94afcc0ac0690b7e7055877f25e9","modified":1598193217437},{"_id":"source/_posts/论文笔记-SecureML-A-System-for-Scalable-Privacy-Preserving-Machine-Learning.md","hash":"0d3733b682c44d7f0da8664197338e5248ec5517","modified":1598193217438},{"_id":"source/categories/index.md","hash":"45f2961293eab5a4092cd98cc5d2cd250d80b26a","modified":1598193217438},{"_id":"source/images/jm.png","hash":"5fd5030da2624ea928553840d156583eedbaadd6","modified":1598193217439},{"_id":"source/images/jm16.ico","hash":"20565e7e04d714f5b35cf75de6c3f68b58d9d938","modified":1598193217440},{"_id":"source/images/jm32.ico","hash":"f574fcf2b5889ff5b3faba64a0d21fbe21bb78e2","modified":1598193217440},{"_id":"source/tags/index.md","hash":"fc031c1962f017401a7298b63cb3ee979118db1c","modified":1598193217440},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"5adfad3ef1b870063e621bc0838268eb2c7c697a","modified":1598193217481},{"_id":"themes/next/.github/ISSUE_TEMPLATE.md","hash":"b1ec000babd42bb7ffd26f5ad8aac9b5bec79ae5","modified":1598193217481},{"_id":"themes/next/.github/browserstack_logo.png","hash":"a6c43887f64a7f48a2814e3714eaa1215e542037","modified":1598193217482},{"_id":"themes/next/.github/PULL_REQUEST_TEMPLATE.md","hash":"1228506a940114288d61812bfe60c045a0abeac1","modified":1598193217482},{"_id":"themes/next/languages/de.yml","hash":"fd02d9c2035798d5dc7c1a96b4c3e24b05b31a47","modified":1598193217486},{"_id":"themes/next/languages/default.yml","hash":"b3bcd8934327448a43d9bfada5dd11b1b8c1402e","modified":1598193217487},{"_id":"themes/next/languages/en.yml","hash":"2f4b4776ca1a08cc266a19afb0d1350a3926f42c","modified":1598193217487},{"_id":"themes/next/languages/fr-FR.yml","hash":"efeeb55d5c4add54ad59a612fc0630ee1300388c","modified":1598193217487},{"_id":"themes/next/languages/id.yml","hash":"dccae33e2a5b3c9f11c0e05ec4a7201af1b25745","modified":1598193217488},{"_id":"themes/next/languages/ja.yml","hash":"37f954e47a3bc669620ca559e3edb3b0072a4be5","modified":1598193217489},{"_id":"themes/next/languages/ko.yml","hash":"dc8f3e8c64eb7c4bb2385025b3006b8efec8b31d","modified":1598193217489},{"_id":"themes/next/languages/nl-NL.yml","hash":"213e7a002b82fb265f69dabafbbc382cfd460030","modified":1598193217489},{"_id":"themes/next/languages/it.yml","hash":"a215d016146b1bd92cef046042081cbe0c7f976f","modified":1598193217488},{"_id":"themes/next/languages/pt-BR.yml","hash":"568d494a1f37726a5375b11452a45c71c3e2852d","modified":1598193217490},{"_id":"themes/next/languages/ru.yml","hash":"e33ee44e80f82e329900fc41eb0bb6823397a4d6","modified":1598193217490},{"_id":"themes/next/languages/pt.yml","hash":"2efcd240c66ab1a122f061505ca0fb1e8819877b","modified":1598193217490},{"_id":"themes/next/languages/vi.yml","hash":"a9b89ebd3e5933033d1386c7c56b66c44aca299a","modified":1598193217491},{"_id":"themes/next/languages/zh-Hans.yml","hash":"66b9b42f143c3cb2f782a94abd4c4cbd5fd7f55f","modified":1598193217491},{"_id":"themes/next/languages/zh-hk.yml","hash":"fe0d45807d015082049f05b54714988c244888da","modified":1598193217491},{"_id":"themes/next/languages/zh-tw.yml","hash":"432463b481e105073accda16c3e590e54c8e7b74","modified":1598193217491},{"_id":"themes/next/layout/_layout.swig","hash":"2164570bb05db11ee4bcfbbb5d183a759afe9d07","modified":1598193217493},{"_id":"themes/next/layout/archive.swig","hash":"9a2c14874a75c7085d2bada5e39201d3fc4fd2b4","modified":1598193217519},{"_id":"themes/next/layout/category.swig","hash":"3cbb3f72429647411f9e85f2544bdf0e3ad2e6b2","modified":1598193217520},{"_id":"themes/next/layout/index.swig","hash":"555a357ecf17128db4e29346c92bb6298e66547a","modified":1598193217520},{"_id":"themes/next/layout/page.swig","hash":"e8fcaa641d46930237675d2ad4b56964d9e262e9","modified":1598193217520},{"_id":"themes/next/layout/post.swig","hash":"7a6ce102ca82c3a80f776e555dddae1a9981e1ed","modified":1598193217521},{"_id":"themes/next/layout/schedule.swig","hash":"87ad6055df01fa2e63e51887d34a2d8f0fbd2f5a","modified":1598193217521},{"_id":"themes/next/layout/tag.swig","hash":"34e1c016cbdf94a31f9c5d494854ff46b2a182e9","modified":1598193217521},{"_id":"themes/next/scripts/merge-configs.js","hash":"38d86aab4fc12fb741ae52099be475196b9db972","modified":1598193217522},{"_id":"themes/next/scripts/merge.js","hash":"39b84b937b2a9608b94e5872349a47200e1800ff","modified":1598193217522},{"_id":"themes/next/test/.jshintrc","hash":"c9fca43ae0d99718e45a6f5ce736a18ba5fc8fb6","modified":1598193217652},{"_id":"themes/next/test/helpers.js","hash":"f25e7f3265eb5a6e1ccbb5e5012fa9bebf134105","modified":1598193217653},{"_id":"themes/next/test/intern.js","hash":"db90b1063356727d72be0d77054fdc32fa882a66","modified":1598193217653},{"_id":"source/_posts/LeetCode刷题.md","hash":"8a90f7d517df7320a31e4ee2f100a913b876e0b6","modified":1598193217430},{"_id":"source/images/20200417221334.jpg","hash":"f1265327e88a201e21642dc915930296f6bfab6c","modified":1598193217439},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1598193217562},{"_id":"themes/next/layout/_custom/header.swig","hash":"ba8ab5a0280b953aa97435ff8946cbcbb2755a27","modified":1598193217492},{"_id":"themes/next/layout/_custom/sidebar.swig","hash":"ba8ab5a0280b953aa97435ff8946cbcbb2755a27","modified":1598193217493},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"8c56dd26157cbc580ae41d97ac34b90ab48ced3f","modified":1598193217493},{"_id":"themes/next/layout/_macro/post-copyright.swig","hash":"f83befdc740beb8dc88805efd7fbb0fef9ed19be","modified":1598193217494},{"_id":"themes/next/layout/_macro/post.swig","hash":"8da472b78b88260a2b4c473d868d49f49e7a37b6","modified":1598193217494},{"_id":"themes/next/layout/_macro/reward.swig","hash":"357d86ec9586705bfbb2c40a8c7d247a407db21a","modified":1598193217494},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"e42d0dafc33bac5756889a6712d919c44a3f87dd","modified":1598193217495},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"e2e4eae391476da994045ed4c7faf5e05aca2cd7","modified":1598193217495},{"_id":"themes/next/layout/_partials/comments.swig","hash":"4adc65a602d1276615da3b887dcbf2ac68e7382b","modified":1598193217496},{"_id":"themes/next/layout/_partials/footer.swig","hash":"575fc11cbcd731bf8820b3d9c1caa1701326ccfc","modified":1598193217496},{"_id":"themes/next/layout/_partials/head.swig","hash":"f14a39dad1ddd98e6d3ceb25dda092ba80d391b5","modified":1598193217496},{"_id":"themes/next/layout/_partials/header.swig","hash":"c54b32263bc8d75918688fb21f795103b3f57f03","modified":1598193217497},{"_id":"themes/next/layout/_partials/page-header.swig","hash":"77c61e0baea3544df361b7338c3cd13dc84dde22","modified":1598193217498},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"0c9d4d502a74a6abbc75f92f99e729463a6203c3","modified":1598193217498},{"_id":"themes/next/layout/_partials/search.swig","hash":"b4ebe4a52a3b51efe549dd1cdee846103664f5eb","modified":1598193217499},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"c0f5a0955f69ca4ed9ee64a2d5f8aa75064935ad","modified":1598193217505},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"931808ad9b8d8390c0dcf9bdeb0954eeb9185d68","modified":1598193217505},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"9be624634703be496a5d2535228bc568a8373af9","modified":1598193217507},{"_id":"themes/next/layout/_third-party/duoshuo-hot-articles.swig","hash":"ba75672183d94f1de7c8bd0eeee497a58c70e889","modified":1598193217515},{"_id":"themes/next/layout/_third-party/mathjax.swig","hash":"a0bd3388587fd943baae0d84ca779a707fbcad89","modified":1598193217515},{"_id":"themes/next/layout/_third-party/exturl.swig","hash":"8301c9600bb3e47f7fb98b0e0332ef3c51bb1688","modified":1598193217515},{"_id":"themes/next/layout/_third-party/needsharebutton.swig","hash":"fa882641da3bd83d9a58a8a97f9d4c62a9ee7b5c","modified":1598193217516},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"554ec568e9d2c71e4a624a8de3cb5929050811d6","modified":1598193217516},{"_id":"themes/next/layout/_third-party/schedule.swig","hash":"db15d7e1552aa2d2386a6b8a33b3b3a40bf9e43d","modified":1598193217516},{"_id":"themes/next/layout/_third-party/scroll-cookie.swig","hash":"9a188938d46931d5f3882a140aa1c48b3a893f0c","modified":1598193217517},{"_id":"themes/next/scripts/tags/button.js","hash":"eddbb612c15ac27faf11c59c019ce188f33dec2c","modified":1598193217523},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"99b66949f18398689b904907af23c013be1b978f","modified":1598193217523},{"_id":"themes/next/scripts/tags/exturl.js","hash":"5022c0ba9f1d13192677cf1fd66005c57c3d0f53","modified":1598193217524},{"_id":"themes/next/scripts/tags/full-image.js","hash":"c9f833158c66bd72f627a0559cf96550e867aa72","modified":1598193217524},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"ac681b0d0d8d39ba3817336c0270c6787c2b6b70","modified":1598193217524},{"_id":"themes/next/scripts/tags/label.js","hash":"6f00952d70aadece844ce7fd27adc52816cc7374","modified":1598193217524},{"_id":"themes/next/scripts/tags/lazy-image.js","hash":"bcba2ff25cd7850ce6da322d8bd85a8dd00b5ceb","modified":1598193217525},{"_id":"themes/next/scripts/tags/note.js","hash":"f7eae135f35cdab23728e9d0d88b76e00715faa0","modified":1598193217525},{"_id":"themes/next/scripts/tags/tabs.js","hash":"aa7fc94a5ec27737458d9fe1a75c0db7593352fd","modified":1598193217525},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"45eeea0b5fba833e21e38ea10ed5ab385ceb4f01","modified":1598193217563},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1598193217563},{"_id":"themes/next/source/css/main.styl","hash":"a91dbb7ef799f0a171b5e726c801139efe545176","modified":1598193217562},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1598193217563},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"bc3588c9b2d7c68830524783120ff6cf957cf668","modified":1598193217564},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"6f076713fb9bf934aa2c1046bdf2cf2e37bc1eab","modified":1598193217565},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"6f55543d1fb9cbc436c101d24f802dec7b41efc3","modified":1598193217564},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"42cd73da328077ccc92f859bb8f3cf621b3484f8","modified":1598193217565},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"70c1535f43e54e5ff35ca81419e77e4c0c301398","modified":1598193217565},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1598193217566},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1598193217566},{"_id":"themes/next/source/images/cc-by.svg","hash":"e92a33c32d1dac8ed94849b2b4e6456e887efe70","modified":1598193217566},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1598193217567},{"_id":"themes/next/source/images/logo.svg","hash":"169f56fd82941591dad3abd734a50ec7259be950","modified":1598193217567},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1598193217567},{"_id":"themes/next/source/images/quote-r.svg","hash":"2a2a250b32a87c69dcc1b1976c74b747bedbfb41","modified":1598193217569},{"_id":"themes/next/source/images/cc-zero.svg","hash":"9bfb52b2f63527a7049247bf00d44e6dc1170e7d","modified":1598193217566},{"_id":"themes/next/source/images/quote-l.svg","hash":"cd108d6f44351cadf8e6742565217f88818a0458","modified":1598193217568},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1598193217569},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1598193217507},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1598193217507},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1598193217551},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1598193217551},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1598193217552},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1598193217561},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1598193217562},{"_id":"themes/next/layout/_partials/head/custom-head.swig","hash":"a223919d2e1bf17ca4d6abb2c86f2efca9883dc1","modified":1598193217497},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"f5e487b0d213ca0bd94aa30bc23b240d65081627","modified":1598193217497},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"b2f0d247b213e4cf8de47af6a304d98070cc7256","modified":1598193217499},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"a8c7f9ca7c605d039a1f3bf4e4d3183700a3dd62","modified":1598193217499},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"b25002a83cbd2ca0c4a5df87ad5bff26477c0457","modified":1598193217500},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"9e3d133ac5bcc6cb51702c83b2611a49811abad1","modified":1598193217500},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"d4fbffd7fa8f2090eb32a871872665d90a885fac","modified":1598193217501},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"d9e2d9282f9be6e04eae105964abb81e512bffed","modified":1598193217500},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"0a9cdd6958395fcdffc80ab60f0c6301b63664a5","modified":1598193217501},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"9b84ab576982b2c3bb0291da49143bc77fba3cc6","modified":1598193217506},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"a9a3995b9615adfb8d6b127c78c6771627bee19a","modified":1598193217506},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"a9a3995b9615adfb8d6b127c78c6771627bee19a","modified":1598193217507},{"_id":"themes/next/layout/_third-party/analytics/analytics-with-widget.swig","hash":"ff947f3561b229bc528cb1837d4ca19612219411","modified":1598193217508},{"_id":"themes/next/layout/_third-party/analytics/application-insights.swig","hash":"71397a5823e8ec8aad3b68aace13150623b3e19d","modified":1598193217508},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"753d262911c27baf663fcaf199267133528656af","modified":1598193217509},{"_id":"themes/next/layout/_third-party/analytics/busuanzi-counter.swig","hash":"16cb23818909f57dac1a5ada66869971c33d7bd8","modified":1598193217509},{"_id":"themes/next/layout/_third-party/analytics/cnzz-analytics.swig","hash":"a10b7f19d7b5725527514622899df413a34a89db","modified":1598193217509},{"_id":"themes/next/layout/_third-party/analytics/facebook-sdk.swig","hash":"7d94845f96197d9d84a405fa5d4ede75fb81b225","modified":1598193217510},{"_id":"themes/next/layout/_third-party/analytics/firestore.swig","hash":"ccc443b22bd4f8c7ac4145664686c756395b90e0","modified":1598193217510},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"b1e13df83fb2b1d5d513b30b7aa6158b0837daab","modified":1598193217510},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"45f3f629c2aacc381095750e1c8649041a71a84b","modified":1598193217510},{"_id":"themes/next/layout/_third-party/analytics/lean-analytics.swig","hash":"e6d10ee4fb70b3ae1cd37e9e36e000306734aa2e","modified":1598193217511},{"_id":"themes/next/layout/_third-party/analytics/tencent-analytics.swig","hash":"8a399df90dadba5ad4e781445b58f4765aeb701e","modified":1598193217511},{"_id":"themes/next/layout/_third-party/analytics/tencent-mta.swig","hash":"5a8027328f060f965b3014060bebec1d7cf149c1","modified":1598193217511},{"_id":"themes/next/layout/_third-party/analytics/vkontakte-api.swig","hash":"f9a1647a8f1866deeb94052d1f87a5df99cb1e70","modified":1598193217512},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"4c501ea0b9c494181eb3c607c5526a5754e7fbd8","modified":1598193217512},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"b83a51bbe0f1e2ded9819070840b0ea145f003a6","modified":1598193217512},{"_id":"themes/next/layout/_third-party/comments/duoshuo.swig","hash":"1600f340e0225361580c44890568dc07dbcf2c89","modified":1598193217513},{"_id":"themes/next/layout/_third-party/comments/gitment.swig","hash":"4dcc3213c033994d342d02b800b6229295433d30","modified":1598193217513},{"_id":"themes/next/layout/_third-party/comments/hypercomments.swig","hash":"af7f3e43cbdc4f88c13f101f0f341af96ace3383","modified":1598193217513},{"_id":"themes/next/layout/_third-party/comments/index.swig","hash":"493bd5999a1061b981922be92d8277a0f9152447","modified":1598193217513},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"9246162d4bc7e949ce1d12d135cbbaf5dc3024ec","modified":1598193217514},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"4050553d44ba1396174161c9a6bb0f89fa779eca","modified":1598193217514},{"_id":"themes/next/layout/_third-party/comments/youyan.swig","hash":"7e65ff8fe586cd655b0e9d1ad2912663ff9bd36c","modified":1598193217514},{"_id":"themes/next/layout/_third-party/search/index.swig","hash":"34599633658f3b0ffb487728b7766e1c7b551f5a","modified":1598193217518},{"_id":"themes/next/layout/_third-party/search/tinysou.swig","hash":"fe95dd3d166634c466e19aa756e65ad6e8254d3e","modified":1598193217518},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"93479642fd076a1257fecc25fcf5d20ccdefe509","modified":1598193217518},{"_id":"themes/next/layout/_third-party/seo/baidu-push.swig","hash":"d8c98938719284fa06492c114d99a1904652a555","modified":1598193217519},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"3403fdd8efde1a0afd11ae8a5a97673f5903087f","modified":1598193217550},{"_id":"themes/next/source/css/_mixins/Gemini.styl","hash":"07f7da320689f828f6e36a6123807964a45157a0","modified":1598193217550},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"7896c3ee107e1a8b9108b6019f1c070600a1e8cc","modified":1598193217551},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"0e55cbd93852dc3f8ccb44df74d35d9918f847e0","modified":1598193217551},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"58e7dd5947817d9fc30770712fc39b2f52230d1e","modified":1598193217560},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"a25408534f8fe6e321db4bbf9dd03335d648fe17","modified":1598193217561},{"_id":"themes/next/source/css/_variables/base.styl","hash":"b1f6ea881a4938a54603d68282b0f8efb4d7915d","modified":1598193217561},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"4069f918ccc312da86db6c51205fc6c6eaabb116","modified":1598193217561},{"_id":"themes/next/source/js/src/affix.js","hash":"1b509c3b5b290a6f4607f0f06461a0c33acb69b1","modified":1598193217570},{"_id":"themes/next/source/js/src/algolia-search.js","hash":"cb431b54ba9c692165a1f5a12e4c564a560f8058","modified":1598193217570},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"0289031200c3d4c2bdd801ee10fff13bb2c353e4","modified":1598193217570},{"_id":"themes/next/source/js/src/exturl.js","hash":"a2a0f0de07e46211f74942a468f42ee270aa555c","modified":1598193217571},{"_id":"themes/next/source/js/src/hook-duoshuo.js","hash":"b35a7dc47b634197b93487cea8671a40a9fdffce","modified":1598193217571},{"_id":"themes/next/source/js/src/js.cookie.js","hash":"1512c751d219577d338ac0780fb2bbd9075d5298","modified":1598193217571},{"_id":"themes/next/source/js/src/motion.js","hash":"885176ed51d468f662fbf0fc09611f45c7e5a3b1","modified":1598193217572},{"_id":"themes/next/source/js/src/post-details.js","hash":"93a18271b4123dd8f94f09d1439b47c3c19a8712","modified":1598193217572},{"_id":"themes/next/source/js/src/scroll-cookie.js","hash":"02cf91514e41200bc9df5d8bdbeb58575ec06074","modified":1598193217573},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"b7657be25fc52ec67c75ab5481bdcb483573338b","modified":1598193217573},{"_id":"themes/next/source/js/src/utils.js","hash":"b3e9eca64aba59403334f3fa821f100d98d40337","modified":1598193217574},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1598193217579},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1598193217583},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","hash":"b02737510e9b89aeed6b54f89f602a9c24b06ff2","modified":1598193217583},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"b4aefc910578d76b267e86dfffdd5121c8db9aec","modified":1598193217623},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"c31ff06a740955e44edd4403902e653ccabfd4db","modified":1598193217623},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"03ddbf76c1dd1afb93eed0b670d2eee747472ef1","modified":1598193217623},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"ee33b2798b1e714b904d663436c6b3521011d1fa","modified":1598193217624},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"71e7183634dc1b9449f590f15ebd7201add22ca7","modified":1598193217624},{"_id":"themes/next/source/lib/fastclick/.bower.json","hash":"bf3eef9d647cd7c9b62feda3bc708c6cdd7c0877","modified":1598193217591},{"_id":"themes/next/source/lib/fastclick/LICENSE","hash":"6f474ea75c42442da7bbcf2e9143ce98258efd8d","modified":1598193217591},{"_id":"themes/next/source/lib/fastclick/bower.json","hash":"a9b3ee1e4db71a0e4ea6d5bed292d176dd68b261","modified":1598193217592},{"_id":"themes/next/source/lib/fastclick/README.md","hash":"68a9b9d53126405b0fa5f3324f1fb96dbcc547aa","modified":1598193217592},{"_id":"themes/next/source/lib/jquery/.bower.json","hash":"865d6c1328ab209a4376b9d2b7a7824369565f28","modified":1598193217633},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1598193217639},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1598193217639},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1598193217639},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1598193217639},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1598193217640},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1598193217640},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1598193217641},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1598193217641},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1598193217641},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1598193217642},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1598193217642},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1598193217642},{"_id":"themes/next/source/lib/pace/pace.min.js","hash":"8aaa675f577d5501f5f22d5ccb07c2b76310b690","modified":1598193217643},{"_id":"themes/next/source/lib/needsharebutton/font-embedded.css","hash":"14264a210bf94232d58d7599ea2ba93bfa4fb458","modified":1598193217637},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","hash":"e33aa8fa48b6639d8d8b937d13261597dd473b3a","modified":1598193217638},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","hash":"2ce5f3bf15c523b9bfc97720d8884bb22602a454","modified":1598193217638},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","hash":"2d9a9f38c493fdf7c0b833bb9184b6a1645c11b2","modified":1598193217643},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","hash":"46a50b91c98b639c9a2b9265c5a1e66a5c656881","modified":1598193217644},{"_id":"themes/next/source/lib/three/three-waves.min.js","hash":"8148492dd49aa876d32bb7d5b728d3f5bf6f5074","modified":1598193217644},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1598193217641},{"_id":"themes/next/source/lib/jquery_lazyload/.bower.json","hash":"90fa628f156d8045357ff11eaf32e61abacf10e8","modified":1598193217634},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","hash":"4ded6fee668544778e97e38c2b211fc56c848e77","modified":1598193217635},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","hash":"e0acf1db27b0cc16128a59c46db1db406b5c4c58","modified":1598193217636},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","hash":"f4a570908f6c89c6edfb1c74959e733eaadea4f2","modified":1598193217636},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","hash":"bf773ad48a0b9aa77681a89d7569eefc0f7b7b18","modified":1598193217636},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","hash":"b930297cb98b8e1dbd5abe9bc1ed9d5935d18ce8","modified":1598193217635},{"_id":"themes/next/source/lib/velocity/.bower.json","hash":"63da5e80ebb61bb66a2794d5936315ca44231f0c","modified":1598193217649},{"_id":"themes/next/source/lib/velocity/bower.json","hash":"92d92860418c4216aa59eb4cb4a556290a7ad9c3","modified":1598193217649},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"dde584994ac13dc601836e86f4cf490e418d9723","modified":1598193217652},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"bf172816a9c57f9040e3d19c24e181a142daf92b","modified":1598193217651},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"dbbfb50f6502f6b81dcc9fee7b31f1e812da3464","modified":1598193217651},{"_id":"themes/next/source/lib/jquery/index.js","hash":"17a740d68a1c330876c198b6a4d9319f379f3af2","modified":1598193217634},{"_id":"themes/next/layout/_third-party/search/algolia-search/dom.swig","hash":"2530de0f3125a912756f6c0e9090cd012134a4c5","modified":1598193217518},{"_id":"themes/next/layout/_third-party/search/algolia-search/assets.swig","hash":"218cc936ba3518a3591b2c9eda46bc701edf7710","modified":1598193217517},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"237d185ac62ec9877e300947fa0109c44fb8db19","modified":1598193217527},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"8f86f694c0749a18ab3ad6f6df75466ca137a4bc","modified":1598193217527},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"8b32928686c327151e13d3ab100157f9a03cd59f","modified":1598193217527},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"ff4489cd582f518bba6909a301ac1292a38b4e96","modified":1598193217528},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"7ad4081466b397e2a6204141bb7768b7c01bd93c","modified":1598193217528},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"4f2801fc4cf3f31bf2069f41db8c6ce0e3da9e39","modified":1598193217533},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"6eb4bcc3056bd279d000607e8b4dad50d368ca69","modified":1598193217541},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"12662536c7a07fff548abe94171f34b768dd610f","modified":1598193217548},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"24ee4b356ff55fc6e58f26a929fa07750002cf29","modified":1598193217548},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"1da5c800d025345f212a3bf1be035060f4e5e6ed","modified":1598193217548},{"_id":"themes/next/source/css/_common/scaffolding/mobile.styl","hash":"91ca75492cd51f2553f4d294ed2f48239fcd55eb","modified":1598193217549},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"a17e2b871a335f290afb392a08f94fd35f59c715","modified":1598193217549},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"3f40e8a9fe8e7bd5cfc4cf4cbbbcb9539462e973","modified":1598193217549},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"ea9069645696f86c5df64208490876fe150c8cae","modified":1598193217550},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"60fa84aa7731760f05f52dd7d8f79b5f74ac478d","modified":1598193217552},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"31127dcbf4c7b4ada53ffbf1638b5fe325b7cbc0","modified":1598193217556},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"748dbfbf9c08e719ddc775958003c64b00d39dab","modified":1598193217557},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"09c965022c13b84ed8a661fee8ac2a6d550495ae","modified":1598193217557},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"a98ad885ee4f48d85b2578a0b9c2bbf166e96733","modified":1598193217557},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"5dbc0d0c897e46760e5dbee416530d485c747bba","modified":1598193217557},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"25d5e45a355ee2093f3b8b8eeac125ebf3905026","modified":1598193217553},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"d0bfd1bef988c76f7d7dd72d88af6f0908a8b0db","modified":1598193217553},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"26666c1f472bf5f3fb9bc62081cca22b4de15ccb","modified":1598193217554},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"b1025c421406d2c24cc92a02ae28c1915b01e240","modified":1598193217554},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"9c99034f8e00d47e978b3959f51eb4a9ded0fcc8","modified":1598193217554},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"9b913b73d31d21f057f97115ffab93cfa578b884","modified":1598193217555},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"09c965022c13b84ed8a661fee8ac2a6d550495ae","modified":1598193217554},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"bce344d3a665b4c55230d2a91eac2ad16d6f32fd","modified":1598193217558},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"416988dca389e6e2fdfa51fa7f4ee07eb53f82fb","modified":1598193217559},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"4642e30010af8b2b037f5b43146b10a934941958","modified":1598193217559},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"1f6e2ce674735269599acc6d77b3ea18d31967fc","modified":1598193217559},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"ad2dcedf393ed1f3f5afd2508d24969c916d02fc","modified":1598193217560},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"86197902dfd3bededba10ba62b8f9f22e0420bde","modified":1598193217560},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"f1d0b5d7af32c423eaa8bb93ab6a0b45655645dc","modified":1598193217573},{"_id":"themes/next/source/lib/Han/dist/han.min.js","hash":"16b03db23a52623348f37c04544f2792032c1fb6","modified":1598193217579},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1598193217584},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1598193217585},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1598193217585},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1598193217585},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1598193217585},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1598193217587},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","hash":"82f33ad0842aa9c154d029e0dada2497d4eb1d57","modified":1598193217589},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","hash":"d71602cbca33b9ecdb7ab291b7f86a49530f3601","modified":1598193217590},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","hash":"ae6318aeb62ad4ce7a7e9a4cdacd93ffb004f0fb","modified":1598193217590},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"3655f1fdf1e584c4d8e8d39026093ca306a5a341","modified":1598193217625},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"1573904b82807abbb32c97a3632c6c6808eaac50","modified":1598193217625},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","hash":"1d6aeda0480d0e4cb6198edf7719d601d4ae2ccc","modified":1598193217595},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1598193217595},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"41ea797c68dbcff2f6fb3aba1d1043a22e7cc0f6","modified":1598193217648},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"a817b6c158cbc5bab3582713de9fe18a18a80552","modified":1598193217648},{"_id":"themes/next/source/lib/Han/dist/han.css","hash":"6c26cdb36687d4f0a11dabf5290a909c3506be5c","modified":1598193217577},{"_id":"themes/next/source/lib/Han/dist/han.min.css","hash":"6d586bfcfb7ae48f1b12f76eec82d3ad31947501","modified":1598193217579},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"88af80502c44cd52ca81ffe7dc7276b7eccb06cf","modified":1598193217625},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1598193217632},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"4237c6e9d59da349639de20e559e87c2c0218cfd","modified":1598193217650},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"9f73c4696f0907aa451a855444f88fc0698fa472","modified":1598193217528},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d63e0cacc53dd375fcc113465a4328c59ff5f2c1","modified":1598193217529},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"1a0d059799a298fe17c49a44298d32cebde93785","modified":1598193217530},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"53cde051e0337f4bf42fb8d6d7a79fa3fa6d4ef2","modified":1598193217529},{"_id":"themes/next/source/css/_common/components/highlight/diff.styl","hash":"167986d0f649516671ddf7193eebba7b421cd115","modified":1598193217531},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"0656e753f182c9f47fef7304c847b7587a85ef0d","modified":1598193217530},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"7fe4d4d656e86276c17cb4e48a560cb6a4def703","modified":1598193217531},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"50450d9fdc8a2b2be8cfca51e3e1a01ffd636c0b","modified":1598193217531},{"_id":"themes/next/source/css/_common/components/post/post-button.styl","hash":"62fbbd32cf5a99ae550c45c763a2c4813a138d01","modified":1598193217533},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"875cbe88d5c7f6248990e2beb97c9828920e7e24","modified":1598193217534},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"1727702eac5d326b5c81a667944a245016668231","modified":1598193217530},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"caf263d1928496688c0e1419801eafd7e6919ce5","modified":1598193217534},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"a200c0a1c5a895ac9dc41e0641a5dfcd766be99b","modified":1598193217534},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"a6c6eb8adba0a090ad1f4b9124e866887f20d10d","modified":1598193217535},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"cd9e214e502697f2f2db84eb721bac57a49b0fce","modified":1598193217535},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"d0d7a5c90d62b685520d2b47fea8ba6019ff5402","modified":1598193217535},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"27deb3d3a243d30022055dac7dad851024099a8b","modified":1598193217536},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"b2495ae5e04dcca610aacadc47881d9e716cd440","modified":1598193217536},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"ca88ea6999a61fb905eb6e72eba5f92d4ee31e6e","modified":1598193217536},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"ccb34c52be8adba5996c6b94f9e723bd07d34c16","modified":1598193217537},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"89d6c3b697efc63de42afd2e89194b1be14152af","modified":1598193217538},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"7968343e41f8b94b318c36289dff1196c3eb1791","modified":1598193217537},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"5a982d8ef3b3623ea5f59e63728990f5623c1b57","modified":1598193217537},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"01567edaea6978628aa5521a122a85434c418bfd","modified":1598193217537},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"b6f3a06a94a6ee5470c956663164d58eda818a64","modified":1598193217532},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"7fb593f90d74a99c21840679933b9ef6fdc16a61","modified":1598193217532},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"8cf318644acc8b4978537c263290363e21c7f5af","modified":1598193217533},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"f9760ecf186954cee3ba4a149be334e9ba296b89","modified":1598193217532},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"761eba9811b050b25d548cc0854de4824b41eb08","modified":1598193217538},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"39f04c4c7237a4e10acd3002331992b79945d241","modified":1598193217538},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-dimmer.styl","hash":"11c22f0fb3f6beb13e5a425ec064a4ff974c13b7","modified":1598193217539},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"8dd9a1c6f4f6baa00c2cf01837e7617120cf9660","modified":1598193217539},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"61f8cea3c01acd600e90e1bc2a07def405503748","modified":1598193217539},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"4e3838d7ac81d9ad133960f0f7ed58a44a015285","modified":1598193217532},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"c8fe49a4bc014c24dead05b782a7082411a4abc5","modified":1598193217540},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"1153bb71edf253765145559674390e16dd67c633","modified":1598193217540},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"a1521d48bb06d8d703753f52a198baa197af7da2","modified":1598193217540},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"5ef6343835f484a2c0770bd1eb9cc443609e4c39","modified":1598193217540},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"2fe76476432b31993338cb45cdb3b29a518b6379","modified":1598193217541},{"_id":"themes/next/source/css/_common/components/tags/exturl.styl","hash":"a3bdd71237afc112b2aa255f278cab6baeb25351","modified":1598193217542},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"f825da191816eef69ea8efb498a7f756d5ebb498","modified":1598193217542},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"e71652d3216e289c8548b1ea2357822c1476a425","modified":1598193217541},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"2ad1a2a9bbf6742d1b0762c4c623b68113d1e0fe","modified":1598193217542},{"_id":"themes/next/source/css/_common/components/tags/label.styl","hash":"2ab1322fe52ab5aafd49e68f5bd890e8380ee927","modified":1598193217543},{"_id":"themes/next/source/css/_common/components/tags/note.styl","hash":"9a409b798decdefdaf7a23f0b11004a8c27e82f3","modified":1598193217543},{"_id":"themes/next/source/css/_common/components/tags/note-modern.styl","hash":"b7076e58d647265ee0ad2b461fe8ce72c9373bc5","modified":1598193217543},{"_id":"themes/next/source/css/_common/components/tags/tabs.styl","hash":"154a87a32d2fead480d5e909c37f6c476671c5e6","modified":1598193217544},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"b80604868e4f5cf20fccafd7ee415c20c804f700","modified":1598193217544},{"_id":"themes/next/source/css/_common/components/third-party/algolia-search.styl","hash":"bba4f3bdb7517cd85376df3e1209b570c0548c69","modified":1598193217545},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"a6e7d698702c2e383dde3fde2abde27951679084","modified":1598193217545},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"5dbeed535d63a50265d96b396a5440f9bb31e4ba","modified":1598193217545},{"_id":"themes/next/source/css/_common/components/third-party/duoshuo.styl","hash":"717cc7f82be9cc151e23a7678601ff2fd3a7fa1d","modified":1598193217545},{"_id":"themes/next/source/css/_common/components/third-party/gitment.styl","hash":"874278147115601d2abf15987f5f7a84ada1ac6b","modified":1598193217546},{"_id":"themes/next/source/css/_common/components/third-party/han.styl","hash":"10599e16414a8b7a76c4e79e6617b5fe3d4d1adf","modified":1598193217546},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"16087276945fa038f199692e3eabb1c52b8ea633","modified":1598193217547},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"15975ba7456b96916b1dbac448a1a0d2c38b8f3d","modified":1598193217546},{"_id":"themes/next/source/css/_common/components/third-party/needsharebutton.styl","hash":"28825ae15fa20ae3942cdaa7bcc1f3523ce59acc","modified":1598193217547},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"1f09be9bb38411f0629b58c3b23873589a6dbcaa","modified":1598193217558},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"1f09be9bb38411f0629b58c3b23873589a6dbcaa","modified":1598193217556},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"9c8196394a89dfa40b87bf0019e80144365a9c93","modified":1598193217547},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"a07aa12cc36ac5c819670c2a3c17d07ed7a08986","modified":1598193217555},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1598193217575},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1598193217576},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1598193217576},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1598193217577},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","hash":"623af3ed5423371ac136a4fe0e8cc7bb7396037a","modified":1598193217577},{"_id":"themes/next/source/lib/Han/dist/han.js","hash":"4ac683b2bc8531c84d98f51b86957be0e6f830f3","modified":1598193217578},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1598193217587},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"ee948b4489aedeb548a77c9e45d8c7c5732fd62d","modified":1598193217588},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"6394c48092085788a8c0ef72670b0652006231a1","modified":1598193217588},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"51139a4c79573d372a347ef01a493222a1eaf10a","modified":1598193217588},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"b88b589f5f1aa1b3d87cc7eef34c281ff749b1ae","modified":1598193217589},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"d22b1629cb23a6181bebb70d0cf653ffe4b835c8","modified":1598193217589},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1598193217627},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1598193217632},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1598193217631},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1598193217629},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","hash":"90a1b22129efc172e2dfcceeeb76bff58bc3192f","modified":1598193217582},{"_id":"themes/next/source/lib/three/three.min.js","hash":"26273b1cb4914850a89529b48091dc584f2c57b8","modified":1598193217647},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"b5483b11f8ba213e733b5b8af9927a04fec996f6","modified":1598193217630},{"_id":"public/search.xml","hash":"a909d772df52c471e07bab5cf37f1795f4506f84","modified":1598272084091},{"_id":"public/tags/index.html","hash":"aac8cd7bf0c644eb937c3c89ddd0c129a745b51f","modified":1598272084091},{"_id":"public/categories/index.html","hash":"68c12427e40d129d426695abfe74e1258fe9dde9","modified":1598272084091},{"_id":"public/2020/08/23/在不同的电脑上更新Hexo博客/index.html","hash":"abe450a5d4035546e7e24a4132af1b1c73204d94","modified":1598272084091},{"_id":"public/2020/08/10/论文笔记-Privacy-Preserving-Ridge-Regression-with-only-Linearly-Homomorphic-Encryption/index.html","hash":"460abdd344cda1bd288c14abfbc0005325334d00","modified":1598272084091},{"_id":"public/2020/07/10/Zotero的附件同步/index.html","hash":"f79f7ba1fbdc3c60b71fa06dc3e25b8ac6115246","modified":1598272084091},{"_id":"public/2020/08/09/论文笔记-Linear-Regression-on-Packed-Encrypted-Data-in-the-Two-Server-Model/index.html","hash":"254a0674811194969b5c758c3f97458ce8b76f1f","modified":1598272084091},{"_id":"public/2020/07/09/论文笔记-Efficient-Multi-Key-Homomorphic-Encryption-with-Packed-Ciphertexts-with-Application-to-Oblivious-Neural-Network-Inference/index.html","hash":"e8ed9a45e255aa9dcaab3c70ae7b7e4a2d95dbfe","modified":1598272084091},{"_id":"public/2020/07/06/群与环的概念/index.html","hash":"46d29ace1cabdc41543a5efb834bfb0b7b1b03c8","modified":1598272084091},{"_id":"public/2020/07/03/全同态加密算法深入解析/index.html","hash":"00d70b17a688229c771f2f0c10d651c5e9459e46","modified":1598272084091},{"_id":"public/2020/07/02/论文笔记-Privacy-preserving-SVM-on-Outsourced-Genomic-Data-via-Secure-Multi-party-Computation/index.html","hash":"61d1edf9548de1084784d71f8225f8a4c5af1764","modified":1598272084091},{"_id":"public/2020/06/28/C-环境设置/index.html","hash":"d631462011790486a0c0ac959a2c3a1b25f1f22a","modified":1598272084091},{"_id":"public/2020/06/19/PPML中的2PC对比3PC/index.html","hash":"7f19d3c7780bd6c8c6a013f6a51c12627c050ae6","modified":1598272084091},{"_id":"public/2020/06/18/论文笔记-ABY3-A-Mixed-Protocol-Framework-for-Machine-Learning/index.html","hash":"6a516d1f1c5e2fde46b60d9a2f5e17e7f0e28940","modified":1598272084091},{"_id":"public/2020/06/17/论文笔记-SecureML-A-System-for-Scalable-Privacy-Preserving-Machine-Learning/index.html","hash":"1dd2b03f92ec1635b17087205bd700542db0b815","modified":1598272084091},{"_id":"public/2020/06/16/论文笔记-Improved-Garbled-Circuit-Free-XOR-Gates-and-Applications/index.html","hash":"2645c2ad132fd58cbd0dcf61abf59456142fb92a","modified":1598272084091},{"_id":"public/2020/06/11/论文笔记-ABY-A-Framework-for-Efficient-Mixed-Protocol-Secure-Two-Party-Computation/index.html","hash":"04a06b44303de9d05e3eabcf2f99523eeb3ee4d6","modified":1598272084091},{"_id":"public/2020/06/10/论文笔记-High-Throughput-Semi-Honest-Secure-Three-Party-Computation-with-an-Honest-Majority/index.html","hash":"afa18eaae63478f03a3c67caadc2c1938f6c9684","modified":1598272084091},{"_id":"public/2020/05/26/论文笔记-Oblivious-Neural-Network-Predictions-via-MiniONN-Transformations/index.html","hash":"b8b97d19316a9286e6cf3e8ef61f60475ed8acf7","modified":1598272084091},{"_id":"public/2020/05/25/LeetCode刷题/index.html","hash":"adbc7d8612f3e425ffbace225907d0267d65b41c","modified":1598272084091},{"_id":"public/2020/05/20/PyTorch入门60题/index.html","hash":"d36432aee22ba812c12ef556bf97a113de688b34","modified":1598272084091},{"_id":"public/2020/05/20/使用you-get下载网址视频/index.html","hash":"a21086a2f1210d80305057d5892fd8e3fd28c947","modified":1598272084091},{"_id":"public/2020/05/18/论文笔记-Designing-an-e-commerce-recommender-system-based-on-collaborative-filtering-using-a-data-mining-approach/index.html","hash":"c5d87427b3cad0c56559cb7e743691aa85c5ee98","modified":1598272084091},{"_id":"public/2020/05/11/Hexo博客NexT主题翻页按钮显示不正常的解决方法/index.html","hash":"561bc0fd58fbfdab62690c21ee2de45dc0c869aa","modified":1598272084091},{"_id":"public/2020/05/01/JupyterLab安装/index.html","hash":"bd2be5ece88afdc7483327b6bbc33f156a91b04c","modified":1598272084091},{"_id":"public/2020/05/11/Hexo博客NexT主题点击侧边栏日志出现问题的解决办法/index.html","hash":"10a112e819b3f6d33ef4bfe1477b86dae9f27c06","modified":1598272084091},{"_id":"public/2020/05/11/Hexo博客NexT主题使用不蒜子统计访客数/index.html","hash":"d76c7ac5f2ccc28fff99fc79d04e9b598330c9ad","modified":1598272084091},{"_id":"public/2020/04/26/LaTeX常用符号表示方法/index.html","hash":"8530940040590b2bdd03073683942c23e5ad04e1","modified":1598272084091},{"_id":"public/2020/04/25/不经意传输（Oblivious-Transfer）/index.html","hash":"49a11383aa2137d4658447488bfa945db84bb328","modified":1598272084091},{"_id":"public/2020/04/24/解决Ubuntu-deepin-wine微信字体乱码/index.html","hash":"5ecfeb5351f07f5dc44ce83716063cc2b2167708","modified":1598272084091},{"_id":"public/2020/04/20/论文笔记-ASTRA-High-Throughput-3PC-over-Rings-with-Application-to-Secure-Prediction/index.html","hash":"f15447234df0517bf49454fa43c4168eba9da8c3","modified":1598272084091},{"_id":"public/2020/04/20/CCF推荐国际学术会议和期刊目录（网络与信息安全）/index.html","hash":"fe48f2e59f83ca7556908800cdd21cdd0cb2248a","modified":1598272084091},{"_id":"public/2020/04/16/论文笔记-Automatic-Unit-Test-Generation-and-Execution-for-JavaScript-Program-through-Symbolic-Execution/index.html","hash":"0c83c46ecd03b2e67984d221331503b4f9a583c1","modified":1598272084091},{"_id":"public/archives/index.html","hash":"f29d9b1e17e3eda00e25a9be261e56523f33e4d9","modified":1598272084091},{"_id":"public/2020/04/11/Hexo博客搭建/index.html","hash":"dcc523ee036ceccee729ccda3cef3ccc30f82510","modified":1598272084091},{"_id":"public/archives/page/2/index.html","hash":"6c3ad84a333b919c56ff34a2d2b082750e4ae997","modified":1598272084091},{"_id":"public/archives/page/3/index.html","hash":"0edcfa0ef7268909803b2791960517872a926ed5","modified":1598272084091},{"_id":"public/archives/page/4/index.html","hash":"b8816af0ae65b3673202fc0d18780b7d316e90af","modified":1598272084091},{"_id":"public/archives/2020/index.html","hash":"83311b6ee18f7f4f00344fbaa0217dbf33e17958","modified":1598272084091},{"_id":"public/archives/2020/page/2/index.html","hash":"823b3bbe723d3eebf5c02df8480e18474edcb175","modified":1598272084091},{"_id":"public/archives/2020/page/3/index.html","hash":"dfccbb4ff4f746bee6248fcfaf4887c86beb47c2","modified":1598272084091},{"_id":"public/archives/2020/page/4/index.html","hash":"9f82efa3d1e9ecc09d21989eb5b06db374bee804","modified":1598272084091},{"_id":"public/archives/2020/04/index.html","hash":"79d6fd19844e0d7fafe1fb36738a3216fabb57e5","modified":1598272084091},{"_id":"public/archives/2020/05/index.html","hash":"d22981f40c32311ce658e03d01b0985cccf55af3","modified":1598272084091},{"_id":"public/archives/2020/06/index.html","hash":"a0eb7db9ce10ab77966584a9ccb64885236d41ee","modified":1598272084091},{"_id":"public/archives/2020/08/index.html","hash":"68258b9badde5336193902362f72c2dff8b877c1","modified":1598272084091},{"_id":"public/archives/2020/07/index.html","hash":"f9654cc3724369ccd491d1f286cd85d5ab1354e1","modified":1598272084091},{"_id":"public/categories/Env/index.html","hash":"77e1f76e77fbf18ed424bfa9f87e5fb9a39c2976","modified":1598272084091},{"_id":"public/categories/Env/page/2/index.html","hash":"66650d5219af263b4e0a748f977add2362e416a7","modified":1598272084091},{"_id":"public/categories/Papers/index.html","hash":"afbf7e371f640639e6f7fdb769291c528e9726c2","modified":1598272084091},{"_id":"public/categories/Papers/page/2/index.html","hash":"3fe1ad4abe723209f2540e4e6dbe60feb7885855","modified":1598272084091},{"_id":"public/categories/Study/index.html","hash":"a4a3926dd410a57c2df37e394ac179291ee32c62","modified":1598272084091},{"_id":"public/categories/Coding/index.html","hash":"d96fd86d4b98673db787ad5d08e41418997fb036","modified":1598272084091},{"_id":"public/tags/密码学/index.html","hash":"6d8d09826dec3ec071676866207ee7f5e6f34ff0","modified":1598272084091},{"_id":"public/tags/C/index.html","hash":"8aef55059a6d416430cba8fd18d9bba594eed5b6","modified":1598272084091},{"_id":"public/tags/Hexo/index.html","hash":"9d3d43fbb7de727d9cb05ca098d575806c76de9b","modified":1598272084091},{"_id":"public/tags/NexT/index.html","hash":"34063f7728a9cda783437904fa7e8edf97143144","modified":1598272084091},{"_id":"public/tags/不蒜子/index.html","hash":"0b4c1273714cd2ac0ae58735ba3a75e7744664a7","modified":1598272084091},{"_id":"public/tags/Jupyter/index.html","hash":"0c2f48a8a7286f7cf743c7e97d30c4efa9da0558","modified":1598272084091},{"_id":"public/tags/Linux/index.html","hash":"181890a2b226764506dc50460f28840d3e71482a","modified":1598272084091},{"_id":"public/tags/LaTeX/index.html","hash":"4266913ee4bdd02c80e356b603c6997b2b855ac2","modified":1598272084091},{"_id":"public/tags/MPC/index.html","hash":"94499ee1e4a8489328991062b69fbbf757d29743","modified":1598272084091},{"_id":"public/tags/PPML/index.html","hash":"97889ac84c40667c4dc2ef383f99ada6a930cedd","modified":1598272084091},{"_id":"public/tags/Secret-Sharing/index.html","hash":"329f117831b2b8f7a63c89ebf5445c0924f332c8","modified":1598272084091},{"_id":"public/tags/PyTorch/index.html","hash":"108c8a6b280035c552e299671868302d930916ae","modified":1598272084091},{"_id":"public/tags/Python/index.html","hash":"ca6c3fc51bde7e515804f35ab3c7386fc1832023","modified":1598272084091},{"_id":"public/tags/Zotero/index.html","hash":"5c3d710080acaee3cc62d89426bbbb17576fedde","modified":1598272084091},{"_id":"public/tags/坚果云/index.html","hash":"2fdc662daa0c89b5a1b5dc1348e8f989a1543c47","modified":1598272084091},{"_id":"public/tags/HE/index.html","hash":"9bd49d1d946800975d28105be092afc8d4d6469e","modified":1598272084091},{"_id":"public/tags/PaperShip/index.html","hash":"c3c08ee918b178a28c25f03c7152c02fcdb1e322","modified":1598272084091},{"_id":"public/tags/群/index.html","hash":"5832236cd1438ba3789c013c4cc45d35657a6a77","modified":1598272084091},{"_id":"public/tags/环/index.html","hash":"21473fa8666a4e2b019042d419d6064afc5250d4","modified":1598272084091},{"_id":"public/tags/近世代数/index.html","hash":"73ff769dbefcc56754d6766a0ae55bcd30259a12","modified":1598272084091},{"_id":"public/tags/Ubuntu/index.html","hash":"06997d6a5ac14838bd8a3bd6f68ff96bb7369ed3","modified":1598272084091},{"_id":"public/tags/Neural-Network/index.html","hash":"a08829188d70cdbe45da68b233c49988ad5f9310","modified":1598272084091},{"_id":"public/tags/SVM/index.html","hash":"f27c04226391fc1b43288656967ea9780d5c3376","modified":1598272084091},{"_id":"public/tags/Linear-Regression/index.html","hash":"5ce51e43295c624eff9ede6c19a6237bc21b68ba","modified":1598272084091},{"_id":"public/tags/Logistic-Regression/index.html","hash":"43c5bb7cf4eb22fedca3226b8f5dc55fa0edcbb4","modified":1598272084091},{"_id":"public/tags/数据挖掘/index.html","hash":"417f66d2f8b3d89f9c1f3c3d0b5379ee4a3970a9","modified":1598272084091},{"_id":"public/tags/推荐系统/index.html","hash":"04b19babfb05aea75707a548da73a44a500643b3","modified":1598272084091},{"_id":"public/tags/JavaScript/index.html","hash":"b0f1600fb94d93f48df7a08124352142efa075ec","modified":1598272084091},{"_id":"public/tags/测试/index.html","hash":"d4a1020720f6737ee1d499862adfe8f9bf92ce8e","modified":1598272084091},{"_id":"public/tags/Garbled-Circuit/index.html","hash":"1eb9904604a093d848e86c13736e35f26fcc4d83","modified":1598272084091},{"_id":"public/tags/LeetCode/index.html","hash":"18cd404dcf7cbfe9d995889a3ef13a52fa598391","modified":1598272084091},{"_id":"public/tags/HIV-co-receptor-prediction/index.html","hash":"dfe53ed560851e08848fb70a7b1911c6d4e82da6","modified":1598272084091},{"_id":"public/page/2/index.html","hash":"3c333dc036fdbf02f3762257eb386bc586d15ec5","modified":1598272084091},{"_id":"public/page/3/index.html","hash":"2a6c23298dd95e1caf0774f2f49947138c8f5670","modified":1598272084091},{"_id":"public/page/4/index.html","hash":"0c7e2d9191c22820c5bbd70b977a8754f286e770","modified":1598272084091},{"_id":"public/index.html","hash":"fe044315fa22f6f4097fb22a3eacab9e34c82865","modified":1598272084091},{"_id":"public/CNAME","hash":"b486611401bdc3e310f128972b45650b2f15a8dc","modified":1598197832789},{"_id":"public/images/jm.png","hash":"5fd5030da2624ea928553840d156583eedbaadd6","modified":1598197832789},{"_id":"public/images/jm16.ico","hash":"20565e7e04d714f5b35cf75de6c3f68b58d9d938","modified":1598197832789},{"_id":"public/images/algolia_logo.svg","hash":"45eeea0b5fba833e21e38ea10ed5ab385ceb4f01","modified":1598197832789},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1598197832789},{"_id":"public/images/jm32.ico","hash":"f574fcf2b5889ff5b3faba64a0d21fbe21bb78e2","modified":1598197832789},{"_id":"public/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1598197832789},{"_id":"public/images/cc-by-nc-nd.svg","hash":"bc3588c9b2d7c68830524783120ff6cf957cf668","modified":1598197832789},{"_id":"public/images/cc-by-nc.svg","hash":"6f076713fb9bf934aa2c1046bdf2cf2e37bc1eab","modified":1598197832789},{"_id":"public/images/cc-by-nc-sa.svg","hash":"6f55543d1fb9cbc436c101d24f802dec7b41efc3","modified":1598197832789},{"_id":"public/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1598197832789},{"_id":"public/images/cc-by-nd.svg","hash":"42cd73da328077ccc92f859bb8f3cf621b3484f8","modified":1598197832789},{"_id":"public/images/cc-by-sa.svg","hash":"70c1535f43e54e5ff35ca81419e77e4c0c301398","modified":1598197832789},{"_id":"public/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1598197832789},{"_id":"public/images/cc-by.svg","hash":"e92a33c32d1dac8ed94849b2b4e6456e887efe70","modified":1598197832789},{"_id":"public/images/logo.svg","hash":"169f56fd82941591dad3abd734a50ec7259be950","modified":1598197832789},{"_id":"public/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1598197832789},{"_id":"public/images/quote-r.svg","hash":"2a2a250b32a87c69dcc1b1976c74b747bedbfb41","modified":1598197832789},{"_id":"public/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1598197832789},{"_id":"public/images/cc-zero.svg","hash":"9bfb52b2f63527a7049247bf00d44e6dc1170e7d","modified":1598197832789},{"_id":"public/images/quote-l.svg","hash":"cd108d6f44351cadf8e6742565217f88818a0458","modified":1598197832789},{"_id":"public/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1598197832789},{"_id":"public/lib/font-awesome/HELP-US-OUT.txt","hash":"ee33b2798b1e714b904d663436c6b3521011d1fa","modified":1598197832789},{"_id":"public/lib/fastclick/LICENSE","hash":"6f474ea75c42442da7bbcf2e9143ce98258efd8d","modified":1598197832789},{"_id":"public/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1598197832789},{"_id":"public/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1598197832789},{"_id":"public/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1598197832789},{"_id":"public/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1598197832789},{"_id":"public/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1598197832789},{"_id":"public/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1598197832789},{"_id":"public/images/20200417221334.jpg","hash":"f1265327e88a201e21642dc915930296f6bfab6c","modified":1598197832789},{"_id":"public/lib/font-awesome/css/font-awesome.css.map","hash":"1573904b82807abbb32c97a3632c6c6808eaac50","modified":1598197832789},{"_id":"public/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1598197832789},{"_id":"public/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1598197832789},{"_id":"public/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1598197832789},{"_id":"public/lib/Han/dist/font/han.woff2","hash":"623af3ed5423371ac136a4fe0e8cc7bb7396037a","modified":1598197832789},{"_id":"public/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1598197832789},{"_id":"public/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1598197832789},{"_id":"public/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1598197832789},{"_id":"public/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1598197832789},{"_id":"public/js/src/bootstrap.js","hash":"034bc8113e0966fe2096ba5b56061bbf10ef0512","modified":1598197832789},{"_id":"public/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1598197832789},{"_id":"public/js/src/post-details.js","hash":"a13f45f7aa8291cf7244ec5ba93907d119c5dbdd","modified":1598197832789},{"_id":"public/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1598197832789},{"_id":"public/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1598197832789},{"_id":"public/js/src/motion.js","hash":"754b294394f102c8fd9423a1789ddb1201677898","modified":1598197832789},{"_id":"public/js/src/scroll-cookie.js","hash":"09dc828cbf5f31158ff6250d2bf7c3cde6365c67","modified":1598197832789},{"_id":"public/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1598197832789},{"_id":"public/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1598197832789},{"_id":"public/js/src/utils.js","hash":"9b1325801d27213083d1487a12b1a62b539ab6f8","modified":1598197832789},{"_id":"public/lib/canvas-ribbon/canvas-ribbon.js","hash":"ff5915eb2596e890a2fc6697c864f861a1995ec0","modified":1598197832789},{"_id":"public/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1598197832789},{"_id":"public/lib/font-awesome/bower.json","hash":"64394a2a9aa00f8e321d8daa5e51a420f0e96dad","modified":1598197832789},{"_id":"public/lib/fastclick/bower.json","hash":"4dcecf83afddba148464d5339c93f6d0aa9f42e9","modified":1598197832789},{"_id":"public/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1598197832789},{"_id":"public/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1598197832789},{"_id":"public/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1598197832789},{"_id":"public/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1598197832789},{"_id":"public/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1598197832789},{"_id":"public/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1598197832789},{"_id":"public/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1598197832789},{"_id":"public/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1598197832789},{"_id":"public/lib/fastclick/README.html","hash":"bebfc78c02e1ac2c219fc5b206c2826c35690669","modified":1598197832789},{"_id":"public/css/main.css","hash":"91001f2f306eef24ae19c4ff22aa632199d5338f","modified":1598197832789},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1598197832789},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1598197832789},{"_id":"public/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1598197832789},{"_id":"public/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1598197832789},{"_id":"public/lib/pace/pace.min.js","hash":"9944dfb7814b911090e96446cea4d36e2b487234","modified":1598197832789},{"_id":"public/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1598197832789},{"_id":"public/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1598197832789},{"_id":"public/lib/needsharebutton/needsharebutton.css","hash":"3ef0020a1815ca6151ea4886cd0d37421ae3695c","modified":1598197832789},{"_id":"public/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1598197832789},{"_id":"public/lib/jquery_lazyload/bower.json","hash":"ae3c3b61e6e7f9e1d7e3585ad854380ecc04cf53","modified":1598197832789},{"_id":"public/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1598197832789},{"_id":"public/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1598197832789},{"_id":"public/lib/velocity/bower.json","hash":"0ef14e7ccdfba5db6eb3f8fc6aa3b47282c36409","modified":1598197832789},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1598197832789},{"_id":"public/js/src/schemes/pisces.js","hash":"8050a5b2683d1d77238c5762b6bd89c543daed6e","modified":1598197832789},{"_id":"public/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1598197832789},{"_id":"public/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1598197832789},{"_id":"public/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1598197832789},{"_id":"public/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1598197832789},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1598197832789},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1598197832789},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1598197832789},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1598197832789},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1598197832789},{"_id":"public/lib/jquery_lazyload/CONTRIBUTING.html","hash":"d93ee404d9fdf816d07f77c002ba43a716760350","modified":1598197832789},{"_id":"public/lib/jquery_lazyload/README.html","hash":"fd960c31c8cfe7596f3064aef5a0551cda49eab5","modified":1598197832789},{"_id":"public/lib/needsharebutton/needsharebutton.js","hash":"9885fd9bea5e7ebafc5b1de9d17be5e106248d96","modified":1598197832789},{"_id":"public/lib/needsharebutton/font-embedded.css","hash":"c39d37278c1e178838732af21bd26cd0baeddfe0","modified":1598197832789},{"_id":"public/lib/three/canvas_sphere.min.js","hash":"d8ea241a53c135a650f7335d2b6982b899fd58a9","modified":1598197832789},{"_id":"public/lib/three/canvas_lines.min.js","hash":"dce4a3b65f8bf958f973690caa7ec4952f353b0c","modified":1598197832789},{"_id":"public/lib/three/three-waves.min.js","hash":"d968cba6b3a50b3626a02d67b544f349d83b147c","modified":1598197832789},{"_id":"public/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1598197832789},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1598197832789},{"_id":"public/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1598197832789},{"_id":"public/lib/Han/dist/han.min.js","hash":"f559c68a25065a14f47da954a7617d87263e409d","modified":1598197832789},{"_id":"public/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1598197832789},{"_id":"public/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1598197832789},{"_id":"public/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1598197832789},{"_id":"public/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1598197832789},{"_id":"public/lib/Han/dist/han.css","hash":"bd40da3fba8735df5850956814e312bd7b3193d7","modified":1598197832789},{"_id":"public/lib/Han/dist/han.min.css","hash":"a0c9e32549a8b8cf327ab9227b037f323cdb60ee","modified":1598197832789},{"_id":"public/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1598197832789},{"_id":"public/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1598197832789},{"_id":"public/lib/Han/dist/han.js","hash":"e345397e0585c9fed1449e614ec13e0224acf2ab","modified":1598197832789},{"_id":"public/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1598197832789},{"_id":"public/lib/three/three.min.js","hash":"73f4cdc17e51a72b9bf5b9291f65386d615c483b","modified":1598197832789},{"_id":"public/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1598197832789},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1598197832789},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1598197832789},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"b5483b11f8ba213e733b5b8af9927a04fec996f6","modified":1598197832789},{"_id":"source/_posts/Java接口、多态总结.md","hash":"625c243cd09e15a2e219672ffc04d14dffa5b1a0","modified":1598198964087},{"_id":"source/_posts/Java构造方法总结.md","hash":"8dad8c9f3d6ea24b26d39486f71d2420b321223d","modified":1598199036191},{"_id":"source/_posts/Java继承、抽象总结.md","hash":"46b50ba0b1cc73870213139e37ef9dce5e5855dc","modified":1598198846006},{"_id":"public/2020/08/24/Java构造方法总结/index.html","hash":"a625319f30ead26ea1a55da313bb5ac6ee935deb","modified":1598272084091},{"_id":"public/2020/08/24/Java继承、抽象总结/index.html","hash":"7e6e8e7011fd803eb376362c74d9ed07bdb9422e","modified":1598272084091},{"_id":"public/2020/08/24/Java接口、多态总结/index.html","hash":"3de387aaa2f1488a9cbbbc7cd1e77b7d33456580","modified":1598272084091},{"_id":"public/tags/Java/index.html","hash":"9efd378622e2a76d44c02c9b12ca23826d68ece7","modified":1598272084091},{"_id":"public/tags/面向对象/index.html","hash":"9d2425628c7a7bac266e276d918b308372ec7378","modified":1598272084091},{"_id":"source/_posts/Java的final、static、匿名对象、内部类、包的声明与访问、访问修饰符以及代码块.md","hash":"d132a09901e26a3bcf3bb297cff993e415b9da6e","modified":1598272052586},{"_id":"public/2020/08/24/Java的final、static、匿名对象、内部类、包的声明与访问、访问修饰符以及代码块/index.html","hash":"5de1a04f34a9ac995c4c4a1def954d6326ac101d","modified":1598272084091}],"Category":[{"name":"Env","_id":"cke79q4ov000288ps7sav52vb"},{"name":"Papers","_id":"cke79q4oz000788ps1940ajsc"},{"name":"Study","_id":"cke79q4p6000n88pscung8yy8"},{"name":"Coding","_id":"cke79q4pb000v88ps071w2vhf"}],"Data":[],"Page":[{"title":"分类","date":"2020-04-15T14:28:14.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: 分类\ndate: 2020-04-15 22:28:14\ntype: categories\n---\n","updated":"2020-08-23T14:33:37.438Z","path":"categories/index.html","comments":1,"layout":"page","_id":"cke79q4ti004588psby04hhms","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"标签","date":"2020-04-15T15:20:40.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: 标签\ndate: 2020-04-15 23:20:40\ntype: tags\n---\n","updated":"2020-08-23T14:33:37.440Z","path":"tags/index.html","comments":1,"layout":"page","_id":"cke79q4tk004788psdxiq09f5","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"C++环境设置","date":"2020-06-28T13:42:53.000Z","_content":"\n----\n\n\n\n<!--more-->\n\n# 安装GNU的C/C++编译器\n\n## UNIX/Linux上的安装\n\n首先在命令行使用以下命令确认系统是否安装了GCC：\n\n```shell\n$ g++ -v\n```\n\n如果系统已经安装了GNU编译器，会显示如下的消息：\n\n```shell\nUsing built-in specs.\nCOLLECT_GCC=gcc\nCOLLECT_LTO_WRAPPER=/usr/libexec/gcc/x86_64-redhat-linux/4.8.5/lto-wrapper\nTarget: x86_64-redhat-linux\nConfigured with: ../configure --prefix=/usr --mandir=/usr/share/man --infodir=/usr/share/info --with-bugurl=http://bugzilla.redhat.com/bugzilla --enable-bootstrap --enable-shared --enable-threads=posix --enable-checking=release --with-system-zlib --enable-__cxa_atexit --disable-libunwind-exceptions --enable-gnu-unique-object --enable-linker-build-id --with-linker-hash-style=gnu --enable-languages=c,c++,objc,obj-c++,java,fortran,ada,go,lto --enable-plugin --enable-initfini-array --disable-libgcj --with-isl=/builddir/build/BUILD/gcc-4.8.5-20150702/obj-x86_64-redhat-linux/isl-install --with-cloog=/builddir/build/BUILD/gcc-4.8.5-20150702/obj-x86_64-redhat-linux/cloog-install --enable-gnu-indirect-function --with-tune=generic --with-arch_32=x86-64 --build=x86_64-redhat-linux\nThread model: posix\ngcc version 4.8.5 20150623 (Red Hat 4.8.5-39) (GCC) \n```\n\n\n\n若未安装，可以使用以下三条命令进行安装：\n\n```shell\n$ yum install gcc\n$ yum install gcc-c++\n$ yum install gdb\n```\n\n\n\n## Windows上的安装\n\n首先访问www.mingw.org，右上方进入下载页面，下载最新版本的MinGW安装程序。\n\n![](http://images.yingwai.top/picgo/gccf1.png)\n\n安装完成后将 MinGW\\bin 路径添加到系统环境变量里。\n\n然后打开 MinGW Installation Manager，点击All Packages把想要安装的Package选中或点击Basic Setup选择mingw32-gcc-g++-bin：\n\n![](http://images.yingwai.top/picgo/gccf2.png)\n\n选择完后点击菜单栏Installation中的Apply changes选项，如果出现某种原因安装未能成功，选择review changes选项重新安装。\n\n完成安装后可以在命令行中输入 `g++ -v`、 `gcc -v` 和 `mingw32-make -v` 检查是否安装成功。\n\n\n\n# g++ 应用说明\n\nhelloworld.cpp 中包含如下简单代码：\n\n```c++\n#include <iostream>\nusing namespace std;\nint main(){\n    cout << \"Hello, world!\" << endl;\n    return 0;\n}\n```\n\n最简单的编译方式为：\n\n```shell\n$ g++ helloworld.cpp\n```\n\n由于命令行中未指定可执行程序的文件名，编译器采用默认的 a.out。程序可以这样来运行：\n\n```shell\n$ ./a.out\nHello, world!\n```\n\n通常我们使用 `-o` 选项指定可执行程序的文件名，以下实例生成一个 helloworld 的可执行文件：\n\n```shell\n$ g++ helloworld.cpp -o helloworld\n```\n\n执行 helloworld：\n\n```shell\n$ ./helloworld\nHello, world!\n```\n\n如果是多个 C++ 代码文件，如 ray1.cpp、ray2.cpp，编译命令如下：\n\n```shell\n$ g++ ray1.cpp ray2.cpp -o ray\n```\n\n生成一个 ray 可执行文件。\n\n\n\n## g++ 常用命令选项\n\nhttps://www.runoob.com/cplusplus/cpp-environment-setup.html\n\n| 选项          | 解释                                                         |\n| ------------- | ------------------------------------------------------------ |\n| `-ansi`       | 只支持 ANSI 标准的 C 语法。这一选项将禁止 GNU C 的某些特色， 例如 asm 或 typeof 关键词。 |\n| `-c`          | 只编译并生成目标文件。                                       |\n| `-DMACRO`     | 以字符串\"1\"定义 MACRO 宏。                                   |\n| `-E`          | 只运行 C 预编译器。                                          |\n| `-g`          | 生成调试信息。GNU 调试器可利用该信息。                       |\n| `-IDIRECTORY` | 指定额外的头文件搜索路径DIRECTORY。                          |\n| `-LDIRECTORY` | 指定额外的函数库搜索路径DIRECTORY。                          |\n| `-lLIBRARY`   | 连接时搜索指定的函数库LIBRARY。                              |\n| `-m486`       | 针对 486 进行代码优化。                                      |\n| `-o`          | FILE 生成指定的输出文件。用在生成可执行文件时。              |\n| `-O0`         | 不进行优化处理。                                             |\n| `-O`          | 或 `-O1` 优化生成代码。                                      |\n| `-O2`         | 进一步优化。                                                 |\n| `-O3`         | 比 `-O2` 更进一步优化，包括 inline 函数。                    |\n| `-shared`     | 生成共享目标文件。通常用在建立共享库时。                     |\n| `-static`     | 禁止使用共享连接。                                           |\n| `-UMACRO`     | 取消对 MACRO 宏的定义。                                      |\n| `-w`          | 不生成任何警告信息。                                         |\n| `-Wall`       | 生成所有警告信息。                                           |\n\n","source":"_posts/C-环境设置.md","raw":"---\ntitle: C++环境设置\ndate: 2020-06-28 21:42:53\ncategories: Env\ntags: [C++]\n---\n\n----\n\n\n\n<!--more-->\n\n# 安装GNU的C/C++编译器\n\n## UNIX/Linux上的安装\n\n首先在命令行使用以下命令确认系统是否安装了GCC：\n\n```shell\n$ g++ -v\n```\n\n如果系统已经安装了GNU编译器，会显示如下的消息：\n\n```shell\nUsing built-in specs.\nCOLLECT_GCC=gcc\nCOLLECT_LTO_WRAPPER=/usr/libexec/gcc/x86_64-redhat-linux/4.8.5/lto-wrapper\nTarget: x86_64-redhat-linux\nConfigured with: ../configure --prefix=/usr --mandir=/usr/share/man --infodir=/usr/share/info --with-bugurl=http://bugzilla.redhat.com/bugzilla --enable-bootstrap --enable-shared --enable-threads=posix --enable-checking=release --with-system-zlib --enable-__cxa_atexit --disable-libunwind-exceptions --enable-gnu-unique-object --enable-linker-build-id --with-linker-hash-style=gnu --enable-languages=c,c++,objc,obj-c++,java,fortran,ada,go,lto --enable-plugin --enable-initfini-array --disable-libgcj --with-isl=/builddir/build/BUILD/gcc-4.8.5-20150702/obj-x86_64-redhat-linux/isl-install --with-cloog=/builddir/build/BUILD/gcc-4.8.5-20150702/obj-x86_64-redhat-linux/cloog-install --enable-gnu-indirect-function --with-tune=generic --with-arch_32=x86-64 --build=x86_64-redhat-linux\nThread model: posix\ngcc version 4.8.5 20150623 (Red Hat 4.8.5-39) (GCC) \n```\n\n\n\n若未安装，可以使用以下三条命令进行安装：\n\n```shell\n$ yum install gcc\n$ yum install gcc-c++\n$ yum install gdb\n```\n\n\n\n## Windows上的安装\n\n首先访问www.mingw.org，右上方进入下载页面，下载最新版本的MinGW安装程序。\n\n![](http://images.yingwai.top/picgo/gccf1.png)\n\n安装完成后将 MinGW\\bin 路径添加到系统环境变量里。\n\n然后打开 MinGW Installation Manager，点击All Packages把想要安装的Package选中或点击Basic Setup选择mingw32-gcc-g++-bin：\n\n![](http://images.yingwai.top/picgo/gccf2.png)\n\n选择完后点击菜单栏Installation中的Apply changes选项，如果出现某种原因安装未能成功，选择review changes选项重新安装。\n\n完成安装后可以在命令行中输入 `g++ -v`、 `gcc -v` 和 `mingw32-make -v` 检查是否安装成功。\n\n\n\n# g++ 应用说明\n\nhelloworld.cpp 中包含如下简单代码：\n\n```c++\n#include <iostream>\nusing namespace std;\nint main(){\n    cout << \"Hello, world!\" << endl;\n    return 0;\n}\n```\n\n最简单的编译方式为：\n\n```shell\n$ g++ helloworld.cpp\n```\n\n由于命令行中未指定可执行程序的文件名，编译器采用默认的 a.out。程序可以这样来运行：\n\n```shell\n$ ./a.out\nHello, world!\n```\n\n通常我们使用 `-o` 选项指定可执行程序的文件名，以下实例生成一个 helloworld 的可执行文件：\n\n```shell\n$ g++ helloworld.cpp -o helloworld\n```\n\n执行 helloworld：\n\n```shell\n$ ./helloworld\nHello, world!\n```\n\n如果是多个 C++ 代码文件，如 ray1.cpp、ray2.cpp，编译命令如下：\n\n```shell\n$ g++ ray1.cpp ray2.cpp -o ray\n```\n\n生成一个 ray 可执行文件。\n\n\n\n## g++ 常用命令选项\n\nhttps://www.runoob.com/cplusplus/cpp-environment-setup.html\n\n| 选项          | 解释                                                         |\n| ------------- | ------------------------------------------------------------ |\n| `-ansi`       | 只支持 ANSI 标准的 C 语法。这一选项将禁止 GNU C 的某些特色， 例如 asm 或 typeof 关键词。 |\n| `-c`          | 只编译并生成目标文件。                                       |\n| `-DMACRO`     | 以字符串\"1\"定义 MACRO 宏。                                   |\n| `-E`          | 只运行 C 预编译器。                                          |\n| `-g`          | 生成调试信息。GNU 调试器可利用该信息。                       |\n| `-IDIRECTORY` | 指定额外的头文件搜索路径DIRECTORY。                          |\n| `-LDIRECTORY` | 指定额外的函数库搜索路径DIRECTORY。                          |\n| `-lLIBRARY`   | 连接时搜索指定的函数库LIBRARY。                              |\n| `-m486`       | 针对 486 进行代码优化。                                      |\n| `-o`          | FILE 生成指定的输出文件。用在生成可执行文件时。              |\n| `-O0`         | 不进行优化处理。                                             |\n| `-O`          | 或 `-O1` 优化生成代码。                                      |\n| `-O2`         | 进一步优化。                                                 |\n| `-O3`         | 比 `-O2` 更进一步优化，包括 inline 函数。                    |\n| `-shared`     | 生成共享目标文件。通常用在建立共享库时。                     |\n| `-static`     | 禁止使用共享连接。                                           |\n| `-UMACRO`     | 取消对 MACRO 宏的定义。                                      |\n| `-w`          | 不生成任何警告信息。                                         |\n| `-Wall`       | 生成所有警告信息。                                           |\n\n","slug":"C-环境设置","published":1,"updated":"2020-08-23T14:33:37.427Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cke79q4oq000088psciln8rit","content":"<hr>\n<a id=\"more\"></a>\n<h1 id=\"安装GNU的C-C-编译器\"><a href=\"#安装GNU的C-C-编译器\" class=\"headerlink\" title=\"安装GNU的C/C++编译器\"></a>安装GNU的C/C++编译器</h1><h2 id=\"UNIX-Linux上的安装\"><a href=\"#UNIX-Linux上的安装\" class=\"headerlink\" title=\"UNIX/Linux上的安装\"></a>UNIX/Linux上的安装</h2><p>首先在命令行使用以下命令确认系统是否安装了GCC：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> g++ -v</span></span><br></pre></td></tr></table></figure>\n<p>如果系统已经安装了GNU编译器，会显示如下的消息：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Using built-in specs.</span><br><span class=\"line\">COLLECT_GCC=gcc</span><br><span class=\"line\">COLLECT_LTO_WRAPPER=/usr/libexec/gcc/x86_64-redhat-linux/4.8.5/lto-wrapper</span><br><span class=\"line\">Target: x86_64-redhat-linux</span><br><span class=\"line\">Configured with: ../configure --prefix=/usr --mandir=/usr/share/man --infodir=/usr/share/info --with-bugurl=http://bugzilla.redhat.com/bugzilla --enable-bootstrap --enable-shared --enable-threads=posix --enable-checking=release --with-system-zlib --enable-__cxa_atexit --disable-libunwind-exceptions --enable-gnu-unique-object --enable-linker-build-id --with-linker-hash-style=gnu --enable-languages=c,c++,objc,obj-c++,java,fortran,ada,go,lto --enable-plugin --enable-initfini-array --disable-libgcj --with-isl=/builddir/build/BUILD/gcc-4.8.5-20150702/obj-x86_64-redhat-linux/isl-install --with-cloog=/builddir/build/BUILD/gcc-4.8.5-20150702/obj-x86_64-redhat-linux/cloog-install --enable-gnu-indirect-function --with-tune=generic --with-arch_32=x86-64 --build=x86_64-redhat-linux</span><br><span class=\"line\">Thread model: posix</span><br><span class=\"line\">gcc version 4.8.5 20150623 (Red Hat 4.8.5-39) (GCC)</span><br></pre></td></tr></table></figure>\n<p>若未安装，可以使用以下三条命令进行安装：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> yum install gcc</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> yum install gcc-c++</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> yum install gdb</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"Windows上的安装\"><a href=\"#Windows上的安装\" class=\"headerlink\" title=\"Windows上的安装\"></a>Windows上的安装</h2><p>首先访问www.mingw.org，右上方进入下载页面，下载最新版本的MinGW安装程序。</p>\n<p><img src=\"http://images.yingwai.top/picgo/gccf1.png\" alt=\"\"></p>\n<p>安装完成后将 MinGW\\bin 路径添加到系统环境变量里。</p>\n<p>然后打开 MinGW Installation Manager，点击All Packages把想要安装的Package选中或点击Basic Setup选择mingw32-gcc-g++-bin：</p>\n<p><img src=\"http://images.yingwai.top/picgo/gccf2.png\" alt=\"\"></p>\n<p>选择完后点击菜单栏Installation中的Apply changes选项，如果出现某种原因安装未能成功，选择review changes选项重新安装。</p>\n<p>完成安装后可以在命令行中输入 <code>g++ -v</code>、 <code>gcc -v</code> 和 <code>mingw32-make -v</code> 检查是否安装成功。</p>\n<h1 id=\"g-应用说明\"><a href=\"#g-应用说明\" class=\"headerlink\" title=\"g++ 应用说明\"></a>g++ 应用说明</h1><p>helloworld.cpp 中包含如下简单代码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Hello, world!\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最简单的编译方式为：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> g++ helloworld.cpp</span></span><br></pre></td></tr></table></figure>\n<p>由于命令行中未指定可执行程序的文件名，编译器采用默认的 a.out。程序可以这样来运行：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> ./a.out</span></span><br><span class=\"line\">Hello, world!</span><br></pre></td></tr></table></figure>\n<p>通常我们使用 <code>-o</code> 选项指定可执行程序的文件名，以下实例生成一个 helloworld 的可执行文件：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> g++ helloworld.cpp -o helloworld</span></span><br></pre></td></tr></table></figure>\n<p>执行 helloworld：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> ./helloworld</span></span><br><span class=\"line\">Hello, world!</span><br></pre></td></tr></table></figure>\n<p>如果是多个 C++ 代码文件，如 ray1.cpp、ray2.cpp，编译命令如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> g++ ray1.cpp ray2.cpp -o ray</span></span><br></pre></td></tr></table></figure>\n<p>生成一个 ray 可执行文件。</p>\n<h2 id=\"g-常用命令选项\"><a href=\"#g-常用命令选项\" class=\"headerlink\" title=\"g++ 常用命令选项\"></a>g++ 常用命令选项</h2><p><a href=\"https://www.runoob.com/cplusplus/cpp-environment-setup.html\" target=\"_blank\" rel=\"noopener\">https://www.runoob.com/cplusplus/cpp-environment-setup.html</a></p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>解释</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>-ansi</code></td>\n<td>只支持 ANSI 标准的 C 语法。这一选项将禁止 GNU C 的某些特色， 例如 asm 或 typeof 关键词。</td>\n</tr>\n<tr>\n<td><code>-c</code></td>\n<td>只编译并生成目标文件。</td>\n</tr>\n<tr>\n<td><code>-DMACRO</code></td>\n<td>以字符串”1”定义 MACRO 宏。</td>\n</tr>\n<tr>\n<td><code>-E</code></td>\n<td>只运行 C 预编译器。</td>\n</tr>\n<tr>\n<td><code>-g</code></td>\n<td>生成调试信息。GNU 调试器可利用该信息。</td>\n</tr>\n<tr>\n<td><code>-IDIRECTORY</code></td>\n<td>指定额外的头文件搜索路径DIRECTORY。</td>\n</tr>\n<tr>\n<td><code>-LDIRECTORY</code></td>\n<td>指定额外的函数库搜索路径DIRECTORY。</td>\n</tr>\n<tr>\n<td><code>-lLIBRARY</code></td>\n<td>连接时搜索指定的函数库LIBRARY。</td>\n</tr>\n<tr>\n<td><code>-m486</code></td>\n<td>针对 486 进行代码优化。</td>\n</tr>\n<tr>\n<td><code>-o</code></td>\n<td>FILE 生成指定的输出文件。用在生成可执行文件时。</td>\n</tr>\n<tr>\n<td><code>-O0</code></td>\n<td>不进行优化处理。</td>\n</tr>\n<tr>\n<td><code>-O</code></td>\n<td>或 <code>-O1</code> 优化生成代码。</td>\n</tr>\n<tr>\n<td><code>-O2</code></td>\n<td>进一步优化。</td>\n</tr>\n<tr>\n<td><code>-O3</code></td>\n<td>比 <code>-O2</code> 更进一步优化，包括 inline 函数。</td>\n</tr>\n<tr>\n<td><code>-shared</code></td>\n<td>生成共享目标文件。通常用在建立共享库时。</td>\n</tr>\n<tr>\n<td><code>-static</code></td>\n<td>禁止使用共享连接。</td>\n</tr>\n<tr>\n<td><code>-UMACRO</code></td>\n<td>取消对 MACRO 宏的定义。</td>\n</tr>\n<tr>\n<td><code>-w</code></td>\n<td>不生成任何警告信息。</td>\n</tr>\n<tr>\n<td><code>-Wall</code></td>\n<td>生成所有警告信息。</td>\n</tr>\n</tbody>\n</table>\n</div>\n","site":{"data":{}},"excerpt":"<hr>","more":"<h1 id=\"安装GNU的C-C-编译器\"><a href=\"#安装GNU的C-C-编译器\" class=\"headerlink\" title=\"安装GNU的C/C++编译器\"></a>安装GNU的C/C++编译器</h1><h2 id=\"UNIX-Linux上的安装\"><a href=\"#UNIX-Linux上的安装\" class=\"headerlink\" title=\"UNIX/Linux上的安装\"></a>UNIX/Linux上的安装</h2><p>首先在命令行使用以下命令确认系统是否安装了GCC：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> g++ -v</span></span><br></pre></td></tr></table></figure>\n<p>如果系统已经安装了GNU编译器，会显示如下的消息：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Using built-in specs.</span><br><span class=\"line\">COLLECT_GCC=gcc</span><br><span class=\"line\">COLLECT_LTO_WRAPPER=/usr/libexec/gcc/x86_64-redhat-linux/4.8.5/lto-wrapper</span><br><span class=\"line\">Target: x86_64-redhat-linux</span><br><span class=\"line\">Configured with: ../configure --prefix=/usr --mandir=/usr/share/man --infodir=/usr/share/info --with-bugurl=http://bugzilla.redhat.com/bugzilla --enable-bootstrap --enable-shared --enable-threads=posix --enable-checking=release --with-system-zlib --enable-__cxa_atexit --disable-libunwind-exceptions --enable-gnu-unique-object --enable-linker-build-id --with-linker-hash-style=gnu --enable-languages=c,c++,objc,obj-c++,java,fortran,ada,go,lto --enable-plugin --enable-initfini-array --disable-libgcj --with-isl=/builddir/build/BUILD/gcc-4.8.5-20150702/obj-x86_64-redhat-linux/isl-install --with-cloog=/builddir/build/BUILD/gcc-4.8.5-20150702/obj-x86_64-redhat-linux/cloog-install --enable-gnu-indirect-function --with-tune=generic --with-arch_32=x86-64 --build=x86_64-redhat-linux</span><br><span class=\"line\">Thread model: posix</span><br><span class=\"line\">gcc version 4.8.5 20150623 (Red Hat 4.8.5-39) (GCC)</span><br></pre></td></tr></table></figure>\n<p>若未安装，可以使用以下三条命令进行安装：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> yum install gcc</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> yum install gcc-c++</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> yum install gdb</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"Windows上的安装\"><a href=\"#Windows上的安装\" class=\"headerlink\" title=\"Windows上的安装\"></a>Windows上的安装</h2><p>首先访问www.mingw.org，右上方进入下载页面，下载最新版本的MinGW安装程序。</p>\n<p><img src=\"http://images.yingwai.top/picgo/gccf1.png\" alt=\"\"></p>\n<p>安装完成后将 MinGW\\bin 路径添加到系统环境变量里。</p>\n<p>然后打开 MinGW Installation Manager，点击All Packages把想要安装的Package选中或点击Basic Setup选择mingw32-gcc-g++-bin：</p>\n<p><img src=\"http://images.yingwai.top/picgo/gccf2.png\" alt=\"\"></p>\n<p>选择完后点击菜单栏Installation中的Apply changes选项，如果出现某种原因安装未能成功，选择review changes选项重新安装。</p>\n<p>完成安装后可以在命令行中输入 <code>g++ -v</code>、 <code>gcc -v</code> 和 <code>mingw32-make -v</code> 检查是否安装成功。</p>\n<h1 id=\"g-应用说明\"><a href=\"#g-应用说明\" class=\"headerlink\" title=\"g++ 应用说明\"></a>g++ 应用说明</h1><p>helloworld.cpp 中包含如下简单代码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Hello, world!\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最简单的编译方式为：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> g++ helloworld.cpp</span></span><br></pre></td></tr></table></figure>\n<p>由于命令行中未指定可执行程序的文件名，编译器采用默认的 a.out。程序可以这样来运行：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> ./a.out</span></span><br><span class=\"line\">Hello, world!</span><br></pre></td></tr></table></figure>\n<p>通常我们使用 <code>-o</code> 选项指定可执行程序的文件名，以下实例生成一个 helloworld 的可执行文件：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> g++ helloworld.cpp -o helloworld</span></span><br></pre></td></tr></table></figure>\n<p>执行 helloworld：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> ./helloworld</span></span><br><span class=\"line\">Hello, world!</span><br></pre></td></tr></table></figure>\n<p>如果是多个 C++ 代码文件，如 ray1.cpp、ray2.cpp，编译命令如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> g++ ray1.cpp ray2.cpp -o ray</span></span><br></pre></td></tr></table></figure>\n<p>生成一个 ray 可执行文件。</p>\n<h2 id=\"g-常用命令选项\"><a href=\"#g-常用命令选项\" class=\"headerlink\" title=\"g++ 常用命令选项\"></a>g++ 常用命令选项</h2><p><a href=\"https://www.runoob.com/cplusplus/cpp-environment-setup.html\" target=\"_blank\" rel=\"noopener\">https://www.runoob.com/cplusplus/cpp-environment-setup.html</a></p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>解释</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>-ansi</code></td>\n<td>只支持 ANSI 标准的 C 语法。这一选项将禁止 GNU C 的某些特色， 例如 asm 或 typeof 关键词。</td>\n</tr>\n<tr>\n<td><code>-c</code></td>\n<td>只编译并生成目标文件。</td>\n</tr>\n<tr>\n<td><code>-DMACRO</code></td>\n<td>以字符串”1”定义 MACRO 宏。</td>\n</tr>\n<tr>\n<td><code>-E</code></td>\n<td>只运行 C 预编译器。</td>\n</tr>\n<tr>\n<td><code>-g</code></td>\n<td>生成调试信息。GNU 调试器可利用该信息。</td>\n</tr>\n<tr>\n<td><code>-IDIRECTORY</code></td>\n<td>指定额外的头文件搜索路径DIRECTORY。</td>\n</tr>\n<tr>\n<td><code>-LDIRECTORY</code></td>\n<td>指定额外的函数库搜索路径DIRECTORY。</td>\n</tr>\n<tr>\n<td><code>-lLIBRARY</code></td>\n<td>连接时搜索指定的函数库LIBRARY。</td>\n</tr>\n<tr>\n<td><code>-m486</code></td>\n<td>针对 486 进行代码优化。</td>\n</tr>\n<tr>\n<td><code>-o</code></td>\n<td>FILE 生成指定的输出文件。用在生成可执行文件时。</td>\n</tr>\n<tr>\n<td><code>-O0</code></td>\n<td>不进行优化处理。</td>\n</tr>\n<tr>\n<td><code>-O</code></td>\n<td>或 <code>-O1</code> 优化生成代码。</td>\n</tr>\n<tr>\n<td><code>-O2</code></td>\n<td>进一步优化。</td>\n</tr>\n<tr>\n<td><code>-O3</code></td>\n<td>比 <code>-O2</code> 更进一步优化，包括 inline 函数。</td>\n</tr>\n<tr>\n<td><code>-shared</code></td>\n<td>生成共享目标文件。通常用在建立共享库时。</td>\n</tr>\n<tr>\n<td><code>-static</code></td>\n<td>禁止使用共享连接。</td>\n</tr>\n<tr>\n<td><code>-UMACRO</code></td>\n<td>取消对 MACRO 宏的定义。</td>\n</tr>\n<tr>\n<td><code>-w</code></td>\n<td>不生成任何警告信息。</td>\n</tr>\n<tr>\n<td><code>-Wall</code></td>\n<td>生成所有警告信息。</td>\n</tr>\n</tbody>\n</table>\n</div>"},{"title":"CCF推荐国际学术会议和期刊目录（网络与信息安全）","date":"2020-04-20T11:43:26.000Z","_content":"\nhttps://www.ccf.org.cn/c/2019-04-25/663625.shtml\n\n<!--more-->\n\n## 中国计算机学会推荐国际学术期刊（网络与信息安全）\n\n### A类\n\n| 序号 | 刊物简称 |                        刊物全称                         |  出版社  |                    网址                    |\n| :--: | :------: | :-----------------------------------------------------: | :------: | :----------------------------------------: |\n|  1   |   TDSC   |  IEEE Transactions on Dependable and Secure Computing   |   IEEE   | http://dblp.uni-trier.de/db/journals/tdsc/ |\n|  2   |   TIFS   | IEEE Transactions on Information Forensics and Security |   IEEE   | http://dblp.uni-trier.de/db/journals/tifs/ |\n|  3   |          |                  Journal of Cryptology                  | Springer | http://dblp.uni-trier.de/db/journals/joc/  |\n\n\n\n### B类\n\n| 序号 | 刊物简称 |                 刊物全称                 |  出版社   |                     网址                      |\n| :--: | :------: | :--------------------------------------: | :-------: | :-------------------------------------------: |\n|  1   |   TOPS   | ACM Transactions on Privacy and Security |    ACM    |             https://tops.acm.org/             |\n|  2   |          |           Computers & Security           | Elsevier  | http://dblp.uni-trier.de/db/journals/compsec/ |\n|  3   |          |     Designs, Codes and Cryptography      | Springer  |   http://dblp.uni-trier.de/db/journals/dcc/   |\n|  4   |   JCS    |       Journal of Computer Security       | IOS Press |   http://dblp.uni-trier.de/db/journals/jcs/   |\n\n\n\n### C类\n\n| 序号 | 刊物简称 |                          刊物全称                          |     出版社     |                             网址                             |\n| :--: | :------: | :--------------------------------------------------------: | :------------: | :----------------------------------------------------------: |\n|  1   |   CLSR   |              Computer Law and Security Review              |    Elsevier    | http://www.journals.elsevier.com/computer-law-and-security-review/ |\n|  2   |          |          EURASIP Journal on Information Security           |    Springer    |         http://dblp.uni-trier.de/db/journals/ejisec/         |\n|  3   |          |                  IET Information Security                  |      IET       |        http://dblp.uni-trier.de/db/journals/iet-ifs/         |\n|  4   |   IMCS   |         Information Management & Computer Security         |    Emerald     |          http://dblp.uni-trier.de/db/journals/imcs/          |\n|  5   |  IJICS   | International Journal of Information and Computer Security |  Inderscience  |         http://dblp.uni-trier.de/db/journals/ijics/          |\n|  6   |  IJISP   | International Journal of Information Security and Privacy  | Idea Group Inc |         http://dblp.uni-trier.de/db/journals/ijisp/          |\n|  7   |   JISA   |      Journal of Information Security and Application       |    Elsevier    |         https://dblp.uni-trier.de/db/journals/istr/          |\n|  8   |   SCN    |            Security and Communication Networks             |     Wiley      |          http://dblp.uni-trier.de/db/journals/scn/           |\n\n\n\n## 中国计算机学会推荐国际学术会议（网络与信息安全）\n\n### A类\n\n| 序号 |    会议简称     |                        会议全称                        |       出版社       |                    网址                     |\n| :--: | :-------------: | :----------------------------------------------------: | :----------------: | :-----------------------------------------: |\n|  1   |       CCS       | ACM Conference on Computer and Communications Security |        ACM         |    http://dblp.uni-trier.de/db/conf/ccs/    |\n|  2   |    EUROCRYPT    |             European Cryptology Conference             |      Springer      | http://dblp.uni-trier.de/db/conf/eurocrypt/ |\n|  3   |       S&P       |         IEEE Symposium on Security and Privacy         |        IEEE        |    http://dblp.uni-trier.de/db/conf/sp/     |\n|  4   |     CRYPTO      |          International Cryptology Conference           |      Springer      |  http://dblp.uni-trier.de/db/conf/crypto/   |\n|  5   | USENIX Security |               Usenix Security Symposium                | USENIX Association |    http://dblp.uni-trier.de/db/conf/uss/    |\n\n\n\n### B类\n\n| 序号 | 会议简称  |                           会议全称                           |  出版社   |                    网址                     |\n| :--: | :-------: | :----------------------------------------------------------: | :-------: | :-----------------------------------------: |\n|  1   |   ACSAC   |       Annual Computer Security Applications Conference       |   IEEE    |   http://dblp.uni-trier.de/db/conf/acsac/   |\n|  2   | ASIACRYPT | Annual International Conference on the Theory and Application of Cryptology and Information Security | Springer  | http://dblp.uni-trier.de/db/conf/asiacrypt/ |\n|  3   |  ESORICS  |     European Symposium on Research in Computer Security      | Springer  |  http://dblp.uni-trier.de/db/conf/esorics/  |\n|  4   |    FSE    |                   Fast Software Encryption                   | Springer  |    http://dblp.uni-trier.de/db/conf/fse/    |\n|  5   |   CSFW    |         IEEE Computer Security Foundations Workshop          |   IEEE    |   http://dblp.uni-trier.de/db/conf/csfw/    |\n|  6   |   SRDS    | IEEE International Symposium on Reliable Distributed Systems |   IEEE    |   http://dblp.uni-trier.de/db/conf/srds/    |\n|  7   |   CHES    | International Conference on Cryptographic Hardware and Embedded Systems | Springer  |   http://dblp.uni-trier.de/db/conf/ches/    |\n|  8   |    DSN    | International Conference on Dependable Systems and Networks  | IEEE/IFIP |    http://dblp.uni-trier.de/db/conf/dsn/    |\n|  9   |   RAID    | International Symposium on Recent Advances in Intrusion Detection | Springer  |   http://dblp.uni-trier.de/db/conf/raid/    |\n|  10  |    PKC    | International Workshop on Practice and Theory in Public Key Cryptography | Springer  |    http://dblp.uni-trier.de/db/conf/pkc/    |\n|  11  |   NDSS    |    ISOC Network and Distributed System Security Symposium    |   ISOC    |   http://dblp.uni-trier.de/db/conf/ndss/    |\n|  12  |    TCC    |              Theory of Cryptography Conference               | Springer  |    http://dblp.uni-trier.de/db/conf/tcc/    |\n\n\n\n### C类\n\n| 序号 |   会议简称   |                           会议全称                           |  出版社  |                     网址                     |\n| :--: | :----------: | :----------------------------------------------------------: | :------: | :------------------------------------------: |\n|  1   |    WiSec     | ACM Conference on Security and Privacy in Wireless and Mobile Networks |   ACM    |   http://dblp.uni-trier.de/db/conf/wisec/    |\n|  2   |    SACMAT    |   ACM Symposium on Access Control Models and Technologies    |   ACM    |   http://dblp.uni-trier.de/db/conf/sacmat/   |\n|  3   |     DRM      |          ACM Workshop on Digital Rights Management           |   ACM    |    http://dblp.uni-trier.de/db/conf/drm/     |\n|  4   |   IH&MMSec   |  ACM Workshop on Information Hiding and Multimedia Security  |   ACM    |     http://dblp.uni-trier.de/db/conf/ih/     |\n|  5   |     ACNS     |          Applied Cryptography and Network Security           | Springer |    http://dblp.uni-trier.de/db/conf/acns/    |\n|  6   |   AsiaCCS    |   Asia Conference on Computer and Communications Security    |   ACM    |    http://dblp.uni-trier.de/db/conf/ccs/     |\n|  7   |    ACISP     |  Australasia Conference on Information Security and Privacy  | Springer |   http://dblp.uni-trier.de/db/conf/acisp/    |\n|  8   |    CT-RSA    |           Cryptographer's Track at RSA Conference            | Springer |   http://dblp.uni-trier.de/db/conf/ctrsa/    |\n|  9   |    DIMVA     | Detection of Intrusions and Malware & Vulnerability Assessment |          |   http://dblp.uni-trier.de/db/conf/dimva/    |\n|  10  |    DFRWS     |              Digital Forensic Research Workshop              | Elsevier |   http://dblp.uni-trier.de/db/conf/dfrws/    |\n|  11  |      FC      |           Financial Cryptography and Data Security           | Springer |     http://dblp.uni-trier.de/db/conf/fc/     |\n|  12  |   TrustCom   | IEEE International Conference on Trust, Security and Privacy in Computing and Communications |   IEEE   |  http://dblp.uni-trier.de/db/conf/trustcom/  |\n|  13  |     SEC      |      IFIP International Information Security Conference      | Springer |    http://dblp.uni-trier.de/db/conf/sec/     |\n|  14  | IFIP WG 11.9 |  IFIP WG 11.9 International Conference on Digital Forensics  | Springer |     *http://www.ifip119.org/Conferences/     |\n|  15  |     ISC      |               Information Security Conference                | Springer |    http://dblp.uni-trier.de/db/conf/isw/     |\n|  16  |    ICDF2C    | International Conference on Digital Forensics & Cyber Crime  | Springer |   http://dblp.uni-trier.de/db/conf/icdf2c/   |\n|  17  |    ICICS     | International Conference on Information and Communications Security | Springer |   http://dblp.uni-trier.de/db/conf/icics/    |\n|  18  |  SecureComm  | International Conference on Security and Privacy in Communication Networks |   ACM    | http://dblp.uni-trier.de/db/conf/securecomm/ |\n|  19  |     NSPW     |               New Security Paradigms Workshop                |   ACM    |    http://dblp.uni-trier.de/db/conf/nspw/    |\n|  20  |     PAM      |          Passive and Active Measurement Conference           | Springer |    http://dblp.uni-trier.de/db/conf/pam/     |\n|  21  |     PETS     |           Privacy Enhancing Technologies Symposium           | Springer |    http://dblp.uni-trier.de/db/conf/pet/     |\n|  22  |     SAC      |                Selected Areas in Cryptography                | Springer |  http://dblp.uni-trier.de/db/conf/sacrypt/   |\n|  23  |    SOUPS     |           Symposium On Usable Privacy and Security           |  USENIX  |   http://dblp.uni-trier.de/db/conf/soups/    |\n|  24  |    HotSec    |          USENIX Workshop on Hot Topics in Security           |  USENIX  |        *http://www.usenix.org/events/        |\n\n","source":"_posts/CCF推荐国际学术会议和期刊目录（网络与信息安全）.md","raw":"---\ntitle: CCF推荐国际学术会议和期刊目录（网络与信息安全）\ndate: 2020-04-20 19:43:26\ncategories: Papers\ntags: [密码学]\n---\n\nhttps://www.ccf.org.cn/c/2019-04-25/663625.shtml\n\n<!--more-->\n\n## 中国计算机学会推荐国际学术期刊（网络与信息安全）\n\n### A类\n\n| 序号 | 刊物简称 |                        刊物全称                         |  出版社  |                    网址                    |\n| :--: | :------: | :-----------------------------------------------------: | :------: | :----------------------------------------: |\n|  1   |   TDSC   |  IEEE Transactions on Dependable and Secure Computing   |   IEEE   | http://dblp.uni-trier.de/db/journals/tdsc/ |\n|  2   |   TIFS   | IEEE Transactions on Information Forensics and Security |   IEEE   | http://dblp.uni-trier.de/db/journals/tifs/ |\n|  3   |          |                  Journal of Cryptology                  | Springer | http://dblp.uni-trier.de/db/journals/joc/  |\n\n\n\n### B类\n\n| 序号 | 刊物简称 |                 刊物全称                 |  出版社   |                     网址                      |\n| :--: | :------: | :--------------------------------------: | :-------: | :-------------------------------------------: |\n|  1   |   TOPS   | ACM Transactions on Privacy and Security |    ACM    |             https://tops.acm.org/             |\n|  2   |          |           Computers & Security           | Elsevier  | http://dblp.uni-trier.de/db/journals/compsec/ |\n|  3   |          |     Designs, Codes and Cryptography      | Springer  |   http://dblp.uni-trier.de/db/journals/dcc/   |\n|  4   |   JCS    |       Journal of Computer Security       | IOS Press |   http://dblp.uni-trier.de/db/journals/jcs/   |\n\n\n\n### C类\n\n| 序号 | 刊物简称 |                          刊物全称                          |     出版社     |                             网址                             |\n| :--: | :------: | :--------------------------------------------------------: | :------------: | :----------------------------------------------------------: |\n|  1   |   CLSR   |              Computer Law and Security Review              |    Elsevier    | http://www.journals.elsevier.com/computer-law-and-security-review/ |\n|  2   |          |          EURASIP Journal on Information Security           |    Springer    |         http://dblp.uni-trier.de/db/journals/ejisec/         |\n|  3   |          |                  IET Information Security                  |      IET       |        http://dblp.uni-trier.de/db/journals/iet-ifs/         |\n|  4   |   IMCS   |         Information Management & Computer Security         |    Emerald     |          http://dblp.uni-trier.de/db/journals/imcs/          |\n|  5   |  IJICS   | International Journal of Information and Computer Security |  Inderscience  |         http://dblp.uni-trier.de/db/journals/ijics/          |\n|  6   |  IJISP   | International Journal of Information Security and Privacy  | Idea Group Inc |         http://dblp.uni-trier.de/db/journals/ijisp/          |\n|  7   |   JISA   |      Journal of Information Security and Application       |    Elsevier    |         https://dblp.uni-trier.de/db/journals/istr/          |\n|  8   |   SCN    |            Security and Communication Networks             |     Wiley      |          http://dblp.uni-trier.de/db/journals/scn/           |\n\n\n\n## 中国计算机学会推荐国际学术会议（网络与信息安全）\n\n### A类\n\n| 序号 |    会议简称     |                        会议全称                        |       出版社       |                    网址                     |\n| :--: | :-------------: | :----------------------------------------------------: | :----------------: | :-----------------------------------------: |\n|  1   |       CCS       | ACM Conference on Computer and Communications Security |        ACM         |    http://dblp.uni-trier.de/db/conf/ccs/    |\n|  2   |    EUROCRYPT    |             European Cryptology Conference             |      Springer      | http://dblp.uni-trier.de/db/conf/eurocrypt/ |\n|  3   |       S&P       |         IEEE Symposium on Security and Privacy         |        IEEE        |    http://dblp.uni-trier.de/db/conf/sp/     |\n|  4   |     CRYPTO      |          International Cryptology Conference           |      Springer      |  http://dblp.uni-trier.de/db/conf/crypto/   |\n|  5   | USENIX Security |               Usenix Security Symposium                | USENIX Association |    http://dblp.uni-trier.de/db/conf/uss/    |\n\n\n\n### B类\n\n| 序号 | 会议简称  |                           会议全称                           |  出版社   |                    网址                     |\n| :--: | :-------: | :----------------------------------------------------------: | :-------: | :-----------------------------------------: |\n|  1   |   ACSAC   |       Annual Computer Security Applications Conference       |   IEEE    |   http://dblp.uni-trier.de/db/conf/acsac/   |\n|  2   | ASIACRYPT | Annual International Conference on the Theory and Application of Cryptology and Information Security | Springer  | http://dblp.uni-trier.de/db/conf/asiacrypt/ |\n|  3   |  ESORICS  |     European Symposium on Research in Computer Security      | Springer  |  http://dblp.uni-trier.de/db/conf/esorics/  |\n|  4   |    FSE    |                   Fast Software Encryption                   | Springer  |    http://dblp.uni-trier.de/db/conf/fse/    |\n|  5   |   CSFW    |         IEEE Computer Security Foundations Workshop          |   IEEE    |   http://dblp.uni-trier.de/db/conf/csfw/    |\n|  6   |   SRDS    | IEEE International Symposium on Reliable Distributed Systems |   IEEE    |   http://dblp.uni-trier.de/db/conf/srds/    |\n|  7   |   CHES    | International Conference on Cryptographic Hardware and Embedded Systems | Springer  |   http://dblp.uni-trier.de/db/conf/ches/    |\n|  8   |    DSN    | International Conference on Dependable Systems and Networks  | IEEE/IFIP |    http://dblp.uni-trier.de/db/conf/dsn/    |\n|  9   |   RAID    | International Symposium on Recent Advances in Intrusion Detection | Springer  |   http://dblp.uni-trier.de/db/conf/raid/    |\n|  10  |    PKC    | International Workshop on Practice and Theory in Public Key Cryptography | Springer  |    http://dblp.uni-trier.de/db/conf/pkc/    |\n|  11  |   NDSS    |    ISOC Network and Distributed System Security Symposium    |   ISOC    |   http://dblp.uni-trier.de/db/conf/ndss/    |\n|  12  |    TCC    |              Theory of Cryptography Conference               | Springer  |    http://dblp.uni-trier.de/db/conf/tcc/    |\n\n\n\n### C类\n\n| 序号 |   会议简称   |                           会议全称                           |  出版社  |                     网址                     |\n| :--: | :----------: | :----------------------------------------------------------: | :------: | :------------------------------------------: |\n|  1   |    WiSec     | ACM Conference on Security and Privacy in Wireless and Mobile Networks |   ACM    |   http://dblp.uni-trier.de/db/conf/wisec/    |\n|  2   |    SACMAT    |   ACM Symposium on Access Control Models and Technologies    |   ACM    |   http://dblp.uni-trier.de/db/conf/sacmat/   |\n|  3   |     DRM      |          ACM Workshop on Digital Rights Management           |   ACM    |    http://dblp.uni-trier.de/db/conf/drm/     |\n|  4   |   IH&MMSec   |  ACM Workshop on Information Hiding and Multimedia Security  |   ACM    |     http://dblp.uni-trier.de/db/conf/ih/     |\n|  5   |     ACNS     |          Applied Cryptography and Network Security           | Springer |    http://dblp.uni-trier.de/db/conf/acns/    |\n|  6   |   AsiaCCS    |   Asia Conference on Computer and Communications Security    |   ACM    |    http://dblp.uni-trier.de/db/conf/ccs/     |\n|  7   |    ACISP     |  Australasia Conference on Information Security and Privacy  | Springer |   http://dblp.uni-trier.de/db/conf/acisp/    |\n|  8   |    CT-RSA    |           Cryptographer's Track at RSA Conference            | Springer |   http://dblp.uni-trier.de/db/conf/ctrsa/    |\n|  9   |    DIMVA     | Detection of Intrusions and Malware & Vulnerability Assessment |          |   http://dblp.uni-trier.de/db/conf/dimva/    |\n|  10  |    DFRWS     |              Digital Forensic Research Workshop              | Elsevier |   http://dblp.uni-trier.de/db/conf/dfrws/    |\n|  11  |      FC      |           Financial Cryptography and Data Security           | Springer |     http://dblp.uni-trier.de/db/conf/fc/     |\n|  12  |   TrustCom   | IEEE International Conference on Trust, Security and Privacy in Computing and Communications |   IEEE   |  http://dblp.uni-trier.de/db/conf/trustcom/  |\n|  13  |     SEC      |      IFIP International Information Security Conference      | Springer |    http://dblp.uni-trier.de/db/conf/sec/     |\n|  14  | IFIP WG 11.9 |  IFIP WG 11.9 International Conference on Digital Forensics  | Springer |     *http://www.ifip119.org/Conferences/     |\n|  15  |     ISC      |               Information Security Conference                | Springer |    http://dblp.uni-trier.de/db/conf/isw/     |\n|  16  |    ICDF2C    | International Conference on Digital Forensics & Cyber Crime  | Springer |   http://dblp.uni-trier.de/db/conf/icdf2c/   |\n|  17  |    ICICS     | International Conference on Information and Communications Security | Springer |   http://dblp.uni-trier.de/db/conf/icics/    |\n|  18  |  SecureComm  | International Conference on Security and Privacy in Communication Networks |   ACM    | http://dblp.uni-trier.de/db/conf/securecomm/ |\n|  19  |     NSPW     |               New Security Paradigms Workshop                |   ACM    |    http://dblp.uni-trier.de/db/conf/nspw/    |\n|  20  |     PAM      |          Passive and Active Measurement Conference           | Springer |    http://dblp.uni-trier.de/db/conf/pam/     |\n|  21  |     PETS     |           Privacy Enhancing Technologies Symposium           | Springer |    http://dblp.uni-trier.de/db/conf/pet/     |\n|  22  |     SAC      |                Selected Areas in Cryptography                | Springer |  http://dblp.uni-trier.de/db/conf/sacrypt/   |\n|  23  |    SOUPS     |           Symposium On Usable Privacy and Security           |  USENIX  |   http://dblp.uni-trier.de/db/conf/soups/    |\n|  24  |    HotSec    |          USENIX Workshop on Hot Topics in Security           |  USENIX  |        *http://www.usenix.org/events/        |\n\n","slug":"CCF推荐国际学术会议和期刊目录（网络与信息安全）","published":1,"updated":"2020-08-23T14:33:37.427Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cke79q4ou000188ps230b9874","content":"<p><a href=\"https://www.ccf.org.cn/c/2019-04-25/663625.shtml\" target=\"_blank\" rel=\"noopener\">https://www.ccf.org.cn/c/2019-04-25/663625.shtml</a></p>\n<a id=\"more\"></a>\n<h2 id=\"中国计算机学会推荐国际学术期刊（网络与信息安全）\"><a href=\"#中国计算机学会推荐国际学术期刊（网络与信息安全）\" class=\"headerlink\" title=\"中国计算机学会推荐国际学术期刊（网络与信息安全）\"></a>中国计算机学会推荐国际学术期刊（网络与信息安全）</h2><h3 id=\"A类\"><a href=\"#A类\" class=\"headerlink\" title=\"A类\"></a>A类</h3><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">序号</th>\n<th style=\"text-align:center\">刊物简称</th>\n<th style=\"text-align:center\">刊物全称</th>\n<th style=\"text-align:center\">出版社</th>\n<th style=\"text-align:center\">网址</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">TDSC</td>\n<td style=\"text-align:center\">IEEE Transactions on Dependable and Secure Computing</td>\n<td style=\"text-align:center\">IEEE</td>\n<td style=\"text-align:center\"><a href=\"http://dblp.uni-trier.de/db/journals/tdsc/\" target=\"_blank\" rel=\"noopener\">http://dblp.uni-trier.de/db/journals/tdsc/</a></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">2</td>\n<td style=\"text-align:center\">TIFS</td>\n<td style=\"text-align:center\">IEEE Transactions on Information Forensics and Security</td>\n<td style=\"text-align:center\">IEEE</td>\n<td style=\"text-align:center\"><a href=\"http://dblp.uni-trier.de/db/journals/tifs/\" target=\"_blank\" rel=\"noopener\">http://dblp.uni-trier.de/db/journals/tifs/</a></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">3</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">Journal of Cryptology</td>\n<td style=\"text-align:center\">Springer</td>\n<td style=\"text-align:center\"><a href=\"http://dblp.uni-trier.de/db/journals/joc/\" target=\"_blank\" rel=\"noopener\">http://dblp.uni-trier.de/db/journals/joc/</a></td>\n</tr>\n</tbody>\n</table>\n</div>\n<h3 id=\"B类\"><a href=\"#B类\" class=\"headerlink\" title=\"B类\"></a>B类</h3><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">序号</th>\n<th style=\"text-align:center\">刊物简称</th>\n<th style=\"text-align:center\">刊物全称</th>\n<th style=\"text-align:center\">出版社</th>\n<th style=\"text-align:center\">网址</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">TOPS</td>\n<td style=\"text-align:center\">ACM Transactions on Privacy and Security</td>\n<td style=\"text-align:center\">ACM</td>\n<td style=\"text-align:center\"><a href=\"https://tops.acm.org/\" target=\"_blank\" rel=\"noopener\">https://tops.acm.org/</a></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">2</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">Computers &amp; Security</td>\n<td style=\"text-align:center\">Elsevier</td>\n<td style=\"text-align:center\"><a href=\"http://dblp.uni-trier.de/db/journals/compsec/\" target=\"_blank\" rel=\"noopener\">http://dblp.uni-trier.de/db/journals/compsec/</a></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">3</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">Designs, Codes and Cryptography</td>\n<td style=\"text-align:center\">Springer</td>\n<td style=\"text-align:center\"><a href=\"http://dblp.uni-trier.de/db/journals/dcc/\" target=\"_blank\" rel=\"noopener\">http://dblp.uni-trier.de/db/journals/dcc/</a></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">4</td>\n<td style=\"text-align:center\">JCS</td>\n<td style=\"text-align:center\">Journal of Computer Security</td>\n<td style=\"text-align:center\">IOS Press</td>\n<td style=\"text-align:center\"><a href=\"http://dblp.uni-trier.de/db/journals/jcs/\" target=\"_blank\" rel=\"noopener\">http://dblp.uni-trier.de/db/journals/jcs/</a></td>\n</tr>\n</tbody>\n</table>\n</div>\n<h3 id=\"C类\"><a href=\"#C类\" class=\"headerlink\" title=\"C类\"></a>C类</h3><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">序号</th>\n<th style=\"text-align:center\">刊物简称</th>\n<th style=\"text-align:center\">刊物全称</th>\n<th style=\"text-align:center\">出版社</th>\n<th style=\"text-align:center\">网址</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">CLSR</td>\n<td style=\"text-align:center\">Computer Law and Security Review</td>\n<td style=\"text-align:center\">Elsevier</td>\n<td style=\"text-align:center\"><a href=\"http://www.journals.elsevier.com/computer-law-and-security-review/\" target=\"_blank\" rel=\"noopener\">http://www.journals.elsevier.com/computer-law-and-security-review/</a></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">2</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">EURASIP Journal on Information Security</td>\n<td style=\"text-align:center\">Springer</td>\n<td style=\"text-align:center\"><a href=\"http://dblp.uni-trier.de/db/journals/ejisec/\" target=\"_blank\" rel=\"noopener\">http://dblp.uni-trier.de/db/journals/ejisec/</a></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">3</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">IET Information Security</td>\n<td style=\"text-align:center\">IET</td>\n<td style=\"text-align:center\"><a href=\"http://dblp.uni-trier.de/db/journals/iet-ifs/\" target=\"_blank\" rel=\"noopener\">http://dblp.uni-trier.de/db/journals/iet-ifs/</a></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">4</td>\n<td style=\"text-align:center\">IMCS</td>\n<td style=\"text-align:center\">Information Management &amp; Computer Security</td>\n<td style=\"text-align:center\">Emerald</td>\n<td style=\"text-align:center\"><a href=\"http://dblp.uni-trier.de/db/journals/imcs/\" target=\"_blank\" rel=\"noopener\">http://dblp.uni-trier.de/db/journals/imcs/</a></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">5</td>\n<td style=\"text-align:center\">IJICS</td>\n<td style=\"text-align:center\">International Journal of Information and Computer Security</td>\n<td style=\"text-align:center\">Inderscience</td>\n<td style=\"text-align:center\"><a href=\"http://dblp.uni-trier.de/db/journals/ijics/\" target=\"_blank\" rel=\"noopener\">http://dblp.uni-trier.de/db/journals/ijics/</a></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">6</td>\n<td style=\"text-align:center\">IJISP</td>\n<td style=\"text-align:center\">International Journal of Information Security and Privacy</td>\n<td style=\"text-align:center\">Idea Group Inc</td>\n<td style=\"text-align:center\"><a href=\"http://dblp.uni-trier.de/db/journals/ijisp/\" target=\"_blank\" rel=\"noopener\">http://dblp.uni-trier.de/db/journals/ijisp/</a></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">7</td>\n<td style=\"text-align:center\">JISA</td>\n<td style=\"text-align:center\">Journal of Information Security and Application</td>\n<td style=\"text-align:center\">Elsevier</td>\n<td style=\"text-align:center\"><a href=\"https://dblp.uni-trier.de/db/journals/istr/\" target=\"_blank\" rel=\"noopener\">https://dblp.uni-trier.de/db/journals/istr/</a></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">8</td>\n<td style=\"text-align:center\">SCN</td>\n<td style=\"text-align:center\">Security and Communication Networks</td>\n<td style=\"text-align:center\">Wiley</td>\n<td style=\"text-align:center\"><a href=\"http://dblp.uni-trier.de/db/journals/scn/\" target=\"_blank\" rel=\"noopener\">http://dblp.uni-trier.de/db/journals/scn/</a></td>\n</tr>\n</tbody>\n</table>\n</div>\n<h2 id=\"中国计算机学会推荐国际学术会议（网络与信息安全）\"><a href=\"#中国计算机学会推荐国际学术会议（网络与信息安全）\" class=\"headerlink\" title=\"中国计算机学会推荐国际学术会议（网络与信息安全）\"></a>中国计算机学会推荐国际学术会议（网络与信息安全）</h2><h3 id=\"A类-1\"><a href=\"#A类-1\" class=\"headerlink\" title=\"A类\"></a>A类</h3><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">序号</th>\n<th style=\"text-align:center\">会议简称</th>\n<th style=\"text-align:center\">会议全称</th>\n<th style=\"text-align:center\">出版社</th>\n<th style=\"text-align:center\">网址</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">CCS</td>\n<td style=\"text-align:center\">ACM Conference on Computer and Communications Security</td>\n<td style=\"text-align:center\">ACM</td>\n<td style=\"text-align:center\"><a href=\"http://dblp.uni-trier.de/db/conf/ccs/\" target=\"_blank\" rel=\"noopener\">http://dblp.uni-trier.de/db/conf/ccs/</a></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">2</td>\n<td style=\"text-align:center\">EUROCRYPT</td>\n<td style=\"text-align:center\">European Cryptology Conference</td>\n<td style=\"text-align:center\">Springer</td>\n<td style=\"text-align:center\"><a href=\"http://dblp.uni-trier.de/db/conf/eurocrypt/\" target=\"_blank\" rel=\"noopener\">http://dblp.uni-trier.de/db/conf/eurocrypt/</a></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">3</td>\n<td style=\"text-align:center\">S&amp;P</td>\n<td style=\"text-align:center\">IEEE Symposium on Security and Privacy</td>\n<td style=\"text-align:center\">IEEE</td>\n<td style=\"text-align:center\"><a href=\"http://dblp.uni-trier.de/db/conf/sp/\" target=\"_blank\" rel=\"noopener\">http://dblp.uni-trier.de/db/conf/sp/</a></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">4</td>\n<td style=\"text-align:center\">CRYPTO</td>\n<td style=\"text-align:center\">International Cryptology Conference</td>\n<td style=\"text-align:center\">Springer</td>\n<td style=\"text-align:center\"><a href=\"http://dblp.uni-trier.de/db/conf/crypto/\" target=\"_blank\" rel=\"noopener\">http://dblp.uni-trier.de/db/conf/crypto/</a></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">5</td>\n<td style=\"text-align:center\">USENIX Security</td>\n<td style=\"text-align:center\">Usenix Security Symposium</td>\n<td style=\"text-align:center\">USENIX Association</td>\n<td style=\"text-align:center\"><a href=\"http://dblp.uni-trier.de/db/conf/uss/\" target=\"_blank\" rel=\"noopener\">http://dblp.uni-trier.de/db/conf/uss/</a></td>\n</tr>\n</tbody>\n</table>\n</div>\n<h3 id=\"B类-1\"><a href=\"#B类-1\" class=\"headerlink\" title=\"B类\"></a>B类</h3><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">序号</th>\n<th style=\"text-align:center\">会议简称</th>\n<th style=\"text-align:center\">会议全称</th>\n<th style=\"text-align:center\">出版社</th>\n<th style=\"text-align:center\">网址</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">ACSAC</td>\n<td style=\"text-align:center\">Annual Computer Security Applications Conference</td>\n<td style=\"text-align:center\">IEEE</td>\n<td style=\"text-align:center\"><a href=\"http://dblp.uni-trier.de/db/conf/acsac/\" target=\"_blank\" rel=\"noopener\">http://dblp.uni-trier.de/db/conf/acsac/</a></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">2</td>\n<td style=\"text-align:center\">ASIACRYPT</td>\n<td style=\"text-align:center\">Annual International Conference on the Theory and Application of Cryptology and Information Security</td>\n<td style=\"text-align:center\">Springer</td>\n<td style=\"text-align:center\"><a href=\"http://dblp.uni-trier.de/db/conf/asiacrypt/\" target=\"_blank\" rel=\"noopener\">http://dblp.uni-trier.de/db/conf/asiacrypt/</a></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">3</td>\n<td style=\"text-align:center\">ESORICS</td>\n<td style=\"text-align:center\">European Symposium on Research in Computer Security</td>\n<td style=\"text-align:center\">Springer</td>\n<td style=\"text-align:center\"><a href=\"http://dblp.uni-trier.de/db/conf/esorics/\" target=\"_blank\" rel=\"noopener\">http://dblp.uni-trier.de/db/conf/esorics/</a></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">4</td>\n<td style=\"text-align:center\">FSE</td>\n<td style=\"text-align:center\">Fast Software Encryption</td>\n<td style=\"text-align:center\">Springer</td>\n<td style=\"text-align:center\"><a href=\"http://dblp.uni-trier.de/db/conf/fse/\" target=\"_blank\" rel=\"noopener\">http://dblp.uni-trier.de/db/conf/fse/</a></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">5</td>\n<td style=\"text-align:center\">CSFW</td>\n<td style=\"text-align:center\">IEEE Computer Security Foundations Workshop</td>\n<td style=\"text-align:center\">IEEE</td>\n<td style=\"text-align:center\"><a href=\"http://dblp.uni-trier.de/db/conf/csfw/\" target=\"_blank\" rel=\"noopener\">http://dblp.uni-trier.de/db/conf/csfw/</a></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">6</td>\n<td style=\"text-align:center\">SRDS</td>\n<td style=\"text-align:center\">IEEE International Symposium on Reliable Distributed Systems</td>\n<td style=\"text-align:center\">IEEE</td>\n<td style=\"text-align:center\"><a href=\"http://dblp.uni-trier.de/db/conf/srds/\" target=\"_blank\" rel=\"noopener\">http://dblp.uni-trier.de/db/conf/srds/</a></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">7</td>\n<td style=\"text-align:center\">CHES</td>\n<td style=\"text-align:center\">International Conference on Cryptographic Hardware and Embedded Systems</td>\n<td style=\"text-align:center\">Springer</td>\n<td style=\"text-align:center\"><a href=\"http://dblp.uni-trier.de/db/conf/ches/\" target=\"_blank\" rel=\"noopener\">http://dblp.uni-trier.de/db/conf/ches/</a></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">8</td>\n<td style=\"text-align:center\">DSN</td>\n<td style=\"text-align:center\">International Conference on Dependable Systems and Networks</td>\n<td style=\"text-align:center\">IEEE/IFIP</td>\n<td style=\"text-align:center\"><a href=\"http://dblp.uni-trier.de/db/conf/dsn/\" target=\"_blank\" rel=\"noopener\">http://dblp.uni-trier.de/db/conf/dsn/</a></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">9</td>\n<td style=\"text-align:center\">RAID</td>\n<td style=\"text-align:center\">International Symposium on Recent Advances in Intrusion Detection</td>\n<td style=\"text-align:center\">Springer</td>\n<td style=\"text-align:center\"><a href=\"http://dblp.uni-trier.de/db/conf/raid/\" target=\"_blank\" rel=\"noopener\">http://dblp.uni-trier.de/db/conf/raid/</a></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">10</td>\n<td style=\"text-align:center\">PKC</td>\n<td style=\"text-align:center\">International Workshop on Practice and Theory in Public Key Cryptography</td>\n<td style=\"text-align:center\">Springer</td>\n<td style=\"text-align:center\"><a href=\"http://dblp.uni-trier.de/db/conf/pkc/\" target=\"_blank\" rel=\"noopener\">http://dblp.uni-trier.de/db/conf/pkc/</a></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">11</td>\n<td style=\"text-align:center\">NDSS</td>\n<td style=\"text-align:center\">ISOC Network and Distributed System Security Symposium</td>\n<td style=\"text-align:center\">ISOC</td>\n<td style=\"text-align:center\"><a href=\"http://dblp.uni-trier.de/db/conf/ndss/\" target=\"_blank\" rel=\"noopener\">http://dblp.uni-trier.de/db/conf/ndss/</a></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">12</td>\n<td style=\"text-align:center\">TCC</td>\n<td style=\"text-align:center\">Theory of Cryptography Conference</td>\n<td style=\"text-align:center\">Springer</td>\n<td style=\"text-align:center\"><a href=\"http://dblp.uni-trier.de/db/conf/tcc/\" target=\"_blank\" rel=\"noopener\">http://dblp.uni-trier.de/db/conf/tcc/</a></td>\n</tr>\n</tbody>\n</table>\n</div>\n<h3 id=\"C类-1\"><a href=\"#C类-1\" class=\"headerlink\" title=\"C类\"></a>C类</h3><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">序号</th>\n<th style=\"text-align:center\">会议简称</th>\n<th style=\"text-align:center\">会议全称</th>\n<th style=\"text-align:center\">出版社</th>\n<th style=\"text-align:center\">网址</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">WiSec</td>\n<td style=\"text-align:center\">ACM Conference on Security and Privacy in Wireless and Mobile Networks</td>\n<td style=\"text-align:center\">ACM</td>\n<td style=\"text-align:center\"><a href=\"http://dblp.uni-trier.de/db/conf/wisec/\" target=\"_blank\" rel=\"noopener\">http://dblp.uni-trier.de/db/conf/wisec/</a></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">2</td>\n<td style=\"text-align:center\">SACMAT</td>\n<td style=\"text-align:center\">ACM Symposium on Access Control Models and Technologies</td>\n<td style=\"text-align:center\">ACM</td>\n<td style=\"text-align:center\"><a href=\"http://dblp.uni-trier.de/db/conf/sacmat/\" target=\"_blank\" rel=\"noopener\">http://dblp.uni-trier.de/db/conf/sacmat/</a></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">3</td>\n<td style=\"text-align:center\">DRM</td>\n<td style=\"text-align:center\">ACM Workshop on Digital Rights Management</td>\n<td style=\"text-align:center\">ACM</td>\n<td style=\"text-align:center\"><a href=\"http://dblp.uni-trier.de/db/conf/drm/\" target=\"_blank\" rel=\"noopener\">http://dblp.uni-trier.de/db/conf/drm/</a></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">4</td>\n<td style=\"text-align:center\">IH&amp;MMSec</td>\n<td style=\"text-align:center\">ACM Workshop on Information Hiding and Multimedia Security</td>\n<td style=\"text-align:center\">ACM</td>\n<td style=\"text-align:center\"><a href=\"http://dblp.uni-trier.de/db/conf/ih/\" target=\"_blank\" rel=\"noopener\">http://dblp.uni-trier.de/db/conf/ih/</a></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">5</td>\n<td style=\"text-align:center\">ACNS</td>\n<td style=\"text-align:center\">Applied Cryptography and Network Security</td>\n<td style=\"text-align:center\">Springer</td>\n<td style=\"text-align:center\"><a href=\"http://dblp.uni-trier.de/db/conf/acns/\" target=\"_blank\" rel=\"noopener\">http://dblp.uni-trier.de/db/conf/acns/</a></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">6</td>\n<td style=\"text-align:center\">AsiaCCS</td>\n<td style=\"text-align:center\">Asia Conference on Computer and Communications Security</td>\n<td style=\"text-align:center\">ACM</td>\n<td style=\"text-align:center\"><a href=\"http://dblp.uni-trier.de/db/conf/ccs/\" target=\"_blank\" rel=\"noopener\">http://dblp.uni-trier.de/db/conf/ccs/</a></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">7</td>\n<td style=\"text-align:center\">ACISP</td>\n<td style=\"text-align:center\">Australasia Conference on Information Security and Privacy</td>\n<td style=\"text-align:center\">Springer</td>\n<td style=\"text-align:center\"><a href=\"http://dblp.uni-trier.de/db/conf/acisp/\" target=\"_blank\" rel=\"noopener\">http://dblp.uni-trier.de/db/conf/acisp/</a></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">8</td>\n<td style=\"text-align:center\">CT-RSA</td>\n<td style=\"text-align:center\">Cryptographer’s Track at RSA Conference</td>\n<td style=\"text-align:center\">Springer</td>\n<td style=\"text-align:center\"><a href=\"http://dblp.uni-trier.de/db/conf/ctrsa/\" target=\"_blank\" rel=\"noopener\">http://dblp.uni-trier.de/db/conf/ctrsa/</a></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">9</td>\n<td style=\"text-align:center\">DIMVA</td>\n<td style=\"text-align:center\">Detection of Intrusions and Malware &amp; Vulnerability Assessment</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"><a href=\"http://dblp.uni-trier.de/db/conf/dimva/\" target=\"_blank\" rel=\"noopener\">http://dblp.uni-trier.de/db/conf/dimva/</a></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">10</td>\n<td style=\"text-align:center\">DFRWS</td>\n<td style=\"text-align:center\">Digital Forensic Research Workshop</td>\n<td style=\"text-align:center\">Elsevier</td>\n<td style=\"text-align:center\"><a href=\"http://dblp.uni-trier.de/db/conf/dfrws/\" target=\"_blank\" rel=\"noopener\">http://dblp.uni-trier.de/db/conf/dfrws/</a></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">11</td>\n<td style=\"text-align:center\">FC</td>\n<td style=\"text-align:center\">Financial Cryptography and Data Security</td>\n<td style=\"text-align:center\">Springer</td>\n<td style=\"text-align:center\"><a href=\"http://dblp.uni-trier.de/db/conf/fc/\" target=\"_blank\" rel=\"noopener\">http://dblp.uni-trier.de/db/conf/fc/</a></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">12</td>\n<td style=\"text-align:center\">TrustCom</td>\n<td style=\"text-align:center\">IEEE International Conference on Trust, Security and Privacy in Computing and Communications</td>\n<td style=\"text-align:center\">IEEE</td>\n<td style=\"text-align:center\"><a href=\"http://dblp.uni-trier.de/db/conf/trustcom/\" target=\"_blank\" rel=\"noopener\">http://dblp.uni-trier.de/db/conf/trustcom/</a></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">13</td>\n<td style=\"text-align:center\">SEC</td>\n<td style=\"text-align:center\">IFIP International Information Security Conference</td>\n<td style=\"text-align:center\">Springer</td>\n<td style=\"text-align:center\"><a href=\"http://dblp.uni-trier.de/db/conf/sec/\" target=\"_blank\" rel=\"noopener\">http://dblp.uni-trier.de/db/conf/sec/</a></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">14</td>\n<td style=\"text-align:center\">IFIP WG 11.9</td>\n<td style=\"text-align:center\">IFIP WG 11.9 International Conference on Digital Forensics</td>\n<td style=\"text-align:center\">Springer</td>\n<td style=\"text-align:center\">*<a href=\"http://www.ifip119.org/Conferences/\" target=\"_blank\" rel=\"noopener\">http://www.ifip119.org/Conferences/</a></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">15</td>\n<td style=\"text-align:center\">ISC</td>\n<td style=\"text-align:center\">Information Security Conference</td>\n<td style=\"text-align:center\">Springer</td>\n<td style=\"text-align:center\"><a href=\"http://dblp.uni-trier.de/db/conf/isw/\" target=\"_blank\" rel=\"noopener\">http://dblp.uni-trier.de/db/conf/isw/</a></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">16</td>\n<td style=\"text-align:center\">ICDF2C</td>\n<td style=\"text-align:center\">International Conference on Digital Forensics &amp; Cyber Crime</td>\n<td style=\"text-align:center\">Springer</td>\n<td style=\"text-align:center\"><a href=\"http://dblp.uni-trier.de/db/conf/icdf2c/\" target=\"_blank\" rel=\"noopener\">http://dblp.uni-trier.de/db/conf/icdf2c/</a></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">17</td>\n<td style=\"text-align:center\">ICICS</td>\n<td style=\"text-align:center\">International Conference on Information and Communications Security</td>\n<td style=\"text-align:center\">Springer</td>\n<td style=\"text-align:center\"><a href=\"http://dblp.uni-trier.de/db/conf/icics/\" target=\"_blank\" rel=\"noopener\">http://dblp.uni-trier.de/db/conf/icics/</a></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">18</td>\n<td style=\"text-align:center\">SecureComm</td>\n<td style=\"text-align:center\">International Conference on Security and Privacy in Communication Networks</td>\n<td style=\"text-align:center\">ACM</td>\n<td style=\"text-align:center\"><a href=\"http://dblp.uni-trier.de/db/conf/securecomm/\" target=\"_blank\" rel=\"noopener\">http://dblp.uni-trier.de/db/conf/securecomm/</a></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">19</td>\n<td style=\"text-align:center\">NSPW</td>\n<td style=\"text-align:center\">New Security Paradigms Workshop</td>\n<td style=\"text-align:center\">ACM</td>\n<td style=\"text-align:center\"><a href=\"http://dblp.uni-trier.de/db/conf/nspw/\" target=\"_blank\" rel=\"noopener\">http://dblp.uni-trier.de/db/conf/nspw/</a></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">20</td>\n<td style=\"text-align:center\">PAM</td>\n<td style=\"text-align:center\">Passive and Active Measurement Conference</td>\n<td style=\"text-align:center\">Springer</td>\n<td style=\"text-align:center\"><a href=\"http://dblp.uni-trier.de/db/conf/pam/\" target=\"_blank\" rel=\"noopener\">http://dblp.uni-trier.de/db/conf/pam/</a></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">21</td>\n<td style=\"text-align:center\">PETS</td>\n<td style=\"text-align:center\">Privacy Enhancing Technologies Symposium</td>\n<td style=\"text-align:center\">Springer</td>\n<td style=\"text-align:center\"><a href=\"http://dblp.uni-trier.de/db/conf/pet/\" target=\"_blank\" rel=\"noopener\">http://dblp.uni-trier.de/db/conf/pet/</a></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">22</td>\n<td style=\"text-align:center\">SAC</td>\n<td style=\"text-align:center\">Selected Areas in Cryptography</td>\n<td style=\"text-align:center\">Springer</td>\n<td style=\"text-align:center\"><a href=\"http://dblp.uni-trier.de/db/conf/sacrypt/\" target=\"_blank\" rel=\"noopener\">http://dblp.uni-trier.de/db/conf/sacrypt/</a></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">23</td>\n<td style=\"text-align:center\">SOUPS</td>\n<td style=\"text-align:center\">Symposium On Usable Privacy and Security</td>\n<td style=\"text-align:center\">USENIX</td>\n<td style=\"text-align:center\"><a href=\"http://dblp.uni-trier.de/db/conf/soups/\" target=\"_blank\" rel=\"noopener\">http://dblp.uni-trier.de/db/conf/soups/</a></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">24</td>\n<td style=\"text-align:center\">HotSec</td>\n<td style=\"text-align:center\">USENIX Workshop on Hot Topics in Security</td>\n<td style=\"text-align:center\">USENIX</td>\n<td style=\"text-align:center\">*<a href=\"http://www.usenix.org/events/\" target=\"_blank\" rel=\"noopener\">http://www.usenix.org/events/</a></td>\n</tr>\n</tbody>\n</table>\n</div>\n","site":{"data":{}},"excerpt":"<p><a href=\"https://www.ccf.org.cn/c/2019-04-25/663625.shtml\" target=\"_blank\" rel=\"noopener\">https://www.ccf.org.cn/c/2019-04-25/663625.shtml</a></p>","more":"<h2 id=\"中国计算机学会推荐国际学术期刊（网络与信息安全）\"><a href=\"#中国计算机学会推荐国际学术期刊（网络与信息安全）\" class=\"headerlink\" title=\"中国计算机学会推荐国际学术期刊（网络与信息安全）\"></a>中国计算机学会推荐国际学术期刊（网络与信息安全）</h2><h3 id=\"A类\"><a href=\"#A类\" class=\"headerlink\" title=\"A类\"></a>A类</h3><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">序号</th>\n<th style=\"text-align:center\">刊物简称</th>\n<th style=\"text-align:center\">刊物全称</th>\n<th style=\"text-align:center\">出版社</th>\n<th style=\"text-align:center\">网址</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">TDSC</td>\n<td style=\"text-align:center\">IEEE Transactions on Dependable and Secure Computing</td>\n<td style=\"text-align:center\">IEEE</td>\n<td style=\"text-align:center\"><a href=\"http://dblp.uni-trier.de/db/journals/tdsc/\" target=\"_blank\" rel=\"noopener\">http://dblp.uni-trier.de/db/journals/tdsc/</a></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">2</td>\n<td style=\"text-align:center\">TIFS</td>\n<td style=\"text-align:center\">IEEE Transactions on Information Forensics and Security</td>\n<td style=\"text-align:center\">IEEE</td>\n<td style=\"text-align:center\"><a href=\"http://dblp.uni-trier.de/db/journals/tifs/\" target=\"_blank\" rel=\"noopener\">http://dblp.uni-trier.de/db/journals/tifs/</a></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">3</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">Journal of Cryptology</td>\n<td style=\"text-align:center\">Springer</td>\n<td style=\"text-align:center\"><a href=\"http://dblp.uni-trier.de/db/journals/joc/\" target=\"_blank\" rel=\"noopener\">http://dblp.uni-trier.de/db/journals/joc/</a></td>\n</tr>\n</tbody>\n</table>\n</div>\n<h3 id=\"B类\"><a href=\"#B类\" class=\"headerlink\" title=\"B类\"></a>B类</h3><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">序号</th>\n<th style=\"text-align:center\">刊物简称</th>\n<th style=\"text-align:center\">刊物全称</th>\n<th style=\"text-align:center\">出版社</th>\n<th style=\"text-align:center\">网址</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">TOPS</td>\n<td style=\"text-align:center\">ACM Transactions on Privacy and Security</td>\n<td style=\"text-align:center\">ACM</td>\n<td style=\"text-align:center\"><a href=\"https://tops.acm.org/\" target=\"_blank\" rel=\"noopener\">https://tops.acm.org/</a></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">2</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">Computers &amp; Security</td>\n<td style=\"text-align:center\">Elsevier</td>\n<td style=\"text-align:center\"><a href=\"http://dblp.uni-trier.de/db/journals/compsec/\" target=\"_blank\" rel=\"noopener\">http://dblp.uni-trier.de/db/journals/compsec/</a></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">3</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">Designs, Codes and Cryptography</td>\n<td style=\"text-align:center\">Springer</td>\n<td style=\"text-align:center\"><a href=\"http://dblp.uni-trier.de/db/journals/dcc/\" target=\"_blank\" rel=\"noopener\">http://dblp.uni-trier.de/db/journals/dcc/</a></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">4</td>\n<td style=\"text-align:center\">JCS</td>\n<td style=\"text-align:center\">Journal of Computer Security</td>\n<td style=\"text-align:center\">IOS Press</td>\n<td style=\"text-align:center\"><a href=\"http://dblp.uni-trier.de/db/journals/jcs/\" target=\"_blank\" rel=\"noopener\">http://dblp.uni-trier.de/db/journals/jcs/</a></td>\n</tr>\n</tbody>\n</table>\n</div>\n<h3 id=\"C类\"><a href=\"#C类\" class=\"headerlink\" title=\"C类\"></a>C类</h3><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">序号</th>\n<th style=\"text-align:center\">刊物简称</th>\n<th style=\"text-align:center\">刊物全称</th>\n<th style=\"text-align:center\">出版社</th>\n<th style=\"text-align:center\">网址</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">CLSR</td>\n<td style=\"text-align:center\">Computer Law and Security Review</td>\n<td style=\"text-align:center\">Elsevier</td>\n<td style=\"text-align:center\"><a href=\"http://www.journals.elsevier.com/computer-law-and-security-review/\" target=\"_blank\" rel=\"noopener\">http://www.journals.elsevier.com/computer-law-and-security-review/</a></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">2</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">EURASIP Journal on Information Security</td>\n<td style=\"text-align:center\">Springer</td>\n<td style=\"text-align:center\"><a href=\"http://dblp.uni-trier.de/db/journals/ejisec/\" target=\"_blank\" rel=\"noopener\">http://dblp.uni-trier.de/db/journals/ejisec/</a></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">3</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">IET Information Security</td>\n<td style=\"text-align:center\">IET</td>\n<td style=\"text-align:center\"><a href=\"http://dblp.uni-trier.de/db/journals/iet-ifs/\" target=\"_blank\" rel=\"noopener\">http://dblp.uni-trier.de/db/journals/iet-ifs/</a></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">4</td>\n<td style=\"text-align:center\">IMCS</td>\n<td style=\"text-align:center\">Information Management &amp; Computer Security</td>\n<td style=\"text-align:center\">Emerald</td>\n<td style=\"text-align:center\"><a href=\"http://dblp.uni-trier.de/db/journals/imcs/\" target=\"_blank\" rel=\"noopener\">http://dblp.uni-trier.de/db/journals/imcs/</a></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">5</td>\n<td style=\"text-align:center\">IJICS</td>\n<td style=\"text-align:center\">International Journal of Information and Computer Security</td>\n<td style=\"text-align:center\">Inderscience</td>\n<td style=\"text-align:center\"><a href=\"http://dblp.uni-trier.de/db/journals/ijics/\" target=\"_blank\" rel=\"noopener\">http://dblp.uni-trier.de/db/journals/ijics/</a></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">6</td>\n<td style=\"text-align:center\">IJISP</td>\n<td style=\"text-align:center\">International Journal of Information Security and Privacy</td>\n<td style=\"text-align:center\">Idea Group Inc</td>\n<td style=\"text-align:center\"><a href=\"http://dblp.uni-trier.de/db/journals/ijisp/\" target=\"_blank\" rel=\"noopener\">http://dblp.uni-trier.de/db/journals/ijisp/</a></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">7</td>\n<td style=\"text-align:center\">JISA</td>\n<td style=\"text-align:center\">Journal of Information Security and Application</td>\n<td style=\"text-align:center\">Elsevier</td>\n<td style=\"text-align:center\"><a href=\"https://dblp.uni-trier.de/db/journals/istr/\" target=\"_blank\" rel=\"noopener\">https://dblp.uni-trier.de/db/journals/istr/</a></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">8</td>\n<td style=\"text-align:center\">SCN</td>\n<td style=\"text-align:center\">Security and Communication Networks</td>\n<td style=\"text-align:center\">Wiley</td>\n<td style=\"text-align:center\"><a href=\"http://dblp.uni-trier.de/db/journals/scn/\" target=\"_blank\" rel=\"noopener\">http://dblp.uni-trier.de/db/journals/scn/</a></td>\n</tr>\n</tbody>\n</table>\n</div>\n<h2 id=\"中国计算机学会推荐国际学术会议（网络与信息安全）\"><a href=\"#中国计算机学会推荐国际学术会议（网络与信息安全）\" class=\"headerlink\" title=\"中国计算机学会推荐国际学术会议（网络与信息安全）\"></a>中国计算机学会推荐国际学术会议（网络与信息安全）</h2><h3 id=\"A类-1\"><a href=\"#A类-1\" class=\"headerlink\" title=\"A类\"></a>A类</h3><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">序号</th>\n<th style=\"text-align:center\">会议简称</th>\n<th style=\"text-align:center\">会议全称</th>\n<th style=\"text-align:center\">出版社</th>\n<th style=\"text-align:center\">网址</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">CCS</td>\n<td style=\"text-align:center\">ACM Conference on Computer and Communications Security</td>\n<td style=\"text-align:center\">ACM</td>\n<td style=\"text-align:center\"><a href=\"http://dblp.uni-trier.de/db/conf/ccs/\" target=\"_blank\" rel=\"noopener\">http://dblp.uni-trier.de/db/conf/ccs/</a></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">2</td>\n<td style=\"text-align:center\">EUROCRYPT</td>\n<td style=\"text-align:center\">European Cryptology Conference</td>\n<td style=\"text-align:center\">Springer</td>\n<td style=\"text-align:center\"><a href=\"http://dblp.uni-trier.de/db/conf/eurocrypt/\" target=\"_blank\" rel=\"noopener\">http://dblp.uni-trier.de/db/conf/eurocrypt/</a></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">3</td>\n<td style=\"text-align:center\">S&amp;P</td>\n<td style=\"text-align:center\">IEEE Symposium on Security and Privacy</td>\n<td style=\"text-align:center\">IEEE</td>\n<td style=\"text-align:center\"><a href=\"http://dblp.uni-trier.de/db/conf/sp/\" target=\"_blank\" rel=\"noopener\">http://dblp.uni-trier.de/db/conf/sp/</a></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">4</td>\n<td style=\"text-align:center\">CRYPTO</td>\n<td style=\"text-align:center\">International Cryptology Conference</td>\n<td style=\"text-align:center\">Springer</td>\n<td style=\"text-align:center\"><a href=\"http://dblp.uni-trier.de/db/conf/crypto/\" target=\"_blank\" rel=\"noopener\">http://dblp.uni-trier.de/db/conf/crypto/</a></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">5</td>\n<td style=\"text-align:center\">USENIX Security</td>\n<td style=\"text-align:center\">Usenix Security Symposium</td>\n<td style=\"text-align:center\">USENIX Association</td>\n<td style=\"text-align:center\"><a href=\"http://dblp.uni-trier.de/db/conf/uss/\" target=\"_blank\" rel=\"noopener\">http://dblp.uni-trier.de/db/conf/uss/</a></td>\n</tr>\n</tbody>\n</table>\n</div>\n<h3 id=\"B类-1\"><a href=\"#B类-1\" class=\"headerlink\" title=\"B类\"></a>B类</h3><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">序号</th>\n<th style=\"text-align:center\">会议简称</th>\n<th style=\"text-align:center\">会议全称</th>\n<th style=\"text-align:center\">出版社</th>\n<th style=\"text-align:center\">网址</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">ACSAC</td>\n<td style=\"text-align:center\">Annual Computer Security Applications Conference</td>\n<td style=\"text-align:center\">IEEE</td>\n<td style=\"text-align:center\"><a href=\"http://dblp.uni-trier.de/db/conf/acsac/\" target=\"_blank\" rel=\"noopener\">http://dblp.uni-trier.de/db/conf/acsac/</a></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">2</td>\n<td style=\"text-align:center\">ASIACRYPT</td>\n<td style=\"text-align:center\">Annual International Conference on the Theory and Application of Cryptology and Information Security</td>\n<td style=\"text-align:center\">Springer</td>\n<td style=\"text-align:center\"><a href=\"http://dblp.uni-trier.de/db/conf/asiacrypt/\" target=\"_blank\" rel=\"noopener\">http://dblp.uni-trier.de/db/conf/asiacrypt/</a></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">3</td>\n<td style=\"text-align:center\">ESORICS</td>\n<td style=\"text-align:center\">European Symposium on Research in Computer Security</td>\n<td style=\"text-align:center\">Springer</td>\n<td style=\"text-align:center\"><a href=\"http://dblp.uni-trier.de/db/conf/esorics/\" target=\"_blank\" rel=\"noopener\">http://dblp.uni-trier.de/db/conf/esorics/</a></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">4</td>\n<td style=\"text-align:center\">FSE</td>\n<td style=\"text-align:center\">Fast Software Encryption</td>\n<td style=\"text-align:center\">Springer</td>\n<td style=\"text-align:center\"><a href=\"http://dblp.uni-trier.de/db/conf/fse/\" target=\"_blank\" rel=\"noopener\">http://dblp.uni-trier.de/db/conf/fse/</a></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">5</td>\n<td style=\"text-align:center\">CSFW</td>\n<td style=\"text-align:center\">IEEE Computer Security Foundations Workshop</td>\n<td style=\"text-align:center\">IEEE</td>\n<td style=\"text-align:center\"><a href=\"http://dblp.uni-trier.de/db/conf/csfw/\" target=\"_blank\" rel=\"noopener\">http://dblp.uni-trier.de/db/conf/csfw/</a></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">6</td>\n<td style=\"text-align:center\">SRDS</td>\n<td style=\"text-align:center\">IEEE International Symposium on Reliable Distributed Systems</td>\n<td style=\"text-align:center\">IEEE</td>\n<td style=\"text-align:center\"><a href=\"http://dblp.uni-trier.de/db/conf/srds/\" target=\"_blank\" rel=\"noopener\">http://dblp.uni-trier.de/db/conf/srds/</a></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">7</td>\n<td style=\"text-align:center\">CHES</td>\n<td style=\"text-align:center\">International Conference on Cryptographic Hardware and Embedded Systems</td>\n<td style=\"text-align:center\">Springer</td>\n<td style=\"text-align:center\"><a href=\"http://dblp.uni-trier.de/db/conf/ches/\" target=\"_blank\" rel=\"noopener\">http://dblp.uni-trier.de/db/conf/ches/</a></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">8</td>\n<td style=\"text-align:center\">DSN</td>\n<td style=\"text-align:center\">International Conference on Dependable Systems and Networks</td>\n<td style=\"text-align:center\">IEEE/IFIP</td>\n<td style=\"text-align:center\"><a href=\"http://dblp.uni-trier.de/db/conf/dsn/\" target=\"_blank\" rel=\"noopener\">http://dblp.uni-trier.de/db/conf/dsn/</a></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">9</td>\n<td style=\"text-align:center\">RAID</td>\n<td style=\"text-align:center\">International Symposium on Recent Advances in Intrusion Detection</td>\n<td style=\"text-align:center\">Springer</td>\n<td style=\"text-align:center\"><a href=\"http://dblp.uni-trier.de/db/conf/raid/\" target=\"_blank\" rel=\"noopener\">http://dblp.uni-trier.de/db/conf/raid/</a></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">10</td>\n<td style=\"text-align:center\">PKC</td>\n<td style=\"text-align:center\">International Workshop on Practice and Theory in Public Key Cryptography</td>\n<td style=\"text-align:center\">Springer</td>\n<td style=\"text-align:center\"><a href=\"http://dblp.uni-trier.de/db/conf/pkc/\" target=\"_blank\" rel=\"noopener\">http://dblp.uni-trier.de/db/conf/pkc/</a></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">11</td>\n<td style=\"text-align:center\">NDSS</td>\n<td style=\"text-align:center\">ISOC Network and Distributed System Security Symposium</td>\n<td style=\"text-align:center\">ISOC</td>\n<td style=\"text-align:center\"><a href=\"http://dblp.uni-trier.de/db/conf/ndss/\" target=\"_blank\" rel=\"noopener\">http://dblp.uni-trier.de/db/conf/ndss/</a></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">12</td>\n<td style=\"text-align:center\">TCC</td>\n<td style=\"text-align:center\">Theory of Cryptography Conference</td>\n<td style=\"text-align:center\">Springer</td>\n<td style=\"text-align:center\"><a href=\"http://dblp.uni-trier.de/db/conf/tcc/\" target=\"_blank\" rel=\"noopener\">http://dblp.uni-trier.de/db/conf/tcc/</a></td>\n</tr>\n</tbody>\n</table>\n</div>\n<h3 id=\"C类-1\"><a href=\"#C类-1\" class=\"headerlink\" title=\"C类\"></a>C类</h3><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">序号</th>\n<th style=\"text-align:center\">会议简称</th>\n<th style=\"text-align:center\">会议全称</th>\n<th style=\"text-align:center\">出版社</th>\n<th style=\"text-align:center\">网址</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">WiSec</td>\n<td style=\"text-align:center\">ACM Conference on Security and Privacy in Wireless and Mobile Networks</td>\n<td style=\"text-align:center\">ACM</td>\n<td style=\"text-align:center\"><a href=\"http://dblp.uni-trier.de/db/conf/wisec/\" target=\"_blank\" rel=\"noopener\">http://dblp.uni-trier.de/db/conf/wisec/</a></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">2</td>\n<td style=\"text-align:center\">SACMAT</td>\n<td style=\"text-align:center\">ACM Symposium on Access Control Models and Technologies</td>\n<td style=\"text-align:center\">ACM</td>\n<td style=\"text-align:center\"><a href=\"http://dblp.uni-trier.de/db/conf/sacmat/\" target=\"_blank\" rel=\"noopener\">http://dblp.uni-trier.de/db/conf/sacmat/</a></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">3</td>\n<td style=\"text-align:center\">DRM</td>\n<td style=\"text-align:center\">ACM Workshop on Digital Rights Management</td>\n<td style=\"text-align:center\">ACM</td>\n<td style=\"text-align:center\"><a href=\"http://dblp.uni-trier.de/db/conf/drm/\" target=\"_blank\" rel=\"noopener\">http://dblp.uni-trier.de/db/conf/drm/</a></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">4</td>\n<td style=\"text-align:center\">IH&amp;MMSec</td>\n<td style=\"text-align:center\">ACM Workshop on Information Hiding and Multimedia Security</td>\n<td style=\"text-align:center\">ACM</td>\n<td style=\"text-align:center\"><a href=\"http://dblp.uni-trier.de/db/conf/ih/\" target=\"_blank\" rel=\"noopener\">http://dblp.uni-trier.de/db/conf/ih/</a></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">5</td>\n<td style=\"text-align:center\">ACNS</td>\n<td style=\"text-align:center\">Applied Cryptography and Network Security</td>\n<td style=\"text-align:center\">Springer</td>\n<td style=\"text-align:center\"><a href=\"http://dblp.uni-trier.de/db/conf/acns/\" target=\"_blank\" rel=\"noopener\">http://dblp.uni-trier.de/db/conf/acns/</a></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">6</td>\n<td style=\"text-align:center\">AsiaCCS</td>\n<td style=\"text-align:center\">Asia Conference on Computer and Communications Security</td>\n<td style=\"text-align:center\">ACM</td>\n<td style=\"text-align:center\"><a href=\"http://dblp.uni-trier.de/db/conf/ccs/\" target=\"_blank\" rel=\"noopener\">http://dblp.uni-trier.de/db/conf/ccs/</a></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">7</td>\n<td style=\"text-align:center\">ACISP</td>\n<td style=\"text-align:center\">Australasia Conference on Information Security and Privacy</td>\n<td style=\"text-align:center\">Springer</td>\n<td style=\"text-align:center\"><a href=\"http://dblp.uni-trier.de/db/conf/acisp/\" target=\"_blank\" rel=\"noopener\">http://dblp.uni-trier.de/db/conf/acisp/</a></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">8</td>\n<td style=\"text-align:center\">CT-RSA</td>\n<td style=\"text-align:center\">Cryptographer’s Track at RSA Conference</td>\n<td style=\"text-align:center\">Springer</td>\n<td style=\"text-align:center\"><a href=\"http://dblp.uni-trier.de/db/conf/ctrsa/\" target=\"_blank\" rel=\"noopener\">http://dblp.uni-trier.de/db/conf/ctrsa/</a></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">9</td>\n<td style=\"text-align:center\">DIMVA</td>\n<td style=\"text-align:center\">Detection of Intrusions and Malware &amp; Vulnerability Assessment</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"><a href=\"http://dblp.uni-trier.de/db/conf/dimva/\" target=\"_blank\" rel=\"noopener\">http://dblp.uni-trier.de/db/conf/dimva/</a></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">10</td>\n<td style=\"text-align:center\">DFRWS</td>\n<td style=\"text-align:center\">Digital Forensic Research Workshop</td>\n<td style=\"text-align:center\">Elsevier</td>\n<td style=\"text-align:center\"><a href=\"http://dblp.uni-trier.de/db/conf/dfrws/\" target=\"_blank\" rel=\"noopener\">http://dblp.uni-trier.de/db/conf/dfrws/</a></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">11</td>\n<td style=\"text-align:center\">FC</td>\n<td style=\"text-align:center\">Financial Cryptography and Data Security</td>\n<td style=\"text-align:center\">Springer</td>\n<td style=\"text-align:center\"><a href=\"http://dblp.uni-trier.de/db/conf/fc/\" target=\"_blank\" rel=\"noopener\">http://dblp.uni-trier.de/db/conf/fc/</a></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">12</td>\n<td style=\"text-align:center\">TrustCom</td>\n<td style=\"text-align:center\">IEEE International Conference on Trust, Security and Privacy in Computing and Communications</td>\n<td style=\"text-align:center\">IEEE</td>\n<td style=\"text-align:center\"><a href=\"http://dblp.uni-trier.de/db/conf/trustcom/\" target=\"_blank\" rel=\"noopener\">http://dblp.uni-trier.de/db/conf/trustcom/</a></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">13</td>\n<td style=\"text-align:center\">SEC</td>\n<td style=\"text-align:center\">IFIP International Information Security Conference</td>\n<td style=\"text-align:center\">Springer</td>\n<td style=\"text-align:center\"><a href=\"http://dblp.uni-trier.de/db/conf/sec/\" target=\"_blank\" rel=\"noopener\">http://dblp.uni-trier.de/db/conf/sec/</a></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">14</td>\n<td style=\"text-align:center\">IFIP WG 11.9</td>\n<td style=\"text-align:center\">IFIP WG 11.9 International Conference on Digital Forensics</td>\n<td style=\"text-align:center\">Springer</td>\n<td style=\"text-align:center\">*<a href=\"http://www.ifip119.org/Conferences/\" target=\"_blank\" rel=\"noopener\">http://www.ifip119.org/Conferences/</a></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">15</td>\n<td style=\"text-align:center\">ISC</td>\n<td style=\"text-align:center\">Information Security Conference</td>\n<td style=\"text-align:center\">Springer</td>\n<td style=\"text-align:center\"><a href=\"http://dblp.uni-trier.de/db/conf/isw/\" target=\"_blank\" rel=\"noopener\">http://dblp.uni-trier.de/db/conf/isw/</a></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">16</td>\n<td style=\"text-align:center\">ICDF2C</td>\n<td style=\"text-align:center\">International Conference on Digital Forensics &amp; Cyber Crime</td>\n<td style=\"text-align:center\">Springer</td>\n<td style=\"text-align:center\"><a href=\"http://dblp.uni-trier.de/db/conf/icdf2c/\" target=\"_blank\" rel=\"noopener\">http://dblp.uni-trier.de/db/conf/icdf2c/</a></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">17</td>\n<td style=\"text-align:center\">ICICS</td>\n<td style=\"text-align:center\">International Conference on Information and Communications Security</td>\n<td style=\"text-align:center\">Springer</td>\n<td style=\"text-align:center\"><a href=\"http://dblp.uni-trier.de/db/conf/icics/\" target=\"_blank\" rel=\"noopener\">http://dblp.uni-trier.de/db/conf/icics/</a></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">18</td>\n<td style=\"text-align:center\">SecureComm</td>\n<td style=\"text-align:center\">International Conference on Security and Privacy in Communication Networks</td>\n<td style=\"text-align:center\">ACM</td>\n<td style=\"text-align:center\"><a href=\"http://dblp.uni-trier.de/db/conf/securecomm/\" target=\"_blank\" rel=\"noopener\">http://dblp.uni-trier.de/db/conf/securecomm/</a></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">19</td>\n<td style=\"text-align:center\">NSPW</td>\n<td style=\"text-align:center\">New Security Paradigms Workshop</td>\n<td style=\"text-align:center\">ACM</td>\n<td style=\"text-align:center\"><a href=\"http://dblp.uni-trier.de/db/conf/nspw/\" target=\"_blank\" rel=\"noopener\">http://dblp.uni-trier.de/db/conf/nspw/</a></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">20</td>\n<td style=\"text-align:center\">PAM</td>\n<td style=\"text-align:center\">Passive and Active Measurement Conference</td>\n<td style=\"text-align:center\">Springer</td>\n<td style=\"text-align:center\"><a href=\"http://dblp.uni-trier.de/db/conf/pam/\" target=\"_blank\" rel=\"noopener\">http://dblp.uni-trier.de/db/conf/pam/</a></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">21</td>\n<td style=\"text-align:center\">PETS</td>\n<td style=\"text-align:center\">Privacy Enhancing Technologies Symposium</td>\n<td style=\"text-align:center\">Springer</td>\n<td style=\"text-align:center\"><a href=\"http://dblp.uni-trier.de/db/conf/pet/\" target=\"_blank\" rel=\"noopener\">http://dblp.uni-trier.de/db/conf/pet/</a></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">22</td>\n<td style=\"text-align:center\">SAC</td>\n<td style=\"text-align:center\">Selected Areas in Cryptography</td>\n<td style=\"text-align:center\">Springer</td>\n<td style=\"text-align:center\"><a href=\"http://dblp.uni-trier.de/db/conf/sacrypt/\" target=\"_blank\" rel=\"noopener\">http://dblp.uni-trier.de/db/conf/sacrypt/</a></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">23</td>\n<td style=\"text-align:center\">SOUPS</td>\n<td style=\"text-align:center\">Symposium On Usable Privacy and Security</td>\n<td style=\"text-align:center\">USENIX</td>\n<td style=\"text-align:center\"><a href=\"http://dblp.uni-trier.de/db/conf/soups/\" target=\"_blank\" rel=\"noopener\">http://dblp.uni-trier.de/db/conf/soups/</a></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">24</td>\n<td style=\"text-align:center\">HotSec</td>\n<td style=\"text-align:center\">USENIX Workshop on Hot Topics in Security</td>\n<td style=\"text-align:center\">USENIX</td>\n<td style=\"text-align:center\">*<a href=\"http://www.usenix.org/events/\" target=\"_blank\" rel=\"noopener\">http://www.usenix.org/events/</a></td>\n</tr>\n</tbody>\n</table>\n</div>"},{"title":"Hexo博客NexT主题点击侧边栏日志出现问题的解决办法","date":"2020-05-11T10:08:08.000Z","_content":"\n部署好博客并安装了NexT主题后，发现一个问题：侧边栏头像下面的日志点击是404的页面。于是到网上搜索，发现是符号转码的问题。\n\n<!--more-->\n\n**解决方法：**\n\n到`\\themes\\next\\layout\\_macro`目录下找到`sidebar.swig`文件，打开找到这一行：\n\n![](http://images.yingwai.top/picgo/nextsidebarrizhif1.png)\n\n原因是`url_for`函数将`||`转码了，\n\n将`theme.menu.archives`后面的括号更换一下位置即可：\n\n![](http://images.yingwai.top/picgo/nextsidebarrizhif2.png)\n\n这时候点击日志就会自动跳转到归档页。","source":"_posts/Hexo博客NexT主题点击侧边栏日志出现问题的解决办法.md","raw":"---\ntitle: Hexo博客NexT主题点击侧边栏日志出现问题的解决办法\ndate: 2020-05-11 18:08:08\ncategories: Env\ntags: [Hexo, NexT]\n---\n\n部署好博客并安装了NexT主题后，发现一个问题：侧边栏头像下面的日志点击是404的页面。于是到网上搜索，发现是符号转码的问题。\n\n<!--more-->\n\n**解决方法：**\n\n到`\\themes\\next\\layout\\_macro`目录下找到`sidebar.swig`文件，打开找到这一行：\n\n![](http://images.yingwai.top/picgo/nextsidebarrizhif1.png)\n\n原因是`url_for`函数将`||`转码了，\n\n将`theme.menu.archives`后面的括号更换一下位置即可：\n\n![](http://images.yingwai.top/picgo/nextsidebarrizhif2.png)\n\n这时候点击日志就会自动跳转到归档页。","slug":"Hexo博客NexT主题点击侧边栏日志出现问题的解决办法","published":1,"updated":"2020-08-23T14:33:37.428Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cke79q4ox000488ps9sx231zg","content":"<p>部署好博客并安装了NexT主题后，发现一个问题：侧边栏头像下面的日志点击是404的页面。于是到网上搜索，发现是符号转码的问题。</p>\n<a id=\"more\"></a>\n<p><strong>解决方法：</strong></p>\n<p>到<code>\\themes\\next\\layout\\_macro</code>目录下找到<code>sidebar.swig</code>文件，打开找到这一行：</p>\n<p><img src=\"http://images.yingwai.top/picgo/nextsidebarrizhif1.png\" alt=\"\"></p>\n<p>原因是<code>url_for</code>函数将<code>||</code>转码了，</p>\n<p>将<code>theme.menu.archives</code>后面的括号更换一下位置即可：</p>\n<p><img src=\"http://images.yingwai.top/picgo/nextsidebarrizhif2.png\" alt=\"\"></p>\n<p>这时候点击日志就会自动跳转到归档页。</p>\n","site":{"data":{}},"excerpt":"<p>部署好博客并安装了NexT主题后，发现一个问题：侧边栏头像下面的日志点击是404的页面。于是到网上搜索，发现是符号转码的问题。</p>","more":"<p><strong>解决方法：</strong></p>\n<p>到<code>\\themes\\next\\layout\\_macro</code>目录下找到<code>sidebar.swig</code>文件，打开找到这一行：</p>\n<p><img src=\"http://images.yingwai.top/picgo/nextsidebarrizhif1.png\" alt=\"\"></p>\n<p>原因是<code>url_for</code>函数将<code>||</code>转码了，</p>\n<p>将<code>theme.menu.archives</code>后面的括号更换一下位置即可：</p>\n<p><img src=\"http://images.yingwai.top/picgo/nextsidebarrizhif2.png\" alt=\"\"></p>\n<p>这时候点击日志就会自动跳转到归档页。</p>"},{"title":"Hexo博客NexT主题使用不蒜子统计访客数","date":"2020-05-11T10:06:33.000Z","_content":"\n\n\n想为自己的博客添加访问统计，经过一番查阅，找到了好用又方便的不蒜子统计，不蒜子是一个极简的网页计数器。\n\n<!--more-->\n\n\n\n# 安装NexT\n\n参考 http://theme-next.iissnan.com/getting-started.html\n\n\n\n# 打开不蒜子统计开关\n\n新版的next主题已经把不蒜子集成进去，只需要打开开关即可：\n\n1. 编辑`\\themes\\next\\_config.yml`，找到里面的`busuanzi_count`配置项，将`enable`设为`true`：\n\n   ![](http://images.yingwai.top/picgo/busuanzif1.png)\n\n   当`enable: true`时，代表开启全局开关。若`site_uv`、`site_pv`、`page_pv`的值均为`false`时，不蒜子仅作记录而不会在页面上显示。\n\n2. 打开对应的站点配置：当`site_uv: true`时，代表在页面底部显示站点的UV值；当`site_pv: true`时，代表在页面底部显示站点的PV值。\n\n\n\n# 不蒜子统计不显示的问题\n\n完成上面的步骤后，进入博客，发现统计人数显示不出来：\n\n![](http://images.yingwai.top/picgo/busuanzif2.png)\n\n**原因：不蒜子的域名更换了，但是next主题里面写进去的域名还是以前的。**\n\n[不蒜子官网](http://busuanzi.ibruce.info/)：\n\n![](http://images.yingwai.top/picgo/busuanzif3.png)\n\n\n\n**解决方法：**\n\n打开`\\themes\\next\\layout\\_third-party\\analytics`文件夹里面的`busuanzi-counter.swig`文件，将旧的域名更换为新的域名：\n\n原来的域名：\n\n![](http://images.yingwai.top/picgo/busuanzif4.png)\n\n更换后：\n\n![](http://images.yingwai.top/picgo/busuanzif5.png)\n\n此时博客的访客数就可以正常显示了。","source":"_posts/Hexo博客NexT主题使用不蒜子统计访客数.md","raw":"---\ntitle: Hexo博客NexT主题使用不蒜子统计访客数\ndate: 2020-05-11 18:06:33\ncategories: Env\ntags: [Hexo, NexT, 不蒜子]\n---\n\n\n\n想为自己的博客添加访问统计，经过一番查阅，找到了好用又方便的不蒜子统计，不蒜子是一个极简的网页计数器。\n\n<!--more-->\n\n\n\n# 安装NexT\n\n参考 http://theme-next.iissnan.com/getting-started.html\n\n\n\n# 打开不蒜子统计开关\n\n新版的next主题已经把不蒜子集成进去，只需要打开开关即可：\n\n1. 编辑`\\themes\\next\\_config.yml`，找到里面的`busuanzi_count`配置项，将`enable`设为`true`：\n\n   ![](http://images.yingwai.top/picgo/busuanzif1.png)\n\n   当`enable: true`时，代表开启全局开关。若`site_uv`、`site_pv`、`page_pv`的值均为`false`时，不蒜子仅作记录而不会在页面上显示。\n\n2. 打开对应的站点配置：当`site_uv: true`时，代表在页面底部显示站点的UV值；当`site_pv: true`时，代表在页面底部显示站点的PV值。\n\n\n\n# 不蒜子统计不显示的问题\n\n完成上面的步骤后，进入博客，发现统计人数显示不出来：\n\n![](http://images.yingwai.top/picgo/busuanzif2.png)\n\n**原因：不蒜子的域名更换了，但是next主题里面写进去的域名还是以前的。**\n\n[不蒜子官网](http://busuanzi.ibruce.info/)：\n\n![](http://images.yingwai.top/picgo/busuanzif3.png)\n\n\n\n**解决方法：**\n\n打开`\\themes\\next\\layout\\_third-party\\analytics`文件夹里面的`busuanzi-counter.swig`文件，将旧的域名更换为新的域名：\n\n原来的域名：\n\n![](http://images.yingwai.top/picgo/busuanzif4.png)\n\n更换后：\n\n![](http://images.yingwai.top/picgo/busuanzif5.png)\n\n此时博客的访客数就可以正常显示了。","slug":"Hexo博客NexT主题使用不蒜子统计访客数","published":1,"updated":"2020-08-23T14:33:37.428Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cke79q4oy000588ps42t38zvn","content":"<p>想为自己的博客添加访问统计，经过一番查阅，找到了好用又方便的不蒜子统计，不蒜子是一个极简的网页计数器。</p>\n<a id=\"more\"></a>\n<h1 id=\"安装NexT\"><a href=\"#安装NexT\" class=\"headerlink\" title=\"安装NexT\"></a>安装NexT</h1><p>参考 <a href=\"http://theme-next.iissnan.com/getting-started.html\" target=\"_blank\" rel=\"noopener\">http://theme-next.iissnan.com/getting-started.html</a></p>\n<h1 id=\"打开不蒜子统计开关\"><a href=\"#打开不蒜子统计开关\" class=\"headerlink\" title=\"打开不蒜子统计开关\"></a>打开不蒜子统计开关</h1><p>新版的next主题已经把不蒜子集成进去，只需要打开开关即可：</p>\n<ol>\n<li><p>编辑<code>\\themes\\next\\_config.yml</code>，找到里面的<code>busuanzi_count</code>配置项，将<code>enable</code>设为<code>true</code>：</p>\n<p><img src=\"http://images.yingwai.top/picgo/busuanzif1.png\" alt=\"\"></p>\n<p>当<code>enable: true</code>时，代表开启全局开关。若<code>site_uv</code>、<code>site_pv</code>、<code>page_pv</code>的值均为<code>false</code>时，不蒜子仅作记录而不会在页面上显示。</p>\n</li>\n<li><p>打开对应的站点配置：当<code>site_uv: true</code>时，代表在页面底部显示站点的UV值；当<code>site_pv: true</code>时，代表在页面底部显示站点的PV值。</p>\n</li>\n</ol>\n<h1 id=\"不蒜子统计不显示的问题\"><a href=\"#不蒜子统计不显示的问题\" class=\"headerlink\" title=\"不蒜子统计不显示的问题\"></a>不蒜子统计不显示的问题</h1><p>完成上面的步骤后，进入博客，发现统计人数显示不出来：</p>\n<p><img src=\"http://images.yingwai.top/picgo/busuanzif2.png\" alt=\"\"></p>\n<p><strong>原因：不蒜子的域名更换了，但是next主题里面写进去的域名还是以前的。</strong></p>\n<p><a href=\"http://busuanzi.ibruce.info/\" target=\"_blank\" rel=\"noopener\">不蒜子官网</a>：</p>\n<p><img src=\"http://images.yingwai.top/picgo/busuanzif3.png\" alt=\"\"></p>\n<p><strong>解决方法：</strong></p>\n<p>打开<code>\\themes\\next\\layout\\_third-party\\analytics</code>文件夹里面的<code>busuanzi-counter.swig</code>文件，将旧的域名更换为新的域名：</p>\n<p>原来的域名：</p>\n<p><img src=\"http://images.yingwai.top/picgo/busuanzif4.png\" alt=\"\"></p>\n<p>更换后：</p>\n<p><img src=\"http://images.yingwai.top/picgo/busuanzif5.png\" alt=\"\"></p>\n<p>此时博客的访客数就可以正常显示了。</p>\n","site":{"data":{}},"excerpt":"<p>想为自己的博客添加访问统计，经过一番查阅，找到了好用又方便的不蒜子统计，不蒜子是一个极简的网页计数器。</p>","more":"<h1 id=\"安装NexT\"><a href=\"#安装NexT\" class=\"headerlink\" title=\"安装NexT\"></a>安装NexT</h1><p>参考 <a href=\"http://theme-next.iissnan.com/getting-started.html\" target=\"_blank\" rel=\"noopener\">http://theme-next.iissnan.com/getting-started.html</a></p>\n<h1 id=\"打开不蒜子统计开关\"><a href=\"#打开不蒜子统计开关\" class=\"headerlink\" title=\"打开不蒜子统计开关\"></a>打开不蒜子统计开关</h1><p>新版的next主题已经把不蒜子集成进去，只需要打开开关即可：</p>\n<ol>\n<li><p>编辑<code>\\themes\\next\\_config.yml</code>，找到里面的<code>busuanzi_count</code>配置项，将<code>enable</code>设为<code>true</code>：</p>\n<p><img src=\"http://images.yingwai.top/picgo/busuanzif1.png\" alt=\"\"></p>\n<p>当<code>enable: true</code>时，代表开启全局开关。若<code>site_uv</code>、<code>site_pv</code>、<code>page_pv</code>的值均为<code>false</code>时，不蒜子仅作记录而不会在页面上显示。</p>\n</li>\n<li><p>打开对应的站点配置：当<code>site_uv: true</code>时，代表在页面底部显示站点的UV值；当<code>site_pv: true</code>时，代表在页面底部显示站点的PV值。</p>\n</li>\n</ol>\n<h1 id=\"不蒜子统计不显示的问题\"><a href=\"#不蒜子统计不显示的问题\" class=\"headerlink\" title=\"不蒜子统计不显示的问题\"></a>不蒜子统计不显示的问题</h1><p>完成上面的步骤后，进入博客，发现统计人数显示不出来：</p>\n<p><img src=\"http://images.yingwai.top/picgo/busuanzif2.png\" alt=\"\"></p>\n<p><strong>原因：不蒜子的域名更换了，但是next主题里面写进去的域名还是以前的。</strong></p>\n<p><a href=\"http://busuanzi.ibruce.info/\" target=\"_blank\" rel=\"noopener\">不蒜子官网</a>：</p>\n<p><img src=\"http://images.yingwai.top/picgo/busuanzif3.png\" alt=\"\"></p>\n<p><strong>解决方法：</strong></p>\n<p>打开<code>\\themes\\next\\layout\\_third-party\\analytics</code>文件夹里面的<code>busuanzi-counter.swig</code>文件，将旧的域名更换为新的域名：</p>\n<p>原来的域名：</p>\n<p><img src=\"http://images.yingwai.top/picgo/busuanzif4.png\" alt=\"\"></p>\n<p>更换后：</p>\n<p><img src=\"http://images.yingwai.top/picgo/busuanzif5.png\" alt=\"\"></p>\n<p>此时博客的访客数就可以正常显示了。</p>"},{"title":"Hexo博客NexT主题翻页按钮显示不正常的解决方法","date":"2020-05-11T10:23:29.000Z","_content":"\n搭好博客后，上去发现底下的翻页按钮显示有问题，显示为`<i class=\"fa fa-angle-right\"></i>`，原因不明：\n\n<!--more-->\n\n![](http://images.yingwai.top/picgo/fanyef1.png)\n\n\n\n**解决办法：**\n\n最简单的办法就是将`<i class=\"fa fa-angle-right\"></i>`这个不能正常显示的字体图标改成一般的字符，我就是按照网上的方法改成正常的一般左右键字符 “ > ”。\n\n到`\\themes\\next\\layout\\_partials`目录下找到`pagination.swig`文件，将\n\n```html\n{% if page.prev or page.next %}\n  <nav class=\"pagination\">\n    {{\n      paginator({\n        prev_text: '<i class=\"fa fa-angle-left\"></i>',\n        next_text: '<i class=\"fa fa-angle-right\"></i>',\n        mid_size: 1\n      })\n    }}\n  </nav>\n{% endif %}\n```\n\n改成\n\n```html\n{% if page.prev or page.next %}\n  <nav class=\"pagination\">\n    {{\n      paginator({\n        prev_text: '<',\n        next_text: '>',\n        mid_size: 1\n      })\n    }}\n  </nav>\n{% endif %}\n```\n\n重新部署即可看到已经正常显示了：\n\n![](http://images.yingwai.top/picgo/fanyef2.png)\n\n","source":"_posts/Hexo博客NexT主题翻页按钮显示不正常的解决方法.md","raw":"---\ntitle: Hexo博客NexT主题翻页按钮显示不正常的解决方法\ndate: 2020-05-11 18:23:29\ncategories: Env\ntags: [Hexo, NexT]\n---\n\n搭好博客后，上去发现底下的翻页按钮显示有问题，显示为`<i class=\"fa fa-angle-right\"></i>`，原因不明：\n\n<!--more-->\n\n![](http://images.yingwai.top/picgo/fanyef1.png)\n\n\n\n**解决办法：**\n\n最简单的办法就是将`<i class=\"fa fa-angle-right\"></i>`这个不能正常显示的字体图标改成一般的字符，我就是按照网上的方法改成正常的一般左右键字符 “ > ”。\n\n到`\\themes\\next\\layout\\_partials`目录下找到`pagination.swig`文件，将\n\n```html\n{% if page.prev or page.next %}\n  <nav class=\"pagination\">\n    {{\n      paginator({\n        prev_text: '<i class=\"fa fa-angle-left\"></i>',\n        next_text: '<i class=\"fa fa-angle-right\"></i>',\n        mid_size: 1\n      })\n    }}\n  </nav>\n{% endif %}\n```\n\n改成\n\n```html\n{% if page.prev or page.next %}\n  <nav class=\"pagination\">\n    {{\n      paginator({\n        prev_text: '<',\n        next_text: '>',\n        mid_size: 1\n      })\n    }}\n  </nav>\n{% endif %}\n```\n\n重新部署即可看到已经正常显示了：\n\n![](http://images.yingwai.top/picgo/fanyef2.png)\n\n","slug":"Hexo博客NexT主题翻页按钮显示不正常的解决方法","published":1,"updated":"2020-08-23T14:33:37.428Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cke79q4oz000688ps1e2n8hcf","content":"<p>搭好博客后，上去发现底下的翻页按钮显示有问题，显示为<code>&lt;i class=&quot;fa fa-angle-right&quot;&gt;&lt;/i&gt;</code>，原因不明：</p>\n<a id=\"more\"></a>\n<p><img src=\"http://images.yingwai.top/picgo/fanyef1.png\" alt=\"\"></p>\n<p><strong>解决办法：</strong></p>\n<p>最简单的办法就是将<code>&lt;i class=&quot;fa fa-angle-right&quot;&gt;&lt;/i&gt;</code>这个不能正常显示的字体图标改成一般的字符，我就是按照网上的方法改成正常的一般左右键字符 “ &gt; ”。</p>\n<p>到<code>\\themes\\next\\layout\\_partials</code>目录下找到<code>pagination.swig</code>文件，将</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;% if page.prev or page.next %&#125;</span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">nav</span> <span class=\"attr\">class</span>=<span class=\"string\">\"pagination\"</span>&gt;</span></span><br><span class=\"line\">    &#123;&#123;</span><br><span class=\"line\">      paginator(&#123;</span><br><span class=\"line\">        prev_text: '<span class=\"tag\">&lt;<span class=\"name\">i</span> <span class=\"attr\">class</span>=<span class=\"string\">\"fa fa-angle-left\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">i</span>&gt;</span>',</span><br><span class=\"line\">        next_text: '<span class=\"tag\">&lt;<span class=\"name\">i</span> <span class=\"attr\">class</span>=<span class=\"string\">\"fa fa-angle-right\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">i</span>&gt;</span>',</span><br><span class=\"line\">        mid_size: 1</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;&#125;</span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">nav</span>&gt;</span></span><br><span class=\"line\">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>\n<p>改成</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;% if page.prev or page.next %&#125;</span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">nav</span> <span class=\"attr\">class</span>=<span class=\"string\">\"pagination\"</span>&gt;</span></span><br><span class=\"line\">    &#123;&#123;</span><br><span class=\"line\">      paginator(&#123;</span><br><span class=\"line\">        prev_text: '<span class=\"tag\">&lt;<span class=\"name\">',</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">next_text:</span> '&gt;</span>',</span><br><span class=\"line\">        mid_size: 1</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;&#125;</span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">nav</span>&gt;</span></span><br><span class=\"line\">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>\n<p>重新部署即可看到已经正常显示了：</p>\n<p><img src=\"http://images.yingwai.top/picgo/fanyef2.png\" alt=\"\"></p>\n","site":{"data":{}},"excerpt":"<p>搭好博客后，上去发现底下的翻页按钮显示有问题，显示为<code>&lt;i class=&quot;fa fa-angle-right&quot;&gt;&lt;/i&gt;</code>，原因不明：</p>","more":"<p><img src=\"http://images.yingwai.top/picgo/fanyef1.png\" alt=\"\"></p>\n<p><strong>解决办法：</strong></p>\n<p>最简单的办法就是将<code>&lt;i class=&quot;fa fa-angle-right&quot;&gt;&lt;/i&gt;</code>这个不能正常显示的字体图标改成一般的字符，我就是按照网上的方法改成正常的一般左右键字符 “ &gt; ”。</p>\n<p>到<code>\\themes\\next\\layout\\_partials</code>目录下找到<code>pagination.swig</code>文件，将</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;% if page.prev or page.next %&#125;</span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">nav</span> <span class=\"attr\">class</span>=<span class=\"string\">\"pagination\"</span>&gt;</span></span><br><span class=\"line\">    &#123;&#123;</span><br><span class=\"line\">      paginator(&#123;</span><br><span class=\"line\">        prev_text: '<span class=\"tag\">&lt;<span class=\"name\">i</span> <span class=\"attr\">class</span>=<span class=\"string\">\"fa fa-angle-left\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">i</span>&gt;</span>',</span><br><span class=\"line\">        next_text: '<span class=\"tag\">&lt;<span class=\"name\">i</span> <span class=\"attr\">class</span>=<span class=\"string\">\"fa fa-angle-right\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">i</span>&gt;</span>',</span><br><span class=\"line\">        mid_size: 1</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;&#125;</span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">nav</span>&gt;</span></span><br><span class=\"line\">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>\n<p>改成</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;% if page.prev or page.next %&#125;</span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">nav</span> <span class=\"attr\">class</span>=<span class=\"string\">\"pagination\"</span>&gt;</span></span><br><span class=\"line\">    &#123;&#123;</span><br><span class=\"line\">      paginator(&#123;</span><br><span class=\"line\">        prev_text: '<span class=\"tag\">&lt;<span class=\"name\">',</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">next_text:</span> '&gt;</span>',</span><br><span class=\"line\">        mid_size: 1</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;&#125;</span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">nav</span>&gt;</span></span><br><span class=\"line\">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>\n<p>重新部署即可看到已经正常显示了：</p>\n<p><img src=\"http://images.yingwai.top/picgo/fanyef2.png\" alt=\"\"></p>"},{"title":"Hexo博客搭建","date":"2020-04-11T10:05:12.000Z","_content":"\n----\n\n\n\n<!-- more -->\n\n## Hexo简介\n\n​\tHexo 是一个快速、简洁且高效的博客框架。Hexo 使用 [Markdown](http://daringfireball.net/projects/markdown/)（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。\n\n\n\n## 搭建流程（Windows）\n\n### 准备工作\n\n#### 安装Git\n\n到 https://git-scm.com/download 选择对应的平台进行下载安装即可。\n\n\n\n#### 安装Node.js\n\n到 https://nodejs.org/en/ 下载安装即可。（Node.js 版本需不低于 8.10，建议使用 Node.js 10.0 及以上版本）\n\n\n\n### 安装Hexo\n\n安装需要借助npm包管理器，由于在国内这个镜像源很慢，因此可以利用npm安装cnpm淘宝镜像源，在命令行中输入：\n\n```shell\n$ npm install -g cnpm --registry=https://registry.npm.taobao.org\n```\n\n安装完后就可以使用cnpm安装hexo：\n\n```shell\n$ cnpm install -g hexo-cli\n```\n\n可以用`hexo -v`来验证是否安装成功。\n\n\n\n### 正式搭建\n\n#### 初始化\n\n建立一个名为 *Blog* 的文件夹，在命令行中进入这个文件夹，在命令行中输入：\n\n```shell\n$ hexo init\n```\n\n初始化完成后，在命令行中输入`hexo s`，此时在浏览器中输入`localhost:4000`就可以看到博客已经创建好了，并且默认创建了一篇文章。\n\n确认过后，键盘按 *Ctrl + C* 即可停止服务。\n\n\n\n#### 部署到Github\n\n首先登陆到[Github](https://github.com/)，新建一个仓库，命名为 \"**你的Github昵称.github.io**\"。\n\n然后需要安装一个git部署插件，在命令行中打开 *Blog* 目录，输入：\n\n```shell\n$ cnpm install --save hexo-deployer-git\n```\n\n打开 *Blog* 目录下的站点配置文件，在文件最后的 ***repo*** 处输入刚刚创建的仓库的地址并在下方添加一行：\n\n```\n# Deployment\n## Docs: https://hexo.io/docs/deployment.html\ndeploy:\n  type: git\n  repo: https://github.com/xxx/xxx.github.io.git\n  branch: master\t# 指定分支，不填默认为master\n```\n\n保存退出后，在命令行中输入：\n\n```shell\n$ hexo d\n```\n\n部署到远端，此时刷新一下自己的Github仓库页面，会发现多了很多文件。在浏览器中访问 **xxx.github.io**，就可以看到博客已经成功部署。\n\n\n\n## 使用Hexo\n\n### 新建文章\n\n在命令行中输入：\n\n```shell\n$ hexo n \"文章标题\"\n```\n\n会在博客目录的`/source/_posts`目录下生成一个markdown文件，使用编辑器打开即可编辑这篇文章。\n\n\n\n### 发布文章\n\n在命令行中依次输入：\n\n```shell\n$ hexo clean\t# 清理缓存文件和已生成的静态文件\n$ hexo g\t# 生成静态文件\n```\n\n再使用`hexo s`命令就可以在`localhost:4000`页面看到新生成的文章已经发布到了博客上面。","source":"_posts/Hexo博客搭建.md","raw":"---\ntitle: Hexo博客搭建\ndate: 2020-04-11 18:05:12\ncategories: Env\ntags: Hexo\n---\n\n----\n\n\n\n<!-- more -->\n\n## Hexo简介\n\n​\tHexo 是一个快速、简洁且高效的博客框架。Hexo 使用 [Markdown](http://daringfireball.net/projects/markdown/)（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。\n\n\n\n## 搭建流程（Windows）\n\n### 准备工作\n\n#### 安装Git\n\n到 https://git-scm.com/download 选择对应的平台进行下载安装即可。\n\n\n\n#### 安装Node.js\n\n到 https://nodejs.org/en/ 下载安装即可。（Node.js 版本需不低于 8.10，建议使用 Node.js 10.0 及以上版本）\n\n\n\n### 安装Hexo\n\n安装需要借助npm包管理器，由于在国内这个镜像源很慢，因此可以利用npm安装cnpm淘宝镜像源，在命令行中输入：\n\n```shell\n$ npm install -g cnpm --registry=https://registry.npm.taobao.org\n```\n\n安装完后就可以使用cnpm安装hexo：\n\n```shell\n$ cnpm install -g hexo-cli\n```\n\n可以用`hexo -v`来验证是否安装成功。\n\n\n\n### 正式搭建\n\n#### 初始化\n\n建立一个名为 *Blog* 的文件夹，在命令行中进入这个文件夹，在命令行中输入：\n\n```shell\n$ hexo init\n```\n\n初始化完成后，在命令行中输入`hexo s`，此时在浏览器中输入`localhost:4000`就可以看到博客已经创建好了，并且默认创建了一篇文章。\n\n确认过后，键盘按 *Ctrl + C* 即可停止服务。\n\n\n\n#### 部署到Github\n\n首先登陆到[Github](https://github.com/)，新建一个仓库，命名为 \"**你的Github昵称.github.io**\"。\n\n然后需要安装一个git部署插件，在命令行中打开 *Blog* 目录，输入：\n\n```shell\n$ cnpm install --save hexo-deployer-git\n```\n\n打开 *Blog* 目录下的站点配置文件，在文件最后的 ***repo*** 处输入刚刚创建的仓库的地址并在下方添加一行：\n\n```\n# Deployment\n## Docs: https://hexo.io/docs/deployment.html\ndeploy:\n  type: git\n  repo: https://github.com/xxx/xxx.github.io.git\n  branch: master\t# 指定分支，不填默认为master\n```\n\n保存退出后，在命令行中输入：\n\n```shell\n$ hexo d\n```\n\n部署到远端，此时刷新一下自己的Github仓库页面，会发现多了很多文件。在浏览器中访问 **xxx.github.io**，就可以看到博客已经成功部署。\n\n\n\n## 使用Hexo\n\n### 新建文章\n\n在命令行中输入：\n\n```shell\n$ hexo n \"文章标题\"\n```\n\n会在博客目录的`/source/_posts`目录下生成一个markdown文件，使用编辑器打开即可编辑这篇文章。\n\n\n\n### 发布文章\n\n在命令行中依次输入：\n\n```shell\n$ hexo clean\t# 清理缓存文件和已生成的静态文件\n$ hexo g\t# 生成静态文件\n```\n\n再使用`hexo s`命令就可以在`localhost:4000`页面看到新生成的文章已经发布到了博客上面。","slug":"Hexo博客搭建","published":1,"updated":"2020-08-23T14:33:37.429Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cke79q4p0000a88psadba07mm","content":"<hr>\n<a id=\"more\"></a>\n<h2 id=\"Hexo简介\"><a href=\"#Hexo简介\" class=\"headerlink\" title=\"Hexo简介\"></a>Hexo简介</h2><p>​    Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 <a href=\"http://daringfireball.net/projects/markdown/\" target=\"_blank\" rel=\"noopener\">Markdown</a>（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p>\n<h2 id=\"搭建流程（Windows）\"><a href=\"#搭建流程（Windows）\" class=\"headerlink\" title=\"搭建流程（Windows）\"></a>搭建流程（Windows）</h2><h3 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h3><h4 id=\"安装Git\"><a href=\"#安装Git\" class=\"headerlink\" title=\"安装Git\"></a>安装Git</h4><p>到 <a href=\"https://git-scm.com/download\" target=\"_blank\" rel=\"noopener\">https://git-scm.com/download</a> 选择对应的平台进行下载安装即可。</p>\n<h4 id=\"安装Node-js\"><a href=\"#安装Node-js\" class=\"headerlink\" title=\"安装Node.js\"></a>安装Node.js</h4><p>到 <a href=\"https://nodejs.org/en/\" target=\"_blank\" rel=\"noopener\">https://nodejs.org/en/</a> 下载安装即可。（Node.js 版本需不低于 8.10，建议使用 Node.js 10.0 及以上版本）</p>\n<h3 id=\"安装Hexo\"><a href=\"#安装Hexo\" class=\"headerlink\" title=\"安装Hexo\"></a>安装Hexo</h3><p>安装需要借助npm包管理器，由于在国内这个镜像源很慢，因此可以利用npm安装cnpm淘宝镜像源，在命令行中输入：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> npm install -g cnpm --registry=https://registry.npm.taobao.org</span></span><br></pre></td></tr></table></figure>\n<p>安装完后就可以使用cnpm安装hexo：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> cnpm install -g hexo-cli</span></span><br></pre></td></tr></table></figure>\n<p>可以用<code>hexo -v</code>来验证是否安装成功。</p>\n<h3 id=\"正式搭建\"><a href=\"#正式搭建\" class=\"headerlink\" title=\"正式搭建\"></a>正式搭建</h3><h4 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h4><p>建立一个名为 <em>Blog</em> 的文件夹，在命令行中进入这个文件夹，在命令行中输入：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> hexo init</span></span><br></pre></td></tr></table></figure>\n<p>初始化完成后，在命令行中输入<code>hexo s</code>，此时在浏览器中输入<code>localhost:4000</code>就可以看到博客已经创建好了，并且默认创建了一篇文章。</p>\n<p>确认过后，键盘按 <em>Ctrl + C</em> 即可停止服务。</p>\n<h4 id=\"部署到Github\"><a href=\"#部署到Github\" class=\"headerlink\" title=\"部署到Github\"></a>部署到Github</h4><p>首先登陆到<a href=\"https://github.com/\" target=\"_blank\" rel=\"noopener\">Github</a>，新建一个仓库，命名为 “<strong>你的Github昵称.github.io</strong>“。</p>\n<p>然后需要安装一个git部署插件，在命令行中打开 <em>Blog</em> 目录，输入：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> cnpm install --save hexo-deployer-git</span></span><br></pre></td></tr></table></figure>\n<p>打开 <em>Blog</em> 目录下的站点配置文件，在文件最后的 <strong><em>repo</em></strong> 处输入刚刚创建的仓库的地址并在下方添加一行：</p>\n<figure class=\"highlight dts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\"># Deployment</span></span><br><span class=\"line\"><span class=\"meta\">## Docs: https:<span class=\"comment\">//hexo.io/docs/deployment.html</span></span></span><br><span class=\"line\"><span class=\"symbol\">deploy:</span></span><br><span class=\"line\"><span class=\"symbol\">  type:</span> git</span><br><span class=\"line\"><span class=\"symbol\">  repo:</span> https:<span class=\"comment\">//github.com/xxx/xxx.github.io.git</span></span><br><span class=\"line\"><span class=\"symbol\">  branch:</span> master\t<span class=\"meta\"># 指定分支，不填默认为master</span></span><br></pre></td></tr></table></figure>\n<p>保存退出后，在命令行中输入：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> hexo d</span></span><br></pre></td></tr></table></figure>\n<p>部署到远端，此时刷新一下自己的Github仓库页面，会发现多了很多文件。在浏览器中访问 <strong>xxx.github.io</strong>，就可以看到博客已经成功部署。</p>\n<h2 id=\"使用Hexo\"><a href=\"#使用Hexo\" class=\"headerlink\" title=\"使用Hexo\"></a>使用Hexo</h2><h3 id=\"新建文章\"><a href=\"#新建文章\" class=\"headerlink\" title=\"新建文章\"></a>新建文章</h3><p>在命令行中输入：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> hexo n <span class=\"string\">\"文章标题\"</span></span></span><br></pre></td></tr></table></figure>\n<p>会在博客目录的<code>/source/_posts</code>目录下生成一个markdown文件，使用编辑器打开即可编辑这篇文章。</p>\n<h3 id=\"发布文章\"><a href=\"#发布文章\" class=\"headerlink\" title=\"发布文章\"></a>发布文章</h3><p>在命令行中依次输入：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> hexo clean\t<span class=\"comment\"># 清理缓存文件和已生成的静态文件</span></span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> hexo g\t<span class=\"comment\"># 生成静态文件</span></span></span><br></pre></td></tr></table></figure>\n<p>再使用<code>hexo s</code>命令就可以在<code>localhost:4000</code>页面看到新生成的文章已经发布到了博客上面。</p>\n","site":{"data":{}},"excerpt":"<hr>","more":"<h2 id=\"Hexo简介\"><a href=\"#Hexo简介\" class=\"headerlink\" title=\"Hexo简介\"></a>Hexo简介</h2><p>​    Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 <a href=\"http://daringfireball.net/projects/markdown/\" target=\"_blank\" rel=\"noopener\">Markdown</a>（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p>\n<h2 id=\"搭建流程（Windows）\"><a href=\"#搭建流程（Windows）\" class=\"headerlink\" title=\"搭建流程（Windows）\"></a>搭建流程（Windows）</h2><h3 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h3><h4 id=\"安装Git\"><a href=\"#安装Git\" class=\"headerlink\" title=\"安装Git\"></a>安装Git</h4><p>到 <a href=\"https://git-scm.com/download\" target=\"_blank\" rel=\"noopener\">https://git-scm.com/download</a> 选择对应的平台进行下载安装即可。</p>\n<h4 id=\"安装Node-js\"><a href=\"#安装Node-js\" class=\"headerlink\" title=\"安装Node.js\"></a>安装Node.js</h4><p>到 <a href=\"https://nodejs.org/en/\" target=\"_blank\" rel=\"noopener\">https://nodejs.org/en/</a> 下载安装即可。（Node.js 版本需不低于 8.10，建议使用 Node.js 10.0 及以上版本）</p>\n<h3 id=\"安装Hexo\"><a href=\"#安装Hexo\" class=\"headerlink\" title=\"安装Hexo\"></a>安装Hexo</h3><p>安装需要借助npm包管理器，由于在国内这个镜像源很慢，因此可以利用npm安装cnpm淘宝镜像源，在命令行中输入：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> npm install -g cnpm --registry=https://registry.npm.taobao.org</span></span><br></pre></td></tr></table></figure>\n<p>安装完后就可以使用cnpm安装hexo：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> cnpm install -g hexo-cli</span></span><br></pre></td></tr></table></figure>\n<p>可以用<code>hexo -v</code>来验证是否安装成功。</p>\n<h3 id=\"正式搭建\"><a href=\"#正式搭建\" class=\"headerlink\" title=\"正式搭建\"></a>正式搭建</h3><h4 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h4><p>建立一个名为 <em>Blog</em> 的文件夹，在命令行中进入这个文件夹，在命令行中输入：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> hexo init</span></span><br></pre></td></tr></table></figure>\n<p>初始化完成后，在命令行中输入<code>hexo s</code>，此时在浏览器中输入<code>localhost:4000</code>就可以看到博客已经创建好了，并且默认创建了一篇文章。</p>\n<p>确认过后，键盘按 <em>Ctrl + C</em> 即可停止服务。</p>\n<h4 id=\"部署到Github\"><a href=\"#部署到Github\" class=\"headerlink\" title=\"部署到Github\"></a>部署到Github</h4><p>首先登陆到<a href=\"https://github.com/\" target=\"_blank\" rel=\"noopener\">Github</a>，新建一个仓库，命名为 “<strong>你的Github昵称.github.io</strong>“。</p>\n<p>然后需要安装一个git部署插件，在命令行中打开 <em>Blog</em> 目录，输入：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> cnpm install --save hexo-deployer-git</span></span><br></pre></td></tr></table></figure>\n<p>打开 <em>Blog</em> 目录下的站点配置文件，在文件最后的 <strong><em>repo</em></strong> 处输入刚刚创建的仓库的地址并在下方添加一行：</p>\n<figure class=\"highlight dts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\"># Deployment</span></span><br><span class=\"line\"><span class=\"meta\">## Docs: https:<span class=\"comment\">//hexo.io/docs/deployment.html</span></span></span><br><span class=\"line\"><span class=\"symbol\">deploy:</span></span><br><span class=\"line\"><span class=\"symbol\">  type:</span> git</span><br><span class=\"line\"><span class=\"symbol\">  repo:</span> https:<span class=\"comment\">//github.com/xxx/xxx.github.io.git</span></span><br><span class=\"line\"><span class=\"symbol\">  branch:</span> master\t<span class=\"meta\"># 指定分支，不填默认为master</span></span><br></pre></td></tr></table></figure>\n<p>保存退出后，在命令行中输入：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> hexo d</span></span><br></pre></td></tr></table></figure>\n<p>部署到远端，此时刷新一下自己的Github仓库页面，会发现多了很多文件。在浏览器中访问 <strong>xxx.github.io</strong>，就可以看到博客已经成功部署。</p>\n<h2 id=\"使用Hexo\"><a href=\"#使用Hexo\" class=\"headerlink\" title=\"使用Hexo\"></a>使用Hexo</h2><h3 id=\"新建文章\"><a href=\"#新建文章\" class=\"headerlink\" title=\"新建文章\"></a>新建文章</h3><p>在命令行中输入：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> hexo n <span class=\"string\">\"文章标题\"</span></span></span><br></pre></td></tr></table></figure>\n<p>会在博客目录的<code>/source/_posts</code>目录下生成一个markdown文件，使用编辑器打开即可编辑这篇文章。</p>\n<h3 id=\"发布文章\"><a href=\"#发布文章\" class=\"headerlink\" title=\"发布文章\"></a>发布文章</h3><p>在命令行中依次输入：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> hexo clean\t<span class=\"comment\"># 清理缓存文件和已生成的静态文件</span></span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> hexo g\t<span class=\"comment\"># 生成静态文件</span></span></span><br></pre></td></tr></table></figure>\n<p>再使用<code>hexo s</code>命令就可以在<code>localhost:4000</code>页面看到新生成的文章已经发布到了博客上面。</p>"},{"title":"JupyterLab安装","date":"2020-05-01T07:50:47.000Z","_content":"\n\n\nJupyterLab 是一个交互式的开发环境，是 Jupyter notebook 的下一代产品，集成了更多的功能，十分好用。\n\n<!--more-->\n\n\n\n# 安装Miniconda\n\n1、进入清华大学开源软件镜像站找到Miniconda: https://mirrors.tuna.tsinghua.edu.cn/anaconda/miniconda/\n\n![](http://images.yingwai.top/picgo/jupyterinstallf1.png)\n\n2、找到Miniconda的Linux版本，右键复制链接地址，然后在服务器中下载：\n\n```shell\n$ wget -c https://mirrors.tuna.tsinghua.edu.cn/anaconda/miniconda/Miniconda3-py37_4.8.2-Linux-x86_64.sh\n```\n\n3、安装刚刚下载的Miniconda：\n\n```shell\n$ bash Miniconda3-py37_4.8.2-Linux-x86_64.sh\n```\n\n根据提示按enter键或输入yes即可。\n\n4、安装成功后，会在当前用户目录下生成一个miniconda3文件夹。\n\n\n\n## 安装pip\n\n在终端中输入以下命令安装pip：\n\n```shell\n$ conda install pip\n```\n\n\n\n### 添加清华源\n\n如果下载速度太慢，可以将conda默认的软件源更换为国内的清华源：\n\n```shell\n$ conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/\n$ conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/\n$ conda config --set show_channel_urls yes\n\n```\n\n添加完成后可以使用`conda info`命令查看是否添加成功。\n\n\n\n# 安装并配置JupyterLab\n\n准备工作完成后，就可以开始安装Jupyterlab。\n\n## 安装JupyterLab\n\n在终端中输入：\n\n```shell\n$ pip install jupyterlab\n```\n\n\n\n## 远程访问配置\n\n在终端中打开ipython：\n\n```shell\n$ ipython\n\nIn [1]: from notebook.auth import passwd\n\nIn [2]: passwd()\nEnter password:\t\t# 输入你要设置的密码\nVerify password:\nOut[2]: 'xxxxx...'\n```\n\n这里输出的字符串要复制下来。\n\n执行完上面的命令后，退出ipython，然后在终端中输入：\n\n```shell\n$ jupyter lab --generate-config\n```\n\n修改配置文件：\n\n```shell\n$ vi .jupyter/jupyter_notebook_config.py\n```\n\n更改内容如下：\n\n```shell\n# 将ip设置为*，意味允许任何IP访问\nc.NotebookApp.ip = '*'\n# 这里的密码就是上面生成的那一串\nc.NotebookApp.password = 'xxxxx...' \n# 服务器上并没有浏览器可以供Jupyter打开 \nc.NotebookApp.open_browser = False \n# 监听端口设置为8888或其他自己喜欢的端口 \nc.NotebookApp.port = 8888\n# 允许远程访问 \nc.NotebookApp.allow_remote_access = True\n```\n\n启动jupyter服务：\n\n```shell\n$ jupyter lab --allow-root\n```\n\n此时在浏览器搜索框中输入`你的服务器ip:你设置的端口`，然后在打开的页面中输入密码就可以进入jupyterlab：\n\n![](http://images.yingwai.top/picgo/jupyterinstallf2.png)\n\n\n\n## 后台运行JupyterLab程序\n\nJupyterLab启动后占用了一个终端窗口，可以用`nohup`命令使JupyterLab在后台运行，并且关闭当前终端也不会停止运行：\n\n```shell\n$ nohup jupyter lab &\n```\n\n* `nohup`命令\n\n  用途：Run COMMAND, ignoring hangup signals.\n\n  输出文件：程序的输出默认重定向到当前文件夹下的`nohup.out`文件中。也可以通过`nohup COMMAND > FILE`命令的方式将输出文件重定位到指定的`FILE`文件中。如果要查看JupyterLab的日志文件，可以打开`nohup.out`文件进行查看。\n\n* `&`命令\n\n  作用：在后台运行程序\n\n\n\n## 查看、关闭后台运行进程\n\n`job -l`命令查看当前终端中后台运行的进程，如果关闭终端后不能显示，需要使用`ps`命令。\n\n`ps -aux | grep jupyter`查看运行的`jupyter`进程：\n\n![](http://images.yingwai.top/picgo/jupyterinstallf3.png)\n\n用户名后面的数字就是JupyterLab的pid，使用`kill -9 pid`命令关闭运行中的JupyterLab。","source":"_posts/JupyterLab安装.md","raw":"---\ntitle: JupyterLab安装\ndate: 2020-05-01 15:50:47\ncategories: Env\ntags: [Jupyter, Linux]\n---\n\n\n\nJupyterLab 是一个交互式的开发环境，是 Jupyter notebook 的下一代产品，集成了更多的功能，十分好用。\n\n<!--more-->\n\n\n\n# 安装Miniconda\n\n1、进入清华大学开源软件镜像站找到Miniconda: https://mirrors.tuna.tsinghua.edu.cn/anaconda/miniconda/\n\n![](http://images.yingwai.top/picgo/jupyterinstallf1.png)\n\n2、找到Miniconda的Linux版本，右键复制链接地址，然后在服务器中下载：\n\n```shell\n$ wget -c https://mirrors.tuna.tsinghua.edu.cn/anaconda/miniconda/Miniconda3-py37_4.8.2-Linux-x86_64.sh\n```\n\n3、安装刚刚下载的Miniconda：\n\n```shell\n$ bash Miniconda3-py37_4.8.2-Linux-x86_64.sh\n```\n\n根据提示按enter键或输入yes即可。\n\n4、安装成功后，会在当前用户目录下生成一个miniconda3文件夹。\n\n\n\n## 安装pip\n\n在终端中输入以下命令安装pip：\n\n```shell\n$ conda install pip\n```\n\n\n\n### 添加清华源\n\n如果下载速度太慢，可以将conda默认的软件源更换为国内的清华源：\n\n```shell\n$ conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/\n$ conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/\n$ conda config --set show_channel_urls yes\n\n```\n\n添加完成后可以使用`conda info`命令查看是否添加成功。\n\n\n\n# 安装并配置JupyterLab\n\n准备工作完成后，就可以开始安装Jupyterlab。\n\n## 安装JupyterLab\n\n在终端中输入：\n\n```shell\n$ pip install jupyterlab\n```\n\n\n\n## 远程访问配置\n\n在终端中打开ipython：\n\n```shell\n$ ipython\n\nIn [1]: from notebook.auth import passwd\n\nIn [2]: passwd()\nEnter password:\t\t# 输入你要设置的密码\nVerify password:\nOut[2]: 'xxxxx...'\n```\n\n这里输出的字符串要复制下来。\n\n执行完上面的命令后，退出ipython，然后在终端中输入：\n\n```shell\n$ jupyter lab --generate-config\n```\n\n修改配置文件：\n\n```shell\n$ vi .jupyter/jupyter_notebook_config.py\n```\n\n更改内容如下：\n\n```shell\n# 将ip设置为*，意味允许任何IP访问\nc.NotebookApp.ip = '*'\n# 这里的密码就是上面生成的那一串\nc.NotebookApp.password = 'xxxxx...' \n# 服务器上并没有浏览器可以供Jupyter打开 \nc.NotebookApp.open_browser = False \n# 监听端口设置为8888或其他自己喜欢的端口 \nc.NotebookApp.port = 8888\n# 允许远程访问 \nc.NotebookApp.allow_remote_access = True\n```\n\n启动jupyter服务：\n\n```shell\n$ jupyter lab --allow-root\n```\n\n此时在浏览器搜索框中输入`你的服务器ip:你设置的端口`，然后在打开的页面中输入密码就可以进入jupyterlab：\n\n![](http://images.yingwai.top/picgo/jupyterinstallf2.png)\n\n\n\n## 后台运行JupyterLab程序\n\nJupyterLab启动后占用了一个终端窗口，可以用`nohup`命令使JupyterLab在后台运行，并且关闭当前终端也不会停止运行：\n\n```shell\n$ nohup jupyter lab &\n```\n\n* `nohup`命令\n\n  用途：Run COMMAND, ignoring hangup signals.\n\n  输出文件：程序的输出默认重定向到当前文件夹下的`nohup.out`文件中。也可以通过`nohup COMMAND > FILE`命令的方式将输出文件重定位到指定的`FILE`文件中。如果要查看JupyterLab的日志文件，可以打开`nohup.out`文件进行查看。\n\n* `&`命令\n\n  作用：在后台运行程序\n\n\n\n## 查看、关闭后台运行进程\n\n`job -l`命令查看当前终端中后台运行的进程，如果关闭终端后不能显示，需要使用`ps`命令。\n\n`ps -aux | grep jupyter`查看运行的`jupyter`进程：\n\n![](http://images.yingwai.top/picgo/jupyterinstallf3.png)\n\n用户名后面的数字就是JupyterLab的pid，使用`kill -9 pid`命令关闭运行中的JupyterLab。","slug":"JupyterLab安装","published":1,"updated":"2020-08-23T14:33:37.429Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cke79q4p1000b88ps3xzyfean","content":"<p>JupyterLab 是一个交互式的开发环境，是 Jupyter notebook 的下一代产品，集成了更多的功能，十分好用。</p>\n<a id=\"more\"></a>\n<h1 id=\"安装Miniconda\"><a href=\"#安装Miniconda\" class=\"headerlink\" title=\"安装Miniconda\"></a>安装Miniconda</h1><p>1、进入清华大学开源软件镜像站找到Miniconda: <a href=\"https://mirrors.tuna.tsinghua.edu.cn/anaconda/miniconda/\" target=\"_blank\" rel=\"noopener\">https://mirrors.tuna.tsinghua.edu.cn/anaconda/miniconda/</a></p>\n<p><img src=\"http://images.yingwai.top/picgo/jupyterinstallf1.png\" alt=\"\"></p>\n<p>2、找到Miniconda的Linux版本，右键复制链接地址，然后在服务器中下载：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> wget -c https://mirrors.tuna.tsinghua.edu.cn/anaconda/miniconda/Miniconda3-py37_4.8.2-Linux-x86_64.sh</span></span><br></pre></td></tr></table></figure>\n<p>3、安装刚刚下载的Miniconda：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> bash Miniconda3-py37_4.8.2-Linux-x86_64.sh</span></span><br></pre></td></tr></table></figure>\n<p>根据提示按enter键或输入yes即可。</p>\n<p>4、安装成功后，会在当前用户目录下生成一个miniconda3文件夹。</p>\n<h2 id=\"安装pip\"><a href=\"#安装pip\" class=\"headerlink\" title=\"安装pip\"></a>安装pip</h2><p>在终端中输入以下命令安装pip：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> conda install pip</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"添加清华源\"><a href=\"#添加清华源\" class=\"headerlink\" title=\"添加清华源\"></a>添加清华源</h3><p>如果下载速度太慢，可以将conda默认的软件源更换为国内的清华源：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> conda config --<span class=\"built_in\">set</span> show_channel_urls yes</span></span><br></pre></td></tr></table></figure>\n<p>添加完成后可以使用<code>conda info</code>命令查看是否添加成功。</p>\n<h1 id=\"安装并配置JupyterLab\"><a href=\"#安装并配置JupyterLab\" class=\"headerlink\" title=\"安装并配置JupyterLab\"></a>安装并配置JupyterLab</h1><p>准备工作完成后，就可以开始安装Jupyterlab。</p>\n<h2 id=\"安装JupyterLab\"><a href=\"#安装JupyterLab\" class=\"headerlink\" title=\"安装JupyterLab\"></a>安装JupyterLab</h2><p>在终端中输入：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> pip install jupyterlab</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"远程访问配置\"><a href=\"#远程访问配置\" class=\"headerlink\" title=\"远程访问配置\"></a>远程访问配置</h2><p>在终端中打开ipython：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> ipython</span></span><br><span class=\"line\"></span><br><span class=\"line\">In [1]: from notebook.auth import passwd</span><br><span class=\"line\"></span><br><span class=\"line\">In [2]: passwd()</span><br><span class=\"line\">Enter password:\t\t# 输入你要设置的密码</span><br><span class=\"line\">Verify password:</span><br><span class=\"line\">Out[2]: 'xxxxx...'</span><br></pre></td></tr></table></figure>\n<p>这里输出的字符串要复制下来。</p>\n<p>执行完上面的命令后，退出ipython，然后在终端中输入：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> jupyter lab --generate-config</span></span><br></pre></td></tr></table></figure>\n<p>修改配置文件：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> vi .jupyter/jupyter_notebook_config.py</span></span><br></pre></td></tr></table></figure>\n<p>更改内容如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 将ip设置为*，意味允许任何IP访问</span></span><br><span class=\"line\">c.NotebookApp.ip = '*'</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 这里的密码就是上面生成的那一串</span></span><br><span class=\"line\">c.NotebookApp.password = 'xxxxx...' </span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 服务器上并没有浏览器可以供Jupyter打开 </span></span><br><span class=\"line\">c.NotebookApp.open_browser = False </span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 监听端口设置为8888或其他自己喜欢的端口 </span></span><br><span class=\"line\">c.NotebookApp.port = 8888</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 允许远程访问 </span></span><br><span class=\"line\">c.NotebookApp.allow_remote_access = True</span><br></pre></td></tr></table></figure>\n<p>启动jupyter服务：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> jupyter lab --allow-root</span></span><br></pre></td></tr></table></figure>\n<p>此时在浏览器搜索框中输入<code>你的服务器ip:你设置的端口</code>，然后在打开的页面中输入密码就可以进入jupyterlab：</p>\n<p><img src=\"http://images.yingwai.top/picgo/jupyterinstallf2.png\" alt=\"\"></p>\n<h2 id=\"后台运行JupyterLab程序\"><a href=\"#后台运行JupyterLab程序\" class=\"headerlink\" title=\"后台运行JupyterLab程序\"></a>后台运行JupyterLab程序</h2><p>JupyterLab启动后占用了一个终端窗口，可以用<code>nohup</code>命令使JupyterLab在后台运行，并且关闭当前终端也不会停止运行：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> nohup jupyter lab &amp;</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li><p><code>nohup</code>命令</p>\n<p>用途：Run COMMAND, ignoring hangup signals.</p>\n<p>输出文件：程序的输出默认重定向到当前文件夹下的<code>nohup.out</code>文件中。也可以通过<code>nohup COMMAND &gt; FILE</code>命令的方式将输出文件重定位到指定的<code>FILE</code>文件中。如果要查看JupyterLab的日志文件，可以打开<code>nohup.out</code>文件进行查看。</p>\n</li>\n<li><p><code>&amp;</code>命令</p>\n<p>作用：在后台运行程序</p>\n</li>\n</ul>\n<h2 id=\"查看、关闭后台运行进程\"><a href=\"#查看、关闭后台运行进程\" class=\"headerlink\" title=\"查看、关闭后台运行进程\"></a>查看、关闭后台运行进程</h2><p><code>job -l</code>命令查看当前终端中后台运行的进程，如果关闭终端后不能显示，需要使用<code>ps</code>命令。</p>\n<p><code>ps -aux | grep jupyter</code>查看运行的<code>jupyter</code>进程：</p>\n<p><img src=\"http://images.yingwai.top/picgo/jupyterinstallf3.png\" alt=\"\"></p>\n<p>用户名后面的数字就是JupyterLab的pid，使用<code>kill -9 pid</code>命令关闭运行中的JupyterLab。</p>\n","site":{"data":{}},"excerpt":"<p>JupyterLab 是一个交互式的开发环境，是 Jupyter notebook 的下一代产品，集成了更多的功能，十分好用。</p>","more":"<h1 id=\"安装Miniconda\"><a href=\"#安装Miniconda\" class=\"headerlink\" title=\"安装Miniconda\"></a>安装Miniconda</h1><p>1、进入清华大学开源软件镜像站找到Miniconda: <a href=\"https://mirrors.tuna.tsinghua.edu.cn/anaconda/miniconda/\" target=\"_blank\" rel=\"noopener\">https://mirrors.tuna.tsinghua.edu.cn/anaconda/miniconda/</a></p>\n<p><img src=\"http://images.yingwai.top/picgo/jupyterinstallf1.png\" alt=\"\"></p>\n<p>2、找到Miniconda的Linux版本，右键复制链接地址，然后在服务器中下载：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> wget -c https://mirrors.tuna.tsinghua.edu.cn/anaconda/miniconda/Miniconda3-py37_4.8.2-Linux-x86_64.sh</span></span><br></pre></td></tr></table></figure>\n<p>3、安装刚刚下载的Miniconda：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> bash Miniconda3-py37_4.8.2-Linux-x86_64.sh</span></span><br></pre></td></tr></table></figure>\n<p>根据提示按enter键或输入yes即可。</p>\n<p>4、安装成功后，会在当前用户目录下生成一个miniconda3文件夹。</p>\n<h2 id=\"安装pip\"><a href=\"#安装pip\" class=\"headerlink\" title=\"安装pip\"></a>安装pip</h2><p>在终端中输入以下命令安装pip：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> conda install pip</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"添加清华源\"><a href=\"#添加清华源\" class=\"headerlink\" title=\"添加清华源\"></a>添加清华源</h3><p>如果下载速度太慢，可以将conda默认的软件源更换为国内的清华源：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> conda config --<span class=\"built_in\">set</span> show_channel_urls yes</span></span><br></pre></td></tr></table></figure>\n<p>添加完成后可以使用<code>conda info</code>命令查看是否添加成功。</p>\n<h1 id=\"安装并配置JupyterLab\"><a href=\"#安装并配置JupyterLab\" class=\"headerlink\" title=\"安装并配置JupyterLab\"></a>安装并配置JupyterLab</h1><p>准备工作完成后，就可以开始安装Jupyterlab。</p>\n<h2 id=\"安装JupyterLab\"><a href=\"#安装JupyterLab\" class=\"headerlink\" title=\"安装JupyterLab\"></a>安装JupyterLab</h2><p>在终端中输入：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> pip install jupyterlab</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"远程访问配置\"><a href=\"#远程访问配置\" class=\"headerlink\" title=\"远程访问配置\"></a>远程访问配置</h2><p>在终端中打开ipython：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> ipython</span></span><br><span class=\"line\"></span><br><span class=\"line\">In [1]: from notebook.auth import passwd</span><br><span class=\"line\"></span><br><span class=\"line\">In [2]: passwd()</span><br><span class=\"line\">Enter password:\t\t# 输入你要设置的密码</span><br><span class=\"line\">Verify password:</span><br><span class=\"line\">Out[2]: 'xxxxx...'</span><br></pre></td></tr></table></figure>\n<p>这里输出的字符串要复制下来。</p>\n<p>执行完上面的命令后，退出ipython，然后在终端中输入：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> jupyter lab --generate-config</span></span><br></pre></td></tr></table></figure>\n<p>修改配置文件：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> vi .jupyter/jupyter_notebook_config.py</span></span><br></pre></td></tr></table></figure>\n<p>更改内容如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 将ip设置为*，意味允许任何IP访问</span></span><br><span class=\"line\">c.NotebookApp.ip = '*'</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 这里的密码就是上面生成的那一串</span></span><br><span class=\"line\">c.NotebookApp.password = 'xxxxx...' </span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 服务器上并没有浏览器可以供Jupyter打开 </span></span><br><span class=\"line\">c.NotebookApp.open_browser = False </span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 监听端口设置为8888或其他自己喜欢的端口 </span></span><br><span class=\"line\">c.NotebookApp.port = 8888</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 允许远程访问 </span></span><br><span class=\"line\">c.NotebookApp.allow_remote_access = True</span><br></pre></td></tr></table></figure>\n<p>启动jupyter服务：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> jupyter lab --allow-root</span></span><br></pre></td></tr></table></figure>\n<p>此时在浏览器搜索框中输入<code>你的服务器ip:你设置的端口</code>，然后在打开的页面中输入密码就可以进入jupyterlab：</p>\n<p><img src=\"http://images.yingwai.top/picgo/jupyterinstallf2.png\" alt=\"\"></p>\n<h2 id=\"后台运行JupyterLab程序\"><a href=\"#后台运行JupyterLab程序\" class=\"headerlink\" title=\"后台运行JupyterLab程序\"></a>后台运行JupyterLab程序</h2><p>JupyterLab启动后占用了一个终端窗口，可以用<code>nohup</code>命令使JupyterLab在后台运行，并且关闭当前终端也不会停止运行：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> nohup jupyter lab &amp;</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li><p><code>nohup</code>命令</p>\n<p>用途：Run COMMAND, ignoring hangup signals.</p>\n<p>输出文件：程序的输出默认重定向到当前文件夹下的<code>nohup.out</code>文件中。也可以通过<code>nohup COMMAND &gt; FILE</code>命令的方式将输出文件重定位到指定的<code>FILE</code>文件中。如果要查看JupyterLab的日志文件，可以打开<code>nohup.out</code>文件进行查看。</p>\n</li>\n<li><p><code>&amp;</code>命令</p>\n<p>作用：在后台运行程序</p>\n</li>\n</ul>\n<h2 id=\"查看、关闭后台运行进程\"><a href=\"#查看、关闭后台运行进程\" class=\"headerlink\" title=\"查看、关闭后台运行进程\"></a>查看、关闭后台运行进程</h2><p><code>job -l</code>命令查看当前终端中后台运行的进程，如果关闭终端后不能显示，需要使用<code>ps</code>命令。</p>\n<p><code>ps -aux | grep jupyter</code>查看运行的<code>jupyter</code>进程：</p>\n<p><img src=\"http://images.yingwai.top/picgo/jupyterinstallf3.png\" alt=\"\"></p>\n<p>用户名后面的数字就是JupyterLab的pid，使用<code>kill -9 pid</code>命令关闭运行中的JupyterLab。</p>"},{"title":"LaTeX常用符号表示方法","date":"2020-04-26T13:19:50.000Z","_content":"\n图片来源：https://blog.csdn.net/caiandyong/article/details/53351737\n\n<!--more-->\n\n# 希腊字母、数学构造、定界符、大型运算符以及标准函数名\n\n![](http://images.yingwai.top/picgo/latexf1.jpg)\n\n# 二元运算、关系符\n\n![](http://images.yingwai.top/picgo/latexf2.jpg)\n\n# 箭头符号、各种符号以及数学模式重音符\n\n![](http://images.yingwai.top/picgo/latexf3.jpg)\n\n# 数列环境、其它风格的字体以及字体大小\n\n![](http://images.yingwai.top/picgo/latexf4.jpg)","source":"_posts/LaTeX常用符号表示方法.md","raw":"---\ntitle: LaTeX常用符号表示方法\ndate: 2020-04-26 21:19:50\ncategories: Env\ntags: LaTeX\n---\n\n图片来源：https://blog.csdn.net/caiandyong/article/details/53351737\n\n<!--more-->\n\n# 希腊字母、数学构造、定界符、大型运算符以及标准函数名\n\n![](http://images.yingwai.top/picgo/latexf1.jpg)\n\n# 二元运算、关系符\n\n![](http://images.yingwai.top/picgo/latexf2.jpg)\n\n# 箭头符号、各种符号以及数学模式重音符\n\n![](http://images.yingwai.top/picgo/latexf3.jpg)\n\n# 数列环境、其它风格的字体以及字体大小\n\n![](http://images.yingwai.top/picgo/latexf4.jpg)","slug":"LaTeX常用符号表示方法","published":1,"updated":"2020-08-23T14:33:37.429Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cke79q4p3000f88psaooq4u6e","content":"<p>图片来源：<a href=\"https://blog.csdn.net/caiandyong/article/details/53351737\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/caiandyong/article/details/53351737</a></p>\n<a id=\"more\"></a>\n<h1 id=\"希腊字母、数学构造、定界符、大型运算符以及标准函数名\"><a href=\"#希腊字母、数学构造、定界符、大型运算符以及标准函数名\" class=\"headerlink\" title=\"希腊字母、数学构造、定界符、大型运算符以及标准函数名\"></a>希腊字母、数学构造、定界符、大型运算符以及标准函数名</h1><p><img src=\"http://images.yingwai.top/picgo/latexf1.jpg\" alt=\"\"></p>\n<h1 id=\"二元运算、关系符\"><a href=\"#二元运算、关系符\" class=\"headerlink\" title=\"二元运算、关系符\"></a>二元运算、关系符</h1><p><img src=\"http://images.yingwai.top/picgo/latexf2.jpg\" alt=\"\"></p>\n<h1 id=\"箭头符号、各种符号以及数学模式重音符\"><a href=\"#箭头符号、各种符号以及数学模式重音符\" class=\"headerlink\" title=\"箭头符号、各种符号以及数学模式重音符\"></a>箭头符号、各种符号以及数学模式重音符</h1><p><img src=\"http://images.yingwai.top/picgo/latexf3.jpg\" alt=\"\"></p>\n<h1 id=\"数列环境、其它风格的字体以及字体大小\"><a href=\"#数列环境、其它风格的字体以及字体大小\" class=\"headerlink\" title=\"数列环境、其它风格的字体以及字体大小\"></a>数列环境、其它风格的字体以及字体大小</h1><p><img src=\"http://images.yingwai.top/picgo/latexf4.jpg\" alt=\"\"></p>\n","site":{"data":{}},"excerpt":"<p>图片来源：<a href=\"https://blog.csdn.net/caiandyong/article/details/53351737\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/caiandyong/article/details/53351737</a></p>","more":"<h1 id=\"希腊字母、数学构造、定界符、大型运算符以及标准函数名\"><a href=\"#希腊字母、数学构造、定界符、大型运算符以及标准函数名\" class=\"headerlink\" title=\"希腊字母、数学构造、定界符、大型运算符以及标准函数名\"></a>希腊字母、数学构造、定界符、大型运算符以及标准函数名</h1><p><img src=\"http://images.yingwai.top/picgo/latexf1.jpg\" alt=\"\"></p>\n<h1 id=\"二元运算、关系符\"><a href=\"#二元运算、关系符\" class=\"headerlink\" title=\"二元运算、关系符\"></a>二元运算、关系符</h1><p><img src=\"http://images.yingwai.top/picgo/latexf2.jpg\" alt=\"\"></p>\n<h1 id=\"箭头符号、各种符号以及数学模式重音符\"><a href=\"#箭头符号、各种符号以及数学模式重音符\" class=\"headerlink\" title=\"箭头符号、各种符号以及数学模式重音符\"></a>箭头符号、各种符号以及数学模式重音符</h1><p><img src=\"http://images.yingwai.top/picgo/latexf3.jpg\" alt=\"\"></p>\n<h1 id=\"数列环境、其它风格的字体以及字体大小\"><a href=\"#数列环境、其它风格的字体以及字体大小\" class=\"headerlink\" title=\"数列环境、其它风格的字体以及字体大小\"></a>数列环境、其它风格的字体以及字体大小</h1><p><img src=\"http://images.yingwai.top/picgo/latexf4.jpg\" alt=\"\"></p>"},{"title":"PPML中的2PC对比3PC","date":"2020-06-19T03:03:28.000Z","_content":"\n----\n\n\n\n<!--more-->\n\n# 共享语义\n\n不同的论文可能设置不太一样，这里2PC我参考的是[SecureML](https://yuyingwai.cn/2020/06/17/论文笔记-SecureML-A-System-for-Scalable-Privacy-Preserving-Machine-Learning/)中的设置，3PC参考的是[ABY3](https://yuyingwai.cn/2020/06/18/论文笔记-ABY3-A-Mixed-Protocol-Framework-for-Machine-Learning/)和[ASTRA](https://yuyingwai.cn/2020/04/20/论文笔记-ASTRA-High-Throughput-3PC-over-Rings-with-Application-to-Secure-Prediction/)中的设置。即对于一个数 $x$ 的算术共享，2PC的情况是将其拆成两份 $x_0$ 和 $x_1$，它们的和为 $x$，两方各拥有一份；3PC的情况是将其拆成三份 $x_0, x_1, x_2$，三方各拥有其中的两份，例如 $P_0$ 有 $(x_0, x_2)$，任意两方即可重构出 $x$。\n\n布尔共享是各份额二进制表示的每一位异或等于原秘密 $x$ 的对应位。\n\n![](http://images.yingwai.top/picgo/2vs3ppt2.png)\n\n\n\n# 加法\n\n2PC和3PC下算术共享的加法是一样的，都只需要在本地将对应数的份额相加，不需要交互。\n\n\n\n# 乘法\n\n## 2PC\n\n乘法则有比较大的区别，首先是2PC，计算乘法 $ab = c$ 需要生成额外的乘法三元组 $(u,v,z)$ 满足 $z = uv$，这个三元组中的每个数也是在两方间加法共享的。\n\n首先两方交互计算 $e = a-u$ 和 $f = b - v$，然后 $P_i$ 将结果 $c = ab$ 的份额设为 $c_i = -ief+a_if+eb_i+z_i$，其中 $i \\in \\{0,1\\}$。\n\n![](http://images.yingwai.top/picgo/2vs3ppt1.png)\n\n\n\n## 3PC\n\n接下来是3PC，由于重复共享的设置（各方拥有三个份额中的两个），计算乘法时几乎不需要交互。计算 $x,y$ 两个数的积 $xy = z$ 时，观察到\n$$\n\\begin{align}\nxy &= (x_0 + x_1 + x_2)(y_0 + y_1 + y_2) \\\\\n&= x_0y_0 + x_0y_1 + x_0y_2 \\\\\n&+ x_1y_0 + x_1y_1 + x_1y_2 \\\\\n&+ x_2y_0 + x_2y_1 + x_2y_2\n\\end{align}\n$$\n可以看到拆开的式子一共有九项，我们可以直接让 $P_i$ 各计算其中三项，令\n$$\nz_0 = x_0y_0 + x_0y_2 + x_2y_0 \\\\\nz_1 = x_0y_1 + x_1y_0 + x_1y_1 \\\\\nz_2 = x_1y_2 + x_2y_1 + x_2y_2\n$$\n这时结果 $z$ 就以加法共享的方式在三方中共享，最后 $P_i$ 将自己的 $z_i$ 发送给 $P_{i+1}$（$i=2$ 时 $i+1 = 0$），$z$ 就重新在三方中重复共享了。\n\n![](http://images.yingwai.top/picgo/aby3ppt3.png)\n\n可以看到计算过程中只涉及本地操作，只有在生成重复共享时才需要三方各一次发送，效率比2PC要高。\n\n\n\n# 比较\n\n比较两个数 $u,v$ 的大小，等同于提取 $a = u-v$ 的 $\\mbox{msb}$，$u>v \\rightarrow u-v>0$ 时 $\\mbox{msb}(a) = 0$，反之 $\\mbox{msb}(a) = 1$。两方下没有给出具体的细节，[SecureML](https://yuyingwai.cn/2020/06/17/论文笔记-SecureML-A-System-for-Scalable-Privacy-Preserving-Machine-Learning/)中只提到使用乱码电路，这是一个比较昂贵的协议（将算术共享转换为布尔或姚共享也需要开销），而三方下的[ASTRA](https://yuyingwai.cn/2020/04/20/论文笔记-ASTRA-High-Throughput-3PC-over-Rings-with-Application-to-Secure-Prediction/)中则利用了秘密共享方案的不对称性，下面的协议是基于 $\\mbox{sign}(r \\cdot a) = \\mbox{sign}(r) \\oplus \\mbox{sign}(a)$ 的事实：\n\n首先在离线阶段，$P_1,P_2$ 共同选取两个随机数 $r, r' \\in \\mathbb{Z}_{2^l}$ 并设 $p = \\mbox{msb}(r)$，然后各方可以非交互式地设置 $p$ 的布尔共享 $[\\![p]\\!]^{\\rm B}_{P_0} = (0,0)$, $[\\![p]\\!]^{\\rm B}_{P_1} = (p,0)$ 以及 $[\\![p]\\!]^{\\rm B}_{P_2} = (p,0)$。\n\n![](http://images.yingwai.top/picgo/2vs3ppt3.png)\n\n到了在线阶段，$P_1$ 和 $P_2$ 设置它们对 $a$ 的份额，使得它们两方各自的份额之和为 $a$ ：$P_1$ 设 $[a]_{P_1} = x_0+x_1$，$P_2$ 设 $[a]_{P_2}=x_2$。然后 $P_1$ 和 $P_2$ 利用离线阶段生成的随机数 $r'$ 对 $[ra]_{P_i}$ 进行盲化并发送给 $P_0$（由于 $P_0$ 知道 $x_2$，若不进行盲化则会暴露 $r$ 给 $P_0$），$P_0$ 重构 $ra$ 并设 $q = \\mbox{msb}(ra)$，然后生成 $q$ 在三方中的布尔共享。最后各方在本地计算 $[\\![\\mbox{msb}(a)]\\!]^B = [\\![p]\\!]^B \\oplus [\\![q]\\!]^B$，此时 $a$ 的符号位在三方中是布尔共享的。\n\n![](http://images.yingwai.top/picgo/2vs3ppt4.png)\n\n","source":"_posts/PPML中的2PC对比3PC.md","raw":"---\ntitle: PPML中的2PC对比3PC\ndate: 2020-06-19 11:03:28\ncategories: Study\ntags: [MPC, 密码学, PPML, Secret Sharing]\n---\n\n----\n\n\n\n<!--more-->\n\n# 共享语义\n\n不同的论文可能设置不太一样，这里2PC我参考的是[SecureML](https://yuyingwai.cn/2020/06/17/论文笔记-SecureML-A-System-for-Scalable-Privacy-Preserving-Machine-Learning/)中的设置，3PC参考的是[ABY3](https://yuyingwai.cn/2020/06/18/论文笔记-ABY3-A-Mixed-Protocol-Framework-for-Machine-Learning/)和[ASTRA](https://yuyingwai.cn/2020/04/20/论文笔记-ASTRA-High-Throughput-3PC-over-Rings-with-Application-to-Secure-Prediction/)中的设置。即对于一个数 $x$ 的算术共享，2PC的情况是将其拆成两份 $x_0$ 和 $x_1$，它们的和为 $x$，两方各拥有一份；3PC的情况是将其拆成三份 $x_0, x_1, x_2$，三方各拥有其中的两份，例如 $P_0$ 有 $(x_0, x_2)$，任意两方即可重构出 $x$。\n\n布尔共享是各份额二进制表示的每一位异或等于原秘密 $x$ 的对应位。\n\n![](http://images.yingwai.top/picgo/2vs3ppt2.png)\n\n\n\n# 加法\n\n2PC和3PC下算术共享的加法是一样的，都只需要在本地将对应数的份额相加，不需要交互。\n\n\n\n# 乘法\n\n## 2PC\n\n乘法则有比较大的区别，首先是2PC，计算乘法 $ab = c$ 需要生成额外的乘法三元组 $(u,v,z)$ 满足 $z = uv$，这个三元组中的每个数也是在两方间加法共享的。\n\n首先两方交互计算 $e = a-u$ 和 $f = b - v$，然后 $P_i$ 将结果 $c = ab$ 的份额设为 $c_i = -ief+a_if+eb_i+z_i$，其中 $i \\in \\{0,1\\}$。\n\n![](http://images.yingwai.top/picgo/2vs3ppt1.png)\n\n\n\n## 3PC\n\n接下来是3PC，由于重复共享的设置（各方拥有三个份额中的两个），计算乘法时几乎不需要交互。计算 $x,y$ 两个数的积 $xy = z$ 时，观察到\n$$\n\\begin{align}\nxy &= (x_0 + x_1 + x_2)(y_0 + y_1 + y_2) \\\\\n&= x_0y_0 + x_0y_1 + x_0y_2 \\\\\n&+ x_1y_0 + x_1y_1 + x_1y_2 \\\\\n&+ x_2y_0 + x_2y_1 + x_2y_2\n\\end{align}\n$$\n可以看到拆开的式子一共有九项，我们可以直接让 $P_i$ 各计算其中三项，令\n$$\nz_0 = x_0y_0 + x_0y_2 + x_2y_0 \\\\\nz_1 = x_0y_1 + x_1y_0 + x_1y_1 \\\\\nz_2 = x_1y_2 + x_2y_1 + x_2y_2\n$$\n这时结果 $z$ 就以加法共享的方式在三方中共享，最后 $P_i$ 将自己的 $z_i$ 发送给 $P_{i+1}$（$i=2$ 时 $i+1 = 0$），$z$ 就重新在三方中重复共享了。\n\n![](http://images.yingwai.top/picgo/aby3ppt3.png)\n\n可以看到计算过程中只涉及本地操作，只有在生成重复共享时才需要三方各一次发送，效率比2PC要高。\n\n\n\n# 比较\n\n比较两个数 $u,v$ 的大小，等同于提取 $a = u-v$ 的 $\\mbox{msb}$，$u>v \\rightarrow u-v>0$ 时 $\\mbox{msb}(a) = 0$，反之 $\\mbox{msb}(a) = 1$。两方下没有给出具体的细节，[SecureML](https://yuyingwai.cn/2020/06/17/论文笔记-SecureML-A-System-for-Scalable-Privacy-Preserving-Machine-Learning/)中只提到使用乱码电路，这是一个比较昂贵的协议（将算术共享转换为布尔或姚共享也需要开销），而三方下的[ASTRA](https://yuyingwai.cn/2020/04/20/论文笔记-ASTRA-High-Throughput-3PC-over-Rings-with-Application-to-Secure-Prediction/)中则利用了秘密共享方案的不对称性，下面的协议是基于 $\\mbox{sign}(r \\cdot a) = \\mbox{sign}(r) \\oplus \\mbox{sign}(a)$ 的事实：\n\n首先在离线阶段，$P_1,P_2$ 共同选取两个随机数 $r, r' \\in \\mathbb{Z}_{2^l}$ 并设 $p = \\mbox{msb}(r)$，然后各方可以非交互式地设置 $p$ 的布尔共享 $[\\![p]\\!]^{\\rm B}_{P_0} = (0,0)$, $[\\![p]\\!]^{\\rm B}_{P_1} = (p,0)$ 以及 $[\\![p]\\!]^{\\rm B}_{P_2} = (p,0)$。\n\n![](http://images.yingwai.top/picgo/2vs3ppt3.png)\n\n到了在线阶段，$P_1$ 和 $P_2$ 设置它们对 $a$ 的份额，使得它们两方各自的份额之和为 $a$ ：$P_1$ 设 $[a]_{P_1} = x_0+x_1$，$P_2$ 设 $[a]_{P_2}=x_2$。然后 $P_1$ 和 $P_2$ 利用离线阶段生成的随机数 $r'$ 对 $[ra]_{P_i}$ 进行盲化并发送给 $P_0$（由于 $P_0$ 知道 $x_2$，若不进行盲化则会暴露 $r$ 给 $P_0$），$P_0$ 重构 $ra$ 并设 $q = \\mbox{msb}(ra)$，然后生成 $q$ 在三方中的布尔共享。最后各方在本地计算 $[\\![\\mbox{msb}(a)]\\!]^B = [\\![p]\\!]^B \\oplus [\\![q]\\!]^B$，此时 $a$ 的符号位在三方中是布尔共享的。\n\n![](http://images.yingwai.top/picgo/2vs3ppt4.png)\n\n","slug":"PPML中的2PC对比3PC","published":1,"updated":"2020-08-23T14:33:37.430Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cke79q4p4000i88pscqcu31r9","content":"<hr>\n<a id=\"more\"></a>\n<h1 id=\"共享语义\"><a href=\"#共享语义\" class=\"headerlink\" title=\"共享语义\"></a>共享语义</h1><p>不同的论文可能设置不太一样，这里2PC我参考的是<a href=\"https://yuyingwai.cn/2020/06/17/论文笔记-SecureML-A-System-for-Scalable-Privacy-Preserving-Machine-Learning/\" target=\"_blank\" rel=\"noopener\">SecureML</a>中的设置，3PC参考的是<a href=\"https://yuyingwai.cn/2020/06/18/论文笔记-ABY3-A-Mixed-Protocol-Framework-for-Machine-Learning/\" target=\"_blank\" rel=\"noopener\">ABY3</a>和<a href=\"https://yuyingwai.cn/2020/04/20/论文笔记-ASTRA-High-Throughput-3PC-over-Rings-with-Application-to-Secure-Prediction/\" target=\"_blank\" rel=\"noopener\">ASTRA</a>中的设置。即对于一个数 $x$ 的算术共享，2PC的情况是将其拆成两份 $x_0$ 和 $x_1$，它们的和为 $x$，两方各拥有一份；3PC的情况是将其拆成三份 $x_0, x_1, x_2$，三方各拥有其中的两份，例如 $P_0$ 有 $(x_0, x_2)$，任意两方即可重构出 $x$。</p>\n<p>布尔共享是各份额二进制表示的每一位异或等于原秘密 $x$ 的对应位。</p>\n<p><img src=\"http://images.yingwai.top/picgo/2vs3ppt2.png\" alt=\"\"></p>\n<h1 id=\"加法\"><a href=\"#加法\" class=\"headerlink\" title=\"加法\"></a>加法</h1><p>2PC和3PC下算术共享的加法是一样的，都只需要在本地将对应数的份额相加，不需要交互。</p>\n<h1 id=\"乘法\"><a href=\"#乘法\" class=\"headerlink\" title=\"乘法\"></a>乘法</h1><h2 id=\"2PC\"><a href=\"#2PC\" class=\"headerlink\" title=\"2PC\"></a>2PC</h2><p>乘法则有比较大的区别，首先是2PC，计算乘法 $ab = c$ 需要生成额外的乘法三元组 $(u,v,z)$ 满足 $z = uv$，这个三元组中的每个数也是在两方间加法共享的。</p>\n<p>首先两方交互计算 $e = a-u$ 和 $f = b - v$，然后 $P_i$ 将结果 $c = ab$ 的份额设为 $c_i = -ief+a_if+eb_i+z_i$，其中 $i \\in {0,1}$。</p>\n<p><img src=\"http://images.yingwai.top/picgo/2vs3ppt1.png\" alt=\"\"></p>\n<h2 id=\"3PC\"><a href=\"#3PC\" class=\"headerlink\" title=\"3PC\"></a>3PC</h2><p>接下来是3PC，由于重复共享的设置（各方拥有三个份额中的两个），计算乘法时几乎不需要交互。计算 $x,y$ 两个数的积 $xy = z$ 时，观察到</p>\n<script type=\"math/tex; mode=display\">\n\\begin{align}\nxy &= (x_0 + x_1 + x_2)(y_0 + y_1 + y_2) \\\\\n&= x_0y_0 + x_0y_1 + x_0y_2 \\\\\n&+ x_1y_0 + x_1y_1 + x_1y_2 \\\\\n&+ x_2y_0 + x_2y_1 + x_2y_2\n\\end{align}</script><p>可以看到拆开的式子一共有九项，我们可以直接让 $P_i$ 各计算其中三项，令</p>\n<script type=\"math/tex; mode=display\">\nz_0 = x_0y_0 + x_0y_2 + x_2y_0 \\\\\nz_1 = x_0y_1 + x_1y_0 + x_1y_1 \\\\\nz_2 = x_1y_2 + x_2y_1 + x_2y_2</script><p>这时结果 $z$ 就以加法共享的方式在三方中共享，最后 $P<em>i$ 将自己的 $z_i$ 发送给 $P</em>{i+1}$（$i=2$ 时 $i+1 = 0$），$z$ 就重新在三方中重复共享了。</p>\n<p><img src=\"http://images.yingwai.top/picgo/aby3ppt3.png\" alt=\"\"></p>\n<p>可以看到计算过程中只涉及本地操作，只有在生成重复共享时才需要三方各一次发送，效率比2PC要高。</p>\n<h1 id=\"比较\"><a href=\"#比较\" class=\"headerlink\" title=\"比较\"></a>比较</h1><p>比较两个数 $u,v$ 的大小，等同于提取 $a = u-v$ 的 $\\mbox{msb}$，$u&gt;v \\rightarrow u-v&gt;0$ 时 $\\mbox{msb}(a) = 0$，反之 $\\mbox{msb}(a) = 1$。两方下没有给出具体的细节，<a href=\"https://yuyingwai.cn/2020/06/17/论文笔记-SecureML-A-System-for-Scalable-Privacy-Preserving-Machine-Learning/\" target=\"_blank\" rel=\"noopener\">SecureML</a>中只提到使用乱码电路，这是一个比较昂贵的协议（将算术共享转换为布尔或姚共享也需要开销），而三方下的<a href=\"https://yuyingwai.cn/2020/04/20/论文笔记-ASTRA-High-Throughput-3PC-over-Rings-with-Application-to-Secure-Prediction/\" target=\"_blank\" rel=\"noopener\">ASTRA</a>中则利用了秘密共享方案的不对称性，下面的协议是基于 $\\mbox{sign}(r \\cdot a) = \\mbox{sign}(r) \\oplus \\mbox{sign}(a)$ 的事实：</p>\n<p>首先在离线阶段，$P<em>1,P_2$ 共同选取两个随机数 $r, r’ \\in \\mathbb{Z}</em>{2^l}$ 并设 $p = \\mbox{msb}(r)$，然后各方可以非交互式地设置 $p$ 的布尔共享 $[![p]!]^{\\rm B}<em>{P_0} = (0,0)$, $[![p]!]^{\\rm B}</em>{P<em>1} = (p,0)$ 以及 $[![p]!]^{\\rm B}</em>{P_2} = (p,0)$。</p>\n<p><img src=\"http://images.yingwai.top/picgo/2vs3ppt3.png\" alt=\"\"></p>\n<p>到了在线阶段，$P<em>1$ 和 $P_2$ 设置它们对 $a$ 的份额，使得它们两方各自的份额之和为 $a$ ：$P_1$ 设 $[a]</em>{P<em>1} = x_0+x_1$，$P_2$ 设 $[a]</em>{P<em>2}=x_2$。然后 $P_1$ 和 $P_2$ 利用离线阶段生成的随机数 $r’$ 对 $[ra]</em>{P_i}$ 进行盲化并发送给 $P_0$（由于 $P_0$ 知道 $x_2$，若不进行盲化则会暴露 $r$ 给 $P_0$），$P_0$ 重构 $ra$ 并设 $q = \\mbox{msb}(ra)$，然后生成 $q$ 在三方中的布尔共享。最后各方在本地计算 $[![\\mbox{msb}(a)]!]^B = [![p]!]^B \\oplus [![q]!]^B$，此时 $a$ 的符号位在三方中是布尔共享的。</p>\n<p><img src=\"http://images.yingwai.top/picgo/2vs3ppt4.png\" alt=\"\"></p>\n","site":{"data":{}},"excerpt":"<hr>","more":"<h1 id=\"共享语义\"><a href=\"#共享语义\" class=\"headerlink\" title=\"共享语义\"></a>共享语义</h1><p>不同的论文可能设置不太一样，这里2PC我参考的是<a href=\"https://yuyingwai.cn/2020/06/17/论文笔记-SecureML-A-System-for-Scalable-Privacy-Preserving-Machine-Learning/\" target=\"_blank\" rel=\"noopener\">SecureML</a>中的设置，3PC参考的是<a href=\"https://yuyingwai.cn/2020/06/18/论文笔记-ABY3-A-Mixed-Protocol-Framework-for-Machine-Learning/\" target=\"_blank\" rel=\"noopener\">ABY3</a>和<a href=\"https://yuyingwai.cn/2020/04/20/论文笔记-ASTRA-High-Throughput-3PC-over-Rings-with-Application-to-Secure-Prediction/\" target=\"_blank\" rel=\"noopener\">ASTRA</a>中的设置。即对于一个数 $x$ 的算术共享，2PC的情况是将其拆成两份 $x_0$ 和 $x_1$，它们的和为 $x$，两方各拥有一份；3PC的情况是将其拆成三份 $x_0, x_1, x_2$，三方各拥有其中的两份，例如 $P_0$ 有 $(x_0, x_2)$，任意两方即可重构出 $x$。</p>\n<p>布尔共享是各份额二进制表示的每一位异或等于原秘密 $x$ 的对应位。</p>\n<p><img src=\"http://images.yingwai.top/picgo/2vs3ppt2.png\" alt=\"\"></p>\n<h1 id=\"加法\"><a href=\"#加法\" class=\"headerlink\" title=\"加法\"></a>加法</h1><p>2PC和3PC下算术共享的加法是一样的，都只需要在本地将对应数的份额相加，不需要交互。</p>\n<h1 id=\"乘法\"><a href=\"#乘法\" class=\"headerlink\" title=\"乘法\"></a>乘法</h1><h2 id=\"2PC\"><a href=\"#2PC\" class=\"headerlink\" title=\"2PC\"></a>2PC</h2><p>乘法则有比较大的区别，首先是2PC，计算乘法 $ab = c$ 需要生成额外的乘法三元组 $(u,v,z)$ 满足 $z = uv$，这个三元组中的每个数也是在两方间加法共享的。</p>\n<p>首先两方交互计算 $e = a-u$ 和 $f = b - v$，然后 $P_i$ 将结果 $c = ab$ 的份额设为 $c_i = -ief+a_if+eb_i+z_i$，其中 $i \\in {0,1}$。</p>\n<p><img src=\"http://images.yingwai.top/picgo/2vs3ppt1.png\" alt=\"\"></p>\n<h2 id=\"3PC\"><a href=\"#3PC\" class=\"headerlink\" title=\"3PC\"></a>3PC</h2><p>接下来是3PC，由于重复共享的设置（各方拥有三个份额中的两个），计算乘法时几乎不需要交互。计算 $x,y$ 两个数的积 $xy = z$ 时，观察到</p>\n<script type=\"math/tex; mode=display\">\n\\begin{align}\nxy &= (x_0 + x_1 + x_2)(y_0 + y_1 + y_2) \\\\\n&= x_0y_0 + x_0y_1 + x_0y_2 \\\\\n&+ x_1y_0 + x_1y_1 + x_1y_2 \\\\\n&+ x_2y_0 + x_2y_1 + x_2y_2\n\\end{align}</script><p>可以看到拆开的式子一共有九项，我们可以直接让 $P_i$ 各计算其中三项，令</p>\n<script type=\"math/tex; mode=display\">\nz_0 = x_0y_0 + x_0y_2 + x_2y_0 \\\\\nz_1 = x_0y_1 + x_1y_0 + x_1y_1 \\\\\nz_2 = x_1y_2 + x_2y_1 + x_2y_2</script><p>这时结果 $z$ 就以加法共享的方式在三方中共享，最后 $P<em>i$ 将自己的 $z_i$ 发送给 $P</em>{i+1}$（$i=2$ 时 $i+1 = 0$），$z$ 就重新在三方中重复共享了。</p>\n<p><img src=\"http://images.yingwai.top/picgo/aby3ppt3.png\" alt=\"\"></p>\n<p>可以看到计算过程中只涉及本地操作，只有在生成重复共享时才需要三方各一次发送，效率比2PC要高。</p>\n<h1 id=\"比较\"><a href=\"#比较\" class=\"headerlink\" title=\"比较\"></a>比较</h1><p>比较两个数 $u,v$ 的大小，等同于提取 $a = u-v$ 的 $\\mbox{msb}$，$u&gt;v \\rightarrow u-v&gt;0$ 时 $\\mbox{msb}(a) = 0$，反之 $\\mbox{msb}(a) = 1$。两方下没有给出具体的细节，<a href=\"https://yuyingwai.cn/2020/06/17/论文笔记-SecureML-A-System-for-Scalable-Privacy-Preserving-Machine-Learning/\" target=\"_blank\" rel=\"noopener\">SecureML</a>中只提到使用乱码电路，这是一个比较昂贵的协议（将算术共享转换为布尔或姚共享也需要开销），而三方下的<a href=\"https://yuyingwai.cn/2020/04/20/论文笔记-ASTRA-High-Throughput-3PC-over-Rings-with-Application-to-Secure-Prediction/\" target=\"_blank\" rel=\"noopener\">ASTRA</a>中则利用了秘密共享方案的不对称性，下面的协议是基于 $\\mbox{sign}(r \\cdot a) = \\mbox{sign}(r) \\oplus \\mbox{sign}(a)$ 的事实：</p>\n<p>首先在离线阶段，$P<em>1,P_2$ 共同选取两个随机数 $r, r’ \\in \\mathbb{Z}</em>{2^l}$ 并设 $p = \\mbox{msb}(r)$，然后各方可以非交互式地设置 $p$ 的布尔共享 $[![p]!]^{\\rm B}<em>{P_0} = (0,0)$, $[![p]!]^{\\rm B}</em>{P<em>1} = (p,0)$ 以及 $[![p]!]^{\\rm B}</em>{P_2} = (p,0)$。</p>\n<p><img src=\"http://images.yingwai.top/picgo/2vs3ppt3.png\" alt=\"\"></p>\n<p>到了在线阶段，$P<em>1$ 和 $P_2$ 设置它们对 $a$ 的份额，使得它们两方各自的份额之和为 $a$ ：$P_1$ 设 $[a]</em>{P<em>1} = x_0+x_1$，$P_2$ 设 $[a]</em>{P<em>2}=x_2$。然后 $P_1$ 和 $P_2$ 利用离线阶段生成的随机数 $r’$ 对 $[ra]</em>{P_i}$ 进行盲化并发送给 $P_0$（由于 $P_0$ 知道 $x_2$，若不进行盲化则会暴露 $r$ 给 $P_0$），$P_0$ 重构 $ra$ 并设 $q = \\mbox{msb}(ra)$，然后生成 $q$ 在三方中的布尔共享。最后各方在本地计算 $[![\\mbox{msb}(a)]!]^B = [![p]!]^B \\oplus [![q]!]^B$，此时 $a$ 的符号位在三方中是布尔共享的。</p>\n<p><img src=\"http://images.yingwai.top/picgo/2vs3ppt4.png\" alt=\"\"></p>"},{"title":"PyTorch入门60题","date":"2020-05-20T10:50:16.000Z","_content":"\n----\n\n\n\n<!-- more -->\n\n## 张量\n\n导入pytorch包\n\n```python\nimport torch\n```\n\n创建一个空的5x3张量\n\n```python\nx = torch.empty(5, 3)\nprint(x)\n```\n\n创建一个随机初始化的5x3张量\n\n```python\nx = torch.rand(5, 3)\nprint(x)\n```\n\n创建一个5x3的0张量，类型为long\n\n```python\nx = torch.zeros(5, 3, dtype=torch.long)\nprint(x)\n```\n\n直接从数组创建张量\n\n```python\nx = torch.tensor([5.5, 3])\nprint(x)\n```\n\n创建一个5x3的单位张量，类型为double\n\n```python\nx = torch.ones(5, 3, dtype=torch.double)\nprint(x)\n```\n\n从已有的张量创建相同维度的新张量，并且重新定义类型为float\n\n```python\nx = torch.randn_like(x, dtype=torch.float)\nprint(x)\n```\n\n打印一个张量的维度\n\n```python\nprint(x.size())\n```\n\n将两个张量相加\n\n```python\ny = torch.rand(5, 3)\nprint(x + y)\n\n# 方法二\n# print(torch.add(x, y))\n\n# 方法三\n# result = torch.empty(5, 3)\n# torch.add(x, y, out=result)\n# print(result)\n\n# 方法四\n# y.add_(x)\n# print(y)\n```\n\n取张量的第一列\n\n```python\nprint(x[:, 1])\n```\n\n将一个4x4的张量resize成一个一维张量\n\n```python\nx = torch.randn(4, 4)\ny = x.view(16)\nprint(x.size(),y.size())\n```\n\n将一个4x4的张量，resize成一个2x8的张量\n\n```python\ny = x.view(2, 8)\nprint(x.size(),y.size())\n\n# 方法二\nz = x.view(-1, 8) # 确定一个维度，-1的维度会被自动计算\nprint(x.size(),z.size())\n```\n\n从张量中取出数字\n\n```python\nx = torch.randn(1)\nprint(x)\nprint(x.item())\n```\n\n### Numpy的操作\n\n将张量转换成numpy数组\n\n```python\na = torch.ones(5)\nprint(a)\n\nb = a.numpy()\nprint(b)\n```\n\n将张量+1，并观察上题中numpy数组的变化\n\n```python\na.add_(1)\nprint(a)\nprint(b)\n```\n\n从numpy数组创建张量\n\n```python\nimport numpy as np\na = np.ones(5)\nb = torch.from_numpy(a)\nprint(a)\nprint(b)\n```\n\n将numpy数组+1并观察上题中张量的变化\n\n```python\nnp.add(a, 1, out=a)\nprint(a)\nprint(b)\n```\n\n\n\n## 自动微分\n\n### 张量的自动微分\n\n新建一个张量，并设置`requires_grad=True`\n\n```python\nx = torch.ones(2, 2, requires_grad=True)\nprint(x)\n```\n\n对张量进行任意操作（y = x + 2）\n\n```python\ny = x + 2\nprint(y)\nprint(y.grad_fn) # y就多了一个AddBackward\n```\n\n再对y进行任意操作\n\n```python\nz = y * y * 3\nout = z.mean()\n\nprint(z) # z多了MulBackward\nprint(out) # out多了MeanBackward\n```\n\n### 梯度\n\n对out进行反向传播\n\n```python\nout.backward()\n```\n\n打印梯度d(out)/dx\n\n```python\nprint(x.grad) #out=0.25*Σ3(x+2)^2\n```\n\n创建一个结果为矢量的计算过程（y=x*2^n）\n\n```python\nx = torch.randn(3, requires_grad=True)\n\ny = x * 2\nwhile y.data.norm() < 1000:\n    y = y * 2\n\nprint(y)\n```\n\n计算`v = [0.``1, 1.0, 0.0001]`处的梯度\n\n```python\nv = torch.tensor([0.1, 1.0, 0.0001], dtype=torch.float)\ny.backward(v)\n\nprint(x.grad)\n```\n\n关闭梯度的功能\n\n```python\nprint(x.requires_grad)\nprint((x ** 2).requires_grad)\n\nwith torch.no_grad():\n    print((x ** 2).requires_grad)\n    \n# 方法二\n# print(x.requires_grad)\n# y = x.detach()\n# print(y.requires_grad)\n# print(x.eq(y).all())\n```\n\n\n\n## 神经网络\n\npytorch实现LeNet5，结构如下所示\n\n![](http://images.yingwai.top/picgo/pytorch60f1.png)\n\n```python\nimport torch\nimport torch.nn as nn\nimport torch.nn.functional as F\n\n\nclass Net(nn.Module):\n\n    def __init__(self):\n        super(Net, self).__init__()\n        # 26.定义①的卷积层，输入为32x32的图像，卷积核大小5x5卷积核种类6\n        self.conv1 = nn.Conv2d(3, 6, 5)\n        # 27.定义③的卷积层，输入为前一层6个特征，卷积核大小5x5，卷积核种类16\n        self.conv2 = nn.Conv2d(6, 16, 5)\n        # 28.定义⑤的全链接层，输入为16*5*5，输出为120\n        self.fc1 = nn.Linear(16 * 5 * 5, 120)  # 6*6 from image dimension\n        # 29.定义⑥的全连接层，输入为120，输出为84\n        self.fc2 = nn.Linear(120, 84)\n        # 30.定义⑥的全连接层，输入为84，输出为10\n        self.fc3 = nn.Linear(84, 10)\n\n    def forward(self, x):\n        # 31.完成input-S2，先卷积+relu，再2x2下采样\n        x = F.max_pool2d(F.relu(self.conv1(x)), (2, 2))\n        # 32.完成S2-S4，先卷积+relu，再2x2下采样\n        x = F.max_pool2d(F.relu(self.conv2(x)), 2) #卷积核方形时，可以只写一个维度\n        # 33.将特征向量扁平成列向量\n        x = x.view(-1, 16 * 5 * 5)\n        # 34.使用fc1+relu\n        x = F.relu(self.fc1(x))\n        # 35.使用fc2+relu\n        x = F.relu(self.fc2(x))\n        # 36.使用fc3\n        x = self.fc3(x)\n        return x\n\n\nnet = Net()\nprint(net)\n```\n\n打印网络的参数\n\n```python\nparams = list(net.parameters())\n# print(params)\nprint(len(params))\n```\n\n打印某一层参数的形状\n\n```python\nprint(params[0].size())\n```\n\n随机输入一个向量，查看前向传播输出\n\n```python\ninput = torch.randn(1, 1, 32, 32)\nout = net(input)\nprint(out)\n```\n\n将梯度初始化\n\n```python\nnet.zero_grad()\n```\n\n随机一个梯度进行反向传播\n\n```python\nout.backward(torch.randn(1, 10))\n```\n\n### 损失函数\n\n用自带的MSELoss()定义损失函数\n\n```python\ncriterion = nn.MSELoss()\n```\n\n随机一个真值，并用随机的输入计算损失\n\n```python\ntarget = torch.randn(10)  # 随机真值\ntarget = target.view(1, -1)  # 变成列向量\n\noutput = net(input)  # 用随机输入计算输出\n\nloss = criterion(output, target)  # 计算损失\nprint(loss)\n```\n\n将梯度初始化，计算上一步中loss的反向传播\n\n```python\nnet.zero_grad()\n\nprint('conv1.bias.grad before backward')\nprint(net.conv1.bias.grad)\n```\n\n计算43中loss的反向传播\n\n```python\nloss.backward()\n\nprint('conv1.bias.grad after backward')\nprint(net.conv1.bias.grad)\n```\n\n### 更新权重\n\n定义SGD优化器算法，学习率设置为0.01\n\n```python\nimport torch.optim as optim\noptimizer = optim.SGD(net.parameters(), lr=0.01)\n```\n\n使用优化器更新权重\n\n```python\noptimizer.zero_grad()\noutput = net(input)\nloss = criterion(output, target)\nloss.backward()\n\n# 更新权重\noptimizer.step()\n```\n\n\n\n## 训练一个分类器\n\n### 读取CIFAR10数据，做标准化\n\n构造一个transform，将三通道(0,1)区间的数据转换成(-1,1)的数据\n\n```python\nimport torchvision\nimport torchvision.transforms as transforms\n\ntransform = transforms.Compose(\n    [transforms.ToTensor(),\n     transforms.Normalize((0.5, 0.5, 0.5), (0.5, 0.5, 0.5))])\n```\n\n读取数据集\n\n```python\ntrainset = cifar(root = './input/cifar10', segmentation='train', transforms=transform)\ntestset = cifar(root = './input/cifar10', segmentation='test', transforms=transform)\ntrainloader = torch.utils.data.DataLoader(trainset, batch_size=batch_size,shuffle=True, num_workers=2)\ntestloader = torch.utils.data.DataLoader(testset, batch_size=batch_size,shuffle=False, num_workers=2)\n\nclasses = ('plane', 'car', 'bird', 'cat',\n           'deer', 'dog', 'frog', 'horse', 'ship', 'truck')\n```\n\n### 建立网络\n\n这部分沿用前面的网络\n\n```python\nnet2 = Net()\n```\n\n### 定义损失函数和优化器\n\n定义交叉熵损失函数\n\n```python\ncriterion2 = nn.CrossEntropyLoss()\n```\n\n定义SGD优化器算法，学习率设置为0.001，`momentum=0.9`\n\n```python\noptimizer2 = optim.SGD(net2.parameters(), lr=0.001, momentum=0.9)\n```\n\n### 训练网络\n\n```python\nfor epoch in range(2):\n\n    running_loss = 0.0\n    for i, data in enumerate(trainloader, 0):\n        # 获取X,y对\n        inputs, labels = data\n\n        # 51.初始化梯度\n        optimizer2.zero_grad()\n\n        # 52.前馈\n        outputs = net2(inputs)\n        # 53.计算损失\n        loss = criterion2(outputs, labels)\n        # 54.计算梯度\n        loss.backward()\n        # 55.更新权值\n        optimizer2.step()\n\n        # 每2000个数据打印平均代价函数值\n        running_loss += loss.item()\n        if i % 2000 == 1999:    # print every 2000 mini-batches\n            print('[%d, %5d] loss: %.3f' %\n                  (epoch + 1, i + 1, running_loss / 2000))\n            running_loss = 0.0\n\nprint('Finished Training')\n```\n\n### 使用模型预测\n\n取一些数据\n\n```python\ndataiter = iter(testloader)\nimages, labels = dataiter.next()\n\n# print images\nimshow(torchvision.utils.make_grid(images))\nprint('GroundTruth: ', ' '.join('%5s' % classes[labels[j]] for j in range(4)))\n```\n\n使用模型预测\n\n```python\noutputs = net2(images)\n\n_, predicted = torch.max(outputs, 1)\n\nprint('Predicted: ', ' '.join('%5s' % classes[predicted[j]]\n                              for j in range(4)))\n```\n\n在测试集上进行打分\n\n```python\ncorrect = 0\ntotal = 0\nwith torch.no_grad():\n    for data in testloader:\n        images, labels = data\n        outputs = net2(images)\n        _, predicted = torch.max(outputs.data, 1)\n        total += labels.size(0)\n        correct += (predicted == labels).sum().item()\n\nprint('Accuracy of the network on the 10000 test images: %d %%' % (\n    100 * correct / total))\n```\n\n### 存取模型\n\n保存训练好的模型\n\n```python\nPATH = './cifar_net.pth'\ntorch.save(net.state_dict(), PATH)\n```\n\n读取保存的模型\n\n```python\npretrained_net = torch.load(PATH)\n```\n\n加载模型\n\n```python\nnet3 = Net()\nnet3.load_state_dict(pretrained_net)\n```","source":"_posts/PyTorch入门60题.md","raw":"---\ntitle: PyTorch入门60题\ndate: 2020-05-20 18:50:16\ncategories: Coding\ntags: [Python, PyTorch]\n---\n\n----\n\n\n\n<!-- more -->\n\n## 张量\n\n导入pytorch包\n\n```python\nimport torch\n```\n\n创建一个空的5x3张量\n\n```python\nx = torch.empty(5, 3)\nprint(x)\n```\n\n创建一个随机初始化的5x3张量\n\n```python\nx = torch.rand(5, 3)\nprint(x)\n```\n\n创建一个5x3的0张量，类型为long\n\n```python\nx = torch.zeros(5, 3, dtype=torch.long)\nprint(x)\n```\n\n直接从数组创建张量\n\n```python\nx = torch.tensor([5.5, 3])\nprint(x)\n```\n\n创建一个5x3的单位张量，类型为double\n\n```python\nx = torch.ones(5, 3, dtype=torch.double)\nprint(x)\n```\n\n从已有的张量创建相同维度的新张量，并且重新定义类型为float\n\n```python\nx = torch.randn_like(x, dtype=torch.float)\nprint(x)\n```\n\n打印一个张量的维度\n\n```python\nprint(x.size())\n```\n\n将两个张量相加\n\n```python\ny = torch.rand(5, 3)\nprint(x + y)\n\n# 方法二\n# print(torch.add(x, y))\n\n# 方法三\n# result = torch.empty(5, 3)\n# torch.add(x, y, out=result)\n# print(result)\n\n# 方法四\n# y.add_(x)\n# print(y)\n```\n\n取张量的第一列\n\n```python\nprint(x[:, 1])\n```\n\n将一个4x4的张量resize成一个一维张量\n\n```python\nx = torch.randn(4, 4)\ny = x.view(16)\nprint(x.size(),y.size())\n```\n\n将一个4x4的张量，resize成一个2x8的张量\n\n```python\ny = x.view(2, 8)\nprint(x.size(),y.size())\n\n# 方法二\nz = x.view(-1, 8) # 确定一个维度，-1的维度会被自动计算\nprint(x.size(),z.size())\n```\n\n从张量中取出数字\n\n```python\nx = torch.randn(1)\nprint(x)\nprint(x.item())\n```\n\n### Numpy的操作\n\n将张量转换成numpy数组\n\n```python\na = torch.ones(5)\nprint(a)\n\nb = a.numpy()\nprint(b)\n```\n\n将张量+1，并观察上题中numpy数组的变化\n\n```python\na.add_(1)\nprint(a)\nprint(b)\n```\n\n从numpy数组创建张量\n\n```python\nimport numpy as np\na = np.ones(5)\nb = torch.from_numpy(a)\nprint(a)\nprint(b)\n```\n\n将numpy数组+1并观察上题中张量的变化\n\n```python\nnp.add(a, 1, out=a)\nprint(a)\nprint(b)\n```\n\n\n\n## 自动微分\n\n### 张量的自动微分\n\n新建一个张量，并设置`requires_grad=True`\n\n```python\nx = torch.ones(2, 2, requires_grad=True)\nprint(x)\n```\n\n对张量进行任意操作（y = x + 2）\n\n```python\ny = x + 2\nprint(y)\nprint(y.grad_fn) # y就多了一个AddBackward\n```\n\n再对y进行任意操作\n\n```python\nz = y * y * 3\nout = z.mean()\n\nprint(z) # z多了MulBackward\nprint(out) # out多了MeanBackward\n```\n\n### 梯度\n\n对out进行反向传播\n\n```python\nout.backward()\n```\n\n打印梯度d(out)/dx\n\n```python\nprint(x.grad) #out=0.25*Σ3(x+2)^2\n```\n\n创建一个结果为矢量的计算过程（y=x*2^n）\n\n```python\nx = torch.randn(3, requires_grad=True)\n\ny = x * 2\nwhile y.data.norm() < 1000:\n    y = y * 2\n\nprint(y)\n```\n\n计算`v = [0.``1, 1.0, 0.0001]`处的梯度\n\n```python\nv = torch.tensor([0.1, 1.0, 0.0001], dtype=torch.float)\ny.backward(v)\n\nprint(x.grad)\n```\n\n关闭梯度的功能\n\n```python\nprint(x.requires_grad)\nprint((x ** 2).requires_grad)\n\nwith torch.no_grad():\n    print((x ** 2).requires_grad)\n    \n# 方法二\n# print(x.requires_grad)\n# y = x.detach()\n# print(y.requires_grad)\n# print(x.eq(y).all())\n```\n\n\n\n## 神经网络\n\npytorch实现LeNet5，结构如下所示\n\n![](http://images.yingwai.top/picgo/pytorch60f1.png)\n\n```python\nimport torch\nimport torch.nn as nn\nimport torch.nn.functional as F\n\n\nclass Net(nn.Module):\n\n    def __init__(self):\n        super(Net, self).__init__()\n        # 26.定义①的卷积层，输入为32x32的图像，卷积核大小5x5卷积核种类6\n        self.conv1 = nn.Conv2d(3, 6, 5)\n        # 27.定义③的卷积层，输入为前一层6个特征，卷积核大小5x5，卷积核种类16\n        self.conv2 = nn.Conv2d(6, 16, 5)\n        # 28.定义⑤的全链接层，输入为16*5*5，输出为120\n        self.fc1 = nn.Linear(16 * 5 * 5, 120)  # 6*6 from image dimension\n        # 29.定义⑥的全连接层，输入为120，输出为84\n        self.fc2 = nn.Linear(120, 84)\n        # 30.定义⑥的全连接层，输入为84，输出为10\n        self.fc3 = nn.Linear(84, 10)\n\n    def forward(self, x):\n        # 31.完成input-S2，先卷积+relu，再2x2下采样\n        x = F.max_pool2d(F.relu(self.conv1(x)), (2, 2))\n        # 32.完成S2-S4，先卷积+relu，再2x2下采样\n        x = F.max_pool2d(F.relu(self.conv2(x)), 2) #卷积核方形时，可以只写一个维度\n        # 33.将特征向量扁平成列向量\n        x = x.view(-1, 16 * 5 * 5)\n        # 34.使用fc1+relu\n        x = F.relu(self.fc1(x))\n        # 35.使用fc2+relu\n        x = F.relu(self.fc2(x))\n        # 36.使用fc3\n        x = self.fc3(x)\n        return x\n\n\nnet = Net()\nprint(net)\n```\n\n打印网络的参数\n\n```python\nparams = list(net.parameters())\n# print(params)\nprint(len(params))\n```\n\n打印某一层参数的形状\n\n```python\nprint(params[0].size())\n```\n\n随机输入一个向量，查看前向传播输出\n\n```python\ninput = torch.randn(1, 1, 32, 32)\nout = net(input)\nprint(out)\n```\n\n将梯度初始化\n\n```python\nnet.zero_grad()\n```\n\n随机一个梯度进行反向传播\n\n```python\nout.backward(torch.randn(1, 10))\n```\n\n### 损失函数\n\n用自带的MSELoss()定义损失函数\n\n```python\ncriterion = nn.MSELoss()\n```\n\n随机一个真值，并用随机的输入计算损失\n\n```python\ntarget = torch.randn(10)  # 随机真值\ntarget = target.view(1, -1)  # 变成列向量\n\noutput = net(input)  # 用随机输入计算输出\n\nloss = criterion(output, target)  # 计算损失\nprint(loss)\n```\n\n将梯度初始化，计算上一步中loss的反向传播\n\n```python\nnet.zero_grad()\n\nprint('conv1.bias.grad before backward')\nprint(net.conv1.bias.grad)\n```\n\n计算43中loss的反向传播\n\n```python\nloss.backward()\n\nprint('conv1.bias.grad after backward')\nprint(net.conv1.bias.grad)\n```\n\n### 更新权重\n\n定义SGD优化器算法，学习率设置为0.01\n\n```python\nimport torch.optim as optim\noptimizer = optim.SGD(net.parameters(), lr=0.01)\n```\n\n使用优化器更新权重\n\n```python\noptimizer.zero_grad()\noutput = net(input)\nloss = criterion(output, target)\nloss.backward()\n\n# 更新权重\noptimizer.step()\n```\n\n\n\n## 训练一个分类器\n\n### 读取CIFAR10数据，做标准化\n\n构造一个transform，将三通道(0,1)区间的数据转换成(-1,1)的数据\n\n```python\nimport torchvision\nimport torchvision.transforms as transforms\n\ntransform = transforms.Compose(\n    [transforms.ToTensor(),\n     transforms.Normalize((0.5, 0.5, 0.5), (0.5, 0.5, 0.5))])\n```\n\n读取数据集\n\n```python\ntrainset = cifar(root = './input/cifar10', segmentation='train', transforms=transform)\ntestset = cifar(root = './input/cifar10', segmentation='test', transforms=transform)\ntrainloader = torch.utils.data.DataLoader(trainset, batch_size=batch_size,shuffle=True, num_workers=2)\ntestloader = torch.utils.data.DataLoader(testset, batch_size=batch_size,shuffle=False, num_workers=2)\n\nclasses = ('plane', 'car', 'bird', 'cat',\n           'deer', 'dog', 'frog', 'horse', 'ship', 'truck')\n```\n\n### 建立网络\n\n这部分沿用前面的网络\n\n```python\nnet2 = Net()\n```\n\n### 定义损失函数和优化器\n\n定义交叉熵损失函数\n\n```python\ncriterion2 = nn.CrossEntropyLoss()\n```\n\n定义SGD优化器算法，学习率设置为0.001，`momentum=0.9`\n\n```python\noptimizer2 = optim.SGD(net2.parameters(), lr=0.001, momentum=0.9)\n```\n\n### 训练网络\n\n```python\nfor epoch in range(2):\n\n    running_loss = 0.0\n    for i, data in enumerate(trainloader, 0):\n        # 获取X,y对\n        inputs, labels = data\n\n        # 51.初始化梯度\n        optimizer2.zero_grad()\n\n        # 52.前馈\n        outputs = net2(inputs)\n        # 53.计算损失\n        loss = criterion2(outputs, labels)\n        # 54.计算梯度\n        loss.backward()\n        # 55.更新权值\n        optimizer2.step()\n\n        # 每2000个数据打印平均代价函数值\n        running_loss += loss.item()\n        if i % 2000 == 1999:    # print every 2000 mini-batches\n            print('[%d, %5d] loss: %.3f' %\n                  (epoch + 1, i + 1, running_loss / 2000))\n            running_loss = 0.0\n\nprint('Finished Training')\n```\n\n### 使用模型预测\n\n取一些数据\n\n```python\ndataiter = iter(testloader)\nimages, labels = dataiter.next()\n\n# print images\nimshow(torchvision.utils.make_grid(images))\nprint('GroundTruth: ', ' '.join('%5s' % classes[labels[j]] for j in range(4)))\n```\n\n使用模型预测\n\n```python\noutputs = net2(images)\n\n_, predicted = torch.max(outputs, 1)\n\nprint('Predicted: ', ' '.join('%5s' % classes[predicted[j]]\n                              for j in range(4)))\n```\n\n在测试集上进行打分\n\n```python\ncorrect = 0\ntotal = 0\nwith torch.no_grad():\n    for data in testloader:\n        images, labels = data\n        outputs = net2(images)\n        _, predicted = torch.max(outputs.data, 1)\n        total += labels.size(0)\n        correct += (predicted == labels).sum().item()\n\nprint('Accuracy of the network on the 10000 test images: %d %%' % (\n    100 * correct / total))\n```\n\n### 存取模型\n\n保存训练好的模型\n\n```python\nPATH = './cifar_net.pth'\ntorch.save(net.state_dict(), PATH)\n```\n\n读取保存的模型\n\n```python\npretrained_net = torch.load(PATH)\n```\n\n加载模型\n\n```python\nnet3 = Net()\nnet3.load_state_dict(pretrained_net)\n```","slug":"PyTorch入门60题","published":1,"updated":"2020-08-23T14:33:37.430Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cke79q4p5000l88ps7hj78kqc","content":"<hr>\n<a id=\"more\"></a>\n<h2 id=\"张量\"><a href=\"#张量\" class=\"headerlink\" title=\"张量\"></a>张量</h2><p>导入pytorch包</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> torch</span><br></pre></td></tr></table></figure>\n<p>创建一个空的5x3张量</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x = torch.empty(<span class=\"number\">5</span>, <span class=\"number\">3</span>)</span><br><span class=\"line\">print(x)</span><br></pre></td></tr></table></figure>\n<p>创建一个随机初始化的5x3张量</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x = torch.rand(<span class=\"number\">5</span>, <span class=\"number\">3</span>)</span><br><span class=\"line\">print(x)</span><br></pre></td></tr></table></figure>\n<p>创建一个5x3的0张量，类型为long</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x = torch.zeros(<span class=\"number\">5</span>, <span class=\"number\">3</span>, dtype=torch.long)</span><br><span class=\"line\">print(x)</span><br></pre></td></tr></table></figure>\n<p>直接从数组创建张量</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x = torch.tensor([<span class=\"number\">5.5</span>, <span class=\"number\">3</span>])</span><br><span class=\"line\">print(x)</span><br></pre></td></tr></table></figure>\n<p>创建一个5x3的单位张量，类型为double</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x = torch.ones(<span class=\"number\">5</span>, <span class=\"number\">3</span>, dtype=torch.double)</span><br><span class=\"line\">print(x)</span><br></pre></td></tr></table></figure>\n<p>从已有的张量创建相同维度的新张量，并且重新定义类型为float</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x = torch.randn_like(x, dtype=torch.float)</span><br><span class=\"line\">print(x)</span><br></pre></td></tr></table></figure>\n<p>打印一个张量的维度</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">print(x.size())</span><br></pre></td></tr></table></figure>\n<p>将两个张量相加</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">y = torch.rand(<span class=\"number\">5</span>, <span class=\"number\">3</span>)</span><br><span class=\"line\">print(x + y)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 方法二</span></span><br><span class=\"line\"><span class=\"comment\"># print(torch.add(x, y))</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 方法三</span></span><br><span class=\"line\"><span class=\"comment\"># result = torch.empty(5, 3)</span></span><br><span class=\"line\"><span class=\"comment\"># torch.add(x, y, out=result)</span></span><br><span class=\"line\"><span class=\"comment\"># print(result)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 方法四</span></span><br><span class=\"line\"><span class=\"comment\"># y.add_(x)</span></span><br><span class=\"line\"><span class=\"comment\"># print(y)</span></span><br></pre></td></tr></table></figure>\n<p>取张量的第一列</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">print(x[:, <span class=\"number\">1</span>])</span><br></pre></td></tr></table></figure>\n<p>将一个4x4的张量resize成一个一维张量</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x = torch.randn(<span class=\"number\">4</span>, <span class=\"number\">4</span>)</span><br><span class=\"line\">y = x.view(<span class=\"number\">16</span>)</span><br><span class=\"line\">print(x.size(),y.size())</span><br></pre></td></tr></table></figure>\n<p>将一个4x4的张量，resize成一个2x8的张量</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">y = x.view(<span class=\"number\">2</span>, <span class=\"number\">8</span>)</span><br><span class=\"line\">print(x.size(),y.size())</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 方法二</span></span><br><span class=\"line\">z = x.view(<span class=\"number\">-1</span>, <span class=\"number\">8</span>) <span class=\"comment\"># 确定一个维度，-1的维度会被自动计算</span></span><br><span class=\"line\">print(x.size(),z.size())</span><br></pre></td></tr></table></figure>\n<p>从张量中取出数字</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x = torch.randn(<span class=\"number\">1</span>)</span><br><span class=\"line\">print(x)</span><br><span class=\"line\">print(x.item())</span><br></pre></td></tr></table></figure>\n<h3 id=\"Numpy的操作\"><a href=\"#Numpy的操作\" class=\"headerlink\" title=\"Numpy的操作\"></a>Numpy的操作</h3><p>将张量转换成numpy数组</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a = torch.ones(<span class=\"number\">5</span>)</span><br><span class=\"line\">print(a)</span><br><span class=\"line\"></span><br><span class=\"line\">b = a.numpy()</span><br><span class=\"line\">print(b)</span><br></pre></td></tr></table></figure>\n<p>将张量+1，并观察上题中numpy数组的变化</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a.add_(<span class=\"number\">1</span>)</span><br><span class=\"line\">print(a)</span><br><span class=\"line\">print(b)</span><br></pre></td></tr></table></figure>\n<p>从numpy数组创建张量</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\">a = np.ones(<span class=\"number\">5</span>)</span><br><span class=\"line\">b = torch.from_numpy(a)</span><br><span class=\"line\">print(a)</span><br><span class=\"line\">print(b)</span><br></pre></td></tr></table></figure>\n<p>将numpy数组+1并观察上题中张量的变化</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">np.add(a, <span class=\"number\">1</span>, out=a)</span><br><span class=\"line\">print(a)</span><br><span class=\"line\">print(b)</span><br></pre></td></tr></table></figure>\n<h2 id=\"自动微分\"><a href=\"#自动微分\" class=\"headerlink\" title=\"自动微分\"></a>自动微分</h2><h3 id=\"张量的自动微分\"><a href=\"#张量的自动微分\" class=\"headerlink\" title=\"张量的自动微分\"></a>张量的自动微分</h3><p>新建一个张量，并设置<code>requires_grad=True</code></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x = torch.ones(<span class=\"number\">2</span>, <span class=\"number\">2</span>, requires_grad=<span class=\"literal\">True</span>)</span><br><span class=\"line\">print(x)</span><br></pre></td></tr></table></figure>\n<p>对张量进行任意操作（y = x + 2）</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">y = x + <span class=\"number\">2</span></span><br><span class=\"line\">print(y)</span><br><span class=\"line\">print(y.grad_fn) <span class=\"comment\"># y就多了一个AddBackward</span></span><br></pre></td></tr></table></figure>\n<p>再对y进行任意操作</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">z = y * y * <span class=\"number\">3</span></span><br><span class=\"line\">out = z.mean()</span><br><span class=\"line\"></span><br><span class=\"line\">print(z) <span class=\"comment\"># z多了MulBackward</span></span><br><span class=\"line\">print(out) <span class=\"comment\"># out多了MeanBackward</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"梯度\"><a href=\"#梯度\" class=\"headerlink\" title=\"梯度\"></a>梯度</h3><p>对out进行反向传播</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">out.backward()</span><br></pre></td></tr></table></figure>\n<p>打印梯度d(out)/dx</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">print(x.grad) <span class=\"comment\">#out=0.25*Σ3(x+2)^2</span></span><br></pre></td></tr></table></figure>\n<p>创建一个结果为矢量的计算过程（y=x*2^n）</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x = torch.randn(<span class=\"number\">3</span>, requires_grad=<span class=\"literal\">True</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">y = x * <span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"keyword\">while</span> y.data.norm() &lt; <span class=\"number\">1000</span>:</span><br><span class=\"line\">    y = y * <span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\">print(y)</span><br></pre></td></tr></table></figure>\n<p>计算<code>v = [0.``1, 1.0, 0.0001]</code>处的梯度</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">v = torch.tensor([<span class=\"number\">0.1</span>, <span class=\"number\">1.0</span>, <span class=\"number\">0.0001</span>], dtype=torch.float)</span><br><span class=\"line\">y.backward(v)</span><br><span class=\"line\"></span><br><span class=\"line\">print(x.grad)</span><br></pre></td></tr></table></figure>\n<p>关闭梯度的功能</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">print(x.requires_grad)</span><br><span class=\"line\">print((x ** <span class=\"number\">2</span>).requires_grad)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">with</span> torch.no_grad():</span><br><span class=\"line\">    print((x ** <span class=\"number\">2</span>).requires_grad)</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\"># 方法二</span></span><br><span class=\"line\"><span class=\"comment\"># print(x.requires_grad)</span></span><br><span class=\"line\"><span class=\"comment\"># y = x.detach()</span></span><br><span class=\"line\"><span class=\"comment\"># print(y.requires_grad)</span></span><br><span class=\"line\"><span class=\"comment\"># print(x.eq(y).all())</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"神经网络\"><a href=\"#神经网络\" class=\"headerlink\" title=\"神经网络\"></a>神经网络</h2><p>pytorch实现LeNet5，结构如下所示</p>\n<p><img src=\"http://images.yingwai.top/picgo/pytorch60f1.png\" alt=\"\"></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> torch</span><br><span class=\"line\"><span class=\"keyword\">import</span> torch.nn <span class=\"keyword\">as</span> nn</span><br><span class=\"line\"><span class=\"keyword\">import</span> torch.nn.functional <span class=\"keyword\">as</span> F</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Net</span><span class=\"params\">(nn.Module)</span>:</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        super(Net, self).__init__()</span><br><span class=\"line\">        <span class=\"comment\"># 26.定义①的卷积层，输入为32x32的图像，卷积核大小5x5卷积核种类6</span></span><br><span class=\"line\">        self.conv1 = nn.Conv2d(<span class=\"number\">3</span>, <span class=\"number\">6</span>, <span class=\"number\">5</span>)</span><br><span class=\"line\">        <span class=\"comment\"># 27.定义③的卷积层，输入为前一层6个特征，卷积核大小5x5，卷积核种类16</span></span><br><span class=\"line\">        self.conv2 = nn.Conv2d(<span class=\"number\">6</span>, <span class=\"number\">16</span>, <span class=\"number\">5</span>)</span><br><span class=\"line\">        <span class=\"comment\"># 28.定义⑤的全链接层，输入为16*5*5，输出为120</span></span><br><span class=\"line\">        self.fc1 = nn.Linear(<span class=\"number\">16</span> * <span class=\"number\">5</span> * <span class=\"number\">5</span>, <span class=\"number\">120</span>)  <span class=\"comment\"># 6*6 from image dimension</span></span><br><span class=\"line\">        <span class=\"comment\"># 29.定义⑥的全连接层，输入为120，输出为84</span></span><br><span class=\"line\">        self.fc2 = nn.Linear(<span class=\"number\">120</span>, <span class=\"number\">84</span>)</span><br><span class=\"line\">        <span class=\"comment\"># 30.定义⑥的全连接层，输入为84，输出为10</span></span><br><span class=\"line\">        self.fc3 = nn.Linear(<span class=\"number\">84</span>, <span class=\"number\">10</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">forward</span><span class=\"params\">(self, x)</span>:</span></span><br><span class=\"line\">        <span class=\"comment\"># 31.完成input-S2，先卷积+relu，再2x2下采样</span></span><br><span class=\"line\">        x = F.max_pool2d(F.relu(self.conv1(x)), (<span class=\"number\">2</span>, <span class=\"number\">2</span>))</span><br><span class=\"line\">        <span class=\"comment\"># 32.完成S2-S4，先卷积+relu，再2x2下采样</span></span><br><span class=\"line\">        x = F.max_pool2d(F.relu(self.conv2(x)), <span class=\"number\">2</span>) <span class=\"comment\">#卷积核方形时，可以只写一个维度</span></span><br><span class=\"line\">        <span class=\"comment\"># 33.将特征向量扁平成列向量</span></span><br><span class=\"line\">        x = x.view(<span class=\"number\">-1</span>, <span class=\"number\">16</span> * <span class=\"number\">5</span> * <span class=\"number\">5</span>)</span><br><span class=\"line\">        <span class=\"comment\"># 34.使用fc1+relu</span></span><br><span class=\"line\">        x = F.relu(self.fc1(x))</span><br><span class=\"line\">        <span class=\"comment\"># 35.使用fc2+relu</span></span><br><span class=\"line\">        x = F.relu(self.fc2(x))</span><br><span class=\"line\">        <span class=\"comment\"># 36.使用fc3</span></span><br><span class=\"line\">        x = self.fc3(x)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> x</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">net = Net()</span><br><span class=\"line\">print(net)</span><br></pre></td></tr></table></figure>\n<p>打印网络的参数</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">params = list(net.parameters())</span><br><span class=\"line\"><span class=\"comment\"># print(params)</span></span><br><span class=\"line\">print(len(params))</span><br></pre></td></tr></table></figure>\n<p>打印某一层参数的形状</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">print(params[<span class=\"number\">0</span>].size())</span><br></pre></td></tr></table></figure>\n<p>随机输入一个向量，查看前向传播输出</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">input = torch.randn(<span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">32</span>, <span class=\"number\">32</span>)</span><br><span class=\"line\">out = net(input)</span><br><span class=\"line\">print(out)</span><br></pre></td></tr></table></figure>\n<p>将梯度初始化</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">net.zero_grad()</span><br></pre></td></tr></table></figure>\n<p>随机一个梯度进行反向传播</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">out.backward(torch.randn(<span class=\"number\">1</span>, <span class=\"number\">10</span>))</span><br></pre></td></tr></table></figure>\n<h3 id=\"损失函数\"><a href=\"#损失函数\" class=\"headerlink\" title=\"损失函数\"></a>损失函数</h3><p>用自带的MSELoss()定义损失函数</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">criterion = nn.MSELoss()</span><br></pre></td></tr></table></figure>\n<p>随机一个真值，并用随机的输入计算损失</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">target = torch.randn(<span class=\"number\">10</span>)  <span class=\"comment\"># 随机真值</span></span><br><span class=\"line\">target = target.view(<span class=\"number\">1</span>, <span class=\"number\">-1</span>)  <span class=\"comment\"># 变成列向量</span></span><br><span class=\"line\"></span><br><span class=\"line\">output = net(input)  <span class=\"comment\"># 用随机输入计算输出</span></span><br><span class=\"line\"></span><br><span class=\"line\">loss = criterion(output, target)  <span class=\"comment\"># 计算损失</span></span><br><span class=\"line\">print(loss)</span><br></pre></td></tr></table></figure>\n<p>将梯度初始化，计算上一步中loss的反向传播</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">net.zero_grad()</span><br><span class=\"line\"></span><br><span class=\"line\">print(<span class=\"string\">'conv1.bias.grad before backward'</span>)</span><br><span class=\"line\">print(net.conv1.bias.grad)</span><br></pre></td></tr></table></figure>\n<p>计算43中loss的反向传播</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">loss.backward()</span><br><span class=\"line\"></span><br><span class=\"line\">print(<span class=\"string\">'conv1.bias.grad after backward'</span>)</span><br><span class=\"line\">print(net.conv1.bias.grad)</span><br></pre></td></tr></table></figure>\n<h3 id=\"更新权重\"><a href=\"#更新权重\" class=\"headerlink\" title=\"更新权重\"></a>更新权重</h3><p>定义SGD优化器算法，学习率设置为0.01</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> torch.optim <span class=\"keyword\">as</span> optim</span><br><span class=\"line\">optimizer = optim.SGD(net.parameters(), lr=<span class=\"number\">0.01</span>)</span><br></pre></td></tr></table></figure>\n<p>使用优化器更新权重</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">optimizer.zero_grad()</span><br><span class=\"line\">output = net(input)</span><br><span class=\"line\">loss = criterion(output, target)</span><br><span class=\"line\">loss.backward()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 更新权重</span></span><br><span class=\"line\">optimizer.step()</span><br></pre></td></tr></table></figure>\n<h2 id=\"训练一个分类器\"><a href=\"#训练一个分类器\" class=\"headerlink\" title=\"训练一个分类器\"></a>训练一个分类器</h2><h3 id=\"读取CIFAR10数据，做标准化\"><a href=\"#读取CIFAR10数据，做标准化\" class=\"headerlink\" title=\"读取CIFAR10数据，做标准化\"></a>读取CIFAR10数据，做标准化</h3><p>构造一个transform，将三通道(0,1)区间的数据转换成(-1,1)的数据</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> torchvision</span><br><span class=\"line\"><span class=\"keyword\">import</span> torchvision.transforms <span class=\"keyword\">as</span> transforms</span><br><span class=\"line\"></span><br><span class=\"line\">transform = transforms.Compose(</span><br><span class=\"line\">    [transforms.ToTensor(),</span><br><span class=\"line\">     transforms.Normalize((<span class=\"number\">0.5</span>, <span class=\"number\">0.5</span>, <span class=\"number\">0.5</span>), (<span class=\"number\">0.5</span>, <span class=\"number\">0.5</span>, <span class=\"number\">0.5</span>))])</span><br></pre></td></tr></table></figure>\n<p>读取数据集</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">trainset = cifar(root = <span class=\"string\">'./input/cifar10'</span>, segmentation=<span class=\"string\">'train'</span>, transforms=transform)</span><br><span class=\"line\">testset = cifar(root = <span class=\"string\">'./input/cifar10'</span>, segmentation=<span class=\"string\">'test'</span>, transforms=transform)</span><br><span class=\"line\">trainloader = torch.utils.data.DataLoader(trainset, batch_size=batch_size,shuffle=<span class=\"literal\">True</span>, num_workers=<span class=\"number\">2</span>)</span><br><span class=\"line\">testloader = torch.utils.data.DataLoader(testset, batch_size=batch_size,shuffle=<span class=\"literal\">False</span>, num_workers=<span class=\"number\">2</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">classes = (<span class=\"string\">'plane'</span>, <span class=\"string\">'car'</span>, <span class=\"string\">'bird'</span>, <span class=\"string\">'cat'</span>,</span><br><span class=\"line\">           <span class=\"string\">'deer'</span>, <span class=\"string\">'dog'</span>, <span class=\"string\">'frog'</span>, <span class=\"string\">'horse'</span>, <span class=\"string\">'ship'</span>, <span class=\"string\">'truck'</span>)</span><br></pre></td></tr></table></figure>\n<h3 id=\"建立网络\"><a href=\"#建立网络\" class=\"headerlink\" title=\"建立网络\"></a>建立网络</h3><p>这部分沿用前面的网络</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">net2 = Net()</span><br></pre></td></tr></table></figure>\n<h3 id=\"定义损失函数和优化器\"><a href=\"#定义损失函数和优化器\" class=\"headerlink\" title=\"定义损失函数和优化器\"></a>定义损失函数和优化器</h3><p>定义交叉熵损失函数</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">criterion2 = nn.CrossEntropyLoss()</span><br></pre></td></tr></table></figure>\n<p>定义SGD优化器算法，学习率设置为0.001，<code>momentum=0.9</code></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">optimizer2 = optim.SGD(net2.parameters(), lr=<span class=\"number\">0.001</span>, momentum=<span class=\"number\">0.9</span>)</span><br></pre></td></tr></table></figure>\n<h3 id=\"训练网络\"><a href=\"#训练网络\" class=\"headerlink\" title=\"训练网络\"></a>训练网络</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> epoch <span class=\"keyword\">in</span> range(<span class=\"number\">2</span>):</span><br><span class=\"line\"></span><br><span class=\"line\">    running_loss = <span class=\"number\">0.0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i, data <span class=\"keyword\">in</span> enumerate(trainloader, <span class=\"number\">0</span>):</span><br><span class=\"line\">        <span class=\"comment\"># 获取X,y对</span></span><br><span class=\"line\">        inputs, labels = data</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># 51.初始化梯度</span></span><br><span class=\"line\">        optimizer2.zero_grad()</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># 52.前馈</span></span><br><span class=\"line\">        outputs = net2(inputs)</span><br><span class=\"line\">        <span class=\"comment\"># 53.计算损失</span></span><br><span class=\"line\">        loss = criterion2(outputs, labels)</span><br><span class=\"line\">        <span class=\"comment\"># 54.计算梯度</span></span><br><span class=\"line\">        loss.backward()</span><br><span class=\"line\">        <span class=\"comment\"># 55.更新权值</span></span><br><span class=\"line\">        optimizer2.step()</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># 每2000个数据打印平均代价函数值</span></span><br><span class=\"line\">        running_loss += loss.item()</span><br><span class=\"line\">        <span class=\"keyword\">if</span> i % <span class=\"number\">2000</span> == <span class=\"number\">1999</span>:    <span class=\"comment\"># print every 2000 mini-batches</span></span><br><span class=\"line\">            print(<span class=\"string\">'[%d, %5d] loss: %.3f'</span> %</span><br><span class=\"line\">                  (epoch + <span class=\"number\">1</span>, i + <span class=\"number\">1</span>, running_loss / <span class=\"number\">2000</span>))</span><br><span class=\"line\">            running_loss = <span class=\"number\">0.0</span></span><br><span class=\"line\"></span><br><span class=\"line\">print(<span class=\"string\">'Finished Training'</span>)</span><br></pre></td></tr></table></figure>\n<h3 id=\"使用模型预测\"><a href=\"#使用模型预测\" class=\"headerlink\" title=\"使用模型预测\"></a>使用模型预测</h3><p>取一些数据</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dataiter = iter(testloader)</span><br><span class=\"line\">images, labels = dataiter.next()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># print images</span></span><br><span class=\"line\">imshow(torchvision.utils.make_grid(images))</span><br><span class=\"line\">print(<span class=\"string\">'GroundTruth: '</span>, <span class=\"string\">' '</span>.join(<span class=\"string\">'%5s'</span> % classes[labels[j]] <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(<span class=\"number\">4</span>)))</span><br></pre></td></tr></table></figure>\n<p>使用模型预测</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">outputs = net2(images)</span><br><span class=\"line\"></span><br><span class=\"line\">_, predicted = torch.max(outputs, <span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">print(<span class=\"string\">'Predicted: '</span>, <span class=\"string\">' '</span>.join(<span class=\"string\">'%5s'</span> % classes[predicted[j]]</span><br><span class=\"line\">                              <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(<span class=\"number\">4</span>)))</span><br></pre></td></tr></table></figure>\n<p>在测试集上进行打分</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">correct = <span class=\"number\">0</span></span><br><span class=\"line\">total = <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"keyword\">with</span> torch.no_grad():</span><br><span class=\"line\">    <span class=\"keyword\">for</span> data <span class=\"keyword\">in</span> testloader:</span><br><span class=\"line\">        images, labels = data</span><br><span class=\"line\">        outputs = net2(images)</span><br><span class=\"line\">        _, predicted = torch.max(outputs.data, <span class=\"number\">1</span>)</span><br><span class=\"line\">        total += labels.size(<span class=\"number\">0</span>)</span><br><span class=\"line\">        correct += (predicted == labels).sum().item()</span><br><span class=\"line\"></span><br><span class=\"line\">print(<span class=\"string\">'Accuracy of the network on the 10000 test images: %d %%'</span> % (</span><br><span class=\"line\">    <span class=\"number\">100</span> * correct / total))</span><br></pre></td></tr></table></figure>\n<h3 id=\"存取模型\"><a href=\"#存取模型\" class=\"headerlink\" title=\"存取模型\"></a>存取模型</h3><p>保存训练好的模型</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PATH = <span class=\"string\">'./cifar_net.pth'</span></span><br><span class=\"line\">torch.save(net.state_dict(), PATH)</span><br></pre></td></tr></table></figure>\n<p>读取保存的模型</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pretrained_net = torch.load(PATH)</span><br></pre></td></tr></table></figure>\n<p>加载模型</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">net3 = Net()</span><br><span class=\"line\">net3.load_state_dict(pretrained_net)</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<hr>","more":"<h2 id=\"张量\"><a href=\"#张量\" class=\"headerlink\" title=\"张量\"></a>张量</h2><p>导入pytorch包</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> torch</span><br></pre></td></tr></table></figure>\n<p>创建一个空的5x3张量</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x = torch.empty(<span class=\"number\">5</span>, <span class=\"number\">3</span>)</span><br><span class=\"line\">print(x)</span><br></pre></td></tr></table></figure>\n<p>创建一个随机初始化的5x3张量</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x = torch.rand(<span class=\"number\">5</span>, <span class=\"number\">3</span>)</span><br><span class=\"line\">print(x)</span><br></pre></td></tr></table></figure>\n<p>创建一个5x3的0张量，类型为long</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x = torch.zeros(<span class=\"number\">5</span>, <span class=\"number\">3</span>, dtype=torch.long)</span><br><span class=\"line\">print(x)</span><br></pre></td></tr></table></figure>\n<p>直接从数组创建张量</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x = torch.tensor([<span class=\"number\">5.5</span>, <span class=\"number\">3</span>])</span><br><span class=\"line\">print(x)</span><br></pre></td></tr></table></figure>\n<p>创建一个5x3的单位张量，类型为double</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x = torch.ones(<span class=\"number\">5</span>, <span class=\"number\">3</span>, dtype=torch.double)</span><br><span class=\"line\">print(x)</span><br></pre></td></tr></table></figure>\n<p>从已有的张量创建相同维度的新张量，并且重新定义类型为float</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x = torch.randn_like(x, dtype=torch.float)</span><br><span class=\"line\">print(x)</span><br></pre></td></tr></table></figure>\n<p>打印一个张量的维度</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">print(x.size())</span><br></pre></td></tr></table></figure>\n<p>将两个张量相加</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">y = torch.rand(<span class=\"number\">5</span>, <span class=\"number\">3</span>)</span><br><span class=\"line\">print(x + y)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 方法二</span></span><br><span class=\"line\"><span class=\"comment\"># print(torch.add(x, y))</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 方法三</span></span><br><span class=\"line\"><span class=\"comment\"># result = torch.empty(5, 3)</span></span><br><span class=\"line\"><span class=\"comment\"># torch.add(x, y, out=result)</span></span><br><span class=\"line\"><span class=\"comment\"># print(result)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 方法四</span></span><br><span class=\"line\"><span class=\"comment\"># y.add_(x)</span></span><br><span class=\"line\"><span class=\"comment\"># print(y)</span></span><br></pre></td></tr></table></figure>\n<p>取张量的第一列</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">print(x[:, <span class=\"number\">1</span>])</span><br></pre></td></tr></table></figure>\n<p>将一个4x4的张量resize成一个一维张量</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x = torch.randn(<span class=\"number\">4</span>, <span class=\"number\">4</span>)</span><br><span class=\"line\">y = x.view(<span class=\"number\">16</span>)</span><br><span class=\"line\">print(x.size(),y.size())</span><br></pre></td></tr></table></figure>\n<p>将一个4x4的张量，resize成一个2x8的张量</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">y = x.view(<span class=\"number\">2</span>, <span class=\"number\">8</span>)</span><br><span class=\"line\">print(x.size(),y.size())</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 方法二</span></span><br><span class=\"line\">z = x.view(<span class=\"number\">-1</span>, <span class=\"number\">8</span>) <span class=\"comment\"># 确定一个维度，-1的维度会被自动计算</span></span><br><span class=\"line\">print(x.size(),z.size())</span><br></pre></td></tr></table></figure>\n<p>从张量中取出数字</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x = torch.randn(<span class=\"number\">1</span>)</span><br><span class=\"line\">print(x)</span><br><span class=\"line\">print(x.item())</span><br></pre></td></tr></table></figure>\n<h3 id=\"Numpy的操作\"><a href=\"#Numpy的操作\" class=\"headerlink\" title=\"Numpy的操作\"></a>Numpy的操作</h3><p>将张量转换成numpy数组</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a = torch.ones(<span class=\"number\">5</span>)</span><br><span class=\"line\">print(a)</span><br><span class=\"line\"></span><br><span class=\"line\">b = a.numpy()</span><br><span class=\"line\">print(b)</span><br></pre></td></tr></table></figure>\n<p>将张量+1，并观察上题中numpy数组的变化</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a.add_(<span class=\"number\">1</span>)</span><br><span class=\"line\">print(a)</span><br><span class=\"line\">print(b)</span><br></pre></td></tr></table></figure>\n<p>从numpy数组创建张量</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\">a = np.ones(<span class=\"number\">5</span>)</span><br><span class=\"line\">b = torch.from_numpy(a)</span><br><span class=\"line\">print(a)</span><br><span class=\"line\">print(b)</span><br></pre></td></tr></table></figure>\n<p>将numpy数组+1并观察上题中张量的变化</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">np.add(a, <span class=\"number\">1</span>, out=a)</span><br><span class=\"line\">print(a)</span><br><span class=\"line\">print(b)</span><br></pre></td></tr></table></figure>\n<h2 id=\"自动微分\"><a href=\"#自动微分\" class=\"headerlink\" title=\"自动微分\"></a>自动微分</h2><h3 id=\"张量的自动微分\"><a href=\"#张量的自动微分\" class=\"headerlink\" title=\"张量的自动微分\"></a>张量的自动微分</h3><p>新建一个张量，并设置<code>requires_grad=True</code></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x = torch.ones(<span class=\"number\">2</span>, <span class=\"number\">2</span>, requires_grad=<span class=\"literal\">True</span>)</span><br><span class=\"line\">print(x)</span><br></pre></td></tr></table></figure>\n<p>对张量进行任意操作（y = x + 2）</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">y = x + <span class=\"number\">2</span></span><br><span class=\"line\">print(y)</span><br><span class=\"line\">print(y.grad_fn) <span class=\"comment\"># y就多了一个AddBackward</span></span><br></pre></td></tr></table></figure>\n<p>再对y进行任意操作</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">z = y * y * <span class=\"number\">3</span></span><br><span class=\"line\">out = z.mean()</span><br><span class=\"line\"></span><br><span class=\"line\">print(z) <span class=\"comment\"># z多了MulBackward</span></span><br><span class=\"line\">print(out) <span class=\"comment\"># out多了MeanBackward</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"梯度\"><a href=\"#梯度\" class=\"headerlink\" title=\"梯度\"></a>梯度</h3><p>对out进行反向传播</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">out.backward()</span><br></pre></td></tr></table></figure>\n<p>打印梯度d(out)/dx</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">print(x.grad) <span class=\"comment\">#out=0.25*Σ3(x+2)^2</span></span><br></pre></td></tr></table></figure>\n<p>创建一个结果为矢量的计算过程（y=x*2^n）</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x = torch.randn(<span class=\"number\">3</span>, requires_grad=<span class=\"literal\">True</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">y = x * <span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"keyword\">while</span> y.data.norm() &lt; <span class=\"number\">1000</span>:</span><br><span class=\"line\">    y = y * <span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\">print(y)</span><br></pre></td></tr></table></figure>\n<p>计算<code>v = [0.``1, 1.0, 0.0001]</code>处的梯度</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">v = torch.tensor([<span class=\"number\">0.1</span>, <span class=\"number\">1.0</span>, <span class=\"number\">0.0001</span>], dtype=torch.float)</span><br><span class=\"line\">y.backward(v)</span><br><span class=\"line\"></span><br><span class=\"line\">print(x.grad)</span><br></pre></td></tr></table></figure>\n<p>关闭梯度的功能</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">print(x.requires_grad)</span><br><span class=\"line\">print((x ** <span class=\"number\">2</span>).requires_grad)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">with</span> torch.no_grad():</span><br><span class=\"line\">    print((x ** <span class=\"number\">2</span>).requires_grad)</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\"># 方法二</span></span><br><span class=\"line\"><span class=\"comment\"># print(x.requires_grad)</span></span><br><span class=\"line\"><span class=\"comment\"># y = x.detach()</span></span><br><span class=\"line\"><span class=\"comment\"># print(y.requires_grad)</span></span><br><span class=\"line\"><span class=\"comment\"># print(x.eq(y).all())</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"神经网络\"><a href=\"#神经网络\" class=\"headerlink\" title=\"神经网络\"></a>神经网络</h2><p>pytorch实现LeNet5，结构如下所示</p>\n<p><img src=\"http://images.yingwai.top/picgo/pytorch60f1.png\" alt=\"\"></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> torch</span><br><span class=\"line\"><span class=\"keyword\">import</span> torch.nn <span class=\"keyword\">as</span> nn</span><br><span class=\"line\"><span class=\"keyword\">import</span> torch.nn.functional <span class=\"keyword\">as</span> F</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Net</span><span class=\"params\">(nn.Module)</span>:</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        super(Net, self).__init__()</span><br><span class=\"line\">        <span class=\"comment\"># 26.定义①的卷积层，输入为32x32的图像，卷积核大小5x5卷积核种类6</span></span><br><span class=\"line\">        self.conv1 = nn.Conv2d(<span class=\"number\">3</span>, <span class=\"number\">6</span>, <span class=\"number\">5</span>)</span><br><span class=\"line\">        <span class=\"comment\"># 27.定义③的卷积层，输入为前一层6个特征，卷积核大小5x5，卷积核种类16</span></span><br><span class=\"line\">        self.conv2 = nn.Conv2d(<span class=\"number\">6</span>, <span class=\"number\">16</span>, <span class=\"number\">5</span>)</span><br><span class=\"line\">        <span class=\"comment\"># 28.定义⑤的全链接层，输入为16*5*5，输出为120</span></span><br><span class=\"line\">        self.fc1 = nn.Linear(<span class=\"number\">16</span> * <span class=\"number\">5</span> * <span class=\"number\">5</span>, <span class=\"number\">120</span>)  <span class=\"comment\"># 6*6 from image dimension</span></span><br><span class=\"line\">        <span class=\"comment\"># 29.定义⑥的全连接层，输入为120，输出为84</span></span><br><span class=\"line\">        self.fc2 = nn.Linear(<span class=\"number\">120</span>, <span class=\"number\">84</span>)</span><br><span class=\"line\">        <span class=\"comment\"># 30.定义⑥的全连接层，输入为84，输出为10</span></span><br><span class=\"line\">        self.fc3 = nn.Linear(<span class=\"number\">84</span>, <span class=\"number\">10</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">forward</span><span class=\"params\">(self, x)</span>:</span></span><br><span class=\"line\">        <span class=\"comment\"># 31.完成input-S2，先卷积+relu，再2x2下采样</span></span><br><span class=\"line\">        x = F.max_pool2d(F.relu(self.conv1(x)), (<span class=\"number\">2</span>, <span class=\"number\">2</span>))</span><br><span class=\"line\">        <span class=\"comment\"># 32.完成S2-S4，先卷积+relu，再2x2下采样</span></span><br><span class=\"line\">        x = F.max_pool2d(F.relu(self.conv2(x)), <span class=\"number\">2</span>) <span class=\"comment\">#卷积核方形时，可以只写一个维度</span></span><br><span class=\"line\">        <span class=\"comment\"># 33.将特征向量扁平成列向量</span></span><br><span class=\"line\">        x = x.view(<span class=\"number\">-1</span>, <span class=\"number\">16</span> * <span class=\"number\">5</span> * <span class=\"number\">5</span>)</span><br><span class=\"line\">        <span class=\"comment\"># 34.使用fc1+relu</span></span><br><span class=\"line\">        x = F.relu(self.fc1(x))</span><br><span class=\"line\">        <span class=\"comment\"># 35.使用fc2+relu</span></span><br><span class=\"line\">        x = F.relu(self.fc2(x))</span><br><span class=\"line\">        <span class=\"comment\"># 36.使用fc3</span></span><br><span class=\"line\">        x = self.fc3(x)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> x</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">net = Net()</span><br><span class=\"line\">print(net)</span><br></pre></td></tr></table></figure>\n<p>打印网络的参数</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">params = list(net.parameters())</span><br><span class=\"line\"><span class=\"comment\"># print(params)</span></span><br><span class=\"line\">print(len(params))</span><br></pre></td></tr></table></figure>\n<p>打印某一层参数的形状</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">print(params[<span class=\"number\">0</span>].size())</span><br></pre></td></tr></table></figure>\n<p>随机输入一个向量，查看前向传播输出</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">input = torch.randn(<span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">32</span>, <span class=\"number\">32</span>)</span><br><span class=\"line\">out = net(input)</span><br><span class=\"line\">print(out)</span><br></pre></td></tr></table></figure>\n<p>将梯度初始化</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">net.zero_grad()</span><br></pre></td></tr></table></figure>\n<p>随机一个梯度进行反向传播</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">out.backward(torch.randn(<span class=\"number\">1</span>, <span class=\"number\">10</span>))</span><br></pre></td></tr></table></figure>\n<h3 id=\"损失函数\"><a href=\"#损失函数\" class=\"headerlink\" title=\"损失函数\"></a>损失函数</h3><p>用自带的MSELoss()定义损失函数</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">criterion = nn.MSELoss()</span><br></pre></td></tr></table></figure>\n<p>随机一个真值，并用随机的输入计算损失</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">target = torch.randn(<span class=\"number\">10</span>)  <span class=\"comment\"># 随机真值</span></span><br><span class=\"line\">target = target.view(<span class=\"number\">1</span>, <span class=\"number\">-1</span>)  <span class=\"comment\"># 变成列向量</span></span><br><span class=\"line\"></span><br><span class=\"line\">output = net(input)  <span class=\"comment\"># 用随机输入计算输出</span></span><br><span class=\"line\"></span><br><span class=\"line\">loss = criterion(output, target)  <span class=\"comment\"># 计算损失</span></span><br><span class=\"line\">print(loss)</span><br></pre></td></tr></table></figure>\n<p>将梯度初始化，计算上一步中loss的反向传播</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">net.zero_grad()</span><br><span class=\"line\"></span><br><span class=\"line\">print(<span class=\"string\">'conv1.bias.grad before backward'</span>)</span><br><span class=\"line\">print(net.conv1.bias.grad)</span><br></pre></td></tr></table></figure>\n<p>计算43中loss的反向传播</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">loss.backward()</span><br><span class=\"line\"></span><br><span class=\"line\">print(<span class=\"string\">'conv1.bias.grad after backward'</span>)</span><br><span class=\"line\">print(net.conv1.bias.grad)</span><br></pre></td></tr></table></figure>\n<h3 id=\"更新权重\"><a href=\"#更新权重\" class=\"headerlink\" title=\"更新权重\"></a>更新权重</h3><p>定义SGD优化器算法，学习率设置为0.01</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> torch.optim <span class=\"keyword\">as</span> optim</span><br><span class=\"line\">optimizer = optim.SGD(net.parameters(), lr=<span class=\"number\">0.01</span>)</span><br></pre></td></tr></table></figure>\n<p>使用优化器更新权重</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">optimizer.zero_grad()</span><br><span class=\"line\">output = net(input)</span><br><span class=\"line\">loss = criterion(output, target)</span><br><span class=\"line\">loss.backward()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 更新权重</span></span><br><span class=\"line\">optimizer.step()</span><br></pre></td></tr></table></figure>\n<h2 id=\"训练一个分类器\"><a href=\"#训练一个分类器\" class=\"headerlink\" title=\"训练一个分类器\"></a>训练一个分类器</h2><h3 id=\"读取CIFAR10数据，做标准化\"><a href=\"#读取CIFAR10数据，做标准化\" class=\"headerlink\" title=\"读取CIFAR10数据，做标准化\"></a>读取CIFAR10数据，做标准化</h3><p>构造一个transform，将三通道(0,1)区间的数据转换成(-1,1)的数据</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> torchvision</span><br><span class=\"line\"><span class=\"keyword\">import</span> torchvision.transforms <span class=\"keyword\">as</span> transforms</span><br><span class=\"line\"></span><br><span class=\"line\">transform = transforms.Compose(</span><br><span class=\"line\">    [transforms.ToTensor(),</span><br><span class=\"line\">     transforms.Normalize((<span class=\"number\">0.5</span>, <span class=\"number\">0.5</span>, <span class=\"number\">0.5</span>), (<span class=\"number\">0.5</span>, <span class=\"number\">0.5</span>, <span class=\"number\">0.5</span>))])</span><br></pre></td></tr></table></figure>\n<p>读取数据集</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">trainset = cifar(root = <span class=\"string\">'./input/cifar10'</span>, segmentation=<span class=\"string\">'train'</span>, transforms=transform)</span><br><span class=\"line\">testset = cifar(root = <span class=\"string\">'./input/cifar10'</span>, segmentation=<span class=\"string\">'test'</span>, transforms=transform)</span><br><span class=\"line\">trainloader = torch.utils.data.DataLoader(trainset, batch_size=batch_size,shuffle=<span class=\"literal\">True</span>, num_workers=<span class=\"number\">2</span>)</span><br><span class=\"line\">testloader = torch.utils.data.DataLoader(testset, batch_size=batch_size,shuffle=<span class=\"literal\">False</span>, num_workers=<span class=\"number\">2</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">classes = (<span class=\"string\">'plane'</span>, <span class=\"string\">'car'</span>, <span class=\"string\">'bird'</span>, <span class=\"string\">'cat'</span>,</span><br><span class=\"line\">           <span class=\"string\">'deer'</span>, <span class=\"string\">'dog'</span>, <span class=\"string\">'frog'</span>, <span class=\"string\">'horse'</span>, <span class=\"string\">'ship'</span>, <span class=\"string\">'truck'</span>)</span><br></pre></td></tr></table></figure>\n<h3 id=\"建立网络\"><a href=\"#建立网络\" class=\"headerlink\" title=\"建立网络\"></a>建立网络</h3><p>这部分沿用前面的网络</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">net2 = Net()</span><br></pre></td></tr></table></figure>\n<h3 id=\"定义损失函数和优化器\"><a href=\"#定义损失函数和优化器\" class=\"headerlink\" title=\"定义损失函数和优化器\"></a>定义损失函数和优化器</h3><p>定义交叉熵损失函数</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">criterion2 = nn.CrossEntropyLoss()</span><br></pre></td></tr></table></figure>\n<p>定义SGD优化器算法，学习率设置为0.001，<code>momentum=0.9</code></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">optimizer2 = optim.SGD(net2.parameters(), lr=<span class=\"number\">0.001</span>, momentum=<span class=\"number\">0.9</span>)</span><br></pre></td></tr></table></figure>\n<h3 id=\"训练网络\"><a href=\"#训练网络\" class=\"headerlink\" title=\"训练网络\"></a>训练网络</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> epoch <span class=\"keyword\">in</span> range(<span class=\"number\">2</span>):</span><br><span class=\"line\"></span><br><span class=\"line\">    running_loss = <span class=\"number\">0.0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i, data <span class=\"keyword\">in</span> enumerate(trainloader, <span class=\"number\">0</span>):</span><br><span class=\"line\">        <span class=\"comment\"># 获取X,y对</span></span><br><span class=\"line\">        inputs, labels = data</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># 51.初始化梯度</span></span><br><span class=\"line\">        optimizer2.zero_grad()</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># 52.前馈</span></span><br><span class=\"line\">        outputs = net2(inputs)</span><br><span class=\"line\">        <span class=\"comment\"># 53.计算损失</span></span><br><span class=\"line\">        loss = criterion2(outputs, labels)</span><br><span class=\"line\">        <span class=\"comment\"># 54.计算梯度</span></span><br><span class=\"line\">        loss.backward()</span><br><span class=\"line\">        <span class=\"comment\"># 55.更新权值</span></span><br><span class=\"line\">        optimizer2.step()</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># 每2000个数据打印平均代价函数值</span></span><br><span class=\"line\">        running_loss += loss.item()</span><br><span class=\"line\">        <span class=\"keyword\">if</span> i % <span class=\"number\">2000</span> == <span class=\"number\">1999</span>:    <span class=\"comment\"># print every 2000 mini-batches</span></span><br><span class=\"line\">            print(<span class=\"string\">'[%d, %5d] loss: %.3f'</span> %</span><br><span class=\"line\">                  (epoch + <span class=\"number\">1</span>, i + <span class=\"number\">1</span>, running_loss / <span class=\"number\">2000</span>))</span><br><span class=\"line\">            running_loss = <span class=\"number\">0.0</span></span><br><span class=\"line\"></span><br><span class=\"line\">print(<span class=\"string\">'Finished Training'</span>)</span><br></pre></td></tr></table></figure>\n<h3 id=\"使用模型预测\"><a href=\"#使用模型预测\" class=\"headerlink\" title=\"使用模型预测\"></a>使用模型预测</h3><p>取一些数据</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dataiter = iter(testloader)</span><br><span class=\"line\">images, labels = dataiter.next()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># print images</span></span><br><span class=\"line\">imshow(torchvision.utils.make_grid(images))</span><br><span class=\"line\">print(<span class=\"string\">'GroundTruth: '</span>, <span class=\"string\">' '</span>.join(<span class=\"string\">'%5s'</span> % classes[labels[j]] <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(<span class=\"number\">4</span>)))</span><br></pre></td></tr></table></figure>\n<p>使用模型预测</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">outputs = net2(images)</span><br><span class=\"line\"></span><br><span class=\"line\">_, predicted = torch.max(outputs, <span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">print(<span class=\"string\">'Predicted: '</span>, <span class=\"string\">' '</span>.join(<span class=\"string\">'%5s'</span> % classes[predicted[j]]</span><br><span class=\"line\">                              <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(<span class=\"number\">4</span>)))</span><br></pre></td></tr></table></figure>\n<p>在测试集上进行打分</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">correct = <span class=\"number\">0</span></span><br><span class=\"line\">total = <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"keyword\">with</span> torch.no_grad():</span><br><span class=\"line\">    <span class=\"keyword\">for</span> data <span class=\"keyword\">in</span> testloader:</span><br><span class=\"line\">        images, labels = data</span><br><span class=\"line\">        outputs = net2(images)</span><br><span class=\"line\">        _, predicted = torch.max(outputs.data, <span class=\"number\">1</span>)</span><br><span class=\"line\">        total += labels.size(<span class=\"number\">0</span>)</span><br><span class=\"line\">        correct += (predicted == labels).sum().item()</span><br><span class=\"line\"></span><br><span class=\"line\">print(<span class=\"string\">'Accuracy of the network on the 10000 test images: %d %%'</span> % (</span><br><span class=\"line\">    <span class=\"number\">100</span> * correct / total))</span><br></pre></td></tr></table></figure>\n<h3 id=\"存取模型\"><a href=\"#存取模型\" class=\"headerlink\" title=\"存取模型\"></a>存取模型</h3><p>保存训练好的模型</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PATH = <span class=\"string\">'./cifar_net.pth'</span></span><br><span class=\"line\">torch.save(net.state_dict(), PATH)</span><br></pre></td></tr></table></figure>\n<p>读取保存的模型</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pretrained_net = torch.load(PATH)</span><br></pre></td></tr></table></figure>\n<p>加载模型</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">net3 = Net()</span><br><span class=\"line\">net3.load_state_dict(pretrained_net)</span><br></pre></td></tr></table></figure>"},{"title":"不经意传输（Oblivious Transfer）","date":"2020-04-25T08:22:21.000Z","_content":"\n*设S有一个秘密，想以1/2的概率传递给R，即B有50%的机会收到这个秘密，另外50%的机会什么也没有收到，协议执行完后，B知道自己是否收到了这个秘密，但S却不知道R是否收到了这个秘密。这种协议就称为不经意传输协议。*\n\n<!--more-->\n\n​\t\t例如A是机密的出售者，S列举了很多问题，意欲出售各个问题的答案，R想买其中一个问题的答案，但又不想让A知道自己买的是哪个问题的答案。\n\n\n\n## 1-out-of-2 OT\n\nOT最早在1981年被 Michael O. Rabin提出，在Rabin的OT协议中，发送者S发送一个信息m给接收者R，接收者R以1/2的概率接受信息m。所以在协议交互的结束的时候，S并不知道R是否接受了消息。该方案是基于RSA加密体系构造的。\n\n1985年S. Even, O. Goldreich, and A. Lempel提出了1-out-2 OT,在新的方案中S每次发送2个信息 $m_0$ 和 $m_1$，而R每次输入一个选择 $b$。当协议结束的时候，S无法获得关于 $b$ 的任何有价值的信息，而R只能获得 $m_b$ ，对于 $m_{1-b}$ ，R也一无所知。\n![](http://images.yingwai.top/picgo/OTf1.png)\n\n## 协议\n\nS要传送两条信息，不妨设为两个比特 $b_0$ 和 $b_1$，而R只能选择接受其中一个比特 $b_{\\theta}$。协议要保证S和R的安全，即：\n\n* S不能知道任何关于 $\\theta$ 的信息；\n* R不能知道任何关于 $b_{1-\\theta}$ 的信息。\n\n为了达成上面两点要求，构造如下协议：\n\n1. S选择好两个比特信息 $b_0$ 和 $b_1$；\n\n2. S运行密钥生成算法（例如RSA）生成公私钥对（$sk,pk$）；\n\n3. S保密私钥，同时S要生成两个随机数 $x_0$ 和 $x_1$，并将这两个随机数和公钥一并传送给R；\n\n4. R选择 $\\theta$，并生成一个数 $r$，R用S的公钥加密 $r$，并生成信息\n\n   ​\t\t\t\t\t\t\t\t$$v =x_{\\theta}+E_{pk}(r)$$\n\n5. S在接收到 $v$ 之后，进行如下计算：\n\n   ​\t\t\t\t\t\t\t\t$r_{0}=D_{s k}\\left(v-x_{0}\\right)$\n   ​\t\t\t\t\t\t\t\t$r_{1}=D_{s k}\\left(v-x_{1}\\right)$\n\n6. S进行如下计算：\n\n   ​\t\t\t\t\t\t\t\t$b_{0}^{\\prime}=b_{0}+r_{0}$\n   ​\t\t\t\t\t\t\t\t$b_{1}^{\\prime}=b_{1}+r_{1}$\n\n   并将 $b'_0$ 和 $b'_1$ 传送给R；\n\n7. 接收到 $b'_0$ 和 $b'_1$ 后，R进行如下计算：\n\n   ​\t\t\t\t\t\t\t\t$b_\\theta = b'_\\theta - r$\n\n\n\n### 正确性\n\n进行如下推导：\n\n​\t\t\t\t\t\t\t\t$b_{\\theta}^{\\prime}-r=b_{\\theta}+r_{\\theta}-r=b_{\\theta}+D_{s k}\\left(v-x_{\\theta}\\right)-r$\n\n而\n\n​\t\t\t\t\t\t$D_{s k}(v-x_\\theta)=D_{s k}\\left(x_\\theta+E_{p k}(r)-x_{\\theta}\\right)=D_{s k}\\left(E_{p k}(r)\\right)=r$\n\n因此可得\n\n​\t\t\t\t\t\t\t\t\t\t\t$b'_\\theta - r = b_\\theta$\n\n\n\n### 对于S的安全性\n\n对于S来说，它的安全性要求R不能推断出 $b_{1-\\theta}$。R得到 $b'_\\theta$ 和 $b'_{1-\\theta}$ 之后，由协议可知R可以正确计算 $b'_\\theta$ ，下面证明R不能计算出 $b_{1-\\theta}$。\n\n​\t\t\t\t\t\t$b_{1-\\theta}^{\\prime}-r=b_{1-\\theta}+D_{s k}\\left(v-x_{\\theta}\\right)-r$\n\n而\n\n​\t\t\t\t\t$D_{s k}\\left(v-x_{\\theta}\\right)=D_{s k}\\left(x_{1-\\theta}+E_{p k}(r)-x_{\\theta}\\right) \\neq r$\n\n而且根据加密的特性，$D_{s k}\\left(x_{1-\\theta}+E_{p k}(r)-x_{\\theta}\\right)-r$ 与随机数是不可区分的，所以 $b'_{1-\\theta}-r$ 与随机数是不可区分的。因此协议对S是安全的。\n\n\n\n### 对于R的安全性\n\nR的安全性要求S不能获得关于 $\\theta$ 任何有价值的信息。\n\n因为 $r$ 是随机数，所以 $E_{pk}(r)$ 与随机数是不可区分的。因此 $v$ 与随机数是不可区分的，所以S不能从 $v$ 获得关于 $\\theta$ 有价值的信息。\n\n","source":"_posts/不经意传输（Oblivious-Transfer）.md","raw":"---\ntitle: 不经意传输（Oblivious Transfer）\ndate: 2020-04-25 16:22:21\ncategories: Study\ntags: [密码学, MPC]\n---\n\n*设S有一个秘密，想以1/2的概率传递给R，即B有50%的机会收到这个秘密，另外50%的机会什么也没有收到，协议执行完后，B知道自己是否收到了这个秘密，但S却不知道R是否收到了这个秘密。这种协议就称为不经意传输协议。*\n\n<!--more-->\n\n​\t\t例如A是机密的出售者，S列举了很多问题，意欲出售各个问题的答案，R想买其中一个问题的答案，但又不想让A知道自己买的是哪个问题的答案。\n\n\n\n## 1-out-of-2 OT\n\nOT最早在1981年被 Michael O. Rabin提出，在Rabin的OT协议中，发送者S发送一个信息m给接收者R，接收者R以1/2的概率接受信息m。所以在协议交互的结束的时候，S并不知道R是否接受了消息。该方案是基于RSA加密体系构造的。\n\n1985年S. Even, O. Goldreich, and A. Lempel提出了1-out-2 OT,在新的方案中S每次发送2个信息 $m_0$ 和 $m_1$，而R每次输入一个选择 $b$。当协议结束的时候，S无法获得关于 $b$ 的任何有价值的信息，而R只能获得 $m_b$ ，对于 $m_{1-b}$ ，R也一无所知。\n![](http://images.yingwai.top/picgo/OTf1.png)\n\n## 协议\n\nS要传送两条信息，不妨设为两个比特 $b_0$ 和 $b_1$，而R只能选择接受其中一个比特 $b_{\\theta}$。协议要保证S和R的安全，即：\n\n* S不能知道任何关于 $\\theta$ 的信息；\n* R不能知道任何关于 $b_{1-\\theta}$ 的信息。\n\n为了达成上面两点要求，构造如下协议：\n\n1. S选择好两个比特信息 $b_0$ 和 $b_1$；\n\n2. S运行密钥生成算法（例如RSA）生成公私钥对（$sk,pk$）；\n\n3. S保密私钥，同时S要生成两个随机数 $x_0$ 和 $x_1$，并将这两个随机数和公钥一并传送给R；\n\n4. R选择 $\\theta$，并生成一个数 $r$，R用S的公钥加密 $r$，并生成信息\n\n   ​\t\t\t\t\t\t\t\t$$v =x_{\\theta}+E_{pk}(r)$$\n\n5. S在接收到 $v$ 之后，进行如下计算：\n\n   ​\t\t\t\t\t\t\t\t$r_{0}=D_{s k}\\left(v-x_{0}\\right)$\n   ​\t\t\t\t\t\t\t\t$r_{1}=D_{s k}\\left(v-x_{1}\\right)$\n\n6. S进行如下计算：\n\n   ​\t\t\t\t\t\t\t\t$b_{0}^{\\prime}=b_{0}+r_{0}$\n   ​\t\t\t\t\t\t\t\t$b_{1}^{\\prime}=b_{1}+r_{1}$\n\n   并将 $b'_0$ 和 $b'_1$ 传送给R；\n\n7. 接收到 $b'_0$ 和 $b'_1$ 后，R进行如下计算：\n\n   ​\t\t\t\t\t\t\t\t$b_\\theta = b'_\\theta - r$\n\n\n\n### 正确性\n\n进行如下推导：\n\n​\t\t\t\t\t\t\t\t$b_{\\theta}^{\\prime}-r=b_{\\theta}+r_{\\theta}-r=b_{\\theta}+D_{s k}\\left(v-x_{\\theta}\\right)-r$\n\n而\n\n​\t\t\t\t\t\t$D_{s k}(v-x_\\theta)=D_{s k}\\left(x_\\theta+E_{p k}(r)-x_{\\theta}\\right)=D_{s k}\\left(E_{p k}(r)\\right)=r$\n\n因此可得\n\n​\t\t\t\t\t\t\t\t\t\t\t$b'_\\theta - r = b_\\theta$\n\n\n\n### 对于S的安全性\n\n对于S来说，它的安全性要求R不能推断出 $b_{1-\\theta}$。R得到 $b'_\\theta$ 和 $b'_{1-\\theta}$ 之后，由协议可知R可以正确计算 $b'_\\theta$ ，下面证明R不能计算出 $b_{1-\\theta}$。\n\n​\t\t\t\t\t\t$b_{1-\\theta}^{\\prime}-r=b_{1-\\theta}+D_{s k}\\left(v-x_{\\theta}\\right)-r$\n\n而\n\n​\t\t\t\t\t$D_{s k}\\left(v-x_{\\theta}\\right)=D_{s k}\\left(x_{1-\\theta}+E_{p k}(r)-x_{\\theta}\\right) \\neq r$\n\n而且根据加密的特性，$D_{s k}\\left(x_{1-\\theta}+E_{p k}(r)-x_{\\theta}\\right)-r$ 与随机数是不可区分的，所以 $b'_{1-\\theta}-r$ 与随机数是不可区分的。因此协议对S是安全的。\n\n\n\n### 对于R的安全性\n\nR的安全性要求S不能获得关于 $\\theta$ 任何有价值的信息。\n\n因为 $r$ 是随机数，所以 $E_{pk}(r)$ 与随机数是不可区分的。因此 $v$ 与随机数是不可区分的，所以S不能从 $v$ 获得关于 $\\theta$ 有价值的信息。\n\n","slug":"不经意传输（Oblivious-Transfer）","published":1,"updated":"2020-08-23T14:33:37.431Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cke79q4p6000o88psaelxbozy","content":"<p><em>设S有一个秘密，想以1/2的概率传递给R，即B有50%的机会收到这个秘密，另外50%的机会什么也没有收到，协议执行完后，B知道自己是否收到了这个秘密，但S却不知道R是否收到了这个秘密。这种协议就称为不经意传输协议。</em></p>\n<a id=\"more\"></a>\n<p>​        例如A是机密的出售者，S列举了很多问题，意欲出售各个问题的答案，R想买其中一个问题的答案，但又不想让A知道自己买的是哪个问题的答案。</p>\n<h2 id=\"1-out-of-2-OT\"><a href=\"#1-out-of-2-OT\" class=\"headerlink\" title=\"1-out-of-2 OT\"></a>1-out-of-2 OT</h2><p>OT最早在1981年被 Michael O. Rabin提出，在Rabin的OT协议中，发送者S发送一个信息m给接收者R，接收者R以1/2的概率接受信息m。所以在协议交互的结束的时候，S并不知道R是否接受了消息。该方案是基于RSA加密体系构造的。</p>\n<p>1985年S. Even, O. Goldreich, and A. Lempel提出了1-out-2 OT,在新的方案中S每次发送2个信息 $m<em>0$ 和 $m_1$，而R每次输入一个选择 $b$。当协议结束的时候，S无法获得关于 $b$ 的任何有价值的信息，而R只能获得 $m_b$ ，对于 $m</em>{1-b}$ ，R也一无所知。<br><img src=\"http://images.yingwai.top/picgo/OTf1.png\" alt=\"\"></p>\n<h2 id=\"协议\"><a href=\"#协议\" class=\"headerlink\" title=\"协议\"></a>协议</h2><p>S要传送两条信息，不妨设为两个比特 $b<em>0$ 和 $b_1$，而R只能选择接受其中一个比特 $b</em>{\\theta}$。协议要保证S和R的安全，即：</p>\n<ul>\n<li>S不能知道任何关于 $\\theta$ 的信息；</li>\n<li>R不能知道任何关于 $b_{1-\\theta}$ 的信息。</li>\n</ul>\n<p>为了达成上面两点要求，构造如下协议：</p>\n<ol>\n<li><p>S选择好两个比特信息 $b_0$ 和 $b_1$；</p>\n</li>\n<li><p>S运行密钥生成算法（例如RSA）生成公私钥对（$sk,pk$）；</p>\n</li>\n<li><p>S保密私钥，同时S要生成两个随机数 $x_0$ 和 $x_1$，并将这两个随机数和公钥一并传送给R；</p>\n</li>\n<li><p>R选择 $\\theta$，并生成一个数 $r$，R用S的公钥加密 $r$，并生成信息</p>\n<p>​                                <script type=\"math/tex\">v =x_{\\theta}+E_{pk}(r)</script></p>\n</li>\n<li><p>S在接收到 $v$ 之后，进行如下计算：</p>\n<p>​                                $r<em>{0}=D</em>{s k}\\left(v-x<em>{0}\\right)$<br>​                                $r</em>{1}=D<em>{s k}\\left(v-x</em>{1}\\right)$</p>\n</li>\n<li><p>S进行如下计算：</p>\n<p>​                                $b<em>{0}^{\\prime}=b</em>{0}+r<em>{0}$<br>​                                $b</em>{1}^{\\prime}=b<em>{1}+r</em>{1}$</p>\n<p>并将 $b’_0$ 和 $b’_1$ 传送给R；</p>\n</li>\n<li><p>接收到 $b’_0$ 和 $b’_1$ 后，R进行如下计算：</p>\n<p>​                                $b<em>\\theta = b’</em>\\theta - r$</p>\n</li>\n</ol>\n<h3 id=\"正确性\"><a href=\"#正确性\" class=\"headerlink\" title=\"正确性\"></a>正确性</h3><p>进行如下推导：</p>\n<p>​                                $b<em>{\\theta}^{\\prime}-r=b</em>{\\theta}+r<em>{\\theta}-r=b</em>{\\theta}+D<em>{s k}\\left(v-x</em>{\\theta}\\right)-r$</p>\n<p>而</p>\n<p>​                        $D<em>{s k}(v-x</em>\\theta)=D<em>{s k}\\left(x</em>\\theta+E<em>{p k}(r)-x</em>{\\theta}\\right)=D<em>{s k}\\left(E</em>{p k}(r)\\right)=r$</p>\n<p>因此可得</p>\n<p>​                                            $b’<em>\\theta - r = b</em>\\theta$</p>\n<h3 id=\"对于S的安全性\"><a href=\"#对于S的安全性\" class=\"headerlink\" title=\"对于S的安全性\"></a>对于S的安全性</h3><p>对于S来说，它的安全性要求R不能推断出 $b<em>{1-\\theta}$。R得到 $b’</em>\\theta$ 和 $b’<em>{1-\\theta}$ 之后，由协议可知R可以正确计算 $b’</em>\\theta$ ，下面证明R不能计算出 $b_{1-\\theta}$。</p>\n<p>​                        $b<em>{1-\\theta}^{\\prime}-r=b</em>{1-\\theta}+D<em>{s k}\\left(v-x</em>{\\theta}\\right)-r$</p>\n<p>而</p>\n<p>​                    $D<em>{s k}\\left(v-x</em>{\\theta}\\right)=D<em>{s k}\\left(x</em>{1-\\theta}+E<em>{p k}(r)-x</em>{\\theta}\\right) \\neq r$</p>\n<p>而且根据加密的特性，$D<em>{s k}\\left(x</em>{1-\\theta}+E<em>{p k}(r)-x</em>{\\theta}\\right)-r$ 与随机数是不可区分的，所以 $b’_{1-\\theta}-r$ 与随机数是不可区分的。因此协议对S是安全的。</p>\n<h3 id=\"对于R的安全性\"><a href=\"#对于R的安全性\" class=\"headerlink\" title=\"对于R的安全性\"></a>对于R的安全性</h3><p>R的安全性要求S不能获得关于 $\\theta$ 任何有价值的信息。</p>\n<p>因为 $r$ 是随机数，所以 $E_{pk}(r)$ 与随机数是不可区分的。因此 $v$ 与随机数是不可区分的，所以S不能从 $v$ 获得关于 $\\theta$ 有价值的信息。</p>\n","site":{"data":{}},"excerpt":"<p><em>设S有一个秘密，想以1/2的概率传递给R，即B有50%的机会收到这个秘密，另外50%的机会什么也没有收到，协议执行完后，B知道自己是否收到了这个秘密，但S却不知道R是否收到了这个秘密。这种协议就称为不经意传输协议。</em></p>","more":"<p>​        例如A是机密的出售者，S列举了很多问题，意欲出售各个问题的答案，R想买其中一个问题的答案，但又不想让A知道自己买的是哪个问题的答案。</p>\n<h2 id=\"1-out-of-2-OT\"><a href=\"#1-out-of-2-OT\" class=\"headerlink\" title=\"1-out-of-2 OT\"></a>1-out-of-2 OT</h2><p>OT最早在1981年被 Michael O. Rabin提出，在Rabin的OT协议中，发送者S发送一个信息m给接收者R，接收者R以1/2的概率接受信息m。所以在协议交互的结束的时候，S并不知道R是否接受了消息。该方案是基于RSA加密体系构造的。</p>\n<p>1985年S. Even, O. Goldreich, and A. Lempel提出了1-out-2 OT,在新的方案中S每次发送2个信息 $m<em>0$ 和 $m_1$，而R每次输入一个选择 $b$。当协议结束的时候，S无法获得关于 $b$ 的任何有价值的信息，而R只能获得 $m_b$ ，对于 $m</em>{1-b}$ ，R也一无所知。<br><img src=\"http://images.yingwai.top/picgo/OTf1.png\" alt=\"\"></p>\n<h2 id=\"协议\"><a href=\"#协议\" class=\"headerlink\" title=\"协议\"></a>协议</h2><p>S要传送两条信息，不妨设为两个比特 $b<em>0$ 和 $b_1$，而R只能选择接受其中一个比特 $b</em>{\\theta}$。协议要保证S和R的安全，即：</p>\n<ul>\n<li>S不能知道任何关于 $\\theta$ 的信息；</li>\n<li>R不能知道任何关于 $b_{1-\\theta}$ 的信息。</li>\n</ul>\n<p>为了达成上面两点要求，构造如下协议：</p>\n<ol>\n<li><p>S选择好两个比特信息 $b_0$ 和 $b_1$；</p>\n</li>\n<li><p>S运行密钥生成算法（例如RSA）生成公私钥对（$sk,pk$）；</p>\n</li>\n<li><p>S保密私钥，同时S要生成两个随机数 $x_0$ 和 $x_1$，并将这两个随机数和公钥一并传送给R；</p>\n</li>\n<li><p>R选择 $\\theta$，并生成一个数 $r$，R用S的公钥加密 $r$，并生成信息</p>\n<p>​                                <script type=\"math/tex\">v =x_{\\theta}+E_{pk}(r)</script></p>\n</li>\n<li><p>S在接收到 $v$ 之后，进行如下计算：</p>\n<p>​                                $r<em>{0}=D</em>{s k}\\left(v-x<em>{0}\\right)$<br>​                                $r</em>{1}=D<em>{s k}\\left(v-x</em>{1}\\right)$</p>\n</li>\n<li><p>S进行如下计算：</p>\n<p>​                                $b<em>{0}^{\\prime}=b</em>{0}+r<em>{0}$<br>​                                $b</em>{1}^{\\prime}=b<em>{1}+r</em>{1}$</p>\n<p>并将 $b’_0$ 和 $b’_1$ 传送给R；</p>\n</li>\n<li><p>接收到 $b’_0$ 和 $b’_1$ 后，R进行如下计算：</p>\n<p>​                                $b<em>\\theta = b’</em>\\theta - r$</p>\n</li>\n</ol>\n<h3 id=\"正确性\"><a href=\"#正确性\" class=\"headerlink\" title=\"正确性\"></a>正确性</h3><p>进行如下推导：</p>\n<p>​                                $b<em>{\\theta}^{\\prime}-r=b</em>{\\theta}+r<em>{\\theta}-r=b</em>{\\theta}+D<em>{s k}\\left(v-x</em>{\\theta}\\right)-r$</p>\n<p>而</p>\n<p>​                        $D<em>{s k}(v-x</em>\\theta)=D<em>{s k}\\left(x</em>\\theta+E<em>{p k}(r)-x</em>{\\theta}\\right)=D<em>{s k}\\left(E</em>{p k}(r)\\right)=r$</p>\n<p>因此可得</p>\n<p>​                                            $b’<em>\\theta - r = b</em>\\theta$</p>\n<h3 id=\"对于S的安全性\"><a href=\"#对于S的安全性\" class=\"headerlink\" title=\"对于S的安全性\"></a>对于S的安全性</h3><p>对于S来说，它的安全性要求R不能推断出 $b<em>{1-\\theta}$。R得到 $b’</em>\\theta$ 和 $b’<em>{1-\\theta}$ 之后，由协议可知R可以正确计算 $b’</em>\\theta$ ，下面证明R不能计算出 $b_{1-\\theta}$。</p>\n<p>​                        $b<em>{1-\\theta}^{\\prime}-r=b</em>{1-\\theta}+D<em>{s k}\\left(v-x</em>{\\theta}\\right)-r$</p>\n<p>而</p>\n<p>​                    $D<em>{s k}\\left(v-x</em>{\\theta}\\right)=D<em>{s k}\\left(x</em>{1-\\theta}+E<em>{p k}(r)-x</em>{\\theta}\\right) \\neq r$</p>\n<p>而且根据加密的特性，$D<em>{s k}\\left(x</em>{1-\\theta}+E<em>{p k}(r)-x</em>{\\theta}\\right)-r$ 与随机数是不可区分的，所以 $b’_{1-\\theta}-r$ 与随机数是不可区分的。因此协议对S是安全的。</p>\n<h3 id=\"对于R的安全性\"><a href=\"#对于R的安全性\" class=\"headerlink\" title=\"对于R的安全性\"></a>对于R的安全性</h3><p>R的安全性要求S不能获得关于 $\\theta$ 任何有价值的信息。</p>\n<p>因为 $r$ 是随机数，所以 $E_{pk}(r)$ 与随机数是不可区分的。因此 $v$ 与随机数是不可区分的，所以S不能从 $v$ 获得关于 $\\theta$ 有价值的信息。</p>"},{"title":"Zotero的附件同步","date":"2020-07-10T15:19:21.000Z","_content":"\n-----\n\n<!--more-->\n\nZotero的存储空间只有100M，不付费的话使用起来肯定不够。因此可以使用坚果云来同步附件，这样做的好处是ios上的PaperShip也可以通过WebDAV读取资料。\n\n# 准备工作\n\n注册一个坚果云账号，然后开启第三方应用管理：\n\n1. 登陆坚果云网页端，点击右上角的账号名称——账户信息——安全选项\n\n   ![](http://images.yingwai.top/picgo/zeterojgyf1.png)\n\n   然后点击添加应用，应用名称填Zotero(也可以填其它，只要你记得对应的软件)，会自动生成一个应用密码。\n\n2. 打开Zotero，点击菜单栏的编辑——首选项——同步，在文件同步中选择WebDav，复制坚果云内第三方应用管理的服务器地址、账户和密码，复制完成后点击 *验证服务器*。\n\n   ![](http://images.yingwai.top/picgo/zeterojgyf2.png)\n\n   这一步出现问题的话可以尝试在坚果云网页端手动建立一个zotero根目录，与zotero填的地址对应。\n\n\n\n# ZotFile的安装与设置\n\n进入[zotfile官网 ](http://zotfile.com/)下载。\n然后打开Zotero，点击菜单栏工具——插件，有以下界面：\n\n![](http://images.yingwai.top/picgo/zeterojgyf3.png)\n\n点击右上角的齿轮，选择 *Install Add-on From File...*，在弹出的插件安装中选择刚才下载的xpi文件进行安装。\n\n安装完成后点击菜单栏工具——ZotFile Preferences——General Settings：\n\n1. 将Source Folder for Attaching new Files中的目录设置为浏览器默认的下载文件目录；\n2. 将Location of Files中的目录设置为第一个Attach stored copy of files，要选择这个才能与前面的WebDAV设置配合使用。\n\n![](http://images.yingwai.top/picgo/zeterojgyf4.png)\n\n下面的 /%w/%y 是命名格式，也可以设置成别的。\n\n完成以上操作后，当我们在浏览器中点击Zotero插件时，软件就会自动将下载下来的pdf文件拷贝到云盘的目录中，并将它的目录链接保存到对应的文献条目下。\n\n\n\n# PaperShip使用\n\n方法类似上面，只要在坚果云网页端添加应用，在PaperShip登陆时选择WebDAV，把账号密码输入即可。这样在PC端管理的文献就可以方便地在移动端进行访问。\n\n效果：\n\n![](http://images.yingwai.top/picgo/zoterojgyf5.jpg)","source":"_posts/Zotero的附件同步.md","raw":"---\ntitle: Zotero的附件同步\ndate: 2020-07-10 23:19:21\ncategories: Env\ntags: [Zotero, 坚果云, PaperShip]\n---\n\n-----\n\n<!--more-->\n\nZotero的存储空间只有100M，不付费的话使用起来肯定不够。因此可以使用坚果云来同步附件，这样做的好处是ios上的PaperShip也可以通过WebDAV读取资料。\n\n# 准备工作\n\n注册一个坚果云账号，然后开启第三方应用管理：\n\n1. 登陆坚果云网页端，点击右上角的账号名称——账户信息——安全选项\n\n   ![](http://images.yingwai.top/picgo/zeterojgyf1.png)\n\n   然后点击添加应用，应用名称填Zotero(也可以填其它，只要你记得对应的软件)，会自动生成一个应用密码。\n\n2. 打开Zotero，点击菜单栏的编辑——首选项——同步，在文件同步中选择WebDav，复制坚果云内第三方应用管理的服务器地址、账户和密码，复制完成后点击 *验证服务器*。\n\n   ![](http://images.yingwai.top/picgo/zeterojgyf2.png)\n\n   这一步出现问题的话可以尝试在坚果云网页端手动建立一个zotero根目录，与zotero填的地址对应。\n\n\n\n# ZotFile的安装与设置\n\n进入[zotfile官网 ](http://zotfile.com/)下载。\n然后打开Zotero，点击菜单栏工具——插件，有以下界面：\n\n![](http://images.yingwai.top/picgo/zeterojgyf3.png)\n\n点击右上角的齿轮，选择 *Install Add-on From File...*，在弹出的插件安装中选择刚才下载的xpi文件进行安装。\n\n安装完成后点击菜单栏工具——ZotFile Preferences——General Settings：\n\n1. 将Source Folder for Attaching new Files中的目录设置为浏览器默认的下载文件目录；\n2. 将Location of Files中的目录设置为第一个Attach stored copy of files，要选择这个才能与前面的WebDAV设置配合使用。\n\n![](http://images.yingwai.top/picgo/zeterojgyf4.png)\n\n下面的 /%w/%y 是命名格式，也可以设置成别的。\n\n完成以上操作后，当我们在浏览器中点击Zotero插件时，软件就会自动将下载下来的pdf文件拷贝到云盘的目录中，并将它的目录链接保存到对应的文献条目下。\n\n\n\n# PaperShip使用\n\n方法类似上面，只要在坚果云网页端添加应用，在PaperShip登陆时选择WebDAV，把账号密码输入即可。这样在PC端管理的文献就可以方便地在移动端进行访问。\n\n效果：\n\n![](http://images.yingwai.top/picgo/zoterojgyf5.jpg)","slug":"Zotero的附件同步","published":1,"updated":"2020-08-23T14:33:37.431Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cke79q4p9000r88ps7v7t8qh9","content":"<hr>\n<a id=\"more\"></a>\n<p>Zotero的存储空间只有100M，不付费的话使用起来肯定不够。因此可以使用坚果云来同步附件，这样做的好处是ios上的PaperShip也可以通过WebDAV读取资料。</p>\n<h1 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h1><p>注册一个坚果云账号，然后开启第三方应用管理：</p>\n<ol>\n<li><p>登陆坚果云网页端，点击右上角的账号名称——账户信息——安全选项</p>\n<p><img src=\"http://images.yingwai.top/picgo/zeterojgyf1.png\" alt=\"\"></p>\n<p>然后点击添加应用，应用名称填Zotero(也可以填其它，只要你记得对应的软件)，会自动生成一个应用密码。</p>\n</li>\n<li><p>打开Zotero，点击菜单栏的编辑——首选项——同步，在文件同步中选择WebDav，复制坚果云内第三方应用管理的服务器地址、账户和密码，复制完成后点击 <em>验证服务器</em>。</p>\n<p><img src=\"http://images.yingwai.top/picgo/zeterojgyf2.png\" alt=\"\"></p>\n<p>这一步出现问题的话可以尝试在坚果云网页端手动建立一个zotero根目录，与zotero填的地址对应。</p>\n</li>\n</ol>\n<h1 id=\"ZotFile的安装与设置\"><a href=\"#ZotFile的安装与设置\" class=\"headerlink\" title=\"ZotFile的安装与设置\"></a>ZotFile的安装与设置</h1><p>进入<a href=\"http://zotfile.com/\" target=\"_blank\" rel=\"noopener\">zotfile官网 </a>下载。<br>然后打开Zotero，点击菜单栏工具——插件，有以下界面：</p>\n<p><img src=\"http://images.yingwai.top/picgo/zeterojgyf3.png\" alt=\"\"></p>\n<p>点击右上角的齿轮，选择 <em>Install Add-on From File…</em>，在弹出的插件安装中选择刚才下载的xpi文件进行安装。</p>\n<p>安装完成后点击菜单栏工具——ZotFile Preferences——General Settings：</p>\n<ol>\n<li>将Source Folder for Attaching new Files中的目录设置为浏览器默认的下载文件目录；</li>\n<li>将Location of Files中的目录设置为第一个Attach stored copy of files，要选择这个才能与前面的WebDAV设置配合使用。</li>\n</ol>\n<p><img src=\"http://images.yingwai.top/picgo/zeterojgyf4.png\" alt=\"\"></p>\n<p>下面的 /%w/%y 是命名格式，也可以设置成别的。</p>\n<p>完成以上操作后，当我们在浏览器中点击Zotero插件时，软件就会自动将下载下来的pdf文件拷贝到云盘的目录中，并将它的目录链接保存到对应的文献条目下。</p>\n<h1 id=\"PaperShip使用\"><a href=\"#PaperShip使用\" class=\"headerlink\" title=\"PaperShip使用\"></a>PaperShip使用</h1><p>方法类似上面，只要在坚果云网页端添加应用，在PaperShip登陆时选择WebDAV，把账号密码输入即可。这样在PC端管理的文献就可以方便地在移动端进行访问。</p>\n<p>效果：</p>\n<p><img src=\"http://images.yingwai.top/picgo/zoterojgyf5.jpg\" alt=\"\"></p>\n","site":{"data":{}},"excerpt":"<hr>","more":"<p>Zotero的存储空间只有100M，不付费的话使用起来肯定不够。因此可以使用坚果云来同步附件，这样做的好处是ios上的PaperShip也可以通过WebDAV读取资料。</p>\n<h1 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h1><p>注册一个坚果云账号，然后开启第三方应用管理：</p>\n<ol>\n<li><p>登陆坚果云网页端，点击右上角的账号名称——账户信息——安全选项</p>\n<p><img src=\"http://images.yingwai.top/picgo/zeterojgyf1.png\" alt=\"\"></p>\n<p>然后点击添加应用，应用名称填Zotero(也可以填其它，只要你记得对应的软件)，会自动生成一个应用密码。</p>\n</li>\n<li><p>打开Zotero，点击菜单栏的编辑——首选项——同步，在文件同步中选择WebDav，复制坚果云内第三方应用管理的服务器地址、账户和密码，复制完成后点击 <em>验证服务器</em>。</p>\n<p><img src=\"http://images.yingwai.top/picgo/zeterojgyf2.png\" alt=\"\"></p>\n<p>这一步出现问题的话可以尝试在坚果云网页端手动建立一个zotero根目录，与zotero填的地址对应。</p>\n</li>\n</ol>\n<h1 id=\"ZotFile的安装与设置\"><a href=\"#ZotFile的安装与设置\" class=\"headerlink\" title=\"ZotFile的安装与设置\"></a>ZotFile的安装与设置</h1><p>进入<a href=\"http://zotfile.com/\" target=\"_blank\" rel=\"noopener\">zotfile官网 </a>下载。<br>然后打开Zotero，点击菜单栏工具——插件，有以下界面：</p>\n<p><img src=\"http://images.yingwai.top/picgo/zeterojgyf3.png\" alt=\"\"></p>\n<p>点击右上角的齿轮，选择 <em>Install Add-on From File…</em>，在弹出的插件安装中选择刚才下载的xpi文件进行安装。</p>\n<p>安装完成后点击菜单栏工具——ZotFile Preferences——General Settings：</p>\n<ol>\n<li>将Source Folder for Attaching new Files中的目录设置为浏览器默认的下载文件目录；</li>\n<li>将Location of Files中的目录设置为第一个Attach stored copy of files，要选择这个才能与前面的WebDAV设置配合使用。</li>\n</ol>\n<p><img src=\"http://images.yingwai.top/picgo/zeterojgyf4.png\" alt=\"\"></p>\n<p>下面的 /%w/%y 是命名格式，也可以设置成别的。</p>\n<p>完成以上操作后，当我们在浏览器中点击Zotero插件时，软件就会自动将下载下来的pdf文件拷贝到云盘的目录中，并将它的目录链接保存到对应的文献条目下。</p>\n<h1 id=\"PaperShip使用\"><a href=\"#PaperShip使用\" class=\"headerlink\" title=\"PaperShip使用\"></a>PaperShip使用</h1><p>方法类似上面，只要在坚果云网页端添加应用，在PaperShip登陆时选择WebDAV，把账号密码输入即可。这样在PC端管理的文献就可以方便地在移动端进行访问。</p>\n<p>效果：</p>\n<p><img src=\"http://images.yingwai.top/picgo/zoterojgyf5.jpg\" alt=\"\"></p>"},{"title":"使用you-get下载网址视频","date":"2020-05-20T10:50:10.000Z","_content":"\n----\n\n\n\n<!--more-->\n\nyou-get是基于Python开发的，实际它不只支持视频下载，还支持图片、音乐等。而且，只要视频的地址，一行代码即可。\n\n\n\n# 安装you-get\n\n安装you-get的方式有很多，下面三种择其一即可。\n\n\n\n## 使用pip安装\n\n```shell\n$ pip3 install you-get\n```\n\n![](http://images.yingwai.top/picgo/yougetf1.png)\n\n\n\n## Git克隆\n\n```shell\n$ git clone git://github.com/soimort/you-get.git\n```\n\n然后直接运行`./setup.py`即可\n\n```shell\n$ python3 setup.py install\n```\n\n\n\n## 通过HomeBrew安装（Mac）\n\n```shell\n$ brew install you-get\n```\n\n\n\n# 下载视频\n\n命令行中输入以下代码下载视频：\n\n```shell\n$ you-get '视频地址URL'\n```\n\n这里以B站某视频为例：\n\n![](http://images.yingwai.top/picgo/yougetf2.png)\n\n下载好的视频存放在系统盘的用户目录下。\n\n\n\n# 查看视频信息\n\n命令行输入：\n\n```shell\n$ you-get -i '视频地址URL'\n```\n\n用刚刚下载的视频测试，结果如下：\n\n![](http://images.yingwai.top/picgo/yougetf3.png)\n\n可以看到它的默认设置不是MP4格式的视频，如果想要换成这种格式，可以在命令行输入：\n\n```shell\n$ you-get --itag=18 '视频地址URL'\n```\n\n\n\n# 支持的网站\n\n除了B站，还可以用you-get下载国内外很多主流网站的视频、图片和音乐。\n\n这里列出支持的国外网站：\n\n![](http://images.yingwai.top/picgo/yougetf4.jpg)","source":"_posts/使用you-get下载网址视频.md","raw":"---\ntitle: 使用you-get下载网址视频\ndate: 2020-05-20 18:50:10\ncategories: Env\ntags: Python\n---\n\n----\n\n\n\n<!--more-->\n\nyou-get是基于Python开发的，实际它不只支持视频下载，还支持图片、音乐等。而且，只要视频的地址，一行代码即可。\n\n\n\n# 安装you-get\n\n安装you-get的方式有很多，下面三种择其一即可。\n\n\n\n## 使用pip安装\n\n```shell\n$ pip3 install you-get\n```\n\n![](http://images.yingwai.top/picgo/yougetf1.png)\n\n\n\n## Git克隆\n\n```shell\n$ git clone git://github.com/soimort/you-get.git\n```\n\n然后直接运行`./setup.py`即可\n\n```shell\n$ python3 setup.py install\n```\n\n\n\n## 通过HomeBrew安装（Mac）\n\n```shell\n$ brew install you-get\n```\n\n\n\n# 下载视频\n\n命令行中输入以下代码下载视频：\n\n```shell\n$ you-get '视频地址URL'\n```\n\n这里以B站某视频为例：\n\n![](http://images.yingwai.top/picgo/yougetf2.png)\n\n下载好的视频存放在系统盘的用户目录下。\n\n\n\n# 查看视频信息\n\n命令行输入：\n\n```shell\n$ you-get -i '视频地址URL'\n```\n\n用刚刚下载的视频测试，结果如下：\n\n![](http://images.yingwai.top/picgo/yougetf3.png)\n\n可以看到它的默认设置不是MP4格式的视频，如果想要换成这种格式，可以在命令行输入：\n\n```shell\n$ you-get --itag=18 '视频地址URL'\n```\n\n\n\n# 支持的网站\n\n除了B站，还可以用you-get下载国内外很多主流网站的视频、图片和音乐。\n\n这里列出支持的国外网站：\n\n![](http://images.yingwai.top/picgo/yougetf4.jpg)","slug":"使用you-get下载网址视频","published":1,"updated":"2020-08-23T14:33:37.431Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cke79q4pa000u88ps31wdbhfo","content":"<hr>\n<a id=\"more\"></a>\n<p>you-get是基于Python开发的，实际它不只支持视频下载，还支持图片、音乐等。而且，只要视频的地址，一行代码即可。</p>\n<h1 id=\"安装you-get\"><a href=\"#安装you-get\" class=\"headerlink\" title=\"安装you-get\"></a>安装you-get</h1><p>安装you-get的方式有很多，下面三种择其一即可。</p>\n<h2 id=\"使用pip安装\"><a href=\"#使用pip安装\" class=\"headerlink\" title=\"使用pip安装\"></a>使用pip安装</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> pip3 install you-get</span></span><br></pre></td></tr></table></figure>\n<p><img src=\"http://images.yingwai.top/picgo/yougetf1.png\" alt=\"\"></p>\n<h2 id=\"Git克隆\"><a href=\"#Git克隆\" class=\"headerlink\" title=\"Git克隆\"></a>Git克隆</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> git <span class=\"built_in\">clone</span> git://github.com/soimort/you-get.git</span></span><br></pre></td></tr></table></figure>\n<p>然后直接运行<code>./setup.py</code>即可</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> python3 setup.py install</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"通过HomeBrew安装（Mac）\"><a href=\"#通过HomeBrew安装（Mac）\" class=\"headerlink\" title=\"通过HomeBrew安装（Mac）\"></a>通过HomeBrew安装（Mac）</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> brew install you-get</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"下载视频\"><a href=\"#下载视频\" class=\"headerlink\" title=\"下载视频\"></a>下载视频</h1><p>命令行中输入以下代码下载视频：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> you-get <span class=\"string\">'视频地址URL'</span></span></span><br></pre></td></tr></table></figure>\n<p>这里以B站某视频为例：</p>\n<p><img src=\"http://images.yingwai.top/picgo/yougetf2.png\" alt=\"\"></p>\n<p>下载好的视频存放在系统盘的用户目录下。</p>\n<h1 id=\"查看视频信息\"><a href=\"#查看视频信息\" class=\"headerlink\" title=\"查看视频信息\"></a>查看视频信息</h1><p>命令行输入：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> you-get -i <span class=\"string\">'视频地址URL'</span></span></span><br></pre></td></tr></table></figure>\n<p>用刚刚下载的视频测试，结果如下：</p>\n<p><img src=\"http://images.yingwai.top/picgo/yougetf3.png\" alt=\"\"></p>\n<p>可以看到它的默认设置不是MP4格式的视频，如果想要换成这种格式，可以在命令行输入：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> you-get --itag=18 <span class=\"string\">'视频地址URL'</span></span></span><br></pre></td></tr></table></figure>\n<h1 id=\"支持的网站\"><a href=\"#支持的网站\" class=\"headerlink\" title=\"支持的网站\"></a>支持的网站</h1><p>除了B站，还可以用you-get下载国内外很多主流网站的视频、图片和音乐。</p>\n<p>这里列出支持的国外网站：</p>\n<p><img src=\"http://images.yingwai.top/picgo/yougetf4.jpg\" alt=\"\"></p>\n","site":{"data":{}},"excerpt":"<hr>","more":"<p>you-get是基于Python开发的，实际它不只支持视频下载，还支持图片、音乐等。而且，只要视频的地址，一行代码即可。</p>\n<h1 id=\"安装you-get\"><a href=\"#安装you-get\" class=\"headerlink\" title=\"安装you-get\"></a>安装you-get</h1><p>安装you-get的方式有很多，下面三种择其一即可。</p>\n<h2 id=\"使用pip安装\"><a href=\"#使用pip安装\" class=\"headerlink\" title=\"使用pip安装\"></a>使用pip安装</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> pip3 install you-get</span></span><br></pre></td></tr></table></figure>\n<p><img src=\"http://images.yingwai.top/picgo/yougetf1.png\" alt=\"\"></p>\n<h2 id=\"Git克隆\"><a href=\"#Git克隆\" class=\"headerlink\" title=\"Git克隆\"></a>Git克隆</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> git <span class=\"built_in\">clone</span> git://github.com/soimort/you-get.git</span></span><br></pre></td></tr></table></figure>\n<p>然后直接运行<code>./setup.py</code>即可</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> python3 setup.py install</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"通过HomeBrew安装（Mac）\"><a href=\"#通过HomeBrew安装（Mac）\" class=\"headerlink\" title=\"通过HomeBrew安装（Mac）\"></a>通过HomeBrew安装（Mac）</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> brew install you-get</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"下载视频\"><a href=\"#下载视频\" class=\"headerlink\" title=\"下载视频\"></a>下载视频</h1><p>命令行中输入以下代码下载视频：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> you-get <span class=\"string\">'视频地址URL'</span></span></span><br></pre></td></tr></table></figure>\n<p>这里以B站某视频为例：</p>\n<p><img src=\"http://images.yingwai.top/picgo/yougetf2.png\" alt=\"\"></p>\n<p>下载好的视频存放在系统盘的用户目录下。</p>\n<h1 id=\"查看视频信息\"><a href=\"#查看视频信息\" class=\"headerlink\" title=\"查看视频信息\"></a>查看视频信息</h1><p>命令行输入：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> you-get -i <span class=\"string\">'视频地址URL'</span></span></span><br></pre></td></tr></table></figure>\n<p>用刚刚下载的视频测试，结果如下：</p>\n<p><img src=\"http://images.yingwai.top/picgo/yougetf3.png\" alt=\"\"></p>\n<p>可以看到它的默认设置不是MP4格式的视频，如果想要换成这种格式，可以在命令行输入：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> you-get --itag=18 <span class=\"string\">'视频地址URL'</span></span></span><br></pre></td></tr></table></figure>\n<h1 id=\"支持的网站\"><a href=\"#支持的网站\" class=\"headerlink\" title=\"支持的网站\"></a>支持的网站</h1><p>除了B站，还可以用you-get下载国内外很多主流网站的视频、图片和音乐。</p>\n<p>这里列出支持的国外网站：</p>\n<p><img src=\"http://images.yingwai.top/picgo/yougetf4.jpg\" alt=\"\"></p>"},{"title":"全同态加密算法深入解析","date":"2020-07-03T03:14:03.000Z","_content":"\n----\n\n<!--more-->\n\n转自https://zhuanlan.zhihu.com/p/54484449\n\n# 介绍\n\n同态加密方案提供了一种惊人的能力——能够在不解密的情况下，对密文数据进行计算。这使您无需破坏敏感源数据，同时可以对数据进行处理。\n\n其中最有影响的一个方案(也是最近一些标准化工作的主题)被称为Fan-Vercauteren (FV)方案(或称为Brakerski-Fan-Vercauteren方案)，我们将在这里深入地进行说明，同时你也可以尝试使用以下实现该方案的算法库：\n\n| Library  | URL                                                          | License                  | Language |\n| -------- | ------------------------------------------------------------ | ------------------------ | -------- |\n| HEANN    | https://github.com/kimandrik/HEAAN                           | CC  non commercial       | C++      |\n| NFLib    | https://github.com/quarkslab/NFLlib                          | GPLv3                    | C++      |\n| FV-NFLib | https://github.com/quarkslab/NFLlib                          | GPLv3                    | C++      |\n| cuHE     | https://github.com/vernamlab/cuHE                            | MIT                      | CUDA C++ |\n| PALISADE | https://git.njit.edu/palisade/PALISADE/tree/master           | Liberal                  | C++      |\n| SEAL     | https://www.microsoft.com/en-us/research/project/simple-encrypted-arithmetic-library/ | Microsoft  research only | C++      |\n| HELib    | https://github.com/shaih/HElib                               | Apache  2.0              | C++      |\n| jLBC     | http://gas.dia.unisa.it/projects/jlbc/download.html          | LGPLv3                   | Java     |\n\n这些加密方案看起来很复杂，也有一点神秘，但希望本文能让您清楚地了解它们的工作原理和驱动因素。\n\n这篇文章的整体结构包括\n\n* 一点点数学介绍\n\n* 加密和解密是如何工作的\n\n* 同态加法和乘法\n\n\n\n# 数学介绍\n\n这些同态加密方案是基于Ring Learning with Errors问题。本质上，这些方案中的数据在加密时(密文)和未加密时(明文)都以多项式表示。\n\n这些几乎是学校里每个人都学过的多项式。像\n$$\n4x^2 + 2x + 1\n$$\n但有一些区别，第一个是系数都是整数，并且需要 $\\bmod t$。假设 $t = 24$，这就像一个$24$小时的时钟，$21$加$6$得到$3$。多项式的所有系数都是这样处理的。\n\n![](http://images.yingwai.top/picgo/HEdif1.jpg)\n\n或者，我们可以将数字考虑在$-11$到$12$之间，这样我们就可以方便地求负数。注意，这只是一个方便系数——余数为$-1$和余数为$23$(除以$24$时)之间没有区别。\n\n![](http://images.yingwai.top/picgo/HEdif2_.jpg)\n\n第二点，也是比较棘手的一点，在于这种使用余数的思想不仅适用于多项式的系数，也适用于多项式本身。\n\n我们定义了一个特殊的多项式，称为多项式模，并且只考虑多项式乘以该多项式模后的余数。FV方案中该多项式模的具体形式为 $x^d+1$，其中对于某些 $n$，有 $d=2n$。为了说明这一点，我们取 $n=4$，因此多项式为 $x^{16}+1$。\n\n因为我们考虑的是关于模 $x^{16}+1$ 之后的余数，所以我们只需要考虑幂从 $x^0$ 到 $x^{15}$ 的多项式。任何更高次的幂都会因乘以该多项式模而消去。这也可以被理解为，$x^{16} \\equiv -1 (\\bmod x^{16}+1)$，这意味着 $x^{16}$ 可以被$-1$替换，以将 $x$ 的更高次幂归约到$0$到$15$的范围内。\n\n所以我们考虑的多项式都是这种形式的\n$$\n\\begin{align}\na_{15}x^{15} &+ a_{14}x^{14} + a_{13}x^{13} + a_{12}x^{12} + a_{11}x^{11} + a_{10}x^{10} + a_{9}x^{9} + a_{8}x^{8}\\\\\n+ &a_{7}x^{7} + a_{6}x^{6} + a_{5}x^{5} + a_{4}x^{4} + a_{3}x^{3} + a_{2}x^{2} + a_{1}x^{1} + a_0\n\\end{align}\n$$\n其中这16系数(即 $a_i$)中的每一个的范围都是从 $0$ 到 $t-1$。我们可以用系数的环面来说明，如下所示：\n\n![](http://images.yingwai.top/picgo/HEdif3.jpg)\n\n在这个图中，每个循环表示多项式中 $x$ 的幂次方前的系数的取值范围（包含24个可能值）。绿点代表系数取$0$时所处的位置。这为我们提供了一种很好的方法来可视化多项式，这在我们考虑加密和解密步骤如何工作时将会有所帮助。\n\nFV加密方案涉及大量的多项式乘法。当我们把 $x$ 的两个幂次方相乘，比如 $2x^{14}$ 和 $x^4$ 时，我们把它们的指数相加，得到 $2x^{18}$。有人可能会假设，求这个多项式关于多项式模的余数可能需要在 $x^{16}$ 处将指数旋转回$0$，得到 $2x^2$，就像上面所示的整数系数那样。如果多项式模是 $x^{16}$，情况就是这样。然而，我们的多项式模是 $x^{16}+1$ - 如上所述，额外的$+1$因子引入了一个符号变化，这有助于进一步干扰乘法的结果。\n\n![](http://images.yingwai.top/picgo/HEdif4.jpg)\n\n如上图所示，当 $2x^{14}$ 乘以 $x^4$ 后模 $$x^{16}+1$$ 时，取这个项(由上面的红点表示)，向前旋转环面$4$个幂，然后从$0$处调整系数的值，得到 $22x^2$(或 $−2x^2$，如果我们认为数字是从$-12$到$11$而不是从$0$到$23$时)。\n\n**这种形式的多项式具有非常丰富的结构和许多不错的特性。它们是分圆多项式的子集**。使用其中一个作为多项式模并不是严格必需的，但是这样做会更加方便快速。\n\n\n\n# 使用环上的多项式加密\n\n我们已经介绍了FV加密方案中使用的环上的多项式的一些属性，现在我们可以讨论加密和解密的工作原理。首先，我们需要讨论如何生成私钥和公钥，然后讨论如何使用它们进行加密和解密。\n\n\n\n## 私钥和公钥\n\n加密采用明文，并使用从私钥派生的公钥将其转换为密文。从明文到密文的转换是通过一种只有在您知道私钥的情况下才容易可逆的方式完成的。\n\n更具体地说，明文是环上的多项式，其具有多项式模 $x^d+1$，其中 $d = 2^n$，以及系数模 $t$。明文加密后为密文，其是由两个环上的、具有相同多项式模的多项式构成的，但系数模为 $q$，通常 $q$ 远大于 $t$。\n\n例如，多项式模为 $x^{4096} + 1$，这意味着明文和密文中的多项式都有 $d=4096$ 个系数。明文多项式的系数需要模 $t = 290764801$，密文多项式的系数需要模 $q = 9214347247561474048$ 或更大。\n\n为了便于说明，我们将使用较小的数字，但希望这些数字能够更好地说明方案的各个步骤中发生了什么。在第一部分中，为了更直观，我们将使用 $d = 16$、$t = 7$ 和 $q = 874$。注意，这些参数是不安全的!!\n\n对于私钥或密钥，我们用 $s$ 表示，它是我们随机生成的一个系数为 $-1$、$0$ 或 $1$ 的多项式。例如，\n$$\ns = x^{15} - x^{13}  - x^{12}  - x^{11}  - x^{9}  + x^{8}  + x^{6}  - x^{4}  + x^{2}  + x - 1\n$$\n接下来，我们从密文空间中随机生成一个多项式(用于生成公钥)，其系数模为 $q$，我们用 $a$ 表示。\n$$\n\\begin{align}\na = 42&x^{15} - 256x^{14} - 393x^{13} - 229x^{12} + 447x^{11} -369x^{10} - 212x^{9} + 107x^8\\\\\n&+ 52x^7 + 70x^6 - 138x^5 + 322x^4 + 186x^3 - 282x^2 - 60x + 84\n\\end{align}\n$$\n我们还定义了一个噪音多项式，它是“小”的，因为它是从离散高斯分布中取的一个小系数。这个多项式只在这里使用一次，然后丢弃。\n$$\n\\begin{align}\ne = -3x^{15} &+ x^{14} + x^{13} + 7x^{12} - 6x^{11} - 6x^{10} + x^{9} + 4x^8\\\\\n&- x^6 + 3x^5 -4x^4 + 4x^3 + 4x + 1\n\\end{align}\n$$\n然后将公钥定义为一对多项式，即 $\\mathbf{pk} = ([−as + e]q, a)$，其中多项式都是模多项式模和系数模 $q$ 的。\n\n对于上面给出的示例，公钥的第一个多项式被构造为\n\n![](http://images.yingwai.top/picgo/HEdif5.jpg)\n\n其中第一个乘法取多项式 $a$，它的系数 $\\bmod q$，然后乘以系数为$-1,0$或$1$的 $s$。由于模上多项式模的多项式的乘法具有“旋转和反射”性质，有效地混合和打乱了 $a$ 的所有系数，并进一步增加了小的噪音。多项式 $a$ 有效地掩盖了公钥中的私钥。\n\n通过从公钥中找到 $s$ 的方式来破解加密方案，其主要涉及的计算为 $([−as + e]q, a)$。唯一的因素是该方案中包含了噪音——如果 $e$ 为零，则很容易从公钥中计算出 $s$。当 $e$ 足够大，但又不太大时，这是一个难题。\n\n本文的示例中，私钥可以通过暴力攻击恢复——尝试每个可能的 $s$ (只有$3^{16}=43046721$组合)*，*然后计算 $as + e$ 来寻找出一个接近公钥的第一项的答案。对于真正的参数，这种暴力攻击的方法是完全不可行的。$3^{4096}$是一个很大的数字，但有更聪明的方法，然后定义给定的一组参数的安全性。\n\n\n\n## 加密\n\n加密过程看起来有点像公钥生成过程。\n\n加密明文的过程是将一个系数模为 $t$ 的多项式转换为一对系数模为 $q$ 的多项式。本例中，我们将加密一个非常简单的多项式(称为消息) $- m = 3 + 4x^8 \\equiv 3−3x^8$ – 只有两个不为零的系数。\n\n加密还需要三个小的多项式。两个噪音多项式来自于相同的离散高斯分布(即和公钥中的噪音多项式的取法一样)，另一个多项式我们称之为 $u$，它的系数为$-1$、$0$或$1$，就像私钥一样。\n$$\n\\begin{align}\ne_1 = &-5x^{15} - 2x^{14} + 3x^{13} - x^{12} - 4x^{11} + 3x^{10} + x^9 + 4x^8\\\\\n&+4x^7 + 5x^6 - 4x^5 - 3x^4 - 3x^3 + 2x^2 - 6x +4\n\\end{align}\n$$\n\n$$\n\\begin{align}\ne_2 = &-7x^{15} + 2x^{14} - 4x^{13} + 5x^{11} + 2x^{10} - x^9 + 4x^8\\\\\n&-4x^7 - 3x^6 + 2x^5 - 2x^4 + x^3 - 4x^2 - 2x + 2\n\\end{align}\n$$\n\n和\n$$\nu = x^{14} + x^{13} + x^{12} - x^8 - x^5 - x^3 + 1\n$$\n这些多项式只在加密过程中使用，然后丢弃。\n\n密文是由两个多项式组成的，通过如下计算得到\n$$\n\\mathbf{ct} = ([\\mathbf{pk}_0u + e_1 + qm/t]_q, [\\mathbf{pk}_1u + e_2]_q)\n$$\n请注意消息中的值是在 $\\bmod t$ 的范围内，而在我们的示例中，它们被缩放为 $q/t$ (即128)，使它们覆盖 $\\bmod q$ 的范围。这是消息被插入到密文时的唯一更改。这些值通过添加到第一项来掩盖，第一项的值是在 $\\bmod q$ 的范围内，与随机的噪音没有区别。$u$ 的随机性改变了每次加密中使用的掩码，从而确保相同的明文在每次加密时产生不同的密文。\n\n![](http://images.yingwai.top/picgo/HEdif6.jpg)\n\n同态加法和乘法之所以有效，是因为消息在密文中以比例来表示。其他项用于掩盖消息，而且可以证明它们是有效的，只有在您知道私钥的情况下才能删除它们。\n\n使用上面给出的多项式显式地计算密文的第一个元素\n$$\n\\begin{align}\n\\mathbf{ct}_0 = 217&x^{15} - 53x^{14} + 13x^{13} - 249x^{12} - 392x{11} - 238x^{10} + 252x^9 + 115x^8\\\\\n+5&x^7 +184x^6 -201x^5 -258x^4 -247x^3 +144x^2 +23x +42\n\\end{align}\n$$\n代入公钥，我们可以看到密文的第一个元素展开为 $\\mathbf{ct}_0 =[e_1 + eu – aus + qm / t]_q$。在这个表达式中，前两项是“小”的，与噪音成比例，后两项是“大”的。第一个大项有效地掩盖了第二个大项，即消息。\n\n密文的第二个元素是这样计算的:\n\n![](http://images.yingwai.top/picgo/HEdif7.jpg)\n\n代入公钥，我们看到密文的第二个元素展开为 $\\mathbf{ct}_1 = [au + e_2]_q$。这说明了解密是如何工作的——如果我们知道 $s$，就可以计算出 $\\mathbf{ct}_1 s = [aus + e_2s]_q$，它可以用来消除密文的第一个元素中的非消息大项。\n\n综上所述，密文可以用公钥、私钥、掩码、噪音和消息表示为\n\n![](http://images.yingwai.top/picgo/HEdif8.jpg)\n\n\n\n## 解密\n\n如上所述，解密相对简单。首先，我们计算 $[\\mathbf{ct}_0 + \\mathbf{ct}_1s]_q$，它将从消息中完全移除掩码。这给我们一个多项式，它可以展开为 $[qm / t + e_1 + eu + e_2s]_q$ -也就是说，缩放后的信息加上一些噪声。因此，只要噪声不太大，我们就可以恢复消息。\n\n明确地，\n$$\n\\begin{align}\n\\mathbf{ct}_1s + \\mathbf{ct}_0 &= 13x^{15} -2x^{14} + 17x^{13} + 22x^{12} - 32x^{11} - 23x^{10} + 19x^9 - 380x^8\\\\\n&+9x^7 + 10x^6 -13x^5 -3x^4 -2x^3 -12x^2 +7x +393\n\\end{align}\n$$\n在这里您可以看到，除了明文的两个非零系数( $x^8$ 和 $x^0$ )之外，所有的系数都小于 $q/t = 128$。如果我们把这个多项式缩放回 $\\bmod t$ 范围内的值，那么我们就得到\n$$\n\\begin{align}\n\\frac{13x^{15}}{128} &- \\frac{x^{14}}{64} + \\frac{17x^{13}}{128} + \\frac{11x^{12}}{64} - \\frac{x^{11}}{4} - \\frac{23x^{10}}{128} + \\frac{19x^{9}}{128} - \\frac{95x^{8}}{32}\\\\\n+ &\\frac{9x^{7}}{128} + \\frac{5x^{6}}{64} - \\frac{13x^{5}}{128} - \\frac{3x^{4}}{128} - \\frac{x^{3}}{64} - \\frac{3x^{2}}{32} + \\frac{7x}{128} + \\frac{393}{128}\n\\end{align}\n$$\n四舍五入这些系数可以恢复我们的消息 $m = 3 − 3x^8$。\n\n我们通过将系数四舍五入，来舍入到最接近的整数后得到我们的信息:\n\n![](http://images.yingwai.top/picgo/HEdif9.jpg)\n\n<center>\n    <i>绿色-噪音变换  粉色-舍入结果</i>\n</center>\n\n\n把它们放在一起，我们通过如下计算来解密密文\n$$\nm' = \\left[\\left \\lfloor \\frac{t}{q}[\\mathbf{ct}_0+\\mathbf{ct}_1s]_q \\right \\rceil \\right]_t\n$$\n$\\lfloor \\rceil$ 表示舍入到最接近的整数(四舍五入)。\n\n如果系数中噪音太大，那么它们最终会更接近一个与正确整数不同的整数，然后解密会(悄无声息地)失败并产生错误的结果。在上面的示例中，最大的噪音为$13 / 128$，所以仍然有一些空间允许产生更多的噪音，并且能够正确解密。噪音的含量可以通过将 $q / t$ 的比值变大或变小来调节。\n\n\n\n# 同态操作\n\n人们对这类密码体制如此感兴趣的一个主要原因是，它们允许同态加法和乘法(来自希腊语*homo* - same和*morphe* - shape)。这意味着您可以在数字仍然加密的情况下进行加法和乘法运算，而不必先解密它们。这是一个令人惊叹的功能，有望在数据保护和安全方面构建一个新的黄金标准。\n\n\n\n## 同态加法\n\n最简单的情况是两个加密数字的加法。假设我们已经用相同的公钥加密了两个多项式 $m_1$ 和 $m_2$：\n$$\n\\begin{align}\n\\mathbf{a} &= ([\\mathbf{pk}_0 u_1 + e_1 + qm_1/t]_q, [\\mathbf{pk}_1 u_1 + e_2]_q),\\\\\n\\mathbf{b} &= ([\\mathbf{pk}_0 u_2 + e_3 + qm_2/t]_q, [\\mathbf{pk}_1 u_2 + e_4]_q).\n\\end{align}\n$$\n注意，我们需要使用两个不同的、小的多项式 $u_1$ 和 $u_2$，以及4个小的噪音多项式 $e_1 \\cdot \\cdot \\cdot e_4$。\n\n如果我们仅仅是将密文中的元素相加，就会得到一个新的密文\n$$\n\\mathbf{a} + \\mathbf{b} = ([\\mathbf{pk}_0(u_1+u_2) + (e_1+e_3) + q(m_1+m_2)/t]_q, [\\mathbf{pk}_1(u_1+u_2) + (e_2+e_4)]_q)\n$$\n由于消息仅存在于具有缩放的密文中，所以加法的结果与 $m_1 + m_2$ 加密的形式相同，只是增加了新的噪音：\n$$\n\\mathbf{c} = ([\\mathbf{pk}_0 (u_3) + (e_5) + q(m_1+m_2)/t]_q, [\\mathbf{pk}_1(u_3) + (e_6)]_q)\n$$\n近似解密(舍入之前)将是\n$$\n[q(m_1 + m_2)/t + e_5 + eu_3 + e_6s]_q\n$$\n这意味着只要新的噪音不是太大，消息 $m_1 + m_2$ 将正确解密。噪音有三种类型：\n$$\ne_5 = e_1 + e_3\n$$\n\n$$\neu_3 = e(u_1 + u_2)\n$$\n\n$$\ne_6s =(e_2 + e_4)s\n$$\n\n我们担心的是，当这些项变得足够大，以至于噪音多项式中的一个系数大于 $q/(2t)$ 时，解密就会失败，因为解密过程结束时的四舍五入操作会四舍五入到错误的数字。\n\n如果我们只考虑第一项，那么我们就把来自离散高斯分布的多项式中的系数相加。这意味着，在某些情况下，我们会把一个负系数加到一个正系数上，结果会更接近于零。在其他情况下，系数会有相同的符号，所以结果会更大。我们可以做很多的同态加法，看看噪音是如何随着加法的数量增加而增加的，这是很有指导意义的。系数的分布如下图所示，其中我们添加了1、5和30个噪音多项式(随机地进行了数百次试验)。\n\n![](http://images.yingwai.top/picgo/HEdif10.png)\n\n当我们添加了30个噪音多项式时，某些系数有可能会大于64，即超过了 $q/t$ 的一半，所以解密不会产生正确的结果。\n\n另外两项表示不同的情况——第二项是一个噪音多项式乘以一些“小的多项式”(系数为$-1$、$0$或$1$)的总和。这种乘法会产生更大的噪音。一个噪音多项式和一个小的多项式的乘积的系数大约将是随机正负号的噪音多项式系数的2/3rds的总和。这意味着这个噪音与多项式的最高次的平方根 $\\sqrt{n}$ 一致。\n\n对这一项绘制与上面相同的分布可以看出，它比第一项大得多，而且即使对于我们示例中的参数，也存在错误解密的危险，即使只是添加了几个参数。\n\n![](http://images.yingwai.top/picgo/HEdif11.png)\n\n第三项是类似的——一组噪音多项式之和，乘以一个“小的多项式”。它的噪音分布是这样的：\n\n![](http://images.yingwai.top/picgo/HEdif12.jpg)\n\n结合起来，我们可以画出这三项的最大系数的增长，作为已经发生的加法数量的函数。这是一个须状图，给出了这些最大值的可变性。(注意噪音的均值接近于零，这是最大系数的幅值分布。)\n\n![](http://images.yingwai.top/picgo/HEdif13.jpg)\n\n这表明，对于我们所选择的参数，由两个以上加法产生的密文，解码错误的概率很高，而且两次加法失败的概率也很高。这是因为有时最大错误大于$64$，当 $q/t = 128$ 时，会导致不正确的解密，就像这里一样。为了给这样的操作提供更多的空间，我们需要使用更大的 $q/t$ 比值，这可以应对通常由所执行的操作数量引入的噪音量。\n\n不幸的是，由密文的同态乘法引入的噪音量又要大得多。\n\n\n\n## 同态乘法\n\n同态乘法在程序上很简单，但是比加法复杂得多。如上所述，消息以 $qm_1/t$ 的比例出现在密文的第一个元素中。因此，将两个密文的第一个元素相乘，再乘以 $t/q$，就会得到一个带有 $qm_1m_2/t$ 的项——如果我们仍然能够除去掩码项，这个项就可以恢复。\n\n因此，要理解同态乘法的机制，关键在于了解如何从密文的乘积中去掉掩码项。要做到这一点，我们的想法是把密文看作是私钥 $s$ 的幂次方的一个简单多项式。这是这篇文章中使用多项式的第三种不同的方法，所以它有点令人困惑，但是它是理解同态乘法如何工作的关键。\n\n我们可以写出解密过程的第一部分，使密文的每个元素都是 $s$ 的多项式的系数：\n$$\n[\\mathbf{ct}_0 + \\mathbf{ct}_1s^1]_q\n$$\n请记住，$\\mathbf{ct}$ 和 $s$ 本身就是多项式，所以这个方程是一个多项式乘以一个多项式($s_0$)加上一个多项式乘以另一个多项式，然后所有这些都取多项式模$x^d + 1$ 和系数模 $q$。\n\n现在，我们在上面看到解密产生了一个与掩码项 $au$ 无关的量。\n$$\n[\\mathbf{ct}_0 + \\mathbf{ct}_1s^1]_q \\rightarrow \\frac{q}{t}m + noise\n$$\n好了，现在考虑两个密文 $\\mathbf{a}$ 和 $\\mathbf{b}$，它们被定义为两个消息 $m_1$ 和 $m_2$ 的加密，它们可以被解密：\n$$\n[\\mathbf{a}_0 + \\mathbf{a}_1 s^1]_q \\rightarrow \\frac{q}{t}m_1 + n_1\\\\\n[\\mathbf{b}_0 + \\mathbf{b}_1 s^1]_q \\rightarrow \\frac{q}{t}m_2 + n_2\n$$\n其中 $n_1$ 和 $n_2$ 表示密文中的噪声。\n\n如果我们取它们的乘积，我们有：\n$$\n[\\mathbf{a}_0 + \\mathbf{a}_1 s^1]_q [\\mathbf{b}_0 + \\mathbf{b}_1 s^1]_q \\rightarrow (\\frac{q}{t}m_1 + n_1)(\\frac{q}{t}m_2 + n_2)\n$$\n右边的表达式与计算 $\\mathbf{a}$ 和 $\\mathbf{b}$ 所用的掩码无关，所以左边也必须与它们无关。\n\n如果我们把左边展开成 $s$ 的形式(为了方便起见，再乘以 $t/q$)就得到了\n$$\nmult(\\mathbf{a}, \\mathbf{b}) = \\mathbf{c}_0 + \\mathbf{c}_1s + \\mathbf{c}_2 s^2\n$$\n其中\n$$\n\\mathbf{c}_0 = \\left[\\frac{t}{q} \\mathbf{a}_0 \\mathbf{b}_0 \\right]_q\n$$\n\n$$\n\\mathbf{c}_1 = \\left[\\frac{t}{q} (\\mathbf{a}_1 \\mathbf{b}_0 + \\mathbf{a}_0 \\mathbf{b}_1) \\right]_q\n$$\n\n$$\n\\mathbf{c}_2 = \\left[\\frac{t}{q} \\mathbf{a}_1 \\mathbf{b}_1 \\right]_q\n$$\n\n这样做意味着我们可以计算出一个新的密文的组成部分，它比原来的密文多一个元素，并且可以正确地使用密钥 $s$ 的幂次方进行解密。\n\n解密的形式展开如下：\n$$\n\\left[\\left \\lfloor \\frac{t}{q}[\\mathbf{ct}_0 s^0 + \\mathbf{ct}_1 s^1 + \\mathbf{ct}_2 s^2]_q \\right \\rceil \\right]_t\n$$\n这只是增加了另一项即多项式乘以多项式的平方。有很多簿记要做，但它只是学校级代数(直到模数部分!)这是解密步骤的概括，它允许我们解密同态乘法的结果。\n\n要了解这一切是如何显式地工作的，请考虑 $\\mathbf{a}$ 和 $\\mathbf{b}$ 在加密过程中的展开式\n$$\n\\begin{align}\n\\mathbf{a} &= [\\mathbf{pk}_0 u_1 + e_{11} + qm_1/t, \\mathbf{pk}_1 u_1 + e_{12}]\\\\\n\\mathbf{b} &= [\\mathbf{pk}_0 u_2 + e_{21} + qm_2/t, \\mathbf{pk}_1 u_2 + e_{22}]\n\\end{align}\n$$\n如果我们展开乘法的定义，同时对结果进行部分解密(即解密到除以 $q/t$ 和整数之前)，那么得到的表达式就很复杂。但是，由于每个密文的组件都是在解密过程中被构造成能够删除掩码项($au_i$)的，所以这个展开的结果完全不依赖于来自公钥的掩码项!!!得到的表达式如下：\n$$\n\\begin{align}\n \\mathbf{c}_0 s^0 + \\mathbf{c}_1 s^1 + \\mathbf{c}_2 s^2 =  &\\frac{q}{t}m_1m_2 + e_{22}m_1s + e_{12}m_2s + em_2u_1 + em_1u_2 + e_{21}m_1 + e_{11}m_2\\\\\n&+ \\frac{t}{q}e^2u_1u_2 + \\frac{t}{q}e_{12}e_{22}s^2 + \\frac{t}{q}e_{22}esu_1 + \\frac{t}{q}e_{12}esu_2\\\\\n&+ \\frac{t}{q}e_{12}e_{21}s + \\frac{t}{q}e_{11}e_{22}s + \\frac{t}{q}e_{21}eu_1 + \\frac{t}{q}e_{11}eu_2 + \\frac{t}{q}e_{11}e_{21}\n\\end{align}\n$$\n这里有很多项，但是现在我们已经去掉了掩码，问题是，噪音(除了第一个)与 $q/(2t)$ 的“噪音预算”相比有多大?\n\n为了感受这一点，我们模拟了大量加密的随机信息的乘法，$d = 16$，$t = 7$，$q = 7168 = 1024 \\times t$。各类型噪音的系数大小分布如下图所示。请注意，总的噪音需要大于 $q/(2t) = 512$ 才能导致解密错误。在这些项中，涉及噪音多项式的项、消息和私钥 $e_{22}m_1 + e_{12}m_2s$ 是最大的贡献者。\n\n![](http://images.yingwai.top/picgo/HEdif14.jpg)\n\n上图显示，对于这些参数，最大的贡献来自于包含噪音多项式乘以消息多项式和私钥的项。这种噪音的最大系数约为300。这里有两项，其他的项更小。把所有的噪音合并成一个，就得到了乘法结果的总噪音。这些系数的分布如下图所示：\n\n![](http://images.yingwai.top/picgo/HEdif15.jpg)\n\n这表明没有足够的预算来安全地进行单次乘法，然后解密这些参数的正确结果(无论如何都是不安全的!)——大约1/4000的系数将具有大于512的噪音，导致约1%的解密错误率。\n\n因此，如果我们将它们视为 $s$ 的多项式，则可以进行密文的乘法，从而在解密时抵消它们自己的掩码项。将它们相乘，并分别跟踪 $s$ 的幂次方的系数和噪音量，以便我们确信它们能够正确解密。\n\n\n\n# Relinearisation和其他话题\n\n上面概述的乘法策略允许我们进行多次乘法，但代价是每次乘法都将密文的大小增加一个多项式。密文在大小上增长可能是一个问题。事实证明，有一些方法可以将密文的大小还原为两个多项式，但代价是增加噪音。这就是所谓的Relinearisation（再线性化），因为你要去掉 $s$ 多项式中的二次项和更高的项。\n\n另一项使这种加密方案切实可行的重要技术是将多个消息打包到一个明文中，通过并行化提高吞吐量。\n\n\n\n# 结论\n\n粗略地说，加密是将消息隐藏在一个环上的多项式中，并添加一些噪音。每个密文都包含足够的信息，可以在给定私钥的情况下除去自己的掩码。因为嵌入只涉及到消息的缩放，所以仍然可以对它们执行加法和乘法，并使用一些巧妙的结构来在之后移除掩码。该方案的安全性来自于在不知道私钥的情况下，在噪声存在的情况下很难去除掩码。这个问题的难度导致了一些优秀的安全性能，例如没有已知的量子算法来攻击这些系统。\n\n如果您已经了解了这些，我们希望您现在能够更好地理解基于Ring Learning with Errors问题的同态加密方案(或者至少是这些方案中的FV方案)的工作原理。","source":"_posts/全同态加密算法深入解析.md","raw":"---\ntitle: 全同态加密算法深入解析\ndate: 2020-07-03 11:14:03\ncategories: Study\ntags: [HE, 密码学]\n---\n\n----\n\n<!--more-->\n\n转自https://zhuanlan.zhihu.com/p/54484449\n\n# 介绍\n\n同态加密方案提供了一种惊人的能力——能够在不解密的情况下，对密文数据进行计算。这使您无需破坏敏感源数据，同时可以对数据进行处理。\n\n其中最有影响的一个方案(也是最近一些标准化工作的主题)被称为Fan-Vercauteren (FV)方案(或称为Brakerski-Fan-Vercauteren方案)，我们将在这里深入地进行说明，同时你也可以尝试使用以下实现该方案的算法库：\n\n| Library  | URL                                                          | License                  | Language |\n| -------- | ------------------------------------------------------------ | ------------------------ | -------- |\n| HEANN    | https://github.com/kimandrik/HEAAN                           | CC  non commercial       | C++      |\n| NFLib    | https://github.com/quarkslab/NFLlib                          | GPLv3                    | C++      |\n| FV-NFLib | https://github.com/quarkslab/NFLlib                          | GPLv3                    | C++      |\n| cuHE     | https://github.com/vernamlab/cuHE                            | MIT                      | CUDA C++ |\n| PALISADE | https://git.njit.edu/palisade/PALISADE/tree/master           | Liberal                  | C++      |\n| SEAL     | https://www.microsoft.com/en-us/research/project/simple-encrypted-arithmetic-library/ | Microsoft  research only | C++      |\n| HELib    | https://github.com/shaih/HElib                               | Apache  2.0              | C++      |\n| jLBC     | http://gas.dia.unisa.it/projects/jlbc/download.html          | LGPLv3                   | Java     |\n\n这些加密方案看起来很复杂，也有一点神秘，但希望本文能让您清楚地了解它们的工作原理和驱动因素。\n\n这篇文章的整体结构包括\n\n* 一点点数学介绍\n\n* 加密和解密是如何工作的\n\n* 同态加法和乘法\n\n\n\n# 数学介绍\n\n这些同态加密方案是基于Ring Learning with Errors问题。本质上，这些方案中的数据在加密时(密文)和未加密时(明文)都以多项式表示。\n\n这些几乎是学校里每个人都学过的多项式。像\n$$\n4x^2 + 2x + 1\n$$\n但有一些区别，第一个是系数都是整数，并且需要 $\\bmod t$。假设 $t = 24$，这就像一个$24$小时的时钟，$21$加$6$得到$3$。多项式的所有系数都是这样处理的。\n\n![](http://images.yingwai.top/picgo/HEdif1.jpg)\n\n或者，我们可以将数字考虑在$-11$到$12$之间，这样我们就可以方便地求负数。注意，这只是一个方便系数——余数为$-1$和余数为$23$(除以$24$时)之间没有区别。\n\n![](http://images.yingwai.top/picgo/HEdif2_.jpg)\n\n第二点，也是比较棘手的一点，在于这种使用余数的思想不仅适用于多项式的系数，也适用于多项式本身。\n\n我们定义了一个特殊的多项式，称为多项式模，并且只考虑多项式乘以该多项式模后的余数。FV方案中该多项式模的具体形式为 $x^d+1$，其中对于某些 $n$，有 $d=2n$。为了说明这一点，我们取 $n=4$，因此多项式为 $x^{16}+1$。\n\n因为我们考虑的是关于模 $x^{16}+1$ 之后的余数，所以我们只需要考虑幂从 $x^0$ 到 $x^{15}$ 的多项式。任何更高次的幂都会因乘以该多项式模而消去。这也可以被理解为，$x^{16} \\equiv -1 (\\bmod x^{16}+1)$，这意味着 $x^{16}$ 可以被$-1$替换，以将 $x$ 的更高次幂归约到$0$到$15$的范围内。\n\n所以我们考虑的多项式都是这种形式的\n$$\n\\begin{align}\na_{15}x^{15} &+ a_{14}x^{14} + a_{13}x^{13} + a_{12}x^{12} + a_{11}x^{11} + a_{10}x^{10} + a_{9}x^{9} + a_{8}x^{8}\\\\\n+ &a_{7}x^{7} + a_{6}x^{6} + a_{5}x^{5} + a_{4}x^{4} + a_{3}x^{3} + a_{2}x^{2} + a_{1}x^{1} + a_0\n\\end{align}\n$$\n其中这16系数(即 $a_i$)中的每一个的范围都是从 $0$ 到 $t-1$。我们可以用系数的环面来说明，如下所示：\n\n![](http://images.yingwai.top/picgo/HEdif3.jpg)\n\n在这个图中，每个循环表示多项式中 $x$ 的幂次方前的系数的取值范围（包含24个可能值）。绿点代表系数取$0$时所处的位置。这为我们提供了一种很好的方法来可视化多项式，这在我们考虑加密和解密步骤如何工作时将会有所帮助。\n\nFV加密方案涉及大量的多项式乘法。当我们把 $x$ 的两个幂次方相乘，比如 $2x^{14}$ 和 $x^4$ 时，我们把它们的指数相加，得到 $2x^{18}$。有人可能会假设，求这个多项式关于多项式模的余数可能需要在 $x^{16}$ 处将指数旋转回$0$，得到 $2x^2$，就像上面所示的整数系数那样。如果多项式模是 $x^{16}$，情况就是这样。然而，我们的多项式模是 $x^{16}+1$ - 如上所述，额外的$+1$因子引入了一个符号变化，这有助于进一步干扰乘法的结果。\n\n![](http://images.yingwai.top/picgo/HEdif4.jpg)\n\n如上图所示，当 $2x^{14}$ 乘以 $x^4$ 后模 $$x^{16}+1$$ 时，取这个项(由上面的红点表示)，向前旋转环面$4$个幂，然后从$0$处调整系数的值，得到 $22x^2$(或 $−2x^2$，如果我们认为数字是从$-12$到$11$而不是从$0$到$23$时)。\n\n**这种形式的多项式具有非常丰富的结构和许多不错的特性。它们是分圆多项式的子集**。使用其中一个作为多项式模并不是严格必需的，但是这样做会更加方便快速。\n\n\n\n# 使用环上的多项式加密\n\n我们已经介绍了FV加密方案中使用的环上的多项式的一些属性，现在我们可以讨论加密和解密的工作原理。首先，我们需要讨论如何生成私钥和公钥，然后讨论如何使用它们进行加密和解密。\n\n\n\n## 私钥和公钥\n\n加密采用明文，并使用从私钥派生的公钥将其转换为密文。从明文到密文的转换是通过一种只有在您知道私钥的情况下才容易可逆的方式完成的。\n\n更具体地说，明文是环上的多项式，其具有多项式模 $x^d+1$，其中 $d = 2^n$，以及系数模 $t$。明文加密后为密文，其是由两个环上的、具有相同多项式模的多项式构成的，但系数模为 $q$，通常 $q$ 远大于 $t$。\n\n例如，多项式模为 $x^{4096} + 1$，这意味着明文和密文中的多项式都有 $d=4096$ 个系数。明文多项式的系数需要模 $t = 290764801$，密文多项式的系数需要模 $q = 9214347247561474048$ 或更大。\n\n为了便于说明，我们将使用较小的数字，但希望这些数字能够更好地说明方案的各个步骤中发生了什么。在第一部分中，为了更直观，我们将使用 $d = 16$、$t = 7$ 和 $q = 874$。注意，这些参数是不安全的!!\n\n对于私钥或密钥，我们用 $s$ 表示，它是我们随机生成的一个系数为 $-1$、$0$ 或 $1$ 的多项式。例如，\n$$\ns = x^{15} - x^{13}  - x^{12}  - x^{11}  - x^{9}  + x^{8}  + x^{6}  - x^{4}  + x^{2}  + x - 1\n$$\n接下来，我们从密文空间中随机生成一个多项式(用于生成公钥)，其系数模为 $q$，我们用 $a$ 表示。\n$$\n\\begin{align}\na = 42&x^{15} - 256x^{14} - 393x^{13} - 229x^{12} + 447x^{11} -369x^{10} - 212x^{9} + 107x^8\\\\\n&+ 52x^7 + 70x^6 - 138x^5 + 322x^4 + 186x^3 - 282x^2 - 60x + 84\n\\end{align}\n$$\n我们还定义了一个噪音多项式，它是“小”的，因为它是从离散高斯分布中取的一个小系数。这个多项式只在这里使用一次，然后丢弃。\n$$\n\\begin{align}\ne = -3x^{15} &+ x^{14} + x^{13} + 7x^{12} - 6x^{11} - 6x^{10} + x^{9} + 4x^8\\\\\n&- x^6 + 3x^5 -4x^4 + 4x^3 + 4x + 1\n\\end{align}\n$$\n然后将公钥定义为一对多项式，即 $\\mathbf{pk} = ([−as + e]q, a)$，其中多项式都是模多项式模和系数模 $q$ 的。\n\n对于上面给出的示例，公钥的第一个多项式被构造为\n\n![](http://images.yingwai.top/picgo/HEdif5.jpg)\n\n其中第一个乘法取多项式 $a$，它的系数 $\\bmod q$，然后乘以系数为$-1,0$或$1$的 $s$。由于模上多项式模的多项式的乘法具有“旋转和反射”性质，有效地混合和打乱了 $a$ 的所有系数，并进一步增加了小的噪音。多项式 $a$ 有效地掩盖了公钥中的私钥。\n\n通过从公钥中找到 $s$ 的方式来破解加密方案，其主要涉及的计算为 $([−as + e]q, a)$。唯一的因素是该方案中包含了噪音——如果 $e$ 为零，则很容易从公钥中计算出 $s$。当 $e$ 足够大，但又不太大时，这是一个难题。\n\n本文的示例中，私钥可以通过暴力攻击恢复——尝试每个可能的 $s$ (只有$3^{16}=43046721$组合)*，*然后计算 $as + e$ 来寻找出一个接近公钥的第一项的答案。对于真正的参数，这种暴力攻击的方法是完全不可行的。$3^{4096}$是一个很大的数字，但有更聪明的方法，然后定义给定的一组参数的安全性。\n\n\n\n## 加密\n\n加密过程看起来有点像公钥生成过程。\n\n加密明文的过程是将一个系数模为 $t$ 的多项式转换为一对系数模为 $q$ 的多项式。本例中，我们将加密一个非常简单的多项式(称为消息) $- m = 3 + 4x^8 \\equiv 3−3x^8$ – 只有两个不为零的系数。\n\n加密还需要三个小的多项式。两个噪音多项式来自于相同的离散高斯分布(即和公钥中的噪音多项式的取法一样)，另一个多项式我们称之为 $u$，它的系数为$-1$、$0$或$1$，就像私钥一样。\n$$\n\\begin{align}\ne_1 = &-5x^{15} - 2x^{14} + 3x^{13} - x^{12} - 4x^{11} + 3x^{10} + x^9 + 4x^8\\\\\n&+4x^7 + 5x^6 - 4x^5 - 3x^4 - 3x^3 + 2x^2 - 6x +4\n\\end{align}\n$$\n\n$$\n\\begin{align}\ne_2 = &-7x^{15} + 2x^{14} - 4x^{13} + 5x^{11} + 2x^{10} - x^9 + 4x^8\\\\\n&-4x^7 - 3x^6 + 2x^5 - 2x^4 + x^3 - 4x^2 - 2x + 2\n\\end{align}\n$$\n\n和\n$$\nu = x^{14} + x^{13} + x^{12} - x^8 - x^5 - x^3 + 1\n$$\n这些多项式只在加密过程中使用，然后丢弃。\n\n密文是由两个多项式组成的，通过如下计算得到\n$$\n\\mathbf{ct} = ([\\mathbf{pk}_0u + e_1 + qm/t]_q, [\\mathbf{pk}_1u + e_2]_q)\n$$\n请注意消息中的值是在 $\\bmod t$ 的范围内，而在我们的示例中，它们被缩放为 $q/t$ (即128)，使它们覆盖 $\\bmod q$ 的范围。这是消息被插入到密文时的唯一更改。这些值通过添加到第一项来掩盖，第一项的值是在 $\\bmod q$ 的范围内，与随机的噪音没有区别。$u$ 的随机性改变了每次加密中使用的掩码，从而确保相同的明文在每次加密时产生不同的密文。\n\n![](http://images.yingwai.top/picgo/HEdif6.jpg)\n\n同态加法和乘法之所以有效，是因为消息在密文中以比例来表示。其他项用于掩盖消息，而且可以证明它们是有效的，只有在您知道私钥的情况下才能删除它们。\n\n使用上面给出的多项式显式地计算密文的第一个元素\n$$\n\\begin{align}\n\\mathbf{ct}_0 = 217&x^{15} - 53x^{14} + 13x^{13} - 249x^{12} - 392x{11} - 238x^{10} + 252x^9 + 115x^8\\\\\n+5&x^7 +184x^6 -201x^5 -258x^4 -247x^3 +144x^2 +23x +42\n\\end{align}\n$$\n代入公钥，我们可以看到密文的第一个元素展开为 $\\mathbf{ct}_0 =[e_1 + eu – aus + qm / t]_q$。在这个表达式中，前两项是“小”的，与噪音成比例，后两项是“大”的。第一个大项有效地掩盖了第二个大项，即消息。\n\n密文的第二个元素是这样计算的:\n\n![](http://images.yingwai.top/picgo/HEdif7.jpg)\n\n代入公钥，我们看到密文的第二个元素展开为 $\\mathbf{ct}_1 = [au + e_2]_q$。这说明了解密是如何工作的——如果我们知道 $s$，就可以计算出 $\\mathbf{ct}_1 s = [aus + e_2s]_q$，它可以用来消除密文的第一个元素中的非消息大项。\n\n综上所述，密文可以用公钥、私钥、掩码、噪音和消息表示为\n\n![](http://images.yingwai.top/picgo/HEdif8.jpg)\n\n\n\n## 解密\n\n如上所述，解密相对简单。首先，我们计算 $[\\mathbf{ct}_0 + \\mathbf{ct}_1s]_q$，它将从消息中完全移除掩码。这给我们一个多项式，它可以展开为 $[qm / t + e_1 + eu + e_2s]_q$ -也就是说，缩放后的信息加上一些噪声。因此，只要噪声不太大，我们就可以恢复消息。\n\n明确地，\n$$\n\\begin{align}\n\\mathbf{ct}_1s + \\mathbf{ct}_0 &= 13x^{15} -2x^{14} + 17x^{13} + 22x^{12} - 32x^{11} - 23x^{10} + 19x^9 - 380x^8\\\\\n&+9x^7 + 10x^6 -13x^5 -3x^4 -2x^3 -12x^2 +7x +393\n\\end{align}\n$$\n在这里您可以看到，除了明文的两个非零系数( $x^8$ 和 $x^0$ )之外，所有的系数都小于 $q/t = 128$。如果我们把这个多项式缩放回 $\\bmod t$ 范围内的值，那么我们就得到\n$$\n\\begin{align}\n\\frac{13x^{15}}{128} &- \\frac{x^{14}}{64} + \\frac{17x^{13}}{128} + \\frac{11x^{12}}{64} - \\frac{x^{11}}{4} - \\frac{23x^{10}}{128} + \\frac{19x^{9}}{128} - \\frac{95x^{8}}{32}\\\\\n+ &\\frac{9x^{7}}{128} + \\frac{5x^{6}}{64} - \\frac{13x^{5}}{128} - \\frac{3x^{4}}{128} - \\frac{x^{3}}{64} - \\frac{3x^{2}}{32} + \\frac{7x}{128} + \\frac{393}{128}\n\\end{align}\n$$\n四舍五入这些系数可以恢复我们的消息 $m = 3 − 3x^8$。\n\n我们通过将系数四舍五入，来舍入到最接近的整数后得到我们的信息:\n\n![](http://images.yingwai.top/picgo/HEdif9.jpg)\n\n<center>\n    <i>绿色-噪音变换  粉色-舍入结果</i>\n</center>\n\n\n把它们放在一起，我们通过如下计算来解密密文\n$$\nm' = \\left[\\left \\lfloor \\frac{t}{q}[\\mathbf{ct}_0+\\mathbf{ct}_1s]_q \\right \\rceil \\right]_t\n$$\n$\\lfloor \\rceil$ 表示舍入到最接近的整数(四舍五入)。\n\n如果系数中噪音太大，那么它们最终会更接近一个与正确整数不同的整数，然后解密会(悄无声息地)失败并产生错误的结果。在上面的示例中，最大的噪音为$13 / 128$，所以仍然有一些空间允许产生更多的噪音，并且能够正确解密。噪音的含量可以通过将 $q / t$ 的比值变大或变小来调节。\n\n\n\n# 同态操作\n\n人们对这类密码体制如此感兴趣的一个主要原因是，它们允许同态加法和乘法(来自希腊语*homo* - same和*morphe* - shape)。这意味着您可以在数字仍然加密的情况下进行加法和乘法运算，而不必先解密它们。这是一个令人惊叹的功能，有望在数据保护和安全方面构建一个新的黄金标准。\n\n\n\n## 同态加法\n\n最简单的情况是两个加密数字的加法。假设我们已经用相同的公钥加密了两个多项式 $m_1$ 和 $m_2$：\n$$\n\\begin{align}\n\\mathbf{a} &= ([\\mathbf{pk}_0 u_1 + e_1 + qm_1/t]_q, [\\mathbf{pk}_1 u_1 + e_2]_q),\\\\\n\\mathbf{b} &= ([\\mathbf{pk}_0 u_2 + e_3 + qm_2/t]_q, [\\mathbf{pk}_1 u_2 + e_4]_q).\n\\end{align}\n$$\n注意，我们需要使用两个不同的、小的多项式 $u_1$ 和 $u_2$，以及4个小的噪音多项式 $e_1 \\cdot \\cdot \\cdot e_4$。\n\n如果我们仅仅是将密文中的元素相加，就会得到一个新的密文\n$$\n\\mathbf{a} + \\mathbf{b} = ([\\mathbf{pk}_0(u_1+u_2) + (e_1+e_3) + q(m_1+m_2)/t]_q, [\\mathbf{pk}_1(u_1+u_2) + (e_2+e_4)]_q)\n$$\n由于消息仅存在于具有缩放的密文中，所以加法的结果与 $m_1 + m_2$ 加密的形式相同，只是增加了新的噪音：\n$$\n\\mathbf{c} = ([\\mathbf{pk}_0 (u_3) + (e_5) + q(m_1+m_2)/t]_q, [\\mathbf{pk}_1(u_3) + (e_6)]_q)\n$$\n近似解密(舍入之前)将是\n$$\n[q(m_1 + m_2)/t + e_5 + eu_3 + e_6s]_q\n$$\n这意味着只要新的噪音不是太大，消息 $m_1 + m_2$ 将正确解密。噪音有三种类型：\n$$\ne_5 = e_1 + e_3\n$$\n\n$$\neu_3 = e(u_1 + u_2)\n$$\n\n$$\ne_6s =(e_2 + e_4)s\n$$\n\n我们担心的是，当这些项变得足够大，以至于噪音多项式中的一个系数大于 $q/(2t)$ 时，解密就会失败，因为解密过程结束时的四舍五入操作会四舍五入到错误的数字。\n\n如果我们只考虑第一项，那么我们就把来自离散高斯分布的多项式中的系数相加。这意味着，在某些情况下，我们会把一个负系数加到一个正系数上，结果会更接近于零。在其他情况下，系数会有相同的符号，所以结果会更大。我们可以做很多的同态加法，看看噪音是如何随着加法的数量增加而增加的，这是很有指导意义的。系数的分布如下图所示，其中我们添加了1、5和30个噪音多项式(随机地进行了数百次试验)。\n\n![](http://images.yingwai.top/picgo/HEdif10.png)\n\n当我们添加了30个噪音多项式时，某些系数有可能会大于64，即超过了 $q/t$ 的一半，所以解密不会产生正确的结果。\n\n另外两项表示不同的情况——第二项是一个噪音多项式乘以一些“小的多项式”(系数为$-1$、$0$或$1$)的总和。这种乘法会产生更大的噪音。一个噪音多项式和一个小的多项式的乘积的系数大约将是随机正负号的噪音多项式系数的2/3rds的总和。这意味着这个噪音与多项式的最高次的平方根 $\\sqrt{n}$ 一致。\n\n对这一项绘制与上面相同的分布可以看出，它比第一项大得多，而且即使对于我们示例中的参数，也存在错误解密的危险，即使只是添加了几个参数。\n\n![](http://images.yingwai.top/picgo/HEdif11.png)\n\n第三项是类似的——一组噪音多项式之和，乘以一个“小的多项式”。它的噪音分布是这样的：\n\n![](http://images.yingwai.top/picgo/HEdif12.jpg)\n\n结合起来，我们可以画出这三项的最大系数的增长，作为已经发生的加法数量的函数。这是一个须状图，给出了这些最大值的可变性。(注意噪音的均值接近于零，这是最大系数的幅值分布。)\n\n![](http://images.yingwai.top/picgo/HEdif13.jpg)\n\n这表明，对于我们所选择的参数，由两个以上加法产生的密文，解码错误的概率很高，而且两次加法失败的概率也很高。这是因为有时最大错误大于$64$，当 $q/t = 128$ 时，会导致不正确的解密，就像这里一样。为了给这样的操作提供更多的空间，我们需要使用更大的 $q/t$ 比值，这可以应对通常由所执行的操作数量引入的噪音量。\n\n不幸的是，由密文的同态乘法引入的噪音量又要大得多。\n\n\n\n## 同态乘法\n\n同态乘法在程序上很简单，但是比加法复杂得多。如上所述，消息以 $qm_1/t$ 的比例出现在密文的第一个元素中。因此，将两个密文的第一个元素相乘，再乘以 $t/q$，就会得到一个带有 $qm_1m_2/t$ 的项——如果我们仍然能够除去掩码项，这个项就可以恢复。\n\n因此，要理解同态乘法的机制，关键在于了解如何从密文的乘积中去掉掩码项。要做到这一点，我们的想法是把密文看作是私钥 $s$ 的幂次方的一个简单多项式。这是这篇文章中使用多项式的第三种不同的方法，所以它有点令人困惑，但是它是理解同态乘法如何工作的关键。\n\n我们可以写出解密过程的第一部分，使密文的每个元素都是 $s$ 的多项式的系数：\n$$\n[\\mathbf{ct}_0 + \\mathbf{ct}_1s^1]_q\n$$\n请记住，$\\mathbf{ct}$ 和 $s$ 本身就是多项式，所以这个方程是一个多项式乘以一个多项式($s_0$)加上一个多项式乘以另一个多项式，然后所有这些都取多项式模$x^d + 1$ 和系数模 $q$。\n\n现在，我们在上面看到解密产生了一个与掩码项 $au$ 无关的量。\n$$\n[\\mathbf{ct}_0 + \\mathbf{ct}_1s^1]_q \\rightarrow \\frac{q}{t}m + noise\n$$\n好了，现在考虑两个密文 $\\mathbf{a}$ 和 $\\mathbf{b}$，它们被定义为两个消息 $m_1$ 和 $m_2$ 的加密，它们可以被解密：\n$$\n[\\mathbf{a}_0 + \\mathbf{a}_1 s^1]_q \\rightarrow \\frac{q}{t}m_1 + n_1\\\\\n[\\mathbf{b}_0 + \\mathbf{b}_1 s^1]_q \\rightarrow \\frac{q}{t}m_2 + n_2\n$$\n其中 $n_1$ 和 $n_2$ 表示密文中的噪声。\n\n如果我们取它们的乘积，我们有：\n$$\n[\\mathbf{a}_0 + \\mathbf{a}_1 s^1]_q [\\mathbf{b}_0 + \\mathbf{b}_1 s^1]_q \\rightarrow (\\frac{q}{t}m_1 + n_1)(\\frac{q}{t}m_2 + n_2)\n$$\n右边的表达式与计算 $\\mathbf{a}$ 和 $\\mathbf{b}$ 所用的掩码无关，所以左边也必须与它们无关。\n\n如果我们把左边展开成 $s$ 的形式(为了方便起见，再乘以 $t/q$)就得到了\n$$\nmult(\\mathbf{a}, \\mathbf{b}) = \\mathbf{c}_0 + \\mathbf{c}_1s + \\mathbf{c}_2 s^2\n$$\n其中\n$$\n\\mathbf{c}_0 = \\left[\\frac{t}{q} \\mathbf{a}_0 \\mathbf{b}_0 \\right]_q\n$$\n\n$$\n\\mathbf{c}_1 = \\left[\\frac{t}{q} (\\mathbf{a}_1 \\mathbf{b}_0 + \\mathbf{a}_0 \\mathbf{b}_1) \\right]_q\n$$\n\n$$\n\\mathbf{c}_2 = \\left[\\frac{t}{q} \\mathbf{a}_1 \\mathbf{b}_1 \\right]_q\n$$\n\n这样做意味着我们可以计算出一个新的密文的组成部分，它比原来的密文多一个元素，并且可以正确地使用密钥 $s$ 的幂次方进行解密。\n\n解密的形式展开如下：\n$$\n\\left[\\left \\lfloor \\frac{t}{q}[\\mathbf{ct}_0 s^0 + \\mathbf{ct}_1 s^1 + \\mathbf{ct}_2 s^2]_q \\right \\rceil \\right]_t\n$$\n这只是增加了另一项即多项式乘以多项式的平方。有很多簿记要做，但它只是学校级代数(直到模数部分!)这是解密步骤的概括，它允许我们解密同态乘法的结果。\n\n要了解这一切是如何显式地工作的，请考虑 $\\mathbf{a}$ 和 $\\mathbf{b}$ 在加密过程中的展开式\n$$\n\\begin{align}\n\\mathbf{a} &= [\\mathbf{pk}_0 u_1 + e_{11} + qm_1/t, \\mathbf{pk}_1 u_1 + e_{12}]\\\\\n\\mathbf{b} &= [\\mathbf{pk}_0 u_2 + e_{21} + qm_2/t, \\mathbf{pk}_1 u_2 + e_{22}]\n\\end{align}\n$$\n如果我们展开乘法的定义，同时对结果进行部分解密(即解密到除以 $q/t$ 和整数之前)，那么得到的表达式就很复杂。但是，由于每个密文的组件都是在解密过程中被构造成能够删除掩码项($au_i$)的，所以这个展开的结果完全不依赖于来自公钥的掩码项!!!得到的表达式如下：\n$$\n\\begin{align}\n \\mathbf{c}_0 s^0 + \\mathbf{c}_1 s^1 + \\mathbf{c}_2 s^2 =  &\\frac{q}{t}m_1m_2 + e_{22}m_1s + e_{12}m_2s + em_2u_1 + em_1u_2 + e_{21}m_1 + e_{11}m_2\\\\\n&+ \\frac{t}{q}e^2u_1u_2 + \\frac{t}{q}e_{12}e_{22}s^2 + \\frac{t}{q}e_{22}esu_1 + \\frac{t}{q}e_{12}esu_2\\\\\n&+ \\frac{t}{q}e_{12}e_{21}s + \\frac{t}{q}e_{11}e_{22}s + \\frac{t}{q}e_{21}eu_1 + \\frac{t}{q}e_{11}eu_2 + \\frac{t}{q}e_{11}e_{21}\n\\end{align}\n$$\n这里有很多项，但是现在我们已经去掉了掩码，问题是，噪音(除了第一个)与 $q/(2t)$ 的“噪音预算”相比有多大?\n\n为了感受这一点，我们模拟了大量加密的随机信息的乘法，$d = 16$，$t = 7$，$q = 7168 = 1024 \\times t$。各类型噪音的系数大小分布如下图所示。请注意，总的噪音需要大于 $q/(2t) = 512$ 才能导致解密错误。在这些项中，涉及噪音多项式的项、消息和私钥 $e_{22}m_1 + e_{12}m_2s$ 是最大的贡献者。\n\n![](http://images.yingwai.top/picgo/HEdif14.jpg)\n\n上图显示，对于这些参数，最大的贡献来自于包含噪音多项式乘以消息多项式和私钥的项。这种噪音的最大系数约为300。这里有两项，其他的项更小。把所有的噪音合并成一个，就得到了乘法结果的总噪音。这些系数的分布如下图所示：\n\n![](http://images.yingwai.top/picgo/HEdif15.jpg)\n\n这表明没有足够的预算来安全地进行单次乘法，然后解密这些参数的正确结果(无论如何都是不安全的!)——大约1/4000的系数将具有大于512的噪音，导致约1%的解密错误率。\n\n因此，如果我们将它们视为 $s$ 的多项式，则可以进行密文的乘法，从而在解密时抵消它们自己的掩码项。将它们相乘，并分别跟踪 $s$ 的幂次方的系数和噪音量，以便我们确信它们能够正确解密。\n\n\n\n# Relinearisation和其他话题\n\n上面概述的乘法策略允许我们进行多次乘法，但代价是每次乘法都将密文的大小增加一个多项式。密文在大小上增长可能是一个问题。事实证明，有一些方法可以将密文的大小还原为两个多项式，但代价是增加噪音。这就是所谓的Relinearisation（再线性化），因为你要去掉 $s$ 多项式中的二次项和更高的项。\n\n另一项使这种加密方案切实可行的重要技术是将多个消息打包到一个明文中，通过并行化提高吞吐量。\n\n\n\n# 结论\n\n粗略地说，加密是将消息隐藏在一个环上的多项式中，并添加一些噪音。每个密文都包含足够的信息，可以在给定私钥的情况下除去自己的掩码。因为嵌入只涉及到消息的缩放，所以仍然可以对它们执行加法和乘法，并使用一些巧妙的结构来在之后移除掩码。该方案的安全性来自于在不知道私钥的情况下，在噪声存在的情况下很难去除掩码。这个问题的难度导致了一些优秀的安全性能，例如没有已知的量子算法来攻击这些系统。\n\n如果您已经了解了这些，我们希望您现在能够更好地理解基于Ring Learning with Errors问题的同态加密方案(或者至少是这些方案中的FV方案)的工作原理。","slug":"全同态加密算法深入解析","published":1,"updated":"2020-08-23T14:33:37.432Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cke79q4pb000z88ps4x2n1i67","content":"<hr>\n<a id=\"more\"></a>\n<p>转自<a href=\"https://zhuanlan.zhihu.com/p/54484449\" target=\"_blank\" rel=\"noopener\">https://zhuanlan.zhihu.com/p/54484449</a></p>\n<h1 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h1><p>同态加密方案提供了一种惊人的能力——能够在不解密的情况下，对密文数据进行计算。这使您无需破坏敏感源数据，同时可以对数据进行处理。</p>\n<p>其中最有影响的一个方案(也是最近一些标准化工作的主题)被称为Fan-Vercauteren (FV)方案(或称为Brakerski-Fan-Vercauteren方案)，我们将在这里深入地进行说明，同时你也可以尝试使用以下实现该方案的算法库：</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>Library</th>\n<th>URL</th>\n<th>License</th>\n<th>Language</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>HEANN</td>\n<td><a href=\"https://github.com/kimandrik/HEAAN\" target=\"_blank\" rel=\"noopener\">https://github.com/kimandrik/HEAAN</a></td>\n<td>CC  non commercial</td>\n<td>C++</td>\n</tr>\n<tr>\n<td>NFLib</td>\n<td><a href=\"https://github.com/quarkslab/NFLlib\" target=\"_blank\" rel=\"noopener\">https://github.com/quarkslab/NFLlib</a></td>\n<td>GPLv3</td>\n<td>C++</td>\n</tr>\n<tr>\n<td>FV-NFLib</td>\n<td><a href=\"https://github.com/quarkslab/NFLlib\" target=\"_blank\" rel=\"noopener\">https://github.com/quarkslab/NFLlib</a></td>\n<td>GPLv3</td>\n<td>C++</td>\n</tr>\n<tr>\n<td>cuHE</td>\n<td><a href=\"https://github.com/vernamlab/cuHE\" target=\"_blank\" rel=\"noopener\">https://github.com/vernamlab/cuHE</a></td>\n<td>MIT</td>\n<td>CUDA C++</td>\n</tr>\n<tr>\n<td>PALISADE</td>\n<td><a href=\"https://git.njit.edu/palisade/PALISADE/tree/master\" target=\"_blank\" rel=\"noopener\">https://git.njit.edu/palisade/PALISADE/tree/master</a></td>\n<td>Liberal</td>\n<td>C++</td>\n</tr>\n<tr>\n<td>SEAL</td>\n<td><a href=\"https://www.microsoft.com/en-us/research/project/simple-encrypted-arithmetic-library/\" target=\"_blank\" rel=\"noopener\">https://www.microsoft.com/en-us/research/project/simple-encrypted-arithmetic-library/</a></td>\n<td>Microsoft  research only</td>\n<td>C++</td>\n</tr>\n<tr>\n<td>HELib</td>\n<td><a href=\"https://github.com/shaih/HElib\" target=\"_blank\" rel=\"noopener\">https://github.com/shaih/HElib</a></td>\n<td>Apache  2.0</td>\n<td>C++</td>\n</tr>\n<tr>\n<td>jLBC</td>\n<td><a href=\"http://gas.dia.unisa.it/projects/jlbc/download.html\" target=\"_blank\" rel=\"noopener\">http://gas.dia.unisa.it/projects/jlbc/download.html</a></td>\n<td>LGPLv3</td>\n<td>Java</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>这些加密方案看起来很复杂，也有一点神秘，但希望本文能让您清楚地了解它们的工作原理和驱动因素。</p>\n<p>这篇文章的整体结构包括</p>\n<ul>\n<li><p>一点点数学介绍</p>\n</li>\n<li><p>加密和解密是如何工作的</p>\n</li>\n<li><p>同态加法和乘法</p>\n</li>\n</ul>\n<h1 id=\"数学介绍\"><a href=\"#数学介绍\" class=\"headerlink\" title=\"数学介绍\"></a>数学介绍</h1><p>这些同态加密方案是基于Ring Learning with Errors问题。本质上，这些方案中的数据在加密时(密文)和未加密时(明文)都以多项式表示。</p>\n<p>这些几乎是学校里每个人都学过的多项式。像</p>\n<script type=\"math/tex; mode=display\">\n4x^2 + 2x + 1</script><p>但有一些区别，第一个是系数都是整数，并且需要 $\\bmod t$。假设 $t = 24$，这就像一个$24$小时的时钟，$21$加$6$得到$3$。多项式的所有系数都是这样处理的。</p>\n<p><img src=\"http://images.yingwai.top/picgo/HEdif1.jpg\" alt=\"\"></p>\n<p>或者，我们可以将数字考虑在$-11$到$12$之间，这样我们就可以方便地求负数。注意，这只是一个方便系数——余数为$-1$和余数为$23$(除以$24$时)之间没有区别。</p>\n<p><img src=\"http://images.yingwai.top/picgo/HEdif2_.jpg\" alt=\"\"></p>\n<p>第二点，也是比较棘手的一点，在于这种使用余数的思想不仅适用于多项式的系数，也适用于多项式本身。</p>\n<p>我们定义了一个特殊的多项式，称为多项式模，并且只考虑多项式乘以该多项式模后的余数。FV方案中该多项式模的具体形式为 $x^d+1$，其中对于某些 $n$，有 $d=2n$。为了说明这一点，我们取 $n=4$，因此多项式为 $x^{16}+1$。</p>\n<p>因为我们考虑的是关于模 $x^{16}+1$ 之后的余数，所以我们只需要考虑幂从 $x^0$ 到 $x^{15}$ 的多项式。任何更高次的幂都会因乘以该多项式模而消去。这也可以被理解为，$x^{16} \\equiv -1 (\\bmod x^{16}+1)$，这意味着 $x^{16}$ 可以被$-1$替换，以将 $x$ 的更高次幂归约到$0$到$15$的范围内。</p>\n<p>所以我们考虑的多项式都是这种形式的</p>\n<script type=\"math/tex; mode=display\">\n\\begin{align}\na_{15}x^{15} &+ a_{14}x^{14} + a_{13}x^{13} + a_{12}x^{12} + a_{11}x^{11} + a_{10}x^{10} + a_{9}x^{9} + a_{8}x^{8}\\\\\n+ &a_{7}x^{7} + a_{6}x^{6} + a_{5}x^{5} + a_{4}x^{4} + a_{3}x^{3} + a_{2}x^{2} + a_{1}x^{1} + a_0\n\\end{align}</script><p>其中这16系数(即 $a_i$)中的每一个的范围都是从 $0$ 到 $t-1$。我们可以用系数的环面来说明，如下所示：</p>\n<p><img src=\"http://images.yingwai.top/picgo/HEdif3.jpg\" alt=\"\"></p>\n<p>在这个图中，每个循环表示多项式中 $x$ 的幂次方前的系数的取值范围（包含24个可能值）。绿点代表系数取$0$时所处的位置。这为我们提供了一种很好的方法来可视化多项式，这在我们考虑加密和解密步骤如何工作时将会有所帮助。</p>\n<p>FV加密方案涉及大量的多项式乘法。当我们把 $x$ 的两个幂次方相乘，比如 $2x^{14}$ 和 $x^4$ 时，我们把它们的指数相加，得到 $2x^{18}$。有人可能会假设，求这个多项式关于多项式模的余数可能需要在 $x^{16}$ 处将指数旋转回$0$，得到 $2x^2$，就像上面所示的整数系数那样。如果多项式模是 $x^{16}$，情况就是这样。然而，我们的多项式模是 $x^{16}+1$ - 如上所述，额外的$+1$因子引入了一个符号变化，这有助于进一步干扰乘法的结果。</p>\n<p><img src=\"http://images.yingwai.top/picgo/HEdif4.jpg\" alt=\"\"></p>\n<p>如上图所示，当 $2x^{14}$ 乘以 $x^4$ 后模 <script type=\"math/tex\">x^{16}+1</script> 时，取这个项(由上面的红点表示)，向前旋转环面$4$个幂，然后从$0$处调整系数的值，得到 $22x^2$(或 $−2x^2$，如果我们认为数字是从$-12$到$11$而不是从$0$到$23$时)。</p>\n<p><strong>这种形式的多项式具有非常丰富的结构和许多不错的特性。它们是分圆多项式的子集</strong>。使用其中一个作为多项式模并不是严格必需的，但是这样做会更加方便快速。</p>\n<h1 id=\"使用环上的多项式加密\"><a href=\"#使用环上的多项式加密\" class=\"headerlink\" title=\"使用环上的多项式加密\"></a>使用环上的多项式加密</h1><p>我们已经介绍了FV加密方案中使用的环上的多项式的一些属性，现在我们可以讨论加密和解密的工作原理。首先，我们需要讨论如何生成私钥和公钥，然后讨论如何使用它们进行加密和解密。</p>\n<h2 id=\"私钥和公钥\"><a href=\"#私钥和公钥\" class=\"headerlink\" title=\"私钥和公钥\"></a>私钥和公钥</h2><p>加密采用明文，并使用从私钥派生的公钥将其转换为密文。从明文到密文的转换是通过一种只有在您知道私钥的情况下才容易可逆的方式完成的。</p>\n<p>更具体地说，明文是环上的多项式，其具有多项式模 $x^d+1$，其中 $d = 2^n$，以及系数模 $t$。明文加密后为密文，其是由两个环上的、具有相同多项式模的多项式构成的，但系数模为 $q$，通常 $q$ 远大于 $t$。</p>\n<p>例如，多项式模为 $x^{4096} + 1$，这意味着明文和密文中的多项式都有 $d=4096$ 个系数。明文多项式的系数需要模 $t = 290764801$，密文多项式的系数需要模 $q = 9214347247561474048$ 或更大。</p>\n<p>为了便于说明，我们将使用较小的数字，但希望这些数字能够更好地说明方案的各个步骤中发生了什么。在第一部分中，为了更直观，我们将使用 $d = 16$、$t = 7$ 和 $q = 874$。注意，这些参数是不安全的!!</p>\n<p>对于私钥或密钥，我们用 $s$ 表示，它是我们随机生成的一个系数为 $-1$、$0$ 或 $1$ 的多项式。例如，</p>\n<script type=\"math/tex; mode=display\">\ns = x^{15} - x^{13}  - x^{12}  - x^{11}  - x^{9}  + x^{8}  + x^{6}  - x^{4}  + x^{2}  + x - 1</script><p>接下来，我们从密文空间中随机生成一个多项式(用于生成公钥)，其系数模为 $q$，我们用 $a$ 表示。</p>\n<script type=\"math/tex; mode=display\">\n\\begin{align}\na = 42&x^{15} - 256x^{14} - 393x^{13} - 229x^{12} + 447x^{11} -369x^{10} - 212x^{9} + 107x^8\\\\\n&+ 52x^7 + 70x^6 - 138x^5 + 322x^4 + 186x^3 - 282x^2 - 60x + 84\n\\end{align}</script><p>我们还定义了一个噪音多项式，它是“小”的，因为它是从离散高斯分布中取的一个小系数。这个多项式只在这里使用一次，然后丢弃。</p>\n<script type=\"math/tex; mode=display\">\n\\begin{align}\ne = -3x^{15} &+ x^{14} + x^{13} + 7x^{12} - 6x^{11} - 6x^{10} + x^{9} + 4x^8\\\\\n&- x^6 + 3x^5 -4x^4 + 4x^3 + 4x + 1\n\\end{align}</script><p>然后将公钥定义为一对多项式，即 $\\mathbf{pk} = ([−as + e]q, a)$，其中多项式都是模多项式模和系数模 $q$ 的。</p>\n<p>对于上面给出的示例，公钥的第一个多项式被构造为</p>\n<p><img src=\"http://images.yingwai.top/picgo/HEdif5.jpg\" alt=\"\"></p>\n<p>其中第一个乘法取多项式 $a$，它的系数 $\\bmod q$，然后乘以系数为$-1,0$或$1$的 $s$。由于模上多项式模的多项式的乘法具有“旋转和反射”性质，有效地混合和打乱了 $a$ 的所有系数，并进一步增加了小的噪音。多项式 $a$ 有效地掩盖了公钥中的私钥。</p>\n<p>通过从公钥中找到 $s$ 的方式来破解加密方案，其主要涉及的计算为 $([−as + e]q, a)$。唯一的因素是该方案中包含了噪音——如果 $e$ 为零，则很容易从公钥中计算出 $s$。当 $e$ 足够大，但又不太大时，这是一个难题。</p>\n<p>本文的示例中，私钥可以通过暴力攻击恢复——尝试每个可能的 $s$ (只有$3^{16}=43046721$组合)<em>，</em>然后计算 $as + e$ 来寻找出一个接近公钥的第一项的答案。对于真正的参数，这种暴力攻击的方法是完全不可行的。$3^{4096}$是一个很大的数字，但有更聪明的方法，然后定义给定的一组参数的安全性。</p>\n<h2 id=\"加密\"><a href=\"#加密\" class=\"headerlink\" title=\"加密\"></a>加密</h2><p>加密过程看起来有点像公钥生成过程。</p>\n<p>加密明文的过程是将一个系数模为 $t$ 的多项式转换为一对系数模为 $q$ 的多项式。本例中，我们将加密一个非常简单的多项式(称为消息) $- m = 3 + 4x^8 \\equiv 3−3x^8$ – 只有两个不为零的系数。</p>\n<p>加密还需要三个小的多项式。两个噪音多项式来自于相同的离散高斯分布(即和公钥中的噪音多项式的取法一样)，另一个多项式我们称之为 $u$，它的系数为$-1$、$0$或$1$，就像私钥一样。</p>\n<script type=\"math/tex; mode=display\">\n\\begin{align}\ne_1 = &-5x^{15} - 2x^{14} + 3x^{13} - x^{12} - 4x^{11} + 3x^{10} + x^9 + 4x^8\\\\\n&+4x^7 + 5x^6 - 4x^5 - 3x^4 - 3x^3 + 2x^2 - 6x +4\n\\end{align}</script><script type=\"math/tex; mode=display\">\n\\begin{align}\ne_2 = &-7x^{15} + 2x^{14} - 4x^{13} + 5x^{11} + 2x^{10} - x^9 + 4x^8\\\\\n&-4x^7 - 3x^6 + 2x^5 - 2x^4 + x^3 - 4x^2 - 2x + 2\n\\end{align}</script><p>和</p>\n<script type=\"math/tex; mode=display\">\nu = x^{14} + x^{13} + x^{12} - x^8 - x^5 - x^3 + 1</script><p>这些多项式只在加密过程中使用，然后丢弃。</p>\n<p>密文是由两个多项式组成的，通过如下计算得到</p>\n<script type=\"math/tex; mode=display\">\n\\mathbf{ct} = ([\\mathbf{pk}_0u + e_1 + qm/t]_q, [\\mathbf{pk}_1u + e_2]_q)</script><p>请注意消息中的值是在 $\\bmod t$ 的范围内，而在我们的示例中，它们被缩放为 $q/t$ (即128)，使它们覆盖 $\\bmod q$ 的范围。这是消息被插入到密文时的唯一更改。这些值通过添加到第一项来掩盖，第一项的值是在 $\\bmod q$ 的范围内，与随机的噪音没有区别。$u$ 的随机性改变了每次加密中使用的掩码，从而确保相同的明文在每次加密时产生不同的密文。</p>\n<p><img src=\"http://images.yingwai.top/picgo/HEdif6.jpg\" alt=\"\"></p>\n<p>同态加法和乘法之所以有效，是因为消息在密文中以比例来表示。其他项用于掩盖消息，而且可以证明它们是有效的，只有在您知道私钥的情况下才能删除它们。</p>\n<p>使用上面给出的多项式显式地计算密文的第一个元素</p>\n<script type=\"math/tex; mode=display\">\n\\begin{align}\n\\mathbf{ct}_0 = 217&x^{15} - 53x^{14} + 13x^{13} - 249x^{12} - 392x{11} - 238x^{10} + 252x^9 + 115x^8\\\\\n+5&x^7 +184x^6 -201x^5 -258x^4 -247x^3 +144x^2 +23x +42\n\\end{align}</script><p>代入公钥，我们可以看到密文的第一个元素展开为 $\\mathbf{ct}_0 =[e_1 + eu – aus + qm / t]_q$。在这个表达式中，前两项是“小”的，与噪音成比例，后两项是“大”的。第一个大项有效地掩盖了第二个大项，即消息。</p>\n<p>密文的第二个元素是这样计算的:</p>\n<p><img src=\"http://images.yingwai.top/picgo/HEdif7.jpg\" alt=\"\"></p>\n<p>代入公钥，我们看到密文的第二个元素展开为 $\\mathbf{ct}_1 = [au + e_2]_q$。这说明了解密是如何工作的——如果我们知道 $s$，就可以计算出 $\\mathbf{ct}_1 s = [aus + e_2s]_q$，它可以用来消除密文的第一个元素中的非消息大项。</p>\n<p>综上所述，密文可以用公钥、私钥、掩码、噪音和消息表示为</p>\n<p><img src=\"http://images.yingwai.top/picgo/HEdif8.jpg\" alt=\"\"></p>\n<h2 id=\"解密\"><a href=\"#解密\" class=\"headerlink\" title=\"解密\"></a>解密</h2><p>如上所述，解密相对简单。首先，我们计算 $[\\mathbf{ct}_0 + \\mathbf{ct}_1s]_q$，它将从消息中完全移除掩码。这给我们一个多项式，它可以展开为 $[qm / t + e_1 + eu + e_2s]_q$ -也就是说，缩放后的信息加上一些噪声。因此，只要噪声不太大，我们就可以恢复消息。</p>\n<p>明确地，</p>\n<script type=\"math/tex; mode=display\">\n\\begin{align}\n\\mathbf{ct}_1s + \\mathbf{ct}_0 &= 13x^{15} -2x^{14} + 17x^{13} + 22x^{12} - 32x^{11} - 23x^{10} + 19x^9 - 380x^8\\\\\n&+9x^7 + 10x^6 -13x^5 -3x^4 -2x^3 -12x^2 +7x +393\n\\end{align}</script><p>在这里您可以看到，除了明文的两个非零系数( $x^8$ 和 $x^0$ )之外，所有的系数都小于 $q/t = 128$。如果我们把这个多项式缩放回 $\\bmod t$ 范围内的值，那么我们就得到</p>\n<script type=\"math/tex; mode=display\">\n\\begin{align}\n\\frac{13x^{15}}{128} &- \\frac{x^{14}}{64} + \\frac{17x^{13}}{128} + \\frac{11x^{12}}{64} - \\frac{x^{11}}{4} - \\frac{23x^{10}}{128} + \\frac{19x^{9}}{128} - \\frac{95x^{8}}{32}\\\\\n+ &\\frac{9x^{7}}{128} + \\frac{5x^{6}}{64} - \\frac{13x^{5}}{128} - \\frac{3x^{4}}{128} - \\frac{x^{3}}{64} - \\frac{3x^{2}}{32} + \\frac{7x}{128} + \\frac{393}{128}\n\\end{align}</script><p>四舍五入这些系数可以恢复我们的消息 $m = 3 − 3x^8$。</p>\n<p>我们通过将系数四舍五入，来舍入到最接近的整数后得到我们的信息:</p>\n<p><img src=\"http://images.yingwai.top/picgo/HEdif9.jpg\" alt=\"\"></p>\n<center>\n    <i>绿色-噪音变换  粉色-舍入结果</i>\n</center>\n\n\n<p>把它们放在一起，我们通过如下计算来解密密文</p>\n<script type=\"math/tex; mode=display\">\nm' = \\left[\\left \\lfloor \\frac{t}{q}[\\mathbf{ct}_0+\\mathbf{ct}_1s]_q \\right \\rceil \\right]_t</script><p>$\\lfloor \\rceil$ 表示舍入到最接近的整数(四舍五入)。</p>\n<p>如果系数中噪音太大，那么它们最终会更接近一个与正确整数不同的整数，然后解密会(悄无声息地)失败并产生错误的结果。在上面的示例中，最大的噪音为$13 / 128$，所以仍然有一些空间允许产生更多的噪音，并且能够正确解密。噪音的含量可以通过将 $q / t$ 的比值变大或变小来调节。</p>\n<h1 id=\"同态操作\"><a href=\"#同态操作\" class=\"headerlink\" title=\"同态操作\"></a>同态操作</h1><p>人们对这类密码体制如此感兴趣的一个主要原因是，它们允许同态加法和乘法(来自希腊语<em>homo</em> - same和<em>morphe</em> - shape)。这意味着您可以在数字仍然加密的情况下进行加法和乘法运算，而不必先解密它们。这是一个令人惊叹的功能，有望在数据保护和安全方面构建一个新的黄金标准。</p>\n<h2 id=\"同态加法\"><a href=\"#同态加法\" class=\"headerlink\" title=\"同态加法\"></a>同态加法</h2><p>最简单的情况是两个加密数字的加法。假设我们已经用相同的公钥加密了两个多项式 $m_1$ 和 $m_2$：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{align}\n\\mathbf{a} &= ([\\mathbf{pk}_0 u_1 + e_1 + qm_1/t]_q, [\\mathbf{pk}_1 u_1 + e_2]_q),\\\\\n\\mathbf{b} &= ([\\mathbf{pk}_0 u_2 + e_3 + qm_2/t]_q, [\\mathbf{pk}_1 u_2 + e_4]_q).\n\\end{align}</script><p>注意，我们需要使用两个不同的、小的多项式 $u_1$ 和 $u_2$，以及4个小的噪音多项式 $e_1 \\cdot \\cdot \\cdot e_4$。</p>\n<p>如果我们仅仅是将密文中的元素相加，就会得到一个新的密文</p>\n<script type=\"math/tex; mode=display\">\n\\mathbf{a} + \\mathbf{b} = ([\\mathbf{pk}_0(u_1+u_2) + (e_1+e_3) + q(m_1+m_2)/t]_q, [\\mathbf{pk}_1(u_1+u_2) + (e_2+e_4)]_q)</script><p>由于消息仅存在于具有缩放的密文中，所以加法的结果与 $m_1 + m_2$ 加密的形式相同，只是增加了新的噪音：</p>\n<script type=\"math/tex; mode=display\">\n\\mathbf{c} = ([\\mathbf{pk}_0 (u_3) + (e_5) + q(m_1+m_2)/t]_q, [\\mathbf{pk}_1(u_3) + (e_6)]_q)</script><p>近似解密(舍入之前)将是</p>\n<script type=\"math/tex; mode=display\">\n[q(m_1 + m_2)/t + e_5 + eu_3 + e_6s]_q</script><p>这意味着只要新的噪音不是太大，消息 $m_1 + m_2$ 将正确解密。噪音有三种类型：</p>\n<script type=\"math/tex; mode=display\">\ne_5 = e_1 + e_3</script><script type=\"math/tex; mode=display\">\neu_3 = e(u_1 + u_2)</script><script type=\"math/tex; mode=display\">\ne_6s =(e_2 + e_4)s</script><p>我们担心的是，当这些项变得足够大，以至于噪音多项式中的一个系数大于 $q/(2t)$ 时，解密就会失败，因为解密过程结束时的四舍五入操作会四舍五入到错误的数字。</p>\n<p>如果我们只考虑第一项，那么我们就把来自离散高斯分布的多项式中的系数相加。这意味着，在某些情况下，我们会把一个负系数加到一个正系数上，结果会更接近于零。在其他情况下，系数会有相同的符号，所以结果会更大。我们可以做很多的同态加法，看看噪音是如何随着加法的数量增加而增加的，这是很有指导意义的。系数的分布如下图所示，其中我们添加了1、5和30个噪音多项式(随机地进行了数百次试验)。</p>\n<p><img src=\"http://images.yingwai.top/picgo/HEdif10.png\" alt=\"\"></p>\n<p>当我们添加了30个噪音多项式时，某些系数有可能会大于64，即超过了 $q/t$ 的一半，所以解密不会产生正确的结果。</p>\n<p>另外两项表示不同的情况——第二项是一个噪音多项式乘以一些“小的多项式”(系数为$-1$、$0$或$1$)的总和。这种乘法会产生更大的噪音。一个噪音多项式和一个小的多项式的乘积的系数大约将是随机正负号的噪音多项式系数的2/3rds的总和。这意味着这个噪音与多项式的最高次的平方根 $\\sqrt{n}$ 一致。</p>\n<p>对这一项绘制与上面相同的分布可以看出，它比第一项大得多，而且即使对于我们示例中的参数，也存在错误解密的危险，即使只是添加了几个参数。</p>\n<p><img src=\"http://images.yingwai.top/picgo/HEdif11.png\" alt=\"\"></p>\n<p>第三项是类似的——一组噪音多项式之和，乘以一个“小的多项式”。它的噪音分布是这样的：</p>\n<p><img src=\"http://images.yingwai.top/picgo/HEdif12.jpg\" alt=\"\"></p>\n<p>结合起来，我们可以画出这三项的最大系数的增长，作为已经发生的加法数量的函数。这是一个须状图，给出了这些最大值的可变性。(注意噪音的均值接近于零，这是最大系数的幅值分布。)</p>\n<p><img src=\"http://images.yingwai.top/picgo/HEdif13.jpg\" alt=\"\"></p>\n<p>这表明，对于我们所选择的参数，由两个以上加法产生的密文，解码错误的概率很高，而且两次加法失败的概率也很高。这是因为有时最大错误大于$64$，当 $q/t = 128$ 时，会导致不正确的解密，就像这里一样。为了给这样的操作提供更多的空间，我们需要使用更大的 $q/t$ 比值，这可以应对通常由所执行的操作数量引入的噪音量。</p>\n<p>不幸的是，由密文的同态乘法引入的噪音量又要大得多。</p>\n<h2 id=\"同态乘法\"><a href=\"#同态乘法\" class=\"headerlink\" title=\"同态乘法\"></a>同态乘法</h2><p>同态乘法在程序上很简单，但是比加法复杂得多。如上所述，消息以 $qm_1/t$ 的比例出现在密文的第一个元素中。因此，将两个密文的第一个元素相乘，再乘以 $t/q$，就会得到一个带有 $qm_1m_2/t$ 的项——如果我们仍然能够除去掩码项，这个项就可以恢复。</p>\n<p>因此，要理解同态乘法的机制，关键在于了解如何从密文的乘积中去掉掩码项。要做到这一点，我们的想法是把密文看作是私钥 $s$ 的幂次方的一个简单多项式。这是这篇文章中使用多项式的第三种不同的方法，所以它有点令人困惑，但是它是理解同态乘法如何工作的关键。</p>\n<p>我们可以写出解密过程的第一部分，使密文的每个元素都是 $s$ 的多项式的系数：</p>\n<script type=\"math/tex; mode=display\">\n[\\mathbf{ct}_0 + \\mathbf{ct}_1s^1]_q</script><p>请记住，$\\mathbf{ct}$ 和 $s$ 本身就是多项式，所以这个方程是一个多项式乘以一个多项式($s_0$)加上一个多项式乘以另一个多项式，然后所有这些都取多项式模$x^d + 1$ 和系数模 $q$。</p>\n<p>现在，我们在上面看到解密产生了一个与掩码项 $au$ 无关的量。</p>\n<script type=\"math/tex; mode=display\">\n[\\mathbf{ct}_0 + \\mathbf{ct}_1s^1]_q \\rightarrow \\frac{q}{t}m + noise</script><p>好了，现在考虑两个密文 $\\mathbf{a}$ 和 $\\mathbf{b}$，它们被定义为两个消息 $m_1$ 和 $m_2$ 的加密，它们可以被解密：</p>\n<script type=\"math/tex; mode=display\">\n[\\mathbf{a}_0 + \\mathbf{a}_1 s^1]_q \\rightarrow \\frac{q}{t}m_1 + n_1\\\\\n[\\mathbf{b}_0 + \\mathbf{b}_1 s^1]_q \\rightarrow \\frac{q}{t}m_2 + n_2</script><p>其中 $n_1$ 和 $n_2$ 表示密文中的噪声。</p>\n<p>如果我们取它们的乘积，我们有：</p>\n<script type=\"math/tex; mode=display\">\n[\\mathbf{a}_0 + \\mathbf{a}_1 s^1]_q [\\mathbf{b}_0 + \\mathbf{b}_1 s^1]_q \\rightarrow (\\frac{q}{t}m_1 + n_1)(\\frac{q}{t}m_2 + n_2)</script><p>右边的表达式与计算 $\\mathbf{a}$ 和 $\\mathbf{b}$ 所用的掩码无关，所以左边也必须与它们无关。</p>\n<p>如果我们把左边展开成 $s$ 的形式(为了方便起见，再乘以 $t/q$)就得到了</p>\n<script type=\"math/tex; mode=display\">\nmult(\\mathbf{a}, \\mathbf{b}) = \\mathbf{c}_0 + \\mathbf{c}_1s + \\mathbf{c}_2 s^2</script><p>其中</p>\n<script type=\"math/tex; mode=display\">\n\\mathbf{c}_0 = \\left[\\frac{t}{q} \\mathbf{a}_0 \\mathbf{b}_0 \\right]_q</script><script type=\"math/tex; mode=display\">\n\\mathbf{c}_1 = \\left[\\frac{t}{q} (\\mathbf{a}_1 \\mathbf{b}_0 + \\mathbf{a}_0 \\mathbf{b}_1) \\right]_q</script><script type=\"math/tex; mode=display\">\n\\mathbf{c}_2 = \\left[\\frac{t}{q} \\mathbf{a}_1 \\mathbf{b}_1 \\right]_q</script><p>这样做意味着我们可以计算出一个新的密文的组成部分，它比原来的密文多一个元素，并且可以正确地使用密钥 $s$ 的幂次方进行解密。</p>\n<p>解密的形式展开如下：</p>\n<script type=\"math/tex; mode=display\">\n\\left[\\left \\lfloor \\frac{t}{q}[\\mathbf{ct}_0 s^0 + \\mathbf{ct}_1 s^1 + \\mathbf{ct}_2 s^2]_q \\right \\rceil \\right]_t</script><p>这只是增加了另一项即多项式乘以多项式的平方。有很多簿记要做，但它只是学校级代数(直到模数部分!)这是解密步骤的概括，它允许我们解密同态乘法的结果。</p>\n<p>要了解这一切是如何显式地工作的，请考虑 $\\mathbf{a}$ 和 $\\mathbf{b}$ 在加密过程中的展开式</p>\n<script type=\"math/tex; mode=display\">\n\\begin{align}\n\\mathbf{a} &= [\\mathbf{pk}_0 u_1 + e_{11} + qm_1/t, \\mathbf{pk}_1 u_1 + e_{12}]\\\\\n\\mathbf{b} &= [\\mathbf{pk}_0 u_2 + e_{21} + qm_2/t, \\mathbf{pk}_1 u_2 + e_{22}]\n\\end{align}</script><p>如果我们展开乘法的定义，同时对结果进行部分解密(即解密到除以 $q/t$ 和整数之前)，那么得到的表达式就很复杂。但是，由于每个密文的组件都是在解密过程中被构造成能够删除掩码项($au_i$)的，所以这个展开的结果完全不依赖于来自公钥的掩码项!!!得到的表达式如下：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{align}\n \\mathbf{c}_0 s^0 + \\mathbf{c}_1 s^1 + \\mathbf{c}_2 s^2 =  &\\frac{q}{t}m_1m_2 + e_{22}m_1s + e_{12}m_2s + em_2u_1 + em_1u_2 + e_{21}m_1 + e_{11}m_2\\\\\n&+ \\frac{t}{q}e^2u_1u_2 + \\frac{t}{q}e_{12}e_{22}s^2 + \\frac{t}{q}e_{22}esu_1 + \\frac{t}{q}e_{12}esu_2\\\\\n&+ \\frac{t}{q}e_{12}e_{21}s + \\frac{t}{q}e_{11}e_{22}s + \\frac{t}{q}e_{21}eu_1 + \\frac{t}{q}e_{11}eu_2 + \\frac{t}{q}e_{11}e_{21}\n\\end{align}</script><p>这里有很多项，但是现在我们已经去掉了掩码，问题是，噪音(除了第一个)与 $q/(2t)$ 的“噪音预算”相比有多大?</p>\n<p>为了感受这一点，我们模拟了大量加密的随机信息的乘法，$d = 16$，$t = 7$，$q = 7168 = 1024 \\times t$。各类型噪音的系数大小分布如下图所示。请注意，总的噪音需要大于 $q/(2t) = 512$ 才能导致解密错误。在这些项中，涉及噪音多项式的项、消息和私钥 $e<em>{22}m_1 + e</em>{12}m_2s$ 是最大的贡献者。</p>\n<p><img src=\"http://images.yingwai.top/picgo/HEdif14.jpg\" alt=\"\"></p>\n<p>上图显示，对于这些参数，最大的贡献来自于包含噪音多项式乘以消息多项式和私钥的项。这种噪音的最大系数约为300。这里有两项，其他的项更小。把所有的噪音合并成一个，就得到了乘法结果的总噪音。这些系数的分布如下图所示：</p>\n<p><img src=\"http://images.yingwai.top/picgo/HEdif15.jpg\" alt=\"\"></p>\n<p>这表明没有足够的预算来安全地进行单次乘法，然后解密这些参数的正确结果(无论如何都是不安全的!)——大约1/4000的系数将具有大于512的噪音，导致约1%的解密错误率。</p>\n<p>因此，如果我们将它们视为 $s$ 的多项式，则可以进行密文的乘法，从而在解密时抵消它们自己的掩码项。将它们相乘，并分别跟踪 $s$ 的幂次方的系数和噪音量，以便我们确信它们能够正确解密。</p>\n<h1 id=\"Relinearisation和其他话题\"><a href=\"#Relinearisation和其他话题\" class=\"headerlink\" title=\"Relinearisation和其他话题\"></a>Relinearisation和其他话题</h1><p>上面概述的乘法策略允许我们进行多次乘法，但代价是每次乘法都将密文的大小增加一个多项式。密文在大小上增长可能是一个问题。事实证明，有一些方法可以将密文的大小还原为两个多项式，但代价是增加噪音。这就是所谓的Relinearisation（再线性化），因为你要去掉 $s$ 多项式中的二次项和更高的项。</p>\n<p>另一项使这种加密方案切实可行的重要技术是将多个消息打包到一个明文中，通过并行化提高吞吐量。</p>\n<h1 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h1><p>粗略地说，加密是将消息隐藏在一个环上的多项式中，并添加一些噪音。每个密文都包含足够的信息，可以在给定私钥的情况下除去自己的掩码。因为嵌入只涉及到消息的缩放，所以仍然可以对它们执行加法和乘法，并使用一些巧妙的结构来在之后移除掩码。该方案的安全性来自于在不知道私钥的情况下，在噪声存在的情况下很难去除掩码。这个问题的难度导致了一些优秀的安全性能，例如没有已知的量子算法来攻击这些系统。</p>\n<p>如果您已经了解了这些，我们希望您现在能够更好地理解基于Ring Learning with Errors问题的同态加密方案(或者至少是这些方案中的FV方案)的工作原理。</p>\n","site":{"data":{}},"excerpt":"<hr>","more":"<p>转自<a href=\"https://zhuanlan.zhihu.com/p/54484449\" target=\"_blank\" rel=\"noopener\">https://zhuanlan.zhihu.com/p/54484449</a></p>\n<h1 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h1><p>同态加密方案提供了一种惊人的能力——能够在不解密的情况下，对密文数据进行计算。这使您无需破坏敏感源数据，同时可以对数据进行处理。</p>\n<p>其中最有影响的一个方案(也是最近一些标准化工作的主题)被称为Fan-Vercauteren (FV)方案(或称为Brakerski-Fan-Vercauteren方案)，我们将在这里深入地进行说明，同时你也可以尝试使用以下实现该方案的算法库：</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>Library</th>\n<th>URL</th>\n<th>License</th>\n<th>Language</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>HEANN</td>\n<td><a href=\"https://github.com/kimandrik/HEAAN\" target=\"_blank\" rel=\"noopener\">https://github.com/kimandrik/HEAAN</a></td>\n<td>CC  non commercial</td>\n<td>C++</td>\n</tr>\n<tr>\n<td>NFLib</td>\n<td><a href=\"https://github.com/quarkslab/NFLlib\" target=\"_blank\" rel=\"noopener\">https://github.com/quarkslab/NFLlib</a></td>\n<td>GPLv3</td>\n<td>C++</td>\n</tr>\n<tr>\n<td>FV-NFLib</td>\n<td><a href=\"https://github.com/quarkslab/NFLlib\" target=\"_blank\" rel=\"noopener\">https://github.com/quarkslab/NFLlib</a></td>\n<td>GPLv3</td>\n<td>C++</td>\n</tr>\n<tr>\n<td>cuHE</td>\n<td><a href=\"https://github.com/vernamlab/cuHE\" target=\"_blank\" rel=\"noopener\">https://github.com/vernamlab/cuHE</a></td>\n<td>MIT</td>\n<td>CUDA C++</td>\n</tr>\n<tr>\n<td>PALISADE</td>\n<td><a href=\"https://git.njit.edu/palisade/PALISADE/tree/master\" target=\"_blank\" rel=\"noopener\">https://git.njit.edu/palisade/PALISADE/tree/master</a></td>\n<td>Liberal</td>\n<td>C++</td>\n</tr>\n<tr>\n<td>SEAL</td>\n<td><a href=\"https://www.microsoft.com/en-us/research/project/simple-encrypted-arithmetic-library/\" target=\"_blank\" rel=\"noopener\">https://www.microsoft.com/en-us/research/project/simple-encrypted-arithmetic-library/</a></td>\n<td>Microsoft  research only</td>\n<td>C++</td>\n</tr>\n<tr>\n<td>HELib</td>\n<td><a href=\"https://github.com/shaih/HElib\" target=\"_blank\" rel=\"noopener\">https://github.com/shaih/HElib</a></td>\n<td>Apache  2.0</td>\n<td>C++</td>\n</tr>\n<tr>\n<td>jLBC</td>\n<td><a href=\"http://gas.dia.unisa.it/projects/jlbc/download.html\" target=\"_blank\" rel=\"noopener\">http://gas.dia.unisa.it/projects/jlbc/download.html</a></td>\n<td>LGPLv3</td>\n<td>Java</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>这些加密方案看起来很复杂，也有一点神秘，但希望本文能让您清楚地了解它们的工作原理和驱动因素。</p>\n<p>这篇文章的整体结构包括</p>\n<ul>\n<li><p>一点点数学介绍</p>\n</li>\n<li><p>加密和解密是如何工作的</p>\n</li>\n<li><p>同态加法和乘法</p>\n</li>\n</ul>\n<h1 id=\"数学介绍\"><a href=\"#数学介绍\" class=\"headerlink\" title=\"数学介绍\"></a>数学介绍</h1><p>这些同态加密方案是基于Ring Learning with Errors问题。本质上，这些方案中的数据在加密时(密文)和未加密时(明文)都以多项式表示。</p>\n<p>这些几乎是学校里每个人都学过的多项式。像</p>\n<script type=\"math/tex; mode=display\">\n4x^2 + 2x + 1</script><p>但有一些区别，第一个是系数都是整数，并且需要 $\\bmod t$。假设 $t = 24$，这就像一个$24$小时的时钟，$21$加$6$得到$3$。多项式的所有系数都是这样处理的。</p>\n<p><img src=\"http://images.yingwai.top/picgo/HEdif1.jpg\" alt=\"\"></p>\n<p>或者，我们可以将数字考虑在$-11$到$12$之间，这样我们就可以方便地求负数。注意，这只是一个方便系数——余数为$-1$和余数为$23$(除以$24$时)之间没有区别。</p>\n<p><img src=\"http://images.yingwai.top/picgo/HEdif2_.jpg\" alt=\"\"></p>\n<p>第二点，也是比较棘手的一点，在于这种使用余数的思想不仅适用于多项式的系数，也适用于多项式本身。</p>\n<p>我们定义了一个特殊的多项式，称为多项式模，并且只考虑多项式乘以该多项式模后的余数。FV方案中该多项式模的具体形式为 $x^d+1$，其中对于某些 $n$，有 $d=2n$。为了说明这一点，我们取 $n=4$，因此多项式为 $x^{16}+1$。</p>\n<p>因为我们考虑的是关于模 $x^{16}+1$ 之后的余数，所以我们只需要考虑幂从 $x^0$ 到 $x^{15}$ 的多项式。任何更高次的幂都会因乘以该多项式模而消去。这也可以被理解为，$x^{16} \\equiv -1 (\\bmod x^{16}+1)$，这意味着 $x^{16}$ 可以被$-1$替换，以将 $x$ 的更高次幂归约到$0$到$15$的范围内。</p>\n<p>所以我们考虑的多项式都是这种形式的</p>\n<script type=\"math/tex; mode=display\">\n\\begin{align}\na_{15}x^{15} &+ a_{14}x^{14} + a_{13}x^{13} + a_{12}x^{12} + a_{11}x^{11} + a_{10}x^{10} + a_{9}x^{9} + a_{8}x^{8}\\\\\n+ &a_{7}x^{7} + a_{6}x^{6} + a_{5}x^{5} + a_{4}x^{4} + a_{3}x^{3} + a_{2}x^{2} + a_{1}x^{1} + a_0\n\\end{align}</script><p>其中这16系数(即 $a_i$)中的每一个的范围都是从 $0$ 到 $t-1$。我们可以用系数的环面来说明，如下所示：</p>\n<p><img src=\"http://images.yingwai.top/picgo/HEdif3.jpg\" alt=\"\"></p>\n<p>在这个图中，每个循环表示多项式中 $x$ 的幂次方前的系数的取值范围（包含24个可能值）。绿点代表系数取$0$时所处的位置。这为我们提供了一种很好的方法来可视化多项式，这在我们考虑加密和解密步骤如何工作时将会有所帮助。</p>\n<p>FV加密方案涉及大量的多项式乘法。当我们把 $x$ 的两个幂次方相乘，比如 $2x^{14}$ 和 $x^4$ 时，我们把它们的指数相加，得到 $2x^{18}$。有人可能会假设，求这个多项式关于多项式模的余数可能需要在 $x^{16}$ 处将指数旋转回$0$，得到 $2x^2$，就像上面所示的整数系数那样。如果多项式模是 $x^{16}$，情况就是这样。然而，我们的多项式模是 $x^{16}+1$ - 如上所述，额外的$+1$因子引入了一个符号变化，这有助于进一步干扰乘法的结果。</p>\n<p><img src=\"http://images.yingwai.top/picgo/HEdif4.jpg\" alt=\"\"></p>\n<p>如上图所示，当 $2x^{14}$ 乘以 $x^4$ 后模 <script type=\"math/tex\">x^{16}+1</script> 时，取这个项(由上面的红点表示)，向前旋转环面$4$个幂，然后从$0$处调整系数的值，得到 $22x^2$(或 $−2x^2$，如果我们认为数字是从$-12$到$11$而不是从$0$到$23$时)。</p>\n<p><strong>这种形式的多项式具有非常丰富的结构和许多不错的特性。它们是分圆多项式的子集</strong>。使用其中一个作为多项式模并不是严格必需的，但是这样做会更加方便快速。</p>\n<h1 id=\"使用环上的多项式加密\"><a href=\"#使用环上的多项式加密\" class=\"headerlink\" title=\"使用环上的多项式加密\"></a>使用环上的多项式加密</h1><p>我们已经介绍了FV加密方案中使用的环上的多项式的一些属性，现在我们可以讨论加密和解密的工作原理。首先，我们需要讨论如何生成私钥和公钥，然后讨论如何使用它们进行加密和解密。</p>\n<h2 id=\"私钥和公钥\"><a href=\"#私钥和公钥\" class=\"headerlink\" title=\"私钥和公钥\"></a>私钥和公钥</h2><p>加密采用明文，并使用从私钥派生的公钥将其转换为密文。从明文到密文的转换是通过一种只有在您知道私钥的情况下才容易可逆的方式完成的。</p>\n<p>更具体地说，明文是环上的多项式，其具有多项式模 $x^d+1$，其中 $d = 2^n$，以及系数模 $t$。明文加密后为密文，其是由两个环上的、具有相同多项式模的多项式构成的，但系数模为 $q$，通常 $q$ 远大于 $t$。</p>\n<p>例如，多项式模为 $x^{4096} + 1$，这意味着明文和密文中的多项式都有 $d=4096$ 个系数。明文多项式的系数需要模 $t = 290764801$，密文多项式的系数需要模 $q = 9214347247561474048$ 或更大。</p>\n<p>为了便于说明，我们将使用较小的数字，但希望这些数字能够更好地说明方案的各个步骤中发生了什么。在第一部分中，为了更直观，我们将使用 $d = 16$、$t = 7$ 和 $q = 874$。注意，这些参数是不安全的!!</p>\n<p>对于私钥或密钥，我们用 $s$ 表示，它是我们随机生成的一个系数为 $-1$、$0$ 或 $1$ 的多项式。例如，</p>\n<script type=\"math/tex; mode=display\">\ns = x^{15} - x^{13}  - x^{12}  - x^{11}  - x^{9}  + x^{8}  + x^{6}  - x^{4}  + x^{2}  + x - 1</script><p>接下来，我们从密文空间中随机生成一个多项式(用于生成公钥)，其系数模为 $q$，我们用 $a$ 表示。</p>\n<script type=\"math/tex; mode=display\">\n\\begin{align}\na = 42&x^{15} - 256x^{14} - 393x^{13} - 229x^{12} + 447x^{11} -369x^{10} - 212x^{9} + 107x^8\\\\\n&+ 52x^7 + 70x^6 - 138x^5 + 322x^4 + 186x^3 - 282x^2 - 60x + 84\n\\end{align}</script><p>我们还定义了一个噪音多项式，它是“小”的，因为它是从离散高斯分布中取的一个小系数。这个多项式只在这里使用一次，然后丢弃。</p>\n<script type=\"math/tex; mode=display\">\n\\begin{align}\ne = -3x^{15} &+ x^{14} + x^{13} + 7x^{12} - 6x^{11} - 6x^{10} + x^{9} + 4x^8\\\\\n&- x^6 + 3x^5 -4x^4 + 4x^3 + 4x + 1\n\\end{align}</script><p>然后将公钥定义为一对多项式，即 $\\mathbf{pk} = ([−as + e]q, a)$，其中多项式都是模多项式模和系数模 $q$ 的。</p>\n<p>对于上面给出的示例，公钥的第一个多项式被构造为</p>\n<p><img src=\"http://images.yingwai.top/picgo/HEdif5.jpg\" alt=\"\"></p>\n<p>其中第一个乘法取多项式 $a$，它的系数 $\\bmod q$，然后乘以系数为$-1,0$或$1$的 $s$。由于模上多项式模的多项式的乘法具有“旋转和反射”性质，有效地混合和打乱了 $a$ 的所有系数，并进一步增加了小的噪音。多项式 $a$ 有效地掩盖了公钥中的私钥。</p>\n<p>通过从公钥中找到 $s$ 的方式来破解加密方案，其主要涉及的计算为 $([−as + e]q, a)$。唯一的因素是该方案中包含了噪音——如果 $e$ 为零，则很容易从公钥中计算出 $s$。当 $e$ 足够大，但又不太大时，这是一个难题。</p>\n<p>本文的示例中，私钥可以通过暴力攻击恢复——尝试每个可能的 $s$ (只有$3^{16}=43046721$组合)<em>，</em>然后计算 $as + e$ 来寻找出一个接近公钥的第一项的答案。对于真正的参数，这种暴力攻击的方法是完全不可行的。$3^{4096}$是一个很大的数字，但有更聪明的方法，然后定义给定的一组参数的安全性。</p>\n<h2 id=\"加密\"><a href=\"#加密\" class=\"headerlink\" title=\"加密\"></a>加密</h2><p>加密过程看起来有点像公钥生成过程。</p>\n<p>加密明文的过程是将一个系数模为 $t$ 的多项式转换为一对系数模为 $q$ 的多项式。本例中，我们将加密一个非常简单的多项式(称为消息) $- m = 3 + 4x^8 \\equiv 3−3x^8$ – 只有两个不为零的系数。</p>\n<p>加密还需要三个小的多项式。两个噪音多项式来自于相同的离散高斯分布(即和公钥中的噪音多项式的取法一样)，另一个多项式我们称之为 $u$，它的系数为$-1$、$0$或$1$，就像私钥一样。</p>\n<script type=\"math/tex; mode=display\">\n\\begin{align}\ne_1 = &-5x^{15} - 2x^{14} + 3x^{13} - x^{12} - 4x^{11} + 3x^{10} + x^9 + 4x^8\\\\\n&+4x^7 + 5x^6 - 4x^5 - 3x^4 - 3x^3 + 2x^2 - 6x +4\n\\end{align}</script><script type=\"math/tex; mode=display\">\n\\begin{align}\ne_2 = &-7x^{15} + 2x^{14} - 4x^{13} + 5x^{11} + 2x^{10} - x^9 + 4x^8\\\\\n&-4x^7 - 3x^6 + 2x^5 - 2x^4 + x^3 - 4x^2 - 2x + 2\n\\end{align}</script><p>和</p>\n<script type=\"math/tex; mode=display\">\nu = x^{14} + x^{13} + x^{12} - x^8 - x^5 - x^3 + 1</script><p>这些多项式只在加密过程中使用，然后丢弃。</p>\n<p>密文是由两个多项式组成的，通过如下计算得到</p>\n<script type=\"math/tex; mode=display\">\n\\mathbf{ct} = ([\\mathbf{pk}_0u + e_1 + qm/t]_q, [\\mathbf{pk}_1u + e_2]_q)</script><p>请注意消息中的值是在 $\\bmod t$ 的范围内，而在我们的示例中，它们被缩放为 $q/t$ (即128)，使它们覆盖 $\\bmod q$ 的范围。这是消息被插入到密文时的唯一更改。这些值通过添加到第一项来掩盖，第一项的值是在 $\\bmod q$ 的范围内，与随机的噪音没有区别。$u$ 的随机性改变了每次加密中使用的掩码，从而确保相同的明文在每次加密时产生不同的密文。</p>\n<p><img src=\"http://images.yingwai.top/picgo/HEdif6.jpg\" alt=\"\"></p>\n<p>同态加法和乘法之所以有效，是因为消息在密文中以比例来表示。其他项用于掩盖消息，而且可以证明它们是有效的，只有在您知道私钥的情况下才能删除它们。</p>\n<p>使用上面给出的多项式显式地计算密文的第一个元素</p>\n<script type=\"math/tex; mode=display\">\n\\begin{align}\n\\mathbf{ct}_0 = 217&x^{15} - 53x^{14} + 13x^{13} - 249x^{12} - 392x{11} - 238x^{10} + 252x^9 + 115x^8\\\\\n+5&x^7 +184x^6 -201x^5 -258x^4 -247x^3 +144x^2 +23x +42\n\\end{align}</script><p>代入公钥，我们可以看到密文的第一个元素展开为 $\\mathbf{ct}_0 =[e_1 + eu – aus + qm / t]_q$。在这个表达式中，前两项是“小”的，与噪音成比例，后两项是“大”的。第一个大项有效地掩盖了第二个大项，即消息。</p>\n<p>密文的第二个元素是这样计算的:</p>\n<p><img src=\"http://images.yingwai.top/picgo/HEdif7.jpg\" alt=\"\"></p>\n<p>代入公钥，我们看到密文的第二个元素展开为 $\\mathbf{ct}_1 = [au + e_2]_q$。这说明了解密是如何工作的——如果我们知道 $s$，就可以计算出 $\\mathbf{ct}_1 s = [aus + e_2s]_q$，它可以用来消除密文的第一个元素中的非消息大项。</p>\n<p>综上所述，密文可以用公钥、私钥、掩码、噪音和消息表示为</p>\n<p><img src=\"http://images.yingwai.top/picgo/HEdif8.jpg\" alt=\"\"></p>\n<h2 id=\"解密\"><a href=\"#解密\" class=\"headerlink\" title=\"解密\"></a>解密</h2><p>如上所述，解密相对简单。首先，我们计算 $[\\mathbf{ct}_0 + \\mathbf{ct}_1s]_q$，它将从消息中完全移除掩码。这给我们一个多项式，它可以展开为 $[qm / t + e_1 + eu + e_2s]_q$ -也就是说，缩放后的信息加上一些噪声。因此，只要噪声不太大，我们就可以恢复消息。</p>\n<p>明确地，</p>\n<script type=\"math/tex; mode=display\">\n\\begin{align}\n\\mathbf{ct}_1s + \\mathbf{ct}_0 &= 13x^{15} -2x^{14} + 17x^{13} + 22x^{12} - 32x^{11} - 23x^{10} + 19x^9 - 380x^8\\\\\n&+9x^7 + 10x^6 -13x^5 -3x^4 -2x^3 -12x^2 +7x +393\n\\end{align}</script><p>在这里您可以看到，除了明文的两个非零系数( $x^8$ 和 $x^0$ )之外，所有的系数都小于 $q/t = 128$。如果我们把这个多项式缩放回 $\\bmod t$ 范围内的值，那么我们就得到</p>\n<script type=\"math/tex; mode=display\">\n\\begin{align}\n\\frac{13x^{15}}{128} &- \\frac{x^{14}}{64} + \\frac{17x^{13}}{128} + \\frac{11x^{12}}{64} - \\frac{x^{11}}{4} - \\frac{23x^{10}}{128} + \\frac{19x^{9}}{128} - \\frac{95x^{8}}{32}\\\\\n+ &\\frac{9x^{7}}{128} + \\frac{5x^{6}}{64} - \\frac{13x^{5}}{128} - \\frac{3x^{4}}{128} - \\frac{x^{3}}{64} - \\frac{3x^{2}}{32} + \\frac{7x}{128} + \\frac{393}{128}\n\\end{align}</script><p>四舍五入这些系数可以恢复我们的消息 $m = 3 − 3x^8$。</p>\n<p>我们通过将系数四舍五入，来舍入到最接近的整数后得到我们的信息:</p>\n<p><img src=\"http://images.yingwai.top/picgo/HEdif9.jpg\" alt=\"\"></p>\n<center>\n    <i>绿色-噪音变换  粉色-舍入结果</i>\n</center>\n\n\n<p>把它们放在一起，我们通过如下计算来解密密文</p>\n<script type=\"math/tex; mode=display\">\nm' = \\left[\\left \\lfloor \\frac{t}{q}[\\mathbf{ct}_0+\\mathbf{ct}_1s]_q \\right \\rceil \\right]_t</script><p>$\\lfloor \\rceil$ 表示舍入到最接近的整数(四舍五入)。</p>\n<p>如果系数中噪音太大，那么它们最终会更接近一个与正确整数不同的整数，然后解密会(悄无声息地)失败并产生错误的结果。在上面的示例中，最大的噪音为$13 / 128$，所以仍然有一些空间允许产生更多的噪音，并且能够正确解密。噪音的含量可以通过将 $q / t$ 的比值变大或变小来调节。</p>\n<h1 id=\"同态操作\"><a href=\"#同态操作\" class=\"headerlink\" title=\"同态操作\"></a>同态操作</h1><p>人们对这类密码体制如此感兴趣的一个主要原因是，它们允许同态加法和乘法(来自希腊语<em>homo</em> - same和<em>morphe</em> - shape)。这意味着您可以在数字仍然加密的情况下进行加法和乘法运算，而不必先解密它们。这是一个令人惊叹的功能，有望在数据保护和安全方面构建一个新的黄金标准。</p>\n<h2 id=\"同态加法\"><a href=\"#同态加法\" class=\"headerlink\" title=\"同态加法\"></a>同态加法</h2><p>最简单的情况是两个加密数字的加法。假设我们已经用相同的公钥加密了两个多项式 $m_1$ 和 $m_2$：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{align}\n\\mathbf{a} &= ([\\mathbf{pk}_0 u_1 + e_1 + qm_1/t]_q, [\\mathbf{pk}_1 u_1 + e_2]_q),\\\\\n\\mathbf{b} &= ([\\mathbf{pk}_0 u_2 + e_3 + qm_2/t]_q, [\\mathbf{pk}_1 u_2 + e_4]_q).\n\\end{align}</script><p>注意，我们需要使用两个不同的、小的多项式 $u_1$ 和 $u_2$，以及4个小的噪音多项式 $e_1 \\cdot \\cdot \\cdot e_4$。</p>\n<p>如果我们仅仅是将密文中的元素相加，就会得到一个新的密文</p>\n<script type=\"math/tex; mode=display\">\n\\mathbf{a} + \\mathbf{b} = ([\\mathbf{pk}_0(u_1+u_2) + (e_1+e_3) + q(m_1+m_2)/t]_q, [\\mathbf{pk}_1(u_1+u_2) + (e_2+e_4)]_q)</script><p>由于消息仅存在于具有缩放的密文中，所以加法的结果与 $m_1 + m_2$ 加密的形式相同，只是增加了新的噪音：</p>\n<script type=\"math/tex; mode=display\">\n\\mathbf{c} = ([\\mathbf{pk}_0 (u_3) + (e_5) + q(m_1+m_2)/t]_q, [\\mathbf{pk}_1(u_3) + (e_6)]_q)</script><p>近似解密(舍入之前)将是</p>\n<script type=\"math/tex; mode=display\">\n[q(m_1 + m_2)/t + e_5 + eu_3 + e_6s]_q</script><p>这意味着只要新的噪音不是太大，消息 $m_1 + m_2$ 将正确解密。噪音有三种类型：</p>\n<script type=\"math/tex; mode=display\">\ne_5 = e_1 + e_3</script><script type=\"math/tex; mode=display\">\neu_3 = e(u_1 + u_2)</script><script type=\"math/tex; mode=display\">\ne_6s =(e_2 + e_4)s</script><p>我们担心的是，当这些项变得足够大，以至于噪音多项式中的一个系数大于 $q/(2t)$ 时，解密就会失败，因为解密过程结束时的四舍五入操作会四舍五入到错误的数字。</p>\n<p>如果我们只考虑第一项，那么我们就把来自离散高斯分布的多项式中的系数相加。这意味着，在某些情况下，我们会把一个负系数加到一个正系数上，结果会更接近于零。在其他情况下，系数会有相同的符号，所以结果会更大。我们可以做很多的同态加法，看看噪音是如何随着加法的数量增加而增加的，这是很有指导意义的。系数的分布如下图所示，其中我们添加了1、5和30个噪音多项式(随机地进行了数百次试验)。</p>\n<p><img src=\"http://images.yingwai.top/picgo/HEdif10.png\" alt=\"\"></p>\n<p>当我们添加了30个噪音多项式时，某些系数有可能会大于64，即超过了 $q/t$ 的一半，所以解密不会产生正确的结果。</p>\n<p>另外两项表示不同的情况——第二项是一个噪音多项式乘以一些“小的多项式”(系数为$-1$、$0$或$1$)的总和。这种乘法会产生更大的噪音。一个噪音多项式和一个小的多项式的乘积的系数大约将是随机正负号的噪音多项式系数的2/3rds的总和。这意味着这个噪音与多项式的最高次的平方根 $\\sqrt{n}$ 一致。</p>\n<p>对这一项绘制与上面相同的分布可以看出，它比第一项大得多，而且即使对于我们示例中的参数，也存在错误解密的危险，即使只是添加了几个参数。</p>\n<p><img src=\"http://images.yingwai.top/picgo/HEdif11.png\" alt=\"\"></p>\n<p>第三项是类似的——一组噪音多项式之和，乘以一个“小的多项式”。它的噪音分布是这样的：</p>\n<p><img src=\"http://images.yingwai.top/picgo/HEdif12.jpg\" alt=\"\"></p>\n<p>结合起来，我们可以画出这三项的最大系数的增长，作为已经发生的加法数量的函数。这是一个须状图，给出了这些最大值的可变性。(注意噪音的均值接近于零，这是最大系数的幅值分布。)</p>\n<p><img src=\"http://images.yingwai.top/picgo/HEdif13.jpg\" alt=\"\"></p>\n<p>这表明，对于我们所选择的参数，由两个以上加法产生的密文，解码错误的概率很高，而且两次加法失败的概率也很高。这是因为有时最大错误大于$64$，当 $q/t = 128$ 时，会导致不正确的解密，就像这里一样。为了给这样的操作提供更多的空间，我们需要使用更大的 $q/t$ 比值，这可以应对通常由所执行的操作数量引入的噪音量。</p>\n<p>不幸的是，由密文的同态乘法引入的噪音量又要大得多。</p>\n<h2 id=\"同态乘法\"><a href=\"#同态乘法\" class=\"headerlink\" title=\"同态乘法\"></a>同态乘法</h2><p>同态乘法在程序上很简单，但是比加法复杂得多。如上所述，消息以 $qm_1/t$ 的比例出现在密文的第一个元素中。因此，将两个密文的第一个元素相乘，再乘以 $t/q$，就会得到一个带有 $qm_1m_2/t$ 的项——如果我们仍然能够除去掩码项，这个项就可以恢复。</p>\n<p>因此，要理解同态乘法的机制，关键在于了解如何从密文的乘积中去掉掩码项。要做到这一点，我们的想法是把密文看作是私钥 $s$ 的幂次方的一个简单多项式。这是这篇文章中使用多项式的第三种不同的方法，所以它有点令人困惑，但是它是理解同态乘法如何工作的关键。</p>\n<p>我们可以写出解密过程的第一部分，使密文的每个元素都是 $s$ 的多项式的系数：</p>\n<script type=\"math/tex; mode=display\">\n[\\mathbf{ct}_0 + \\mathbf{ct}_1s^1]_q</script><p>请记住，$\\mathbf{ct}$ 和 $s$ 本身就是多项式，所以这个方程是一个多项式乘以一个多项式($s_0$)加上一个多项式乘以另一个多项式，然后所有这些都取多项式模$x^d + 1$ 和系数模 $q$。</p>\n<p>现在，我们在上面看到解密产生了一个与掩码项 $au$ 无关的量。</p>\n<script type=\"math/tex; mode=display\">\n[\\mathbf{ct}_0 + \\mathbf{ct}_1s^1]_q \\rightarrow \\frac{q}{t}m + noise</script><p>好了，现在考虑两个密文 $\\mathbf{a}$ 和 $\\mathbf{b}$，它们被定义为两个消息 $m_1$ 和 $m_2$ 的加密，它们可以被解密：</p>\n<script type=\"math/tex; mode=display\">\n[\\mathbf{a}_0 + \\mathbf{a}_1 s^1]_q \\rightarrow \\frac{q}{t}m_1 + n_1\\\\\n[\\mathbf{b}_0 + \\mathbf{b}_1 s^1]_q \\rightarrow \\frac{q}{t}m_2 + n_2</script><p>其中 $n_1$ 和 $n_2$ 表示密文中的噪声。</p>\n<p>如果我们取它们的乘积，我们有：</p>\n<script type=\"math/tex; mode=display\">\n[\\mathbf{a}_0 + \\mathbf{a}_1 s^1]_q [\\mathbf{b}_0 + \\mathbf{b}_1 s^1]_q \\rightarrow (\\frac{q}{t}m_1 + n_1)(\\frac{q}{t}m_2 + n_2)</script><p>右边的表达式与计算 $\\mathbf{a}$ 和 $\\mathbf{b}$ 所用的掩码无关，所以左边也必须与它们无关。</p>\n<p>如果我们把左边展开成 $s$ 的形式(为了方便起见，再乘以 $t/q$)就得到了</p>\n<script type=\"math/tex; mode=display\">\nmult(\\mathbf{a}, \\mathbf{b}) = \\mathbf{c}_0 + \\mathbf{c}_1s + \\mathbf{c}_2 s^2</script><p>其中</p>\n<script type=\"math/tex; mode=display\">\n\\mathbf{c}_0 = \\left[\\frac{t}{q} \\mathbf{a}_0 \\mathbf{b}_0 \\right]_q</script><script type=\"math/tex; mode=display\">\n\\mathbf{c}_1 = \\left[\\frac{t}{q} (\\mathbf{a}_1 \\mathbf{b}_0 + \\mathbf{a}_0 \\mathbf{b}_1) \\right]_q</script><script type=\"math/tex; mode=display\">\n\\mathbf{c}_2 = \\left[\\frac{t}{q} \\mathbf{a}_1 \\mathbf{b}_1 \\right]_q</script><p>这样做意味着我们可以计算出一个新的密文的组成部分，它比原来的密文多一个元素，并且可以正确地使用密钥 $s$ 的幂次方进行解密。</p>\n<p>解密的形式展开如下：</p>\n<script type=\"math/tex; mode=display\">\n\\left[\\left \\lfloor \\frac{t}{q}[\\mathbf{ct}_0 s^0 + \\mathbf{ct}_1 s^1 + \\mathbf{ct}_2 s^2]_q \\right \\rceil \\right]_t</script><p>这只是增加了另一项即多项式乘以多项式的平方。有很多簿记要做，但它只是学校级代数(直到模数部分!)这是解密步骤的概括，它允许我们解密同态乘法的结果。</p>\n<p>要了解这一切是如何显式地工作的，请考虑 $\\mathbf{a}$ 和 $\\mathbf{b}$ 在加密过程中的展开式</p>\n<script type=\"math/tex; mode=display\">\n\\begin{align}\n\\mathbf{a} &= [\\mathbf{pk}_0 u_1 + e_{11} + qm_1/t, \\mathbf{pk}_1 u_1 + e_{12}]\\\\\n\\mathbf{b} &= [\\mathbf{pk}_0 u_2 + e_{21} + qm_2/t, \\mathbf{pk}_1 u_2 + e_{22}]\n\\end{align}</script><p>如果我们展开乘法的定义，同时对结果进行部分解密(即解密到除以 $q/t$ 和整数之前)，那么得到的表达式就很复杂。但是，由于每个密文的组件都是在解密过程中被构造成能够删除掩码项($au_i$)的，所以这个展开的结果完全不依赖于来自公钥的掩码项!!!得到的表达式如下：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{align}\n \\mathbf{c}_0 s^0 + \\mathbf{c}_1 s^1 + \\mathbf{c}_2 s^2 =  &\\frac{q}{t}m_1m_2 + e_{22}m_1s + e_{12}m_2s + em_2u_1 + em_1u_2 + e_{21}m_1 + e_{11}m_2\\\\\n&+ \\frac{t}{q}e^2u_1u_2 + \\frac{t}{q}e_{12}e_{22}s^2 + \\frac{t}{q}e_{22}esu_1 + \\frac{t}{q}e_{12}esu_2\\\\\n&+ \\frac{t}{q}e_{12}e_{21}s + \\frac{t}{q}e_{11}e_{22}s + \\frac{t}{q}e_{21}eu_1 + \\frac{t}{q}e_{11}eu_2 + \\frac{t}{q}e_{11}e_{21}\n\\end{align}</script><p>这里有很多项，但是现在我们已经去掉了掩码，问题是，噪音(除了第一个)与 $q/(2t)$ 的“噪音预算”相比有多大?</p>\n<p>为了感受这一点，我们模拟了大量加密的随机信息的乘法，$d = 16$，$t = 7$，$q = 7168 = 1024 \\times t$。各类型噪音的系数大小分布如下图所示。请注意，总的噪音需要大于 $q/(2t) = 512$ 才能导致解密错误。在这些项中，涉及噪音多项式的项、消息和私钥 $e<em>{22}m_1 + e</em>{12}m_2s$ 是最大的贡献者。</p>\n<p><img src=\"http://images.yingwai.top/picgo/HEdif14.jpg\" alt=\"\"></p>\n<p>上图显示，对于这些参数，最大的贡献来自于包含噪音多项式乘以消息多项式和私钥的项。这种噪音的最大系数约为300。这里有两项，其他的项更小。把所有的噪音合并成一个，就得到了乘法结果的总噪音。这些系数的分布如下图所示：</p>\n<p><img src=\"http://images.yingwai.top/picgo/HEdif15.jpg\" alt=\"\"></p>\n<p>这表明没有足够的预算来安全地进行单次乘法，然后解密这些参数的正确结果(无论如何都是不安全的!)——大约1/4000的系数将具有大于512的噪音，导致约1%的解密错误率。</p>\n<p>因此，如果我们将它们视为 $s$ 的多项式，则可以进行密文的乘法，从而在解密时抵消它们自己的掩码项。将它们相乘，并分别跟踪 $s$ 的幂次方的系数和噪音量，以便我们确信它们能够正确解密。</p>\n<h1 id=\"Relinearisation和其他话题\"><a href=\"#Relinearisation和其他话题\" class=\"headerlink\" title=\"Relinearisation和其他话题\"></a>Relinearisation和其他话题</h1><p>上面概述的乘法策略允许我们进行多次乘法，但代价是每次乘法都将密文的大小增加一个多项式。密文在大小上增长可能是一个问题。事实证明，有一些方法可以将密文的大小还原为两个多项式，但代价是增加噪音。这就是所谓的Relinearisation（再线性化），因为你要去掉 $s$ 多项式中的二次项和更高的项。</p>\n<p>另一项使这种加密方案切实可行的重要技术是将多个消息打包到一个明文中，通过并行化提高吞吐量。</p>\n<h1 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h1><p>粗略地说，加密是将消息隐藏在一个环上的多项式中，并添加一些噪音。每个密文都包含足够的信息，可以在给定私钥的情况下除去自己的掩码。因为嵌入只涉及到消息的缩放，所以仍然可以对它们执行加法和乘法，并使用一些巧妙的结构来在之后移除掩码。该方案的安全性来自于在不知道私钥的情况下，在噪声存在的情况下很难去除掩码。这个问题的难度导致了一些优秀的安全性能，例如没有已知的量子算法来攻击这些系统。</p>\n<p>如果您已经了解了这些，我们希望您现在能够更好地理解基于Ring Learning with Errors问题的同态加密方案(或者至少是这些方案中的FV方案)的工作原理。</p>"},{"title":"在不同的电脑上更新Hexo博客","date":"2020-08-23T14:55:00.000Z","_content":"\n-----\n\n<!--more-->\n\n参考了https://helloliwen.github.io/870ed150.html以及https://www.zhihu.com/question/21193762中CrazyMilk的回答。\n\n思路是使用git的分支来管理。\n\n# 搭建流程\n\n原本编辑博客的电脑：\n\n1. 首先在github上新建一个hexo分支，并设置它为默认分支。\n\n2. 在电脑上的其它目录中，克隆hexo仓库到本地，获得隐藏的.git文件夹。\n\n3. 复制这个文件夹到原来的博客目录下，删除博客主题目录下的.git文件夹，然后前面克隆的文件夹就可以删除了。\n\n4. 上传\n\n   ```shell\n   $ git add .\n   $ git commit -m \"备注\"\n   $ git push origin hexo\n   ```\n\n\n\n# 本机编辑博客\n\n编辑完文章后，\n\n1. 上传到hexo分支\n\n   ```shell\n   $ git add .\n   $ git commit -m \"备注\"\n   $ git push origin hexo\n   ```\n\n2. 部署\n\n   ```shell\n   $ hexo d -g\n   ```\n\n\n\n# 在别的电脑上编辑博客\n\n## 准备工作\n\n1. 安装git\n2. 克隆github上的hexo分支到本地\n3. 安装node.js\n4. 安装hexo（不需要初始化）\n\n后面两步可以参考[Hexo博客搭建](https://yuyingwai.cn/2020/04/11/Hexo博客搭建/)。\n\n\n\n## 编辑博客\n\n**每次换电脑进行博客更新时，不管上次在其他电脑有没有更新，最好先执行`git pull origin hexo` 命令**，即将远端最新的hexo分支拉到本地，使本地与远端达到同步。\n\n然后与本机编辑一样，先用 `git add .`、`git commit -m \"备注\"` 和 `git push origin hexo` 上传，再进行部署。","source":"_posts/在不同的电脑上更新Hexo博客.md","raw":"---\ntitle: 在不同的电脑上更新Hexo博客\ndate: 2020-08-23 22:55:00\ncategories: Env\ntags: Hexo\n---\n\n-----\n\n<!--more-->\n\n参考了https://helloliwen.github.io/870ed150.html以及https://www.zhihu.com/question/21193762中CrazyMilk的回答。\n\n思路是使用git的分支来管理。\n\n# 搭建流程\n\n原本编辑博客的电脑：\n\n1. 首先在github上新建一个hexo分支，并设置它为默认分支。\n\n2. 在电脑上的其它目录中，克隆hexo仓库到本地，获得隐藏的.git文件夹。\n\n3. 复制这个文件夹到原来的博客目录下，删除博客主题目录下的.git文件夹，然后前面克隆的文件夹就可以删除了。\n\n4. 上传\n\n   ```shell\n   $ git add .\n   $ git commit -m \"备注\"\n   $ git push origin hexo\n   ```\n\n\n\n# 本机编辑博客\n\n编辑完文章后，\n\n1. 上传到hexo分支\n\n   ```shell\n   $ git add .\n   $ git commit -m \"备注\"\n   $ git push origin hexo\n   ```\n\n2. 部署\n\n   ```shell\n   $ hexo d -g\n   ```\n\n\n\n# 在别的电脑上编辑博客\n\n## 准备工作\n\n1. 安装git\n2. 克隆github上的hexo分支到本地\n3. 安装node.js\n4. 安装hexo（不需要初始化）\n\n后面两步可以参考[Hexo博客搭建](https://yuyingwai.cn/2020/04/11/Hexo博客搭建/)。\n\n\n\n## 编辑博客\n\n**每次换电脑进行博客更新时，不管上次在其他电脑有没有更新，最好先执行`git pull origin hexo` 命令**，即将远端最新的hexo分支拉到本地，使本地与远端达到同步。\n\n然后与本机编辑一样，先用 `git add .`、`git commit -m \"备注\"` 和 `git push origin hexo` 上传，再进行部署。","slug":"在不同的电脑上更新Hexo博客","published":1,"updated":"2020-08-23T15:47:50.415Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cke79q4pe001188psgvujbx1n","content":"<hr>\n<a id=\"more\"></a>\n<p>参考了<a href=\"https://helloliwen.github.io/870ed150.html以及https://www.zhihu.com/question/21193762中CrazyMilk的回答。\" target=\"_blank\" rel=\"noopener\">https://helloliwen.github.io/870ed150.html以及https://www.zhihu.com/question/21193762中CrazyMilk的回答。</a></p>\n<p>思路是使用git的分支来管理。</p>\n<h1 id=\"搭建流程\"><a href=\"#搭建流程\" class=\"headerlink\" title=\"搭建流程\"></a>搭建流程</h1><p>原本编辑博客的电脑：</p>\n<ol>\n<li><p>首先在github上新建一个hexo分支，并设置它为默认分支。</p>\n</li>\n<li><p>在电脑上的其它目录中，克隆hexo仓库到本地，获得隐藏的.git文件夹。</p>\n</li>\n<li><p>复制这个文件夹到原来的博客目录下，删除博客主题目录下的.git文件夹，然后前面克隆的文件夹就可以删除了。</p>\n</li>\n<li><p>上传</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> git add .</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> git commit -m <span class=\"string\">\"备注\"</span></span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> git push origin hexo</span></span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h1 id=\"本机编辑博客\"><a href=\"#本机编辑博客\" class=\"headerlink\" title=\"本机编辑博客\"></a>本机编辑博客</h1><p>编辑完文章后，</p>\n<ol>\n<li><p>上传到hexo分支</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> git add .</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> git commit -m <span class=\"string\">\"备注\"</span></span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> git push origin hexo</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>部署</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> hexo d -g</span></span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h1 id=\"在别的电脑上编辑博客\"><a href=\"#在别的电脑上编辑博客\" class=\"headerlink\" title=\"在别的电脑上编辑博客\"></a>在别的电脑上编辑博客</h1><h2 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h2><ol>\n<li>安装git</li>\n<li>克隆github上的hexo分支到本地</li>\n<li>安装node.js</li>\n<li>安装hexo（不需要初始化）</li>\n</ol>\n<p>后面两步可以参考<a href=\"https://yuyingwai.cn/2020/04/11/Hexo博客搭建/\" target=\"_blank\" rel=\"noopener\">Hexo博客搭建</a>。</p>\n<h2 id=\"编辑博客\"><a href=\"#编辑博客\" class=\"headerlink\" title=\"编辑博客\"></a>编辑博客</h2><p><strong>每次换电脑进行博客更新时，不管上次在其他电脑有没有更新，最好先执行<code>git pull origin hexo</code> 命令</strong>，即将远端最新的hexo分支拉到本地，使本地与远端达到同步。</p>\n<p>然后与本机编辑一样，先用 <code>git add .</code>、<code>git commit -m &quot;备注&quot;</code> 和 <code>git push origin hexo</code> 上传，再进行部署。</p>\n","site":{"data":{}},"excerpt":"<hr>","more":"<p>参考了<a href=\"https://helloliwen.github.io/870ed150.html以及https://www.zhihu.com/question/21193762中CrazyMilk的回答。\" target=\"_blank\" rel=\"noopener\">https://helloliwen.github.io/870ed150.html以及https://www.zhihu.com/question/21193762中CrazyMilk的回答。</a></p>\n<p>思路是使用git的分支来管理。</p>\n<h1 id=\"搭建流程\"><a href=\"#搭建流程\" class=\"headerlink\" title=\"搭建流程\"></a>搭建流程</h1><p>原本编辑博客的电脑：</p>\n<ol>\n<li><p>首先在github上新建一个hexo分支，并设置它为默认分支。</p>\n</li>\n<li><p>在电脑上的其它目录中，克隆hexo仓库到本地，获得隐藏的.git文件夹。</p>\n</li>\n<li><p>复制这个文件夹到原来的博客目录下，删除博客主题目录下的.git文件夹，然后前面克隆的文件夹就可以删除了。</p>\n</li>\n<li><p>上传</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> git add .</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> git commit -m <span class=\"string\">\"备注\"</span></span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> git push origin hexo</span></span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h1 id=\"本机编辑博客\"><a href=\"#本机编辑博客\" class=\"headerlink\" title=\"本机编辑博客\"></a>本机编辑博客</h1><p>编辑完文章后，</p>\n<ol>\n<li><p>上传到hexo分支</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> git add .</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> git commit -m <span class=\"string\">\"备注\"</span></span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> git push origin hexo</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>部署</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> hexo d -g</span></span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h1 id=\"在别的电脑上编辑博客\"><a href=\"#在别的电脑上编辑博客\" class=\"headerlink\" title=\"在别的电脑上编辑博客\"></a>在别的电脑上编辑博客</h1><h2 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h2><ol>\n<li>安装git</li>\n<li>克隆github上的hexo分支到本地</li>\n<li>安装node.js</li>\n<li>安装hexo（不需要初始化）</li>\n</ol>\n<p>后面两步可以参考<a href=\"https://yuyingwai.cn/2020/04/11/Hexo博客搭建/\" target=\"_blank\" rel=\"noopener\">Hexo博客搭建</a>。</p>\n<h2 id=\"编辑博客\"><a href=\"#编辑博客\" class=\"headerlink\" title=\"编辑博客\"></a>编辑博客</h2><p><strong>每次换电脑进行博客更新时，不管上次在其他电脑有没有更新，最好先执行<code>git pull origin hexo</code> 命令</strong>，即将远端最新的hexo分支拉到本地，使本地与远端达到同步。</p>\n<p>然后与本机编辑一样，先用 <code>git add .</code>、<code>git commit -m &quot;备注&quot;</code> 和 <code>git push origin hexo</code> 上传，再进行部署。</p>"},{"title":"群与环的概念","date":"2020-07-06T11:46:54.000Z","_content":"\n----\n\n<!--more-->\n\n# 群(Group)\n\n## 群的定义\n\n群是一个集合 $G$ 加上在 $G$ 中定义的一个二元运算 $\\circ$，$\\circ$ 满足下面条件：\n\n1. **封闭性(Closure)**：对于任意的 $a,b \\in G$，$a \\circ b \\in G$ ；\n2. **结合律(Associativity)**：对于任意的 $a,b,c \\in G$，有 $(a \\circ b) \\circ c = a \\circ (b \\circ c)$；\n3. **单位元(Identity element)**：在 $G$ 中存在一个元素 $e$，它对 $G$ 中的任意元素 $g$，有 $e \\circ g = g \\circ e = g$；\n4. **逆元(Inverse element)**：对 $G$ 中任意元素 $g$ 都存在 $G$ 中的一个 $g'$ 使 $g \\circ g' = g' \\circ g = e$。\n\n单位元 $e$ 和每个 $g$ 对应的逆元 $g^{-1}$ 都是唯一的。\n\n\n\n## 其它一些概念\n\n1. 假如一个群的元素个数是一个有限整数，称这个群为**有限群**，否则称这个群为**无限群**。一个有限群 $G$ 的元素的个数叫做这个**群的阶**，记为 $|G|$。\n2. **交换群**：也称为**Abel群**，对于任意的 $a,b \\in G$ 都有 $a \\circ b = b \\circ a$，即满足交换律的群。\n3. **半群**：仅满足群定义中封闭性与结合律。\n4. **幺半群**：仅满足群定义中封闭性与结合律与单位元。\n\n\n\n## 循环群\n\n循环群 $G$ 中的每一个元素都是某一固定元素 $a$ 的方幂，即 $G = \\{a^n | n \\in \\mathbb{Z}\\}$。我们也称 $G$ 是由元素 $a$ 生成的，记为 $G=(a)$，$a$ 称为 $G$ 的一个生成元素。\n\n例子1：$G = (\\mathbb{Z}, +)$ 是一个循环群，因为 $G = (1)$。\n\n例子2：设 $p$ 是一个素数，则模 $p$ 的简化剩余系 $(\\mathbb{Z}^*_p, \\times)$ 构成一个循环群。模 $p$ 的原根 $g$ 为这个群的一个生成元素。\n\n\n\n## 群同态与群同构\n\n设 $(G,\\cdot), (H,\\times)$ 是两个群，如果存在 $G$ 到 $H$ 的一个映射 $f : G \\mapsto H$，使得\n$$\nf(a \\cdot b) = f(a) \\times f(b)\n$$\n对一切 $a,b \\in G$ 均成立，那么就说 $f$ 是 $G$ 到 $H$ 的一个**同态映射**。如果 $f$ 是 $G$ 到 $H$ 的满射，那么就说 $f$ 是满同态，用符号 $G \\sim H$ 表示，称 $H$ 为 $f$ 下的同态象。如果 $G$ 到 $H$ 的同态映射 $f$ 是单射，那么就说 $f$ 是 $G$ 到 $H$ 的单一同态。如果这个 $f$ 是 $G$ 到 $H$ 的一一映射，那么就说 $f$ 是 $G$ 到 $H$ 的一个同构映射，此时称这两个**群同构**，记为 $G \\cong H$。\n\n假定 $G$ 是一个由元 $a$ 所生成的循环群。当 $a$ 的阶无限时，那么 $G$ 与整数加群同构；若 $a$ 的阶是一个有限整数 $n$，那么 $G$ 与模 $n$ 的剩余类加群同构。\n\n\n\n# 环(Ring)\n\n## 环的定义\n\n设 $R$ 是一个非空集合，其上定义两个运算：加法 $(+)$ 和乘法 $(\\cdot)$，$(R,+,\\cdot)$ 构成一个环，如果这些运算满足\n\n1. $(R, +)$ 是一个交换群，其单位元称为零元，记为 $0$。即：\n   * $(R,+)$ 是封闭的；\n   * $(a+b) = (b+a)$；\n   * $(a+b)+c=a+(b+c)$\n   * $0+a = a+0 = a$；\n   * $\\forall a \\ \\exists(-a)$ 满足 $a+-a = -a + a=0$。\n2. $(R, \\cdot)$ 形成一个半群，即：\n   * $(a \\cdot b) \\cdot c = a \\cdot (b \\cdot c)$；\n   * $(R, \\cdot)$ 是封闭的。\n3. 乘法关于加法满足分配律：\n   * $a \\cdot (b + c) = (a \\cdot b) + (a \\cdot c)$；\n   * $(a+b) \\cdot c =  (a \\cdot c) + (b \\cdot c)$。\n\n其中，乘法运算符 $\\cdot$ 常被忽略，所以 $a \\cdot b$ 可简写为 $ab$。此外，乘法是比加法优先的运算，所以 $a+bc$ 其实是 $a + (b \\cdot c)$。\n\n\n\n## 基本性质\n\n考虑一个环 $R$，\n\n1. 如果 $a + b = a + c$，那么 $b = c$；\n2. 对于任意的 $a \\in R$，都有 $0a = a0 = 0$，这里的 $0$ 为加群中的零元；\n3. 对于任意的 $a,b \\in R$，都有 $(-a)b = -ab = a(-b)$。\n\n最后定义 $a$ 的 $n$ 次方。环 $R$ 中，$a^n$ 表示\n$$\n\\begin{matrix} \n& n个 \\\\ a^n = & \\overbrace{ a \\cdot \\cdot \\cdot a }\n\\end{matrix}\n$$\n显然对于正整数 $n,m$ 有\n$$\na^n \\cdot a^m = a^{m+n}, \\ \\ (a^n)^m = a^{mn}\n$$\n\n\n## 环例子\n\n* 全体整数所成集合 $\\mathbb{Z}$ 对于数的加法和乘法作成一个环，称为整数环。\n* 模 $n$ 剩余系对于模 $n$ 加法和模 $n$ 乘法成为一个环。\n\n","source":"_posts/群与环的概念.md","raw":"---\ntitle: 群与环的概念\ndate: 2020-07-06 19:46:54\ncategories: Study\ntags: [群, 环, 近世代数]\n---\n\n----\n\n<!--more-->\n\n# 群(Group)\n\n## 群的定义\n\n群是一个集合 $G$ 加上在 $G$ 中定义的一个二元运算 $\\circ$，$\\circ$ 满足下面条件：\n\n1. **封闭性(Closure)**：对于任意的 $a,b \\in G$，$a \\circ b \\in G$ ；\n2. **结合律(Associativity)**：对于任意的 $a,b,c \\in G$，有 $(a \\circ b) \\circ c = a \\circ (b \\circ c)$；\n3. **单位元(Identity element)**：在 $G$ 中存在一个元素 $e$，它对 $G$ 中的任意元素 $g$，有 $e \\circ g = g \\circ e = g$；\n4. **逆元(Inverse element)**：对 $G$ 中任意元素 $g$ 都存在 $G$ 中的一个 $g'$ 使 $g \\circ g' = g' \\circ g = e$。\n\n单位元 $e$ 和每个 $g$ 对应的逆元 $g^{-1}$ 都是唯一的。\n\n\n\n## 其它一些概念\n\n1. 假如一个群的元素个数是一个有限整数，称这个群为**有限群**，否则称这个群为**无限群**。一个有限群 $G$ 的元素的个数叫做这个**群的阶**，记为 $|G|$。\n2. **交换群**：也称为**Abel群**，对于任意的 $a,b \\in G$ 都有 $a \\circ b = b \\circ a$，即满足交换律的群。\n3. **半群**：仅满足群定义中封闭性与结合律。\n4. **幺半群**：仅满足群定义中封闭性与结合律与单位元。\n\n\n\n## 循环群\n\n循环群 $G$ 中的每一个元素都是某一固定元素 $a$ 的方幂，即 $G = \\{a^n | n \\in \\mathbb{Z}\\}$。我们也称 $G$ 是由元素 $a$ 生成的，记为 $G=(a)$，$a$ 称为 $G$ 的一个生成元素。\n\n例子1：$G = (\\mathbb{Z}, +)$ 是一个循环群，因为 $G = (1)$。\n\n例子2：设 $p$ 是一个素数，则模 $p$ 的简化剩余系 $(\\mathbb{Z}^*_p, \\times)$ 构成一个循环群。模 $p$ 的原根 $g$ 为这个群的一个生成元素。\n\n\n\n## 群同态与群同构\n\n设 $(G,\\cdot), (H,\\times)$ 是两个群，如果存在 $G$ 到 $H$ 的一个映射 $f : G \\mapsto H$，使得\n$$\nf(a \\cdot b) = f(a) \\times f(b)\n$$\n对一切 $a,b \\in G$ 均成立，那么就说 $f$ 是 $G$ 到 $H$ 的一个**同态映射**。如果 $f$ 是 $G$ 到 $H$ 的满射，那么就说 $f$ 是满同态，用符号 $G \\sim H$ 表示，称 $H$ 为 $f$ 下的同态象。如果 $G$ 到 $H$ 的同态映射 $f$ 是单射，那么就说 $f$ 是 $G$ 到 $H$ 的单一同态。如果这个 $f$ 是 $G$ 到 $H$ 的一一映射，那么就说 $f$ 是 $G$ 到 $H$ 的一个同构映射，此时称这两个**群同构**，记为 $G \\cong H$。\n\n假定 $G$ 是一个由元 $a$ 所生成的循环群。当 $a$ 的阶无限时，那么 $G$ 与整数加群同构；若 $a$ 的阶是一个有限整数 $n$，那么 $G$ 与模 $n$ 的剩余类加群同构。\n\n\n\n# 环(Ring)\n\n## 环的定义\n\n设 $R$ 是一个非空集合，其上定义两个运算：加法 $(+)$ 和乘法 $(\\cdot)$，$(R,+,\\cdot)$ 构成一个环，如果这些运算满足\n\n1. $(R, +)$ 是一个交换群，其单位元称为零元，记为 $0$。即：\n   * $(R,+)$ 是封闭的；\n   * $(a+b) = (b+a)$；\n   * $(a+b)+c=a+(b+c)$\n   * $0+a = a+0 = a$；\n   * $\\forall a \\ \\exists(-a)$ 满足 $a+-a = -a + a=0$。\n2. $(R, \\cdot)$ 形成一个半群，即：\n   * $(a \\cdot b) \\cdot c = a \\cdot (b \\cdot c)$；\n   * $(R, \\cdot)$ 是封闭的。\n3. 乘法关于加法满足分配律：\n   * $a \\cdot (b + c) = (a \\cdot b) + (a \\cdot c)$；\n   * $(a+b) \\cdot c =  (a \\cdot c) + (b \\cdot c)$。\n\n其中，乘法运算符 $\\cdot$ 常被忽略，所以 $a \\cdot b$ 可简写为 $ab$。此外，乘法是比加法优先的运算，所以 $a+bc$ 其实是 $a + (b \\cdot c)$。\n\n\n\n## 基本性质\n\n考虑一个环 $R$，\n\n1. 如果 $a + b = a + c$，那么 $b = c$；\n2. 对于任意的 $a \\in R$，都有 $0a = a0 = 0$，这里的 $0$ 为加群中的零元；\n3. 对于任意的 $a,b \\in R$，都有 $(-a)b = -ab = a(-b)$。\n\n最后定义 $a$ 的 $n$ 次方。环 $R$ 中，$a^n$ 表示\n$$\n\\begin{matrix} \n& n个 \\\\ a^n = & \\overbrace{ a \\cdot \\cdot \\cdot a }\n\\end{matrix}\n$$\n显然对于正整数 $n,m$ 有\n$$\na^n \\cdot a^m = a^{m+n}, \\ \\ (a^n)^m = a^{mn}\n$$\n\n\n## 环例子\n\n* 全体整数所成集合 $\\mathbb{Z}$ 对于数的加法和乘法作成一个环，称为整数环。\n* 模 $n$ 剩余系对于模 $n$ 加法和模 $n$ 乘法成为一个环。\n\n","slug":"群与环的概念","published":1,"updated":"2020-08-23T14:33:37.432Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cke79q4pf001588ps9crk5p8x","content":"<hr>\n<a id=\"more\"></a>\n<h1 id=\"群-Group\"><a href=\"#群-Group\" class=\"headerlink\" title=\"群(Group)\"></a>群(Group)</h1><h2 id=\"群的定义\"><a href=\"#群的定义\" class=\"headerlink\" title=\"群的定义\"></a>群的定义</h2><p>群是一个集合 $G$ 加上在 $G$ 中定义的一个二元运算 $\\circ$，$\\circ$ 满足下面条件：</p>\n<ol>\n<li><strong>封闭性(Closure)</strong>：对于任意的 $a,b \\in G$，$a \\circ b \\in G$ ；</li>\n<li><strong>结合律(Associativity)</strong>：对于任意的 $a,b,c \\in G$，有 $(a \\circ b) \\circ c = a \\circ (b \\circ c)$；</li>\n<li><strong>单位元(Identity element)</strong>：在 $G$ 中存在一个元素 $e$，它对 $G$ 中的任意元素 $g$，有 $e \\circ g = g \\circ e = g$；</li>\n<li><strong>逆元(Inverse element)</strong>：对 $G$ 中任意元素 $g$ 都存在 $G$ 中的一个 $g’$ 使 $g \\circ g’ = g’ \\circ g = e$。</li>\n</ol>\n<p>单位元 $e$ 和每个 $g$ 对应的逆元 $g^{-1}$ 都是唯一的。</p>\n<h2 id=\"其它一些概念\"><a href=\"#其它一些概念\" class=\"headerlink\" title=\"其它一些概念\"></a>其它一些概念</h2><ol>\n<li>假如一个群的元素个数是一个有限整数，称这个群为<strong>有限群</strong>，否则称这个群为<strong>无限群</strong>。一个有限群 $G$ 的元素的个数叫做这个<strong>群的阶</strong>，记为 $|G|$。</li>\n<li><strong>交换群</strong>：也称为<strong>Abel群</strong>，对于任意的 $a,b \\in G$ 都有 $a \\circ b = b \\circ a$，即满足交换律的群。</li>\n<li><strong>半群</strong>：仅满足群定义中封闭性与结合律。</li>\n<li><strong>幺半群</strong>：仅满足群定义中封闭性与结合律与单位元。</li>\n</ol>\n<h2 id=\"循环群\"><a href=\"#循环群\" class=\"headerlink\" title=\"循环群\"></a>循环群</h2><p>循环群 $G$ 中的每一个元素都是某一固定元素 $a$ 的方幂，即 $G = {a^n | n \\in \\mathbb{Z}}$。我们也称 $G$ 是由元素 $a$ 生成的，记为 $G=(a)$，$a$ 称为 $G$ 的一个生成元素。</p>\n<p>例子1：$G = (\\mathbb{Z}, +)$ 是一个循环群，因为 $G = (1)$。</p>\n<p>例子2：设 $p$ 是一个素数，则模 $p$ 的简化剩余系 $(\\mathbb{Z}^*_p, \\times)$ 构成一个循环群。模 $p$ 的原根 $g$ 为这个群的一个生成元素。</p>\n<h2 id=\"群同态与群同构\"><a href=\"#群同态与群同构\" class=\"headerlink\" title=\"群同态与群同构\"></a>群同态与群同构</h2><p>设 $(G,\\cdot), (H,\\times)$ 是两个群，如果存在 $G$ 到 $H$ 的一个映射 $f : G \\mapsto H$，使得</p>\n<script type=\"math/tex; mode=display\">\nf(a \\cdot b) = f(a) \\times f(b)</script><p>对一切 $a,b \\in G$ 均成立，那么就说 $f$ 是 $G$ 到 $H$ 的一个<strong>同态映射</strong>。如果 $f$ 是 $G$ 到 $H$ 的满射，那么就说 $f$ 是满同态，用符号 $G \\sim H$ 表示，称 $H$ 为 $f$ 下的同态象。如果 $G$ 到 $H$ 的同态映射 $f$ 是单射，那么就说 $f$ 是 $G$ 到 $H$ 的单一同态。如果这个 $f$ 是 $G$ 到 $H$ 的一一映射，那么就说 $f$ 是 $G$ 到 $H$ 的一个同构映射，此时称这两个<strong>群同构</strong>，记为 $G \\cong H$。</p>\n<p>假定 $G$ 是一个由元 $a$ 所生成的循环群。当 $a$ 的阶无限时，那么 $G$ 与整数加群同构；若 $a$ 的阶是一个有限整数 $n$，那么 $G$ 与模 $n$ 的剩余类加群同构。</p>\n<h1 id=\"环-Ring\"><a href=\"#环-Ring\" class=\"headerlink\" title=\"环(Ring)\"></a>环(Ring)</h1><h2 id=\"环的定义\"><a href=\"#环的定义\" class=\"headerlink\" title=\"环的定义\"></a>环的定义</h2><p>设 $R$ 是一个非空集合，其上定义两个运算：加法 $(+)$ 和乘法 $(\\cdot)$，$(R,+,\\cdot)$ 构成一个环，如果这些运算满足</p>\n<ol>\n<li>$(R, +)$ 是一个交换群，其单位元称为零元，记为 $0$。即：<ul>\n<li>$(R,+)$ 是封闭的；</li>\n<li>$(a+b) = (b+a)$；</li>\n<li>$(a+b)+c=a+(b+c)$</li>\n<li>$0+a = a+0 = a$；</li>\n<li>$\\forall a \\ \\exists(-a)$ 满足 $a+-a = -a + a=0$。</li>\n</ul>\n</li>\n<li>$(R, \\cdot)$ 形成一个半群，即：<ul>\n<li>$(a \\cdot b) \\cdot c = a \\cdot (b \\cdot c)$；</li>\n<li>$(R, \\cdot)$ 是封闭的。</li>\n</ul>\n</li>\n<li>乘法关于加法满足分配律：<ul>\n<li>$a \\cdot (b + c) = (a \\cdot b) + (a \\cdot c)$；</li>\n<li>$(a+b) \\cdot c =  (a \\cdot c) + (b \\cdot c)$。</li>\n</ul>\n</li>\n</ol>\n<p>其中，乘法运算符 $\\cdot$ 常被忽略，所以 $a \\cdot b$ 可简写为 $ab$。此外，乘法是比加法优先的运算，所以 $a+bc$ 其实是 $a + (b \\cdot c)$。</p>\n<h2 id=\"基本性质\"><a href=\"#基本性质\" class=\"headerlink\" title=\"基本性质\"></a>基本性质</h2><p>考虑一个环 $R$，</p>\n<ol>\n<li>如果 $a + b = a + c$，那么 $b = c$；</li>\n<li>对于任意的 $a \\in R$，都有 $0a = a0 = 0$，这里的 $0$ 为加群中的零元；</li>\n<li>对于任意的 $a,b \\in R$，都有 $(-a)b = -ab = a(-b)$。</li>\n</ol>\n<p>最后定义 $a$ 的 $n$ 次方。环 $R$ 中，$a^n$ 表示</p>\n<script type=\"math/tex; mode=display\">\n\\begin{matrix} \n& n个 \\\\ a^n = & \\overbrace{ a \\cdot \\cdot \\cdot a }\n\\end{matrix}</script><p>显然对于正整数 $n,m$ 有</p>\n<script type=\"math/tex; mode=display\">\na^n \\cdot a^m = a^{m+n}, \\ \\ (a^n)^m = a^{mn}</script><h2 id=\"环例子\"><a href=\"#环例子\" class=\"headerlink\" title=\"环例子\"></a>环例子</h2><ul>\n<li>全体整数所成集合 $\\mathbb{Z}$ 对于数的加法和乘法作成一个环，称为整数环。</li>\n<li>模 $n$ 剩余系对于模 $n$ 加法和模 $n$ 乘法成为一个环。</li>\n</ul>\n","site":{"data":{}},"excerpt":"<hr>","more":"<h1 id=\"群-Group\"><a href=\"#群-Group\" class=\"headerlink\" title=\"群(Group)\"></a>群(Group)</h1><h2 id=\"群的定义\"><a href=\"#群的定义\" class=\"headerlink\" title=\"群的定义\"></a>群的定义</h2><p>群是一个集合 $G$ 加上在 $G$ 中定义的一个二元运算 $\\circ$，$\\circ$ 满足下面条件：</p>\n<ol>\n<li><strong>封闭性(Closure)</strong>：对于任意的 $a,b \\in G$，$a \\circ b \\in G$ ；</li>\n<li><strong>结合律(Associativity)</strong>：对于任意的 $a,b,c \\in G$，有 $(a \\circ b) \\circ c = a \\circ (b \\circ c)$；</li>\n<li><strong>单位元(Identity element)</strong>：在 $G$ 中存在一个元素 $e$，它对 $G$ 中的任意元素 $g$，有 $e \\circ g = g \\circ e = g$；</li>\n<li><strong>逆元(Inverse element)</strong>：对 $G$ 中任意元素 $g$ 都存在 $G$ 中的一个 $g’$ 使 $g \\circ g’ = g’ \\circ g = e$。</li>\n</ol>\n<p>单位元 $e$ 和每个 $g$ 对应的逆元 $g^{-1}$ 都是唯一的。</p>\n<h2 id=\"其它一些概念\"><a href=\"#其它一些概念\" class=\"headerlink\" title=\"其它一些概念\"></a>其它一些概念</h2><ol>\n<li>假如一个群的元素个数是一个有限整数，称这个群为<strong>有限群</strong>，否则称这个群为<strong>无限群</strong>。一个有限群 $G$ 的元素的个数叫做这个<strong>群的阶</strong>，记为 $|G|$。</li>\n<li><strong>交换群</strong>：也称为<strong>Abel群</strong>，对于任意的 $a,b \\in G$ 都有 $a \\circ b = b \\circ a$，即满足交换律的群。</li>\n<li><strong>半群</strong>：仅满足群定义中封闭性与结合律。</li>\n<li><strong>幺半群</strong>：仅满足群定义中封闭性与结合律与单位元。</li>\n</ol>\n<h2 id=\"循环群\"><a href=\"#循环群\" class=\"headerlink\" title=\"循环群\"></a>循环群</h2><p>循环群 $G$ 中的每一个元素都是某一固定元素 $a$ 的方幂，即 $G = {a^n | n \\in \\mathbb{Z}}$。我们也称 $G$ 是由元素 $a$ 生成的，记为 $G=(a)$，$a$ 称为 $G$ 的一个生成元素。</p>\n<p>例子1：$G = (\\mathbb{Z}, +)$ 是一个循环群，因为 $G = (1)$。</p>\n<p>例子2：设 $p$ 是一个素数，则模 $p$ 的简化剩余系 $(\\mathbb{Z}^*_p, \\times)$ 构成一个循环群。模 $p$ 的原根 $g$ 为这个群的一个生成元素。</p>\n<h2 id=\"群同态与群同构\"><a href=\"#群同态与群同构\" class=\"headerlink\" title=\"群同态与群同构\"></a>群同态与群同构</h2><p>设 $(G,\\cdot), (H,\\times)$ 是两个群，如果存在 $G$ 到 $H$ 的一个映射 $f : G \\mapsto H$，使得</p>\n<script type=\"math/tex; mode=display\">\nf(a \\cdot b) = f(a) \\times f(b)</script><p>对一切 $a,b \\in G$ 均成立，那么就说 $f$ 是 $G$ 到 $H$ 的一个<strong>同态映射</strong>。如果 $f$ 是 $G$ 到 $H$ 的满射，那么就说 $f$ 是满同态，用符号 $G \\sim H$ 表示，称 $H$ 为 $f$ 下的同态象。如果 $G$ 到 $H$ 的同态映射 $f$ 是单射，那么就说 $f$ 是 $G$ 到 $H$ 的单一同态。如果这个 $f$ 是 $G$ 到 $H$ 的一一映射，那么就说 $f$ 是 $G$ 到 $H$ 的一个同构映射，此时称这两个<strong>群同构</strong>，记为 $G \\cong H$。</p>\n<p>假定 $G$ 是一个由元 $a$ 所生成的循环群。当 $a$ 的阶无限时，那么 $G$ 与整数加群同构；若 $a$ 的阶是一个有限整数 $n$，那么 $G$ 与模 $n$ 的剩余类加群同构。</p>\n<h1 id=\"环-Ring\"><a href=\"#环-Ring\" class=\"headerlink\" title=\"环(Ring)\"></a>环(Ring)</h1><h2 id=\"环的定义\"><a href=\"#环的定义\" class=\"headerlink\" title=\"环的定义\"></a>环的定义</h2><p>设 $R$ 是一个非空集合，其上定义两个运算：加法 $(+)$ 和乘法 $(\\cdot)$，$(R,+,\\cdot)$ 构成一个环，如果这些运算满足</p>\n<ol>\n<li>$(R, +)$ 是一个交换群，其单位元称为零元，记为 $0$。即：<ul>\n<li>$(R,+)$ 是封闭的；</li>\n<li>$(a+b) = (b+a)$；</li>\n<li>$(a+b)+c=a+(b+c)$</li>\n<li>$0+a = a+0 = a$；</li>\n<li>$\\forall a \\ \\exists(-a)$ 满足 $a+-a = -a + a=0$。</li>\n</ul>\n</li>\n<li>$(R, \\cdot)$ 形成一个半群，即：<ul>\n<li>$(a \\cdot b) \\cdot c = a \\cdot (b \\cdot c)$；</li>\n<li>$(R, \\cdot)$ 是封闭的。</li>\n</ul>\n</li>\n<li>乘法关于加法满足分配律：<ul>\n<li>$a \\cdot (b + c) = (a \\cdot b) + (a \\cdot c)$；</li>\n<li>$(a+b) \\cdot c =  (a \\cdot c) + (b \\cdot c)$。</li>\n</ul>\n</li>\n</ol>\n<p>其中，乘法运算符 $\\cdot$ 常被忽略，所以 $a \\cdot b$ 可简写为 $ab$。此外，乘法是比加法优先的运算，所以 $a+bc$ 其实是 $a + (b \\cdot c)$。</p>\n<h2 id=\"基本性质\"><a href=\"#基本性质\" class=\"headerlink\" title=\"基本性质\"></a>基本性质</h2><p>考虑一个环 $R$，</p>\n<ol>\n<li>如果 $a + b = a + c$，那么 $b = c$；</li>\n<li>对于任意的 $a \\in R$，都有 $0a = a0 = 0$，这里的 $0$ 为加群中的零元；</li>\n<li>对于任意的 $a,b \\in R$，都有 $(-a)b = -ab = a(-b)$。</li>\n</ol>\n<p>最后定义 $a$ 的 $n$ 次方。环 $R$ 中，$a^n$ 表示</p>\n<script type=\"math/tex; mode=display\">\n\\begin{matrix} \n& n个 \\\\ a^n = & \\overbrace{ a \\cdot \\cdot \\cdot a }\n\\end{matrix}</script><p>显然对于正整数 $n,m$ 有</p>\n<script type=\"math/tex; mode=display\">\na^n \\cdot a^m = a^{m+n}, \\ \\ (a^n)^m = a^{mn}</script><h2 id=\"环例子\"><a href=\"#环例子\" class=\"headerlink\" title=\"环例子\"></a>环例子</h2><ul>\n<li>全体整数所成集合 $\\mathbb{Z}$ 对于数的加法和乘法作成一个环，称为整数环。</li>\n<li>模 $n$ 剩余系对于模 $n$ 加法和模 $n$ 乘法成为一个环。</li>\n</ul>"},{"title":"解决Ubuntu deepin-wine微信字体乱码","date":"2020-04-23T16:30:22.000Z","_content":"\n----\n\n\n\n<!--more-->\n\n# 解决乱码+修改字体(微软雅黑)\n\n下载微软雅黑字体,msyh.ttc\n\n\n\n## 添加字体\n\n```shell\n$ cp msyh.ttc ~/.deepinwine/Deepin-WeChat/drive_c/windows/Fonts\n```\n\n\n\n## 修改系统注册表\n\n```shell\n$ gedit ~/.deepinwine/Deepin-WeChat/system.reg\n```\n\n修改以下两行\n\n```\n\"MS Shell Dlg\"=\"msyh\"\n\"MS Shell Dlg 2\"=\"msyh\"\n```\n\n\n\n## 字体注册\n\n```shell\n$ gedit msyh_config.reg\n```\n\n内容添加\n\n```\nREGEDIT4\n[HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows NT\\CurrentVersion\\FontLink\\SystemLink]\n\"Lucida Sans Unicode\"=\"msyh.ttc\"\n\"Microsoft Sans Serif\"=\"msyh.ttc\"\n\"MS Sans Serif\"=\"msyh.ttc\"\n\"Tahoma\"=\"msyh.ttc\"\n\"Tahoma Bold\"=\"msyhbd.ttc\"\n\"msyh\"=\"msyh.ttc\"\n\"Arial\"=\"msyh.ttc\"\n\"Arial Black\"=\"msyh.ttc\"\n#注册\nWINEPREFIX=~/.deepinwine/Deepin-WeChat deepin-wine regedit msyh_config.reg\n```\n\n\n\n## Reboot","source":"_posts/解决Ubuntu-deepin-wine微信字体乱码.md","raw":"---\ntitle: 解决Ubuntu deepin-wine微信字体乱码\ndate: 2020-04-24 00:30:22\ncategories: Env\ntags: [Ubuntu, Linux]\n---\n\n----\n\n\n\n<!--more-->\n\n# 解决乱码+修改字体(微软雅黑)\n\n下载微软雅黑字体,msyh.ttc\n\n\n\n## 添加字体\n\n```shell\n$ cp msyh.ttc ~/.deepinwine/Deepin-WeChat/drive_c/windows/Fonts\n```\n\n\n\n## 修改系统注册表\n\n```shell\n$ gedit ~/.deepinwine/Deepin-WeChat/system.reg\n```\n\n修改以下两行\n\n```\n\"MS Shell Dlg\"=\"msyh\"\n\"MS Shell Dlg 2\"=\"msyh\"\n```\n\n\n\n## 字体注册\n\n```shell\n$ gedit msyh_config.reg\n```\n\n内容添加\n\n```\nREGEDIT4\n[HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows NT\\CurrentVersion\\FontLink\\SystemLink]\n\"Lucida Sans Unicode\"=\"msyh.ttc\"\n\"Microsoft Sans Serif\"=\"msyh.ttc\"\n\"MS Sans Serif\"=\"msyh.ttc\"\n\"Tahoma\"=\"msyh.ttc\"\n\"Tahoma Bold\"=\"msyhbd.ttc\"\n\"msyh\"=\"msyh.ttc\"\n\"Arial\"=\"msyh.ttc\"\n\"Arial Black\"=\"msyh.ttc\"\n#注册\nWINEPREFIX=~/.deepinwine/Deepin-WeChat deepin-wine regedit msyh_config.reg\n```\n\n\n\n## Reboot","slug":"解决Ubuntu-deepin-wine微信字体乱码","published":1,"updated":"2020-08-23T14:33:37.432Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cke79q4pg001888pse6shhc9z","content":"<hr>\n<a id=\"more\"></a>\n<h1 id=\"解决乱码-修改字体-微软雅黑\"><a href=\"#解决乱码-修改字体-微软雅黑\" class=\"headerlink\" title=\"解决乱码+修改字体(微软雅黑)\"></a>解决乱码+修改字体(微软雅黑)</h1><p>下载微软雅黑字体,msyh.ttc</p>\n<h2 id=\"添加字体\"><a href=\"#添加字体\" class=\"headerlink\" title=\"添加字体\"></a>添加字体</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> cp msyh.ttc ~/.deepinwine/Deepin-WeChat/drive_c/windows/Fonts</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"修改系统注册表\"><a href=\"#修改系统注册表\" class=\"headerlink\" title=\"修改系统注册表\"></a>修改系统注册表</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> gedit ~/.deepinwine/Deepin-WeChat/system.reg</span></span><br></pre></td></tr></table></figure>\n<p>修改以下两行</p>\n<figure class=\"highlight 1c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"MS Shell Dlg\"</span>=<span class=\"string\">\"msyh\"</span></span><br><span class=\"line\"><span class=\"string\">\"MS Shell Dlg 2\"</span>=<span class=\"string\">\"msyh\"</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"字体注册\"><a href=\"#字体注册\" class=\"headerlink\" title=\"字体注册\"></a>字体注册</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> gedit msyh_config.reg</span></span><br></pre></td></tr></table></figure>\n<p>内容添加</p>\n<figure class=\"highlight moonscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">REGEDIT4</span><br><span class=\"line\">[HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows NT\\CurrentVersion\\FontLink\\SystemLink]</span><br><span class=\"line\"><span class=\"string\">\"Lucida Sans Unicode\"</span>=<span class=\"string\">\"msyh.ttc\"</span></span><br><span class=\"line\"><span class=\"string\">\"Microsoft Sans Serif\"</span>=<span class=\"string\">\"msyh.ttc\"</span></span><br><span class=\"line\"><span class=\"string\">\"MS Sans Serif\"</span>=<span class=\"string\">\"msyh.ttc\"</span></span><br><span class=\"line\"><span class=\"string\">\"Tahoma\"</span>=<span class=\"string\">\"msyh.ttc\"</span></span><br><span class=\"line\"><span class=\"string\">\"Tahoma Bold\"</span>=<span class=\"string\">\"msyhbd.ttc\"</span></span><br><span class=\"line\"><span class=\"string\">\"msyh\"</span>=<span class=\"string\">\"msyh.ttc\"</span></span><br><span class=\"line\"><span class=\"string\">\"Arial\"</span>=<span class=\"string\">\"msyh.ttc\"</span></span><br><span class=\"line\"><span class=\"string\">\"Arial Black\"</span>=<span class=\"string\">\"msyh.ttc\"</span></span><br><span class=\"line\">#注册</span><br><span class=\"line\">WINEPREFIX=~/.deepinwine/Deepin-WeChat deepin-wine regedit msyh_config.reg</span><br></pre></td></tr></table></figure>\n<h2 id=\"Reboot\"><a href=\"#Reboot\" class=\"headerlink\" title=\"Reboot\"></a>Reboot</h2>","site":{"data":{}},"excerpt":"<hr>","more":"<h1 id=\"解决乱码-修改字体-微软雅黑\"><a href=\"#解决乱码-修改字体-微软雅黑\" class=\"headerlink\" title=\"解决乱码+修改字体(微软雅黑)\"></a>解决乱码+修改字体(微软雅黑)</h1><p>下载微软雅黑字体,msyh.ttc</p>\n<h2 id=\"添加字体\"><a href=\"#添加字体\" class=\"headerlink\" title=\"添加字体\"></a>添加字体</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> cp msyh.ttc ~/.deepinwine/Deepin-WeChat/drive_c/windows/Fonts</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"修改系统注册表\"><a href=\"#修改系统注册表\" class=\"headerlink\" title=\"修改系统注册表\"></a>修改系统注册表</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> gedit ~/.deepinwine/Deepin-WeChat/system.reg</span></span><br></pre></td></tr></table></figure>\n<p>修改以下两行</p>\n<figure class=\"highlight 1c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"MS Shell Dlg\"</span>=<span class=\"string\">\"msyh\"</span></span><br><span class=\"line\"><span class=\"string\">\"MS Shell Dlg 2\"</span>=<span class=\"string\">\"msyh\"</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"字体注册\"><a href=\"#字体注册\" class=\"headerlink\" title=\"字体注册\"></a>字体注册</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> gedit msyh_config.reg</span></span><br></pre></td></tr></table></figure>\n<p>内容添加</p>\n<figure class=\"highlight moonscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">REGEDIT4</span><br><span class=\"line\">[HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows NT\\CurrentVersion\\FontLink\\SystemLink]</span><br><span class=\"line\"><span class=\"string\">\"Lucida Sans Unicode\"</span>=<span class=\"string\">\"msyh.ttc\"</span></span><br><span class=\"line\"><span class=\"string\">\"Microsoft Sans Serif\"</span>=<span class=\"string\">\"msyh.ttc\"</span></span><br><span class=\"line\"><span class=\"string\">\"MS Sans Serif\"</span>=<span class=\"string\">\"msyh.ttc\"</span></span><br><span class=\"line\"><span class=\"string\">\"Tahoma\"</span>=<span class=\"string\">\"msyh.ttc\"</span></span><br><span class=\"line\"><span class=\"string\">\"Tahoma Bold\"</span>=<span class=\"string\">\"msyhbd.ttc\"</span></span><br><span class=\"line\"><span class=\"string\">\"msyh\"</span>=<span class=\"string\">\"msyh.ttc\"</span></span><br><span class=\"line\"><span class=\"string\">\"Arial\"</span>=<span class=\"string\">\"msyh.ttc\"</span></span><br><span class=\"line\"><span class=\"string\">\"Arial Black\"</span>=<span class=\"string\">\"msyh.ttc\"</span></span><br><span class=\"line\">#注册</span><br><span class=\"line\">WINEPREFIX=~/.deepinwine/Deepin-WeChat deepin-wine regedit msyh_config.reg</span><br></pre></td></tr></table></figure>\n<h2 id=\"Reboot\"><a href=\"#Reboot\" class=\"headerlink\" title=\"Reboot\"></a>Reboot</h2>"},{"title":"论文笔记 ABY - A Framework for Efficient Mixed-Protocol Secure Two-Party Computation","date":"2020-06-11T14:09:08.000Z","_content":"\n*Daniel Demmler, Thomas Schneider, Michael Zohner*\n\n[NDSS 2015](https://dblp.uni-trier.de/db/conf/ndss/ndss2015.html#Demmler0Z15)\n\nhttps://www.ndss-symposium.org/ndss2015/ndss-2015-programme/aby-framework-efficient-mixed-protocol-secure-two-party-computation/\n\n<!--more-->\n\n# 摘要\n\n安全计算使相互不信任的各方能够在其私有输入上联合计算函数，而不会泄露函数的输出以外的任何信息。半诚实模型中的通用安全计算协议已经被广泛研究，并形成了几个最佳实践。在这项工作中，我们设计并实现了一个混合协议框架，称为Aby，它有效地结合了基于算术共享、布尔共享和姚的乱码电路的安全计算方案，并为安全两方计算提供了最佳实践方案。我们的框架允许预计算几乎所有的密码运算，并基于预计算的不经意传输扩展在安全计算方案之间提供新颖、高效的转换。ABY支持多种标准操作，我们在本地网络和公共洲际云上执行基准测试。从我们的基准测试中，我们对安全计算协议的高效设计有了新的见解，最突出的是，基于不经意传输的乘法比基于同态加密的乘法要高效得多。我们使用ABY为三个示例应用(私有集合交集、生物特征匹配和模幂运算)构建混合协议，并表明它们比使用单一协议更有效。\n\n**关键词**：安全的两方计算；混合协议；高效的协议设计\n\n\n\n\n\n# 共享类型\n\n在本节中，详细介绍作者的Aby框架使用的共享类型：算术共享(§III-A)、布尔共享(§III-B)和姚共享(§III-C)。对于每种共享类型，本文将在各自的小节中描述共享的语义、标准操作和最新技术。\n\n## 算术共享\n\n对于算术共享，在环 $\\mathbb{Z}_{2^l}$(整数模 $2^l$)中相加地共享 $l$ 位值 $x$ 作为两个值的和。以下描述的协议基于[2]、[44]、[67]。首先，作者定义了共享语义(§III-A1)和操作(§III-A2)，并概述了基于算术共享的安全计算的相关工作(§III-A3)。然后，作者详细介绍了如何使用同态加密(§III-A4)或OT(§III-A5)生成算术乘法三元组；作者在§V-C后面的部分对这两种方法的性能进行了实验比较。在下面，作者假设要在环Z2‘中执行的所有算术运算，即所有运算都是($\\bmod 2^l$)。\n\n\n\n### 共享语义\n\n算术共享基于在各方之间附加共享私有值，如下所示：\n\n* **被共享的值。**对于一个 $l$ 位的 $x$ 的算术共享 $\\langle x \\rangle ^ A$，有 $\\langle x \\rangle ^A_0 + \\langle x \\rangle ^A_1 \\equiv x (\\bmod 2^l)$，其中 $\\langle x \\rangle ^ A_0, \\langle x \\rangle ^A_1 \\in \\mathbb{Z}_{2^l}$。\n* **共享。**$\\mathsf{Shr}^A_i(x)$：$P_i$ 选择 $r \\in_R \\mathbb{Z}_{2^l}$，设 $\\langle x \\rangle^A_i = x - r$，然后发送 $r$ 给 $P_{1-i}$，后者设 $\\langle x \\rangle^A_{1-i} = r$。\n* **重构。**$\\mathsf{Rec}^A_i(x)$：$P_{1-i}$ 发送它的份额 $\\langle x \\rangle^A_{1-i}$ 给 $P_i$，后者计算 $x = \\langle x \\rangle ^A_0 + \\langle x \\rangle ^A_1$。\n\n\n\n### 操作\n\n每个算术电路都是一系列加法和乘法门，评估如下：\n\n* **加法。**$\\langle z \\rangle ^ A = \\langle x \\rangle ^ A + \\langle y \\rangle ^ A$：$P_i$ 在本地计算 $\\langle z \\rangle ^ A_i = \\langle x \\rangle ^ A_i + \\langle y \\rangle ^ A_i$。\n* **乘法。**$\\langle z \\rangle ^ A = \\langle x \\rangle ^ A \\cdot \\langle y \\rangle ^ A$：乘法使用形式为 $\\langle c \\rangle ^ A = \\langle a \\rangle ^ A \\cdot \\langle b \\rangle ^ A$ 的预计算算术乘法三元组[4]：$P_i$ 设 $\\langle e \\rangle ^A_i = \\langle x \\rangle ^A_i - \\langle a \\rangle ^A_i$ 和 $\\langle f \\rangle ^A_i = \\langle y \\rangle ^A_i - \\langle b \\rangle ^A_i$，双方执行 $\\mathsf{Rec}^A(e)$ 和 $$\\mathsf{Rec}^A(f)$$，然后 $P_i$ 设 $\\langle z \\rangle ^ A_i = i \\cdot e \\cdot f + f \\cdot \\langle a \\rangle ^ A_i + e \\cdot \\langle b \\rangle ^ A_i + \\langle c \\rangle ^ A_i$。本文给出了预计算算术乘法的协议。\n\n\n\n### 利用加性同态加密生成算术乘法三元组\n\n通常，$\\langle a \\rangle ^ A \\cdot \\langle b \\rangle ^ A = \\langle c \\rangle ^ A$ 形式的算术乘法三元组在设置阶段使用如协议1所示的加法同态加密方案来生成。该用于生成乘法三元组的协议在[2，附录A]中被提到为“众所周知的民间传说”。对于同态加密，我们使用Paillier[25]、[26]、[62]的密码系统，或者使用Damgard-Geisler-Krøigaard(DGK)[22]、[23]的密码系统，并使用如[10]、[32]、[52]中描述的Pohlig-Hellman算法[65]进行完全解密。在Paillier加密中，明文空间为 $Z_N$，使用参数为 $r$ 的统计盲化；在DGK加密中，将明文空间设置为 $\\mathbb{Z}_{2^{2l+1}}$，使用参数为 $r$ 的完全盲化。关于安全性和正确性的证明，请参阅[67]和[66]。\n\n**复杂度。**为了生成 $l$ 位乘法三元组，$P_0$ 和 $P_1$ 交换 $3$ 个密文，对于Paillier每个密文长度为 $2\\varphi$ 比特(而DGK为 $\\varphi$ 比特)，导致总共6个 $\\varphi$ 比特的通信(对应的3个 $\\varphi$ 比特)。对于Paillier加密，我们还使用了[67]中描述的打包优化，该优化将从 $P_1$ 到 $P_0$ 的多个消息打包成单个密文，从而减少解密次数，并将每个乘法三倍的通信量减少到 $4 \\varphi + 2 \\varphi / \\lfloor \\varphi / (2l+1+ \\sigma) \\rfloor$ 比特。\n\n![](http://images.yingwai.top/picgo/aby2p1.png)\n\n\n\n### 通过不经意传输生成算术乘法三元组\n\n可以基于OT扩展生成算术乘法三元组，而不是使用同态加密。该议定书是在[33，Sect. 4.1]中提出的，并在[15]中使用。它允许使用OT有效地计算两个秘密共享值的乘积。在下面，本文将描述使用更有效的相关OT扩展的协议的一个微小变体。总体而言，可以在 $l$ 位串上使用 $2l$ 个相关的OT，即 C-OT$^{2l}_l$ (或者甚至在更短的串上，如下所述)来生成 $l$ 位乘法三元组。\n\n\n\n## 布尔共享\n\n布尔共享使用基于异或的秘密共享方案。为了简化表示，假定使用单个比特值；对于 $l$ 比特的值，每个操作都并行执行多次。\n\n\n\n### 共享语义\n\n* **被共享的值。**如果有 $\\langle x \\rangle ^B_0 \\oplus \\langle x \\rangle ^B_1 = x$，其中 $\\langle x \\rangle ^B_0, \\langle x \\rangle ^B_1 \\in \\mathbb{Z}_2$，那么就说比特 $x$ 的布尔共享 $\\langle x \\rangle ^B$ 是在两方之间共享的。\n* **共享。**$\\mathsf{Shr}_i^B(x)$：$P_i$ 选择 $r \\in_R \\{0,1\\}$，计算 $\\langle x \\rangle ^B_i = x \\oplus r$，然后发送 $r$ 给 $P_{1-i}$，后者设 $\\langle x \\rangle ^B_{1-i} = r$。\n* **重构。**$\\mathsf{Rec}_i^B(x)$：$P_{1-i}$ 发送它的份额 $\\langle x \\rangle ^B_{1-i}$ 给 $P_i$，后者计算 $x = \\langle x \\rangle ^B_0 \\oplus \\langle x \\rangle ^B_1$。\n\n\n\n### 操作\n\n每个有效计算的函数都可以表示为一个由异或门和与门组成的布尔电路，本文将在下面详细说明对它的求值。\n\n* **异或。**$\\langle z \\rangle ^B = \\langle x \\rangle ^B \\oplus \\langle y \\rangle ^B$：$P_i$ 本地计算 $\\langle z \\rangle ^B_i = \\langle x \\rangle ^B_i \\oplus \\langle y \\rangle ^B_i$。\n* **与。**$\\langle z \\rangle ^B = \\langle x \\rangle ^B \\wedge \\langle y \\rangle ^B$：与使用预计算布尔乘法三元组 $\\langle c \\rangle ^B = \\langle a \\rangle ^B \\wedge \\langle b \\rangle ^B$ 进行评估，如下所示：$P_i$ 计算 $\\langle e \\rangle ^B_i = \\langle a \\rangle ^B_i \\oplus \\langle x \\rangle ^B_i$ 和 $\\langle f \\rangle ^B_i = \\langle b \\rangle ^B_i \\oplus \\langle y \\rangle ^B_i$，双方执行 $\\mathsf{Rec}^B(e)$ 和 $\\mathsf{Rec}^B(f)$，然后 $P_i$ 设 $\\langle z \\rangle ^B_i = i \\cdot e \\cdot f \\oplus f \\cdot \\langle a \\rangle ^B_i \\oplus e \\cdot \\langle b \\rangle ^B_i \\oplus \\langle c \\rangle ^B_i$。如文献[1]所述，使用 R-OT$^2_1$ 可以有效地预计算布尔乘法三元组。\n* **多路复用。**对于多路复用器操作，本文使用[54]中提出的协议，该协议只需要 R-OT$^2_l$，而评估具有 $l$ 个与门的多路复用电路需要 R-OT$^{2l}_1$(参见[64]中的向量乘法三元组)。\n* **其它。**对于标准功能，本文使用[69]中总结的深度优化电路结构。\n\n\n\n## 姚氏共享\n\n在Yao用于安全两方计算的乱码电路协议[74]中，一方(称为Garbler)将布尔函数加密为乱码电路，由另一方(称为赋值器)进行评估。更详细地，加布勒将要计算的函数表示为布尔电路，并将满足 $k_0^w, k_1^w \\in \\{0,1\\}^{\\kappa}$ 的两个线密钥 $(k_0^w, k_1^w)$ 分配给每条线 $w$。然后，Garbler使用加密函数 $\\mathsf{Gb}$ 对两个输入线密钥的所有可能组合上的每个门的输出线密钥进行加密(详情见§III-C2中的共享)。然后，他将损坏的电路(由所有损坏的门组成)连同电路的相应输入键一起发送给评估器(参见§III-C1的共享)。评估者使用门的输入线路密钥迭代地解密每个乱码的门，以获得输出线路密钥(参见§III-C2中的与)，并最终重构电路的明文输出(参见§III-C1中的重构)。\n\n在下面，我们假设 $P_0$ 充当Garbler，$P_1$ 充当评估者，并详细说明Yao共享，假设使用free-XOR[47]和点置换[53]优化的乱码方案。使用这些技术，Garbler随机选择 $R[0]=1$ 的全局 $\\kappa$ 位串 $R$。对于每根导线 $w$，线密钥分别为 $k^w_0 \\in_R \\{0,1\\}^{\\kappa}$ 和 $k^w_1 = k^w_0 \\oplus R$。最低有效位 $k^w_0[0]$、$k^w_1[0]=1 − k^w_0[0]$ 称为置换位。作者指出，YAO共享也可以与其他改进方案一起实例化。\n\n\n\n### 共享语义\n\n直观地，对于每根导线 $w$，$P_0$ 持有两个键 $k_0^w$ 和 $k_1^w$，以及 $P_1$ 持有这些键中的一个，而不知道它对应于两个明文值中的哪一个。为了简化表示，我们假定使用单个比特值；对于 $l$ 比特的值，每个操作都并行执行多次。\n\n* **被共享的值。**值 $x$ 的乱码电路共享 $\\langle x \\rangle ^Y$ 被共享为 $\\langle x \\rangle ^Y_0 = k_0$ 和 $\\langle x \\rangle ^Y_1 = k_x = k_0 \\oplus xR$。\n* **共享。**$\\mathsf{Shr}^Y_0(x)$：$P_0$ 取随机值 $\\langle x \\rangle ^Y_0 = k_0 \\in_R \\{0,1\\}^{\\kappa}$ 然后发送 $k_x = k_0 \\oplus xR$ 给 $P_1$。\n* **重构。**$\\mathsf{Rec}^Y_i (x)$：$P_{1-i}$ 发送它的置换位 $\\pi = \\langle x \\rangle ^Y_{1-i}[0]$ 给 $P_i$，后者计算 $x = \\pi \\oplus \\langle x \\rangle ^Y_i[0]$。\n\n\n\n### 操作\n\n使用姚氏共享，由XOR和AND门组成的布尔电路评估如下：\n\n* **异或。**$\\langle z \\rangle ^Y = \\langle x \\rangle ^Y \\oplus \\langle y \\rangle ^Y$ 使用 free-XOR 技术[47]进行评估：$P_i$ 本地计算 $\\langle z \\rangle ^Y_i = \\langle x \\rangle ^Y_i \\oplus \\langle y \\rangle ^Y_i$。\n* **与。**$\\langle z \\rangle ^Y = \\langle x \\rangle ^Y \\wedge \\langle y \\rangle ^Y$ 评估如下：$P_0$ 使用 $\\mathsf{Gb}_{\\langle z \\rangle ^Y_0}(\\langle x \\rangle ^Y_0, \\langle y \\rangle ^Y_0)$ 生成乱码表，其中 $\\mathsf{Gb}$ 是[7]中定义的乱码函数。$P_0$ 发送该表给 $P_1$，后者使用它的密钥 $\\langle x \\rangle ^Y_1$ 和 $\\langle y \\rangle ^Y_1$ 进行解密。\n* **其它。**对于标准功能，本文使用[45]中总结的尺寸优化的电路结构。\n\n\n\n# 共享转换\n\n在本节中，将详细介绍在不同共享之间进行转换的方法。首先解释已经存在的或直接的转换：Y2B(§IV-A)、B2Y(§IV-B)、A2Y(§IV-C)和A2B(§IV-D)。然后，我们详细说明了B2A(§IV-E)和Y 2A(§IV-F)的改进结构。作者将共享、重构和转换操作的复杂性总结在表1。\n\n![](http://images.yingwai.top/picgo/aby2t1.png)\n\n<center>\n    <i>表1 用于l比特的值的共享、重构和转换操作的在线阶段的总计算(对称密码操作数)、通信和消息数。κ是对称安全参数。</i>\n</center>\n\n\n\n\n## 姚氏到布尔共享(Y2B)\n\n将姚共享 $\\langle x \\rangle ^Y$ 转换为布尔共享 $\\langle x \\rangle ^B$ 是最简单的转换，基本上是免费的。关键的发现是 $\\langle x \\rangle ^Y_0$ 和 $\\langle x \\rangle ^Y_1$ 的排列位已经形成了 $x$ 的有效布尔共享。因此，$P_i$ 在本地设置 $\\langle x \\rangle ^B_i = Y2B(\\langle x \\rangle ^Y_i) = \\langle x \\rangle ^Y_i[0]$。\n\n\n\n## 布尔到姚氏共享(B2Y)\n\n将布尔共享 $\\langle x \\rangle ^B$ 转换为姚共享 $\\langle x \\rangle ^Y$ 非常类似于 $\\mathsf{Shr}^Y_1$ 操作(参见§III-C1)：在下文中，我们假设 $x$ 是1比特；对于 $l$ 比特的值，每个运算都并行完成 $l$ 次。设 $x_0 = \\langle x \\rangle ^B_0$ 和 $x_1 = \\langle x \\rangle ^B_1$。$P_0$ 选取 $\\langle x \\rangle ^Y_0 = k_0 \\in_R \\{0,1\\}^{\\kappa}$。双方执行 OT$^1_{\\kappa}$，其中 $P_0$ 作为具有输入的发送方 $(k_0 \\oplus x_0 \\cdot R;k_0 \\oplus (1−x_0) \\cdot R)$，而 $P_1$ 作为具有选择位 $x_1$ 的接收方，并且不经意地获得 $\\langle x \\rangle ^Y_1 = k_0 \\oplus (x_0 \\oplus x_1) \\cdot R = k_x$。\n\n\n\n## 算术到姚氏共享(A2Y)\n\n算术共享 $\\langle x \\rangle ^A$ 到Yao共享 $\\langle x \\rangle ^Y$ 的转换在[35]、[44]、[46]中概述，并且可以通过安全地评估加法电路来完成。更准确地说，各方秘密地将他们的算术份额 $x_0 = \\langle x \\rangle ^A_0$ 和 $x_1 = \\langle x \\rangle ^A_1$ 共享为 $\\langle x_0 \\rangle ^Y = \\mathsf{Shr}^Y_0(x_0)$ 和 $\\langle x_1 \\rangle ^Y = \\mathsf{Shr}^Y_1(x_1)$，并计算 $\\langle x \\rangle ^Y = \\langle x_0 \\rangle ^Y + \\langle x_1 \\rangle ^Y$。\n\n\n\n## 算术到布尔共享(A2B)\n\n可以使用布尔加法电路(类似于§IV-C中描述的A2Y转换)或通过使用算术位提取电路[17]、[18]、[21]、[70]来完成将算术共享 $\\langle x \\rangle ^A$ 转换为布尔共享 $\\langle x \\rangle ^B$。如在[69]中总结的，布尔加法电路可以被实例化为大小优化的随 $O(l)$ 大小和深度变化的变量，或者实例化为随 $O(l\\log_2l)$ 大小和 $O(\\log_2l)$ 深度变化的深度优化的变量。在本文的框架中，$Y2B$ 转换是免费的，我们简单地计算 $\\langle x \\rangle ^B = A2B(\\langle x \\rangle ^A) = Y2B(A2Y(\\langle x \\rangle ^A))$，因为我们在§V-D中的评估表明，Yao共享中的加法比布尔共享中的加法更有效。\n\n\n\n## 布尔到算术共享(B2A)\n\n将 $l$ 比特布尔共享 $\\langle x \\rangle ^B$ 转换为算术共享 $\\langle x \\rangle ^A$ 的简单解决方案是评估布尔减法电路，其中 $P_0$ 输入 $\\langle x \\rangle ^B_0$ 和随机数 $r \\in_R \\{0,1\\}^l$，并且设置 $\\langle x \\rangle ^A_0 = r$，然后 $P_1$ 输入 $\\langle x \\rangle ^B_1$ 并获得 $\\langle x \\rangle ^A_1 = x - r$。然而，评估这样的布尔减法电路将具有 $O(l)$ 大小和深度或者 $O(l \\log_2 l)$ 大小和 $O(\\log_2 l)$ 深度[69]。\n\n为了提高转换的性能，可以使用与§III-A5中描述的算术乘法三次生成类似的技术。一般的想法是对每个比特执行OT，其中我们不经意地转移了两个值，这两个值被2的幂相加相关。接收方可以获得这些值中的一个，并且通过将它们相加，各方获得有效的算术份额。\n\n更详细地说，在OT协议中，$P_0$ 充当发送者，$P_1$ 充当接收者。在第 $i$ 个OT中，$P_0$ 随机选择 $r_i \\in_R \\{0, 1\\}^l$ 以及输入 $(s_{i,0}, s_{i_1})$，其中 $s_{i,0} = (1 - \\langle x \\rangle^B_0[i]) \\cdot 2^i - r_i$ 以及 $s_{i,1} = \\langle x \\rangle^B_0[i] \\cdot 2^i - r_i$，而 $P_1$ 输入 $\\langle x \\rangle^B_1[i]$ 作为选择位，收到输出 $s_{\\langle x \\rangle ^B_1[i]} = (\\langle x \\rangle^B_0[i] \\oplus \\langle x \\rangle^B_1[i]) \\cdot 2^i - r_i$。最后，$P_0$ 计算 $\\langle x \\rangle^A_0 = \\sum^l_{i=1}r_i$，$P_1$ 计算 $\\langle x \\rangle^A_1$ $=\\sum^l_{i=1}s_{\\langle x \\rangle^B_1[i]}$ $=\\sum^l_{i=1}(\\langle x \\rangle^B_0[i] \\oplus \\langle x \\rangle^B_1[i]) \\cdot$ $2^i-\\sum^l_{i=1}r_i$ $=\\sum^l_{i=1}x[i] \\cdot 2^i -$ $\\sum^l_{i=1}r_i$ $=x - \\langle x \\rangle^A_0$。安全性和正确性类似于§III-A5的协议。\n\n**复杂度。**观察到，由于我们传输一个随机元素和另一个作为相关性，并且只需要第 $i$ 个OT中的 $l-i$ 个最低有效位，所以我们可以使用C-OT和§III-A5中概述的相同技巧，导致(平均)C-OT$^l_{(l+1)/2}$ 和恒定轮数。相比之下，当使用布尔共享评估减法电路时，对于深度为 $O(\\log_2l)$ 的电路各方将需要评估 $O(l \\log_2 l)$次R-OT或对于深度为 $l$ 的电路评估 $2l$ 次ROT。本文的转换方法也比转换成姚共享(这已经需要 $2l$ OT)并在乱码电路中进行减法运算。\n\n\n\n## 姚氏到算术共享(Y2A)\n\n在[35]，[44]，[46]中描述了从姚共享 $\\langle x \\rangle ^Y$ 到算术共享 $\\langle x \\rangle ^A$ 的转换：$P_0$ 随机选择 $r \\in_R \\mathbb{Z}_{2^l}$，执行 $\\mathsf{Shr}^Y_0$，然后双方评估布尔减法电路 $\\langle d \\rangle ^Y = \\langle x \\rangle ^Y - \\langle r \\rangle ^Y$，以获得它们的算术份额为 $\\langle x \\rangle ^A_0 = r$ 和 $\\langle x \\rangle ^A_1 = \\mathsf{Rec}^Y_1(\\langle d \\rangle ^Y)$。\n\n然而，由于我们免费执行 $Y2B$，而 $B2A$ 在计算和通信方面更便宜，我们建议计算 $\\langle x \\rangle ^A = Y2A(\\langle x \\rangle ^Y) = B2A(Y2B(\\langle x \\rangle ^Y))$。","source":"_posts/论文笔记-ABY-A-Framework-for-Efficient-Mixed-Protocol-Secure-Two-Party-Computation.md","raw":"---\ntitle: >-\n  论文笔记 ABY - A Framework for Efficient Mixed-Protocol Secure Two-Party\n  Computation\ndate: 2020-06-11 22:09:08\ncategories: Papers\ntags: [MPC, 密码学, PPML, Secret Sharing]\n---\n\n*Daniel Demmler, Thomas Schneider, Michael Zohner*\n\n[NDSS 2015](https://dblp.uni-trier.de/db/conf/ndss/ndss2015.html#Demmler0Z15)\n\nhttps://www.ndss-symposium.org/ndss2015/ndss-2015-programme/aby-framework-efficient-mixed-protocol-secure-two-party-computation/\n\n<!--more-->\n\n# 摘要\n\n安全计算使相互不信任的各方能够在其私有输入上联合计算函数，而不会泄露函数的输出以外的任何信息。半诚实模型中的通用安全计算协议已经被广泛研究，并形成了几个最佳实践。在这项工作中，我们设计并实现了一个混合协议框架，称为Aby，它有效地结合了基于算术共享、布尔共享和姚的乱码电路的安全计算方案，并为安全两方计算提供了最佳实践方案。我们的框架允许预计算几乎所有的密码运算，并基于预计算的不经意传输扩展在安全计算方案之间提供新颖、高效的转换。ABY支持多种标准操作，我们在本地网络和公共洲际云上执行基准测试。从我们的基准测试中，我们对安全计算协议的高效设计有了新的见解，最突出的是，基于不经意传输的乘法比基于同态加密的乘法要高效得多。我们使用ABY为三个示例应用(私有集合交集、生物特征匹配和模幂运算)构建混合协议，并表明它们比使用单一协议更有效。\n\n**关键词**：安全的两方计算；混合协议；高效的协议设计\n\n\n\n\n\n# 共享类型\n\n在本节中，详细介绍作者的Aby框架使用的共享类型：算术共享(§III-A)、布尔共享(§III-B)和姚共享(§III-C)。对于每种共享类型，本文将在各自的小节中描述共享的语义、标准操作和最新技术。\n\n## 算术共享\n\n对于算术共享，在环 $\\mathbb{Z}_{2^l}$(整数模 $2^l$)中相加地共享 $l$ 位值 $x$ 作为两个值的和。以下描述的协议基于[2]、[44]、[67]。首先，作者定义了共享语义(§III-A1)和操作(§III-A2)，并概述了基于算术共享的安全计算的相关工作(§III-A3)。然后，作者详细介绍了如何使用同态加密(§III-A4)或OT(§III-A5)生成算术乘法三元组；作者在§V-C后面的部分对这两种方法的性能进行了实验比较。在下面，作者假设要在环Z2‘中执行的所有算术运算，即所有运算都是($\\bmod 2^l$)。\n\n\n\n### 共享语义\n\n算术共享基于在各方之间附加共享私有值，如下所示：\n\n* **被共享的值。**对于一个 $l$ 位的 $x$ 的算术共享 $\\langle x \\rangle ^ A$，有 $\\langle x \\rangle ^A_0 + \\langle x \\rangle ^A_1 \\equiv x (\\bmod 2^l)$，其中 $\\langle x \\rangle ^ A_0, \\langle x \\rangle ^A_1 \\in \\mathbb{Z}_{2^l}$。\n* **共享。**$\\mathsf{Shr}^A_i(x)$：$P_i$ 选择 $r \\in_R \\mathbb{Z}_{2^l}$，设 $\\langle x \\rangle^A_i = x - r$，然后发送 $r$ 给 $P_{1-i}$，后者设 $\\langle x \\rangle^A_{1-i} = r$。\n* **重构。**$\\mathsf{Rec}^A_i(x)$：$P_{1-i}$ 发送它的份额 $\\langle x \\rangle^A_{1-i}$ 给 $P_i$，后者计算 $x = \\langle x \\rangle ^A_0 + \\langle x \\rangle ^A_1$。\n\n\n\n### 操作\n\n每个算术电路都是一系列加法和乘法门，评估如下：\n\n* **加法。**$\\langle z \\rangle ^ A = \\langle x \\rangle ^ A + \\langle y \\rangle ^ A$：$P_i$ 在本地计算 $\\langle z \\rangle ^ A_i = \\langle x \\rangle ^ A_i + \\langle y \\rangle ^ A_i$。\n* **乘法。**$\\langle z \\rangle ^ A = \\langle x \\rangle ^ A \\cdot \\langle y \\rangle ^ A$：乘法使用形式为 $\\langle c \\rangle ^ A = \\langle a \\rangle ^ A \\cdot \\langle b \\rangle ^ A$ 的预计算算术乘法三元组[4]：$P_i$ 设 $\\langle e \\rangle ^A_i = \\langle x \\rangle ^A_i - \\langle a \\rangle ^A_i$ 和 $\\langle f \\rangle ^A_i = \\langle y \\rangle ^A_i - \\langle b \\rangle ^A_i$，双方执行 $\\mathsf{Rec}^A(e)$ 和 $$\\mathsf{Rec}^A(f)$$，然后 $P_i$ 设 $\\langle z \\rangle ^ A_i = i \\cdot e \\cdot f + f \\cdot \\langle a \\rangle ^ A_i + e \\cdot \\langle b \\rangle ^ A_i + \\langle c \\rangle ^ A_i$。本文给出了预计算算术乘法的协议。\n\n\n\n### 利用加性同态加密生成算术乘法三元组\n\n通常，$\\langle a \\rangle ^ A \\cdot \\langle b \\rangle ^ A = \\langle c \\rangle ^ A$ 形式的算术乘法三元组在设置阶段使用如协议1所示的加法同态加密方案来生成。该用于生成乘法三元组的协议在[2，附录A]中被提到为“众所周知的民间传说”。对于同态加密，我们使用Paillier[25]、[26]、[62]的密码系统，或者使用Damgard-Geisler-Krøigaard(DGK)[22]、[23]的密码系统，并使用如[10]、[32]、[52]中描述的Pohlig-Hellman算法[65]进行完全解密。在Paillier加密中，明文空间为 $Z_N$，使用参数为 $r$ 的统计盲化；在DGK加密中，将明文空间设置为 $\\mathbb{Z}_{2^{2l+1}}$，使用参数为 $r$ 的完全盲化。关于安全性和正确性的证明，请参阅[67]和[66]。\n\n**复杂度。**为了生成 $l$ 位乘法三元组，$P_0$ 和 $P_1$ 交换 $3$ 个密文，对于Paillier每个密文长度为 $2\\varphi$ 比特(而DGK为 $\\varphi$ 比特)，导致总共6个 $\\varphi$ 比特的通信(对应的3个 $\\varphi$ 比特)。对于Paillier加密，我们还使用了[67]中描述的打包优化，该优化将从 $P_1$ 到 $P_0$ 的多个消息打包成单个密文，从而减少解密次数，并将每个乘法三倍的通信量减少到 $4 \\varphi + 2 \\varphi / \\lfloor \\varphi / (2l+1+ \\sigma) \\rfloor$ 比特。\n\n![](http://images.yingwai.top/picgo/aby2p1.png)\n\n\n\n### 通过不经意传输生成算术乘法三元组\n\n可以基于OT扩展生成算术乘法三元组，而不是使用同态加密。该议定书是在[33，Sect. 4.1]中提出的，并在[15]中使用。它允许使用OT有效地计算两个秘密共享值的乘积。在下面，本文将描述使用更有效的相关OT扩展的协议的一个微小变体。总体而言，可以在 $l$ 位串上使用 $2l$ 个相关的OT，即 C-OT$^{2l}_l$ (或者甚至在更短的串上，如下所述)来生成 $l$ 位乘法三元组。\n\n\n\n## 布尔共享\n\n布尔共享使用基于异或的秘密共享方案。为了简化表示，假定使用单个比特值；对于 $l$ 比特的值，每个操作都并行执行多次。\n\n\n\n### 共享语义\n\n* **被共享的值。**如果有 $\\langle x \\rangle ^B_0 \\oplus \\langle x \\rangle ^B_1 = x$，其中 $\\langle x \\rangle ^B_0, \\langle x \\rangle ^B_1 \\in \\mathbb{Z}_2$，那么就说比特 $x$ 的布尔共享 $\\langle x \\rangle ^B$ 是在两方之间共享的。\n* **共享。**$\\mathsf{Shr}_i^B(x)$：$P_i$ 选择 $r \\in_R \\{0,1\\}$，计算 $\\langle x \\rangle ^B_i = x \\oplus r$，然后发送 $r$ 给 $P_{1-i}$，后者设 $\\langle x \\rangle ^B_{1-i} = r$。\n* **重构。**$\\mathsf{Rec}_i^B(x)$：$P_{1-i}$ 发送它的份额 $\\langle x \\rangle ^B_{1-i}$ 给 $P_i$，后者计算 $x = \\langle x \\rangle ^B_0 \\oplus \\langle x \\rangle ^B_1$。\n\n\n\n### 操作\n\n每个有效计算的函数都可以表示为一个由异或门和与门组成的布尔电路，本文将在下面详细说明对它的求值。\n\n* **异或。**$\\langle z \\rangle ^B = \\langle x \\rangle ^B \\oplus \\langle y \\rangle ^B$：$P_i$ 本地计算 $\\langle z \\rangle ^B_i = \\langle x \\rangle ^B_i \\oplus \\langle y \\rangle ^B_i$。\n* **与。**$\\langle z \\rangle ^B = \\langle x \\rangle ^B \\wedge \\langle y \\rangle ^B$：与使用预计算布尔乘法三元组 $\\langle c \\rangle ^B = \\langle a \\rangle ^B \\wedge \\langle b \\rangle ^B$ 进行评估，如下所示：$P_i$ 计算 $\\langle e \\rangle ^B_i = \\langle a \\rangle ^B_i \\oplus \\langle x \\rangle ^B_i$ 和 $\\langle f \\rangle ^B_i = \\langle b \\rangle ^B_i \\oplus \\langle y \\rangle ^B_i$，双方执行 $\\mathsf{Rec}^B(e)$ 和 $\\mathsf{Rec}^B(f)$，然后 $P_i$ 设 $\\langle z \\rangle ^B_i = i \\cdot e \\cdot f \\oplus f \\cdot \\langle a \\rangle ^B_i \\oplus e \\cdot \\langle b \\rangle ^B_i \\oplus \\langle c \\rangle ^B_i$。如文献[1]所述，使用 R-OT$^2_1$ 可以有效地预计算布尔乘法三元组。\n* **多路复用。**对于多路复用器操作，本文使用[54]中提出的协议，该协议只需要 R-OT$^2_l$，而评估具有 $l$ 个与门的多路复用电路需要 R-OT$^{2l}_1$(参见[64]中的向量乘法三元组)。\n* **其它。**对于标准功能，本文使用[69]中总结的深度优化电路结构。\n\n\n\n## 姚氏共享\n\n在Yao用于安全两方计算的乱码电路协议[74]中，一方(称为Garbler)将布尔函数加密为乱码电路，由另一方(称为赋值器)进行评估。更详细地，加布勒将要计算的函数表示为布尔电路，并将满足 $k_0^w, k_1^w \\in \\{0,1\\}^{\\kappa}$ 的两个线密钥 $(k_0^w, k_1^w)$ 分配给每条线 $w$。然后，Garbler使用加密函数 $\\mathsf{Gb}$ 对两个输入线密钥的所有可能组合上的每个门的输出线密钥进行加密(详情见§III-C2中的共享)。然后，他将损坏的电路(由所有损坏的门组成)连同电路的相应输入键一起发送给评估器(参见§III-C1的共享)。评估者使用门的输入线路密钥迭代地解密每个乱码的门，以获得输出线路密钥(参见§III-C2中的与)，并最终重构电路的明文输出(参见§III-C1中的重构)。\n\n在下面，我们假设 $P_0$ 充当Garbler，$P_1$ 充当评估者，并详细说明Yao共享，假设使用free-XOR[47]和点置换[53]优化的乱码方案。使用这些技术，Garbler随机选择 $R[0]=1$ 的全局 $\\kappa$ 位串 $R$。对于每根导线 $w$，线密钥分别为 $k^w_0 \\in_R \\{0,1\\}^{\\kappa}$ 和 $k^w_1 = k^w_0 \\oplus R$。最低有效位 $k^w_0[0]$、$k^w_1[0]=1 − k^w_0[0]$ 称为置换位。作者指出，YAO共享也可以与其他改进方案一起实例化。\n\n\n\n### 共享语义\n\n直观地，对于每根导线 $w$，$P_0$ 持有两个键 $k_0^w$ 和 $k_1^w$，以及 $P_1$ 持有这些键中的一个，而不知道它对应于两个明文值中的哪一个。为了简化表示，我们假定使用单个比特值；对于 $l$ 比特的值，每个操作都并行执行多次。\n\n* **被共享的值。**值 $x$ 的乱码电路共享 $\\langle x \\rangle ^Y$ 被共享为 $\\langle x \\rangle ^Y_0 = k_0$ 和 $\\langle x \\rangle ^Y_1 = k_x = k_0 \\oplus xR$。\n* **共享。**$\\mathsf{Shr}^Y_0(x)$：$P_0$ 取随机值 $\\langle x \\rangle ^Y_0 = k_0 \\in_R \\{0,1\\}^{\\kappa}$ 然后发送 $k_x = k_0 \\oplus xR$ 给 $P_1$。\n* **重构。**$\\mathsf{Rec}^Y_i (x)$：$P_{1-i}$ 发送它的置换位 $\\pi = \\langle x \\rangle ^Y_{1-i}[0]$ 给 $P_i$，后者计算 $x = \\pi \\oplus \\langle x \\rangle ^Y_i[0]$。\n\n\n\n### 操作\n\n使用姚氏共享，由XOR和AND门组成的布尔电路评估如下：\n\n* **异或。**$\\langle z \\rangle ^Y = \\langle x \\rangle ^Y \\oplus \\langle y \\rangle ^Y$ 使用 free-XOR 技术[47]进行评估：$P_i$ 本地计算 $\\langle z \\rangle ^Y_i = \\langle x \\rangle ^Y_i \\oplus \\langle y \\rangle ^Y_i$。\n* **与。**$\\langle z \\rangle ^Y = \\langle x \\rangle ^Y \\wedge \\langle y \\rangle ^Y$ 评估如下：$P_0$ 使用 $\\mathsf{Gb}_{\\langle z \\rangle ^Y_0}(\\langle x \\rangle ^Y_0, \\langle y \\rangle ^Y_0)$ 生成乱码表，其中 $\\mathsf{Gb}$ 是[7]中定义的乱码函数。$P_0$ 发送该表给 $P_1$，后者使用它的密钥 $\\langle x \\rangle ^Y_1$ 和 $\\langle y \\rangle ^Y_1$ 进行解密。\n* **其它。**对于标准功能，本文使用[45]中总结的尺寸优化的电路结构。\n\n\n\n# 共享转换\n\n在本节中，将详细介绍在不同共享之间进行转换的方法。首先解释已经存在的或直接的转换：Y2B(§IV-A)、B2Y(§IV-B)、A2Y(§IV-C)和A2B(§IV-D)。然后，我们详细说明了B2A(§IV-E)和Y 2A(§IV-F)的改进结构。作者将共享、重构和转换操作的复杂性总结在表1。\n\n![](http://images.yingwai.top/picgo/aby2t1.png)\n\n<center>\n    <i>表1 用于l比特的值的共享、重构和转换操作的在线阶段的总计算(对称密码操作数)、通信和消息数。κ是对称安全参数。</i>\n</center>\n\n\n\n\n## 姚氏到布尔共享(Y2B)\n\n将姚共享 $\\langle x \\rangle ^Y$ 转换为布尔共享 $\\langle x \\rangle ^B$ 是最简单的转换，基本上是免费的。关键的发现是 $\\langle x \\rangle ^Y_0$ 和 $\\langle x \\rangle ^Y_1$ 的排列位已经形成了 $x$ 的有效布尔共享。因此，$P_i$ 在本地设置 $\\langle x \\rangle ^B_i = Y2B(\\langle x \\rangle ^Y_i) = \\langle x \\rangle ^Y_i[0]$。\n\n\n\n## 布尔到姚氏共享(B2Y)\n\n将布尔共享 $\\langle x \\rangle ^B$ 转换为姚共享 $\\langle x \\rangle ^Y$ 非常类似于 $\\mathsf{Shr}^Y_1$ 操作(参见§III-C1)：在下文中，我们假设 $x$ 是1比特；对于 $l$ 比特的值，每个运算都并行完成 $l$ 次。设 $x_0 = \\langle x \\rangle ^B_0$ 和 $x_1 = \\langle x \\rangle ^B_1$。$P_0$ 选取 $\\langle x \\rangle ^Y_0 = k_0 \\in_R \\{0,1\\}^{\\kappa}$。双方执行 OT$^1_{\\kappa}$，其中 $P_0$ 作为具有输入的发送方 $(k_0 \\oplus x_0 \\cdot R;k_0 \\oplus (1−x_0) \\cdot R)$，而 $P_1$ 作为具有选择位 $x_1$ 的接收方，并且不经意地获得 $\\langle x \\rangle ^Y_1 = k_0 \\oplus (x_0 \\oplus x_1) \\cdot R = k_x$。\n\n\n\n## 算术到姚氏共享(A2Y)\n\n算术共享 $\\langle x \\rangle ^A$ 到Yao共享 $\\langle x \\rangle ^Y$ 的转换在[35]、[44]、[46]中概述，并且可以通过安全地评估加法电路来完成。更准确地说，各方秘密地将他们的算术份额 $x_0 = \\langle x \\rangle ^A_0$ 和 $x_1 = \\langle x \\rangle ^A_1$ 共享为 $\\langle x_0 \\rangle ^Y = \\mathsf{Shr}^Y_0(x_0)$ 和 $\\langle x_1 \\rangle ^Y = \\mathsf{Shr}^Y_1(x_1)$，并计算 $\\langle x \\rangle ^Y = \\langle x_0 \\rangle ^Y + \\langle x_1 \\rangle ^Y$。\n\n\n\n## 算术到布尔共享(A2B)\n\n可以使用布尔加法电路(类似于§IV-C中描述的A2Y转换)或通过使用算术位提取电路[17]、[18]、[21]、[70]来完成将算术共享 $\\langle x \\rangle ^A$ 转换为布尔共享 $\\langle x \\rangle ^B$。如在[69]中总结的，布尔加法电路可以被实例化为大小优化的随 $O(l)$ 大小和深度变化的变量，或者实例化为随 $O(l\\log_2l)$ 大小和 $O(\\log_2l)$ 深度变化的深度优化的变量。在本文的框架中，$Y2B$ 转换是免费的，我们简单地计算 $\\langle x \\rangle ^B = A2B(\\langle x \\rangle ^A) = Y2B(A2Y(\\langle x \\rangle ^A))$，因为我们在§V-D中的评估表明，Yao共享中的加法比布尔共享中的加法更有效。\n\n\n\n## 布尔到算术共享(B2A)\n\n将 $l$ 比特布尔共享 $\\langle x \\rangle ^B$ 转换为算术共享 $\\langle x \\rangle ^A$ 的简单解决方案是评估布尔减法电路，其中 $P_0$ 输入 $\\langle x \\rangle ^B_0$ 和随机数 $r \\in_R \\{0,1\\}^l$，并且设置 $\\langle x \\rangle ^A_0 = r$，然后 $P_1$ 输入 $\\langle x \\rangle ^B_1$ 并获得 $\\langle x \\rangle ^A_1 = x - r$。然而，评估这样的布尔减法电路将具有 $O(l)$ 大小和深度或者 $O(l \\log_2 l)$ 大小和 $O(\\log_2 l)$ 深度[69]。\n\n为了提高转换的性能，可以使用与§III-A5中描述的算术乘法三次生成类似的技术。一般的想法是对每个比特执行OT，其中我们不经意地转移了两个值，这两个值被2的幂相加相关。接收方可以获得这些值中的一个，并且通过将它们相加，各方获得有效的算术份额。\n\n更详细地说，在OT协议中，$P_0$ 充当发送者，$P_1$ 充当接收者。在第 $i$ 个OT中，$P_0$ 随机选择 $r_i \\in_R \\{0, 1\\}^l$ 以及输入 $(s_{i,0}, s_{i_1})$，其中 $s_{i,0} = (1 - \\langle x \\rangle^B_0[i]) \\cdot 2^i - r_i$ 以及 $s_{i,1} = \\langle x \\rangle^B_0[i] \\cdot 2^i - r_i$，而 $P_1$ 输入 $\\langle x \\rangle^B_1[i]$ 作为选择位，收到输出 $s_{\\langle x \\rangle ^B_1[i]} = (\\langle x \\rangle^B_0[i] \\oplus \\langle x \\rangle^B_1[i]) \\cdot 2^i - r_i$。最后，$P_0$ 计算 $\\langle x \\rangle^A_0 = \\sum^l_{i=1}r_i$，$P_1$ 计算 $\\langle x \\rangle^A_1$ $=\\sum^l_{i=1}s_{\\langle x \\rangle^B_1[i]}$ $=\\sum^l_{i=1}(\\langle x \\rangle^B_0[i] \\oplus \\langle x \\rangle^B_1[i]) \\cdot$ $2^i-\\sum^l_{i=1}r_i$ $=\\sum^l_{i=1}x[i] \\cdot 2^i -$ $\\sum^l_{i=1}r_i$ $=x - \\langle x \\rangle^A_0$。安全性和正确性类似于§III-A5的协议。\n\n**复杂度。**观察到，由于我们传输一个随机元素和另一个作为相关性，并且只需要第 $i$ 个OT中的 $l-i$ 个最低有效位，所以我们可以使用C-OT和§III-A5中概述的相同技巧，导致(平均)C-OT$^l_{(l+1)/2}$ 和恒定轮数。相比之下，当使用布尔共享评估减法电路时，对于深度为 $O(\\log_2l)$ 的电路各方将需要评估 $O(l \\log_2 l)$次R-OT或对于深度为 $l$ 的电路评估 $2l$ 次ROT。本文的转换方法也比转换成姚共享(这已经需要 $2l$ OT)并在乱码电路中进行减法运算。\n\n\n\n## 姚氏到算术共享(Y2A)\n\n在[35]，[44]，[46]中描述了从姚共享 $\\langle x \\rangle ^Y$ 到算术共享 $\\langle x \\rangle ^A$ 的转换：$P_0$ 随机选择 $r \\in_R \\mathbb{Z}_{2^l}$，执行 $\\mathsf{Shr}^Y_0$，然后双方评估布尔减法电路 $\\langle d \\rangle ^Y = \\langle x \\rangle ^Y - \\langle r \\rangle ^Y$，以获得它们的算术份额为 $\\langle x \\rangle ^A_0 = r$ 和 $\\langle x \\rangle ^A_1 = \\mathsf{Rec}^Y_1(\\langle d \\rangle ^Y)$。\n\n然而，由于我们免费执行 $Y2B$，而 $B2A$ 在计算和通信方面更便宜，我们建议计算 $\\langle x \\rangle ^A = Y2A(\\langle x \\rangle ^Y) = B2A(Y2B(\\langle x \\rangle ^Y))$。","slug":"论文笔记-ABY-A-Framework-for-Efficient-Mixed-Protocol-Secure-Two-Party-Computation","published":1,"updated":"2020-08-23T14:33:37.433Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cke79q4ph001a88ps5wkjblu9","content":"<p><em>Daniel Demmler, Thomas Schneider, Michael Zohner</em></p>\n<p><a href=\"https://dblp.uni-trier.de/db/conf/ndss/ndss2015.html#Demmler0Z15\" target=\"_blank\" rel=\"noopener\">NDSS 2015</a></p>\n<p><a href=\"https://www.ndss-symposium.org/ndss2015/ndss-2015-programme/aby-framework-efficient-mixed-protocol-secure-two-party-computation/\" target=\"_blank\" rel=\"noopener\">https://www.ndss-symposium.org/ndss2015/ndss-2015-programme/aby-framework-efficient-mixed-protocol-secure-two-party-computation/</a></p>\n<a id=\"more\"></a>\n<h1 id=\"摘要\"><a href=\"#摘要\" class=\"headerlink\" title=\"摘要\"></a>摘要</h1><p>安全计算使相互不信任的各方能够在其私有输入上联合计算函数，而不会泄露函数的输出以外的任何信息。半诚实模型中的通用安全计算协议已经被广泛研究，并形成了几个最佳实践。在这项工作中，我们设计并实现了一个混合协议框架，称为Aby，它有效地结合了基于算术共享、布尔共享和姚的乱码电路的安全计算方案，并为安全两方计算提供了最佳实践方案。我们的框架允许预计算几乎所有的密码运算，并基于预计算的不经意传输扩展在安全计算方案之间提供新颖、高效的转换。ABY支持多种标准操作，我们在本地网络和公共洲际云上执行基准测试。从我们的基准测试中，我们对安全计算协议的高效设计有了新的见解，最突出的是，基于不经意传输的乘法比基于同态加密的乘法要高效得多。我们使用ABY为三个示例应用(私有集合交集、生物特征匹配和模幂运算)构建混合协议，并表明它们比使用单一协议更有效。</p>\n<p><strong>关键词</strong>：安全的两方计算；混合协议；高效的协议设计</p>\n<h1 id=\"共享类型\"><a href=\"#共享类型\" class=\"headerlink\" title=\"共享类型\"></a>共享类型</h1><p>在本节中，详细介绍作者的Aby框架使用的共享类型：算术共享(§III-A)、布尔共享(§III-B)和姚共享(§III-C)。对于每种共享类型，本文将在各自的小节中描述共享的语义、标准操作和最新技术。</p>\n<h2 id=\"算术共享\"><a href=\"#算术共享\" class=\"headerlink\" title=\"算术共享\"></a>算术共享</h2><p>对于算术共享，在环 $\\mathbb{Z}_{2^l}$(整数模 $2^l$)中相加地共享 $l$ 位值 $x$ 作为两个值的和。以下描述的协议基于[2]、[44]、[67]。首先，作者定义了共享语义(§III-A1)和操作(§III-A2)，并概述了基于算术共享的安全计算的相关工作(§III-A3)。然后，作者详细介绍了如何使用同态加密(§III-A4)或OT(§III-A5)生成算术乘法三元组；作者在§V-C后面的部分对这两种方法的性能进行了实验比较。在下面，作者假设要在环Z2‘中执行的所有算术运算，即所有运算都是($\\bmod 2^l$)。</p>\n<h3 id=\"共享语义\"><a href=\"#共享语义\" class=\"headerlink\" title=\"共享语义\"></a>共享语义</h3><p>算术共享基于在各方之间附加共享私有值，如下所示：</p>\n<ul>\n<li><strong>被共享的值。</strong>对于一个 $l$ 位的 $x$ 的算术共享 $\\langle x \\rangle ^ A$，有 $\\langle x \\rangle ^A<em>0 + \\langle x \\rangle ^A_1 \\equiv x (\\bmod 2^l)$，其中 $\\langle x \\rangle ^ A_0, \\langle x \\rangle ^A_1 \\in \\mathbb{Z}</em>{2^l}$。</li>\n<li><strong>共享。</strong>$\\mathsf{Shr}^A<em>i(x)$：$P_i$ 选择 $r \\in_R \\mathbb{Z}</em>{2^l}$，设 $\\langle x \\rangle^A<em>i = x - r$，然后发送 $r$ 给 $P</em>{1-i}$，后者设 $\\langle x \\rangle^A_{1-i} = r$。</li>\n<li><strong>重构。</strong>$\\mathsf{Rec}^A<em>i(x)$：$P</em>{1-i}$ 发送它的份额 $\\langle x \\rangle^A_{1-i}$ 给 $P_i$，后者计算 $x = \\langle x \\rangle ^A_0 + \\langle x \\rangle ^A_1$。</li>\n</ul>\n<h3 id=\"操作\"><a href=\"#操作\" class=\"headerlink\" title=\"操作\"></a>操作</h3><p>每个算术电路都是一系列加法和乘法门，评估如下：</p>\n<ul>\n<li><strong>加法。</strong>$\\langle z \\rangle ^ A = \\langle x \\rangle ^ A + \\langle y \\rangle ^ A$：$P_i$ 在本地计算 $\\langle z \\rangle ^ A_i = \\langle x \\rangle ^ A_i + \\langle y \\rangle ^ A_i$。</li>\n<li><strong>乘法。</strong>$\\langle z \\rangle ^ A = \\langle x \\rangle ^ A \\cdot \\langle y \\rangle ^ A$：乘法使用形式为 $\\langle c \\rangle ^ A = \\langle a \\rangle ^ A \\cdot \\langle b \\rangle ^ A$ 的预计算算术乘法三元组[4]：$P_i$ 设 $\\langle e \\rangle ^A_i = \\langle x \\rangle ^A_i - \\langle a \\rangle ^A_i$ 和 $\\langle f \\rangle ^A_i = \\langle y \\rangle ^A_i - \\langle b \\rangle ^A_i$，双方执行 $\\mathsf{Rec}^A(e)$ 和 <script type=\"math/tex\">\\mathsf{Rec}^A(f)</script>，然后 $P_i$ 设 $\\langle z \\rangle ^ A_i = i \\cdot e \\cdot f + f \\cdot \\langle a \\rangle ^ A_i + e \\cdot \\langle b \\rangle ^ A_i + \\langle c \\rangle ^ A_i$。本文给出了预计算算术乘法的协议。</li>\n</ul>\n<h3 id=\"利用加性同态加密生成算术乘法三元组\"><a href=\"#利用加性同态加密生成算术乘法三元组\" class=\"headerlink\" title=\"利用加性同态加密生成算术乘法三元组\"></a>利用加性同态加密生成算术乘法三元组</h3><p>通常，$\\langle a \\rangle ^ A \\cdot \\langle b \\rangle ^ A = \\langle c \\rangle ^ A$ 形式的算术乘法三元组在设置阶段使用如协议1所示的加法同态加密方案来生成。该用于生成乘法三元组的协议在[2，附录A]中被提到为“众所周知的民间传说”。对于同态加密，我们使用Paillier[25]、[26]、[62]的密码系统，或者使用Damgard-Geisler-Krøigaard(DGK)[22]、[23]的密码系统，并使用如[10]、[32]、[52]中描述的Pohlig-Hellman算法[65]进行完全解密。在Paillier加密中，明文空间为 $Z<em>N$，使用参数为 $r$ 的统计盲化；在DGK加密中，将明文空间设置为 $\\mathbb{Z}</em>{2^{2l+1}}$，使用参数为 $r$ 的完全盲化。关于安全性和正确性的证明，请参阅[67]和[66]。</p>\n<p><strong>复杂度。</strong>为了生成 $l$ 位乘法三元组，$P_0$ 和 $P_1$ 交换 $3$ 个密文，对于Paillier每个密文长度为 $2\\varphi$ 比特(而DGK为 $\\varphi$ 比特)，导致总共6个 $\\varphi$ 比特的通信(对应的3个 $\\varphi$ 比特)。对于Paillier加密，我们还使用了[67]中描述的打包优化，该优化将从 $P_1$ 到 $P_0$ 的多个消息打包成单个密文，从而减少解密次数，并将每个乘法三倍的通信量减少到 $4 \\varphi + 2 \\varphi / \\lfloor \\varphi / (2l+1+ \\sigma) \\rfloor$ 比特。</p>\n<p><img src=\"http://images.yingwai.top/picgo/aby2p1.png\" alt=\"\"></p>\n<h3 id=\"通过不经意传输生成算术乘法三元组\"><a href=\"#通过不经意传输生成算术乘法三元组\" class=\"headerlink\" title=\"通过不经意传输生成算术乘法三元组\"></a>通过不经意传输生成算术乘法三元组</h3><p>可以基于OT扩展生成算术乘法三元组，而不是使用同态加密。该议定书是在[33，Sect. 4.1]中提出的，并在[15]中使用。它允许使用OT有效地计算两个秘密共享值的乘积。在下面，本文将描述使用更有效的相关OT扩展的协议的一个微小变体。总体而言，可以在 $l$ 位串上使用 $2l$ 个相关的OT，即 C-OT$^{2l}_l$ (或者甚至在更短的串上，如下所述)来生成 $l$ 位乘法三元组。</p>\n<h2 id=\"布尔共享\"><a href=\"#布尔共享\" class=\"headerlink\" title=\"布尔共享\"></a>布尔共享</h2><p>布尔共享使用基于异或的秘密共享方案。为了简化表示，假定使用单个比特值；对于 $l$ 比特的值，每个操作都并行执行多次。</p>\n<h3 id=\"共享语义-1\"><a href=\"#共享语义-1\" class=\"headerlink\" title=\"共享语义\"></a>共享语义</h3><ul>\n<li><strong>被共享的值。</strong>如果有 $\\langle x \\rangle ^B_0 \\oplus \\langle x \\rangle ^B_1 = x$，其中 $\\langle x \\rangle ^B_0, \\langle x \\rangle ^B_1 \\in \\mathbb{Z}_2$，那么就说比特 $x$ 的布尔共享 $\\langle x \\rangle ^B$ 是在两方之间共享的。</li>\n<li><strong>共享。</strong>$\\mathsf{Shr}<em>i^B(x)$：$P_i$ 选择 $r \\in_R {0,1}$，计算 $\\langle x \\rangle ^B_i = x \\oplus r$，然后发送 $r$ 给 $P</em>{1-i}$，后者设 $\\langle x \\rangle ^B_{1-i} = r$。</li>\n<li><strong>重构。</strong>$\\mathsf{Rec}<em>i^B(x)$：$P</em>{1-i}$ 发送它的份额 $\\langle x \\rangle ^B_{1-i}$ 给 $P_i$，后者计算 $x = \\langle x \\rangle ^B_0 \\oplus \\langle x \\rangle ^B_1$。</li>\n</ul>\n<h3 id=\"操作-1\"><a href=\"#操作-1\" class=\"headerlink\" title=\"操作\"></a>操作</h3><p>每个有效计算的函数都可以表示为一个由异或门和与门组成的布尔电路，本文将在下面详细说明对它的求值。</p>\n<ul>\n<li><strong>异或。</strong>$\\langle z \\rangle ^B = \\langle x \\rangle ^B \\oplus \\langle y \\rangle ^B$：$P_i$ 本地计算 $\\langle z \\rangle ^B_i = \\langle x \\rangle ^B_i \\oplus \\langle y \\rangle ^B_i$。</li>\n<li><strong>与。</strong>$\\langle z \\rangle ^B = \\langle x \\rangle ^B \\wedge \\langle y \\rangle ^B$：与使用预计算布尔乘法三元组 $\\langle c \\rangle ^B = \\langle a \\rangle ^B \\wedge \\langle b \\rangle ^B$ 进行评估，如下所示：$P_i$ 计算 $\\langle e \\rangle ^B_i = \\langle a \\rangle ^B_i \\oplus \\langle x \\rangle ^B_i$ 和 $\\langle f \\rangle ^B_i = \\langle b \\rangle ^B_i \\oplus \\langle y \\rangle ^B_i$，双方执行 $\\mathsf{Rec}^B(e)$ 和 $\\mathsf{Rec}^B(f)$，然后 $P_i$ 设 $\\langle z \\rangle ^B_i = i \\cdot e \\cdot f \\oplus f \\cdot \\langle a \\rangle ^B_i \\oplus e \\cdot \\langle b \\rangle ^B_i \\oplus \\langle c \\rangle ^B_i$。如文献[1]所述，使用 R-OT$^2_1$ 可以有效地预计算布尔乘法三元组。</li>\n<li><strong>多路复用。</strong>对于多路复用器操作，本文使用[54]中提出的协议，该协议只需要 R-OT$^2_l$，而评估具有 $l$ 个与门的多路复用电路需要 R-OT$^{2l}_1$(参见[64]中的向量乘法三元组)。</li>\n<li><strong>其它。</strong>对于标准功能，本文使用[69]中总结的深度优化电路结构。</li>\n</ul>\n<h2 id=\"姚氏共享\"><a href=\"#姚氏共享\" class=\"headerlink\" title=\"姚氏共享\"></a>姚氏共享</h2><p>在Yao用于安全两方计算的乱码电路协议[74]中，一方(称为Garbler)将布尔函数加密为乱码电路，由另一方(称为赋值器)进行评估。更详细地，加布勒将要计算的函数表示为布尔电路，并将满足 $k_0^w, k_1^w \\in {0,1}^{\\kappa}$ 的两个线密钥 $(k_0^w, k_1^w)$ 分配给每条线 $w$。然后，Garbler使用加密函数 $\\mathsf{Gb}$ 对两个输入线密钥的所有可能组合上的每个门的输出线密钥进行加密(详情见§III-C2中的共享)。然后，他将损坏的电路(由所有损坏的门组成)连同电路的相应输入键一起发送给评估器(参见§III-C1的共享)。评估者使用门的输入线路密钥迭代地解密每个乱码的门，以获得输出线路密钥(参见§III-C2中的与)，并最终重构电路的明文输出(参见§III-C1中的重构)。</p>\n<p>在下面，我们假设 $P_0$ 充当Garbler，$P_1$ 充当评估者，并详细说明Yao共享，假设使用free-XOR[47]和点置换[53]优化的乱码方案。使用这些技术，Garbler随机选择 $R[0]=1$ 的全局 $\\kappa$ 位串 $R$。对于每根导线 $w$，线密钥分别为 $k^w_0 \\in_R {0,1}^{\\kappa}$ 和 $k^w_1 = k^w_0 \\oplus R$。最低有效位 $k^w_0[0]$、$k^w_1[0]=1 − k^w_0[0]$ 称为置换位。作者指出，YAO共享也可以与其他改进方案一起实例化。</p>\n<h3 id=\"共享语义-2\"><a href=\"#共享语义-2\" class=\"headerlink\" title=\"共享语义\"></a>共享语义</h3><p>直观地，对于每根导线 $w$，$P_0$ 持有两个键 $k_0^w$ 和 $k_1^w$，以及 $P_1$ 持有这些键中的一个，而不知道它对应于两个明文值中的哪一个。为了简化表示，我们假定使用单个比特值；对于 $l$ 比特的值，每个操作都并行执行多次。</p>\n<ul>\n<li><strong>被共享的值。</strong>值 $x$ 的乱码电路共享 $\\langle x \\rangle ^Y$ 被共享为 $\\langle x \\rangle ^Y_0 = k_0$ 和 $\\langle x \\rangle ^Y_1 = k_x = k_0 \\oplus xR$。</li>\n<li><strong>共享。</strong>$\\mathsf{Shr}^Y_0(x)$：$P_0$ 取随机值 $\\langle x \\rangle ^Y_0 = k_0 \\in_R {0,1}^{\\kappa}$ 然后发送 $k_x = k_0 \\oplus xR$ 给 $P_1$。</li>\n<li><strong>重构。</strong>$\\mathsf{Rec}^Y<em>i (x)$：$P</em>{1-i}$ 发送它的置换位 $\\pi = \\langle x \\rangle ^Y_{1-i}[0]$ 给 $P_i$，后者计算 $x = \\pi \\oplus \\langle x \\rangle ^Y_i[0]$。</li>\n</ul>\n<h3 id=\"操作-2\"><a href=\"#操作-2\" class=\"headerlink\" title=\"操作\"></a>操作</h3><p>使用姚氏共享，由XOR和AND门组成的布尔电路评估如下：</p>\n<ul>\n<li><strong>异或。</strong>$\\langle z \\rangle ^Y = \\langle x \\rangle ^Y \\oplus \\langle y \\rangle ^Y$ 使用 free-XOR 技术[47]进行评估：$P_i$ 本地计算 $\\langle z \\rangle ^Y_i = \\langle x \\rangle ^Y_i \\oplus \\langle y \\rangle ^Y_i$。</li>\n<li><strong>与。</strong>$\\langle z \\rangle ^Y = \\langle x \\rangle ^Y \\wedge \\langle y \\rangle ^Y$ 评估如下：$P<em>0$ 使用 $\\mathsf{Gb}</em>{\\langle z \\rangle ^Y_0}(\\langle x \\rangle ^Y_0, \\langle y \\rangle ^Y_0)$ 生成乱码表，其中 $\\mathsf{Gb}$ 是[7]中定义的乱码函数。$P_0$ 发送该表给 $P_1$，后者使用它的密钥 $\\langle x \\rangle ^Y_1$ 和 $\\langle y \\rangle ^Y_1$ 进行解密。</li>\n<li><strong>其它。</strong>对于标准功能，本文使用[45]中总结的尺寸优化的电路结构。</li>\n</ul>\n<h1 id=\"共享转换\"><a href=\"#共享转换\" class=\"headerlink\" title=\"共享转换\"></a>共享转换</h1><p>在本节中，将详细介绍在不同共享之间进行转换的方法。首先解释已经存在的或直接的转换：Y2B(§IV-A)、B2Y(§IV-B)、A2Y(§IV-C)和A2B(§IV-D)。然后，我们详细说明了B2A(§IV-E)和Y 2A(§IV-F)的改进结构。作者将共享、重构和转换操作的复杂性总结在表1。</p>\n<p><img src=\"http://images.yingwai.top/picgo/aby2t1.png\" alt=\"\"></p>\n<center>\n    <i>表1 用于l比特的值的共享、重构和转换操作的在线阶段的总计算(对称密码操作数)、通信和消息数。κ是对称安全参数。</i>\n</center>\n\n\n\n\n<h2 id=\"姚氏到布尔共享-Y2B\"><a href=\"#姚氏到布尔共享-Y2B\" class=\"headerlink\" title=\"姚氏到布尔共享(Y2B)\"></a>姚氏到布尔共享(Y2B)</h2><p>将姚共享 $\\langle x \\rangle ^Y$ 转换为布尔共享 $\\langle x \\rangle ^B$ 是最简单的转换，基本上是免费的。关键的发现是 $\\langle x \\rangle ^Y_0$ 和 $\\langle x \\rangle ^Y_1$ 的排列位已经形成了 $x$ 的有效布尔共享。因此，$P_i$ 在本地设置 $\\langle x \\rangle ^B_i = Y2B(\\langle x \\rangle ^Y_i) = \\langle x \\rangle ^Y_i[0]$。</p>\n<h2 id=\"布尔到姚氏共享-B2Y\"><a href=\"#布尔到姚氏共享-B2Y\" class=\"headerlink\" title=\"布尔到姚氏共享(B2Y)\"></a>布尔到姚氏共享(B2Y)</h2><p>将布尔共享 $\\langle x \\rangle ^B$ 转换为姚共享 $\\langle x \\rangle ^Y$ 非常类似于 $\\mathsf{Shr}^Y<em>1$ 操作(参见§III-C1)：在下文中，我们假设 $x$ 是1比特；对于 $l$ 比特的值，每个运算都并行完成 $l$ 次。设 $x_0 = \\langle x \\rangle ^B_0$ 和 $x_1 = \\langle x \\rangle ^B_1$。$P_0$ 选取 $\\langle x \\rangle ^Y_0 = k_0 \\in_R {0,1}^{\\kappa}$。双方执行 OT$^1</em>{\\kappa}$，其中 $P_0$ 作为具有输入的发送方 $(k_0 \\oplus x_0 \\cdot R;k_0 \\oplus (1−x_0) \\cdot R)$，而 $P_1$ 作为具有选择位 $x_1$ 的接收方，并且不经意地获得 $\\langle x \\rangle ^Y_1 = k_0 \\oplus (x_0 \\oplus x_1) \\cdot R = k_x$。</p>\n<h2 id=\"算术到姚氏共享-A2Y\"><a href=\"#算术到姚氏共享-A2Y\" class=\"headerlink\" title=\"算术到姚氏共享(A2Y)\"></a>算术到姚氏共享(A2Y)</h2><p>算术共享 $\\langle x \\rangle ^A$ 到Yao共享 $\\langle x \\rangle ^Y$ 的转换在[35]、[44]、[46]中概述，并且可以通过安全地评估加法电路来完成。更准确地说，各方秘密地将他们的算术份额 $x_0 = \\langle x \\rangle ^A_0$ 和 $x_1 = \\langle x \\rangle ^A_1$ 共享为 $\\langle x_0 \\rangle ^Y = \\mathsf{Shr}^Y_0(x_0)$ 和 $\\langle x_1 \\rangle ^Y = \\mathsf{Shr}^Y_1(x_1)$，并计算 $\\langle x \\rangle ^Y = \\langle x_0 \\rangle ^Y + \\langle x_1 \\rangle ^Y$。</p>\n<h2 id=\"算术到布尔共享-A2B\"><a href=\"#算术到布尔共享-A2B\" class=\"headerlink\" title=\"算术到布尔共享(A2B)\"></a>算术到布尔共享(A2B)</h2><p>可以使用布尔加法电路(类似于§IV-C中描述的A2Y转换)或通过使用算术位提取电路[17]、[18]、[21]、[70]来完成将算术共享 $\\langle x \\rangle ^A$ 转换为布尔共享 $\\langle x \\rangle ^B$。如在[69]中总结的，布尔加法电路可以被实例化为大小优化的随 $O(l)$ 大小和深度变化的变量，或者实例化为随 $O(l\\log_2l)$ 大小和 $O(\\log_2l)$ 深度变化的深度优化的变量。在本文的框架中，$Y2B$ 转换是免费的，我们简单地计算 $\\langle x \\rangle ^B = A2B(\\langle x \\rangle ^A) = Y2B(A2Y(\\langle x \\rangle ^A))$，因为我们在§V-D中的评估表明，Yao共享中的加法比布尔共享中的加法更有效。</p>\n<h2 id=\"布尔到算术共享-B2A\"><a href=\"#布尔到算术共享-B2A\" class=\"headerlink\" title=\"布尔到算术共享(B2A)\"></a>布尔到算术共享(B2A)</h2><p>将 $l$ 比特布尔共享 $\\langle x \\rangle ^B$ 转换为算术共享 $\\langle x \\rangle ^A$ 的简单解决方案是评估布尔减法电路，其中 $P_0$ 输入 $\\langle x \\rangle ^B_0$ 和随机数 $r \\in_R {0,1}^l$，并且设置 $\\langle x \\rangle ^A_0 = r$，然后 $P_1$ 输入 $\\langle x \\rangle ^B_1$ 并获得 $\\langle x \\rangle ^A_1 = x - r$。然而，评估这样的布尔减法电路将具有 $O(l)$ 大小和深度或者 $O(l \\log_2 l)$ 大小和 $O(\\log_2 l)$ 深度[69]。</p>\n<p>为了提高转换的性能，可以使用与§III-A5中描述的算术乘法三次生成类似的技术。一般的想法是对每个比特执行OT，其中我们不经意地转移了两个值，这两个值被2的幂相加相关。接收方可以获得这些值中的一个，并且通过将它们相加，各方获得有效的算术份额。</p>\n<p>更详细地说，在OT协议中，$P<em>0$ 充当发送者，$P_1$ 充当接收者。在第 $i$ 个OT中，$P_0$ 随机选择 $r_i \\in_R {0, 1}^l$ 以及输入 $(s</em>{i,0}, s<em>{i_1})$，其中 $s</em>{i,0} = (1 - \\langle x \\rangle^B<em>0[i]) \\cdot 2^i - r_i$ 以及 $s</em>{i,1} = \\langle x \\rangle^B<em>0[i] \\cdot 2^i - r_i$，而 $P_1$ 输入 $\\langle x \\rangle^B_1[i]$ 作为选择位，收到输出 $s</em>{\\langle x \\rangle ^B<em>1[i]} = (\\langle x \\rangle^B_0[i] \\oplus \\langle x \\rangle^B_1[i]) \\cdot 2^i - r_i$。最后，$P_0$ 计算 $\\langle x \\rangle^A_0 = \\sum^l</em>{i=1}r<em>i$，$P_1$ 计算 $\\langle x \\rangle^A_1$ $=\\sum^l</em>{i=1}s<em>{\\langle x \\rangle^B_1[i]}$ $=\\sum^l</em>{i=1}(\\langle x \\rangle^B<em>0[i] \\oplus \\langle x \\rangle^B_1[i]) \\cdot$ $2^i-\\sum^l</em>{i=1}r<em>i$ $=\\sum^l</em>{i=1}x[i] \\cdot 2^i -$ $\\sum^l_{i=1}r_i$ $=x - \\langle x \\rangle^A_0$。安全性和正确性类似于§III-A5的协议。</p>\n<p><strong>复杂度。</strong>观察到，由于我们传输一个随机元素和另一个作为相关性，并且只需要第 $i$ 个OT中的 $l-i$ 个最低有效位，所以我们可以使用C-OT和§III-A5中概述的相同技巧，导致(平均)C-OT$^l_{(l+1)/2}$ 和恒定轮数。相比之下，当使用布尔共享评估减法电路时，对于深度为 $O(\\log_2l)$ 的电路各方将需要评估 $O(l \\log_2 l)$次R-OT或对于深度为 $l$ 的电路评估 $2l$ 次ROT。本文的转换方法也比转换成姚共享(这已经需要 $2l$ OT)并在乱码电路中进行减法运算。</p>\n<h2 id=\"姚氏到算术共享-Y2A\"><a href=\"#姚氏到算术共享-Y2A\" class=\"headerlink\" title=\"姚氏到算术共享(Y2A)\"></a>姚氏到算术共享(Y2A)</h2><p>在[35]，[44]，[46]中描述了从姚共享 $\\langle x \\rangle ^Y$ 到算术共享 $\\langle x \\rangle ^A$ 的转换：$P<em>0$ 随机选择 $r \\in_R \\mathbb{Z}</em>{2^l}$，执行 $\\mathsf{Shr}^Y_0$，然后双方评估布尔减法电路 $\\langle d \\rangle ^Y = \\langle x \\rangle ^Y - \\langle r \\rangle ^Y$，以获得它们的算术份额为 $\\langle x \\rangle ^A_0 = r$ 和 $\\langle x \\rangle ^A_1 = \\mathsf{Rec}^Y_1(\\langle d \\rangle ^Y)$。</p>\n<p>然而，由于我们免费执行 $Y2B$，而 $B2A$ 在计算和通信方面更便宜，我们建议计算 $\\langle x \\rangle ^A = Y2A(\\langle x \\rangle ^Y) = B2A(Y2B(\\langle x \\rangle ^Y))$。</p>\n","site":{"data":{}},"excerpt":"<p><em>Daniel Demmler, Thomas Schneider, Michael Zohner</em></p>\n<p><a href=\"https://dblp.uni-trier.de/db/conf/ndss/ndss2015.html#Demmler0Z15\" target=\"_blank\" rel=\"noopener\">NDSS 2015</a></p>\n<p><a href=\"https://www.ndss-symposium.org/ndss2015/ndss-2015-programme/aby-framework-efficient-mixed-protocol-secure-two-party-computation/\" target=\"_blank\" rel=\"noopener\">https://www.ndss-symposium.org/ndss2015/ndss-2015-programme/aby-framework-efficient-mixed-protocol-secure-two-party-computation/</a></p>","more":"<h1 id=\"摘要\"><a href=\"#摘要\" class=\"headerlink\" title=\"摘要\"></a>摘要</h1><p>安全计算使相互不信任的各方能够在其私有输入上联合计算函数，而不会泄露函数的输出以外的任何信息。半诚实模型中的通用安全计算协议已经被广泛研究，并形成了几个最佳实践。在这项工作中，我们设计并实现了一个混合协议框架，称为Aby，它有效地结合了基于算术共享、布尔共享和姚的乱码电路的安全计算方案，并为安全两方计算提供了最佳实践方案。我们的框架允许预计算几乎所有的密码运算，并基于预计算的不经意传输扩展在安全计算方案之间提供新颖、高效的转换。ABY支持多种标准操作，我们在本地网络和公共洲际云上执行基准测试。从我们的基准测试中，我们对安全计算协议的高效设计有了新的见解，最突出的是，基于不经意传输的乘法比基于同态加密的乘法要高效得多。我们使用ABY为三个示例应用(私有集合交集、生物特征匹配和模幂运算)构建混合协议，并表明它们比使用单一协议更有效。</p>\n<p><strong>关键词</strong>：安全的两方计算；混合协议；高效的协议设计</p>\n<h1 id=\"共享类型\"><a href=\"#共享类型\" class=\"headerlink\" title=\"共享类型\"></a>共享类型</h1><p>在本节中，详细介绍作者的Aby框架使用的共享类型：算术共享(§III-A)、布尔共享(§III-B)和姚共享(§III-C)。对于每种共享类型，本文将在各自的小节中描述共享的语义、标准操作和最新技术。</p>\n<h2 id=\"算术共享\"><a href=\"#算术共享\" class=\"headerlink\" title=\"算术共享\"></a>算术共享</h2><p>对于算术共享，在环 $\\mathbb{Z}_{2^l}$(整数模 $2^l$)中相加地共享 $l$ 位值 $x$ 作为两个值的和。以下描述的协议基于[2]、[44]、[67]。首先，作者定义了共享语义(§III-A1)和操作(§III-A2)，并概述了基于算术共享的安全计算的相关工作(§III-A3)。然后，作者详细介绍了如何使用同态加密(§III-A4)或OT(§III-A5)生成算术乘法三元组；作者在§V-C后面的部分对这两种方法的性能进行了实验比较。在下面，作者假设要在环Z2‘中执行的所有算术运算，即所有运算都是($\\bmod 2^l$)。</p>\n<h3 id=\"共享语义\"><a href=\"#共享语义\" class=\"headerlink\" title=\"共享语义\"></a>共享语义</h3><p>算术共享基于在各方之间附加共享私有值，如下所示：</p>\n<ul>\n<li><strong>被共享的值。</strong>对于一个 $l$ 位的 $x$ 的算术共享 $\\langle x \\rangle ^ A$，有 $\\langle x \\rangle ^A<em>0 + \\langle x \\rangle ^A_1 \\equiv x (\\bmod 2^l)$，其中 $\\langle x \\rangle ^ A_0, \\langle x \\rangle ^A_1 \\in \\mathbb{Z}</em>{2^l}$。</li>\n<li><strong>共享。</strong>$\\mathsf{Shr}^A<em>i(x)$：$P_i$ 选择 $r \\in_R \\mathbb{Z}</em>{2^l}$，设 $\\langle x \\rangle^A<em>i = x - r$，然后发送 $r$ 给 $P</em>{1-i}$，后者设 $\\langle x \\rangle^A_{1-i} = r$。</li>\n<li><strong>重构。</strong>$\\mathsf{Rec}^A<em>i(x)$：$P</em>{1-i}$ 发送它的份额 $\\langle x \\rangle^A_{1-i}$ 给 $P_i$，后者计算 $x = \\langle x \\rangle ^A_0 + \\langle x \\rangle ^A_1$。</li>\n</ul>\n<h3 id=\"操作\"><a href=\"#操作\" class=\"headerlink\" title=\"操作\"></a>操作</h3><p>每个算术电路都是一系列加法和乘法门，评估如下：</p>\n<ul>\n<li><strong>加法。</strong>$\\langle z \\rangle ^ A = \\langle x \\rangle ^ A + \\langle y \\rangle ^ A$：$P_i$ 在本地计算 $\\langle z \\rangle ^ A_i = \\langle x \\rangle ^ A_i + \\langle y \\rangle ^ A_i$。</li>\n<li><strong>乘法。</strong>$\\langle z \\rangle ^ A = \\langle x \\rangle ^ A \\cdot \\langle y \\rangle ^ A$：乘法使用形式为 $\\langle c \\rangle ^ A = \\langle a \\rangle ^ A \\cdot \\langle b \\rangle ^ A$ 的预计算算术乘法三元组[4]：$P_i$ 设 $\\langle e \\rangle ^A_i = \\langle x \\rangle ^A_i - \\langle a \\rangle ^A_i$ 和 $\\langle f \\rangle ^A_i = \\langle y \\rangle ^A_i - \\langle b \\rangle ^A_i$，双方执行 $\\mathsf{Rec}^A(e)$ 和 <script type=\"math/tex\">\\mathsf{Rec}^A(f)</script>，然后 $P_i$ 设 $\\langle z \\rangle ^ A_i = i \\cdot e \\cdot f + f \\cdot \\langle a \\rangle ^ A_i + e \\cdot \\langle b \\rangle ^ A_i + \\langle c \\rangle ^ A_i$。本文给出了预计算算术乘法的协议。</li>\n</ul>\n<h3 id=\"利用加性同态加密生成算术乘法三元组\"><a href=\"#利用加性同态加密生成算术乘法三元组\" class=\"headerlink\" title=\"利用加性同态加密生成算术乘法三元组\"></a>利用加性同态加密生成算术乘法三元组</h3><p>通常，$\\langle a \\rangle ^ A \\cdot \\langle b \\rangle ^ A = \\langle c \\rangle ^ A$ 形式的算术乘法三元组在设置阶段使用如协议1所示的加法同态加密方案来生成。该用于生成乘法三元组的协议在[2，附录A]中被提到为“众所周知的民间传说”。对于同态加密，我们使用Paillier[25]、[26]、[62]的密码系统，或者使用Damgard-Geisler-Krøigaard(DGK)[22]、[23]的密码系统，并使用如[10]、[32]、[52]中描述的Pohlig-Hellman算法[65]进行完全解密。在Paillier加密中，明文空间为 $Z<em>N$，使用参数为 $r$ 的统计盲化；在DGK加密中，将明文空间设置为 $\\mathbb{Z}</em>{2^{2l+1}}$，使用参数为 $r$ 的完全盲化。关于安全性和正确性的证明，请参阅[67]和[66]。</p>\n<p><strong>复杂度。</strong>为了生成 $l$ 位乘法三元组，$P_0$ 和 $P_1$ 交换 $3$ 个密文，对于Paillier每个密文长度为 $2\\varphi$ 比特(而DGK为 $\\varphi$ 比特)，导致总共6个 $\\varphi$ 比特的通信(对应的3个 $\\varphi$ 比特)。对于Paillier加密，我们还使用了[67]中描述的打包优化，该优化将从 $P_1$ 到 $P_0$ 的多个消息打包成单个密文，从而减少解密次数，并将每个乘法三倍的通信量减少到 $4 \\varphi + 2 \\varphi / \\lfloor \\varphi / (2l+1+ \\sigma) \\rfloor$ 比特。</p>\n<p><img src=\"http://images.yingwai.top/picgo/aby2p1.png\" alt=\"\"></p>\n<h3 id=\"通过不经意传输生成算术乘法三元组\"><a href=\"#通过不经意传输生成算术乘法三元组\" class=\"headerlink\" title=\"通过不经意传输生成算术乘法三元组\"></a>通过不经意传输生成算术乘法三元组</h3><p>可以基于OT扩展生成算术乘法三元组，而不是使用同态加密。该议定书是在[33，Sect. 4.1]中提出的，并在[15]中使用。它允许使用OT有效地计算两个秘密共享值的乘积。在下面，本文将描述使用更有效的相关OT扩展的协议的一个微小变体。总体而言，可以在 $l$ 位串上使用 $2l$ 个相关的OT，即 C-OT$^{2l}_l$ (或者甚至在更短的串上，如下所述)来生成 $l$ 位乘法三元组。</p>\n<h2 id=\"布尔共享\"><a href=\"#布尔共享\" class=\"headerlink\" title=\"布尔共享\"></a>布尔共享</h2><p>布尔共享使用基于异或的秘密共享方案。为了简化表示，假定使用单个比特值；对于 $l$ 比特的值，每个操作都并行执行多次。</p>\n<h3 id=\"共享语义-1\"><a href=\"#共享语义-1\" class=\"headerlink\" title=\"共享语义\"></a>共享语义</h3><ul>\n<li><strong>被共享的值。</strong>如果有 $\\langle x \\rangle ^B_0 \\oplus \\langle x \\rangle ^B_1 = x$，其中 $\\langle x \\rangle ^B_0, \\langle x \\rangle ^B_1 \\in \\mathbb{Z}_2$，那么就说比特 $x$ 的布尔共享 $\\langle x \\rangle ^B$ 是在两方之间共享的。</li>\n<li><strong>共享。</strong>$\\mathsf{Shr}<em>i^B(x)$：$P_i$ 选择 $r \\in_R {0,1}$，计算 $\\langle x \\rangle ^B_i = x \\oplus r$，然后发送 $r$ 给 $P</em>{1-i}$，后者设 $\\langle x \\rangle ^B_{1-i} = r$。</li>\n<li><strong>重构。</strong>$\\mathsf{Rec}<em>i^B(x)$：$P</em>{1-i}$ 发送它的份额 $\\langle x \\rangle ^B_{1-i}$ 给 $P_i$，后者计算 $x = \\langle x \\rangle ^B_0 \\oplus \\langle x \\rangle ^B_1$。</li>\n</ul>\n<h3 id=\"操作-1\"><a href=\"#操作-1\" class=\"headerlink\" title=\"操作\"></a>操作</h3><p>每个有效计算的函数都可以表示为一个由异或门和与门组成的布尔电路，本文将在下面详细说明对它的求值。</p>\n<ul>\n<li><strong>异或。</strong>$\\langle z \\rangle ^B = \\langle x \\rangle ^B \\oplus \\langle y \\rangle ^B$：$P_i$ 本地计算 $\\langle z \\rangle ^B_i = \\langle x \\rangle ^B_i \\oplus \\langle y \\rangle ^B_i$。</li>\n<li><strong>与。</strong>$\\langle z \\rangle ^B = \\langle x \\rangle ^B \\wedge \\langle y \\rangle ^B$：与使用预计算布尔乘法三元组 $\\langle c \\rangle ^B = \\langle a \\rangle ^B \\wedge \\langle b \\rangle ^B$ 进行评估，如下所示：$P_i$ 计算 $\\langle e \\rangle ^B_i = \\langle a \\rangle ^B_i \\oplus \\langle x \\rangle ^B_i$ 和 $\\langle f \\rangle ^B_i = \\langle b \\rangle ^B_i \\oplus \\langle y \\rangle ^B_i$，双方执行 $\\mathsf{Rec}^B(e)$ 和 $\\mathsf{Rec}^B(f)$，然后 $P_i$ 设 $\\langle z \\rangle ^B_i = i \\cdot e \\cdot f \\oplus f \\cdot \\langle a \\rangle ^B_i \\oplus e \\cdot \\langle b \\rangle ^B_i \\oplus \\langle c \\rangle ^B_i$。如文献[1]所述，使用 R-OT$^2_1$ 可以有效地预计算布尔乘法三元组。</li>\n<li><strong>多路复用。</strong>对于多路复用器操作，本文使用[54]中提出的协议，该协议只需要 R-OT$^2_l$，而评估具有 $l$ 个与门的多路复用电路需要 R-OT$^{2l}_1$(参见[64]中的向量乘法三元组)。</li>\n<li><strong>其它。</strong>对于标准功能，本文使用[69]中总结的深度优化电路结构。</li>\n</ul>\n<h2 id=\"姚氏共享\"><a href=\"#姚氏共享\" class=\"headerlink\" title=\"姚氏共享\"></a>姚氏共享</h2><p>在Yao用于安全两方计算的乱码电路协议[74]中，一方(称为Garbler)将布尔函数加密为乱码电路，由另一方(称为赋值器)进行评估。更详细地，加布勒将要计算的函数表示为布尔电路，并将满足 $k_0^w, k_1^w \\in {0,1}^{\\kappa}$ 的两个线密钥 $(k_0^w, k_1^w)$ 分配给每条线 $w$。然后，Garbler使用加密函数 $\\mathsf{Gb}$ 对两个输入线密钥的所有可能组合上的每个门的输出线密钥进行加密(详情见§III-C2中的共享)。然后，他将损坏的电路(由所有损坏的门组成)连同电路的相应输入键一起发送给评估器(参见§III-C1的共享)。评估者使用门的输入线路密钥迭代地解密每个乱码的门，以获得输出线路密钥(参见§III-C2中的与)，并最终重构电路的明文输出(参见§III-C1中的重构)。</p>\n<p>在下面，我们假设 $P_0$ 充当Garbler，$P_1$ 充当评估者，并详细说明Yao共享，假设使用free-XOR[47]和点置换[53]优化的乱码方案。使用这些技术，Garbler随机选择 $R[0]=1$ 的全局 $\\kappa$ 位串 $R$。对于每根导线 $w$，线密钥分别为 $k^w_0 \\in_R {0,1}^{\\kappa}$ 和 $k^w_1 = k^w_0 \\oplus R$。最低有效位 $k^w_0[0]$、$k^w_1[0]=1 − k^w_0[0]$ 称为置换位。作者指出，YAO共享也可以与其他改进方案一起实例化。</p>\n<h3 id=\"共享语义-2\"><a href=\"#共享语义-2\" class=\"headerlink\" title=\"共享语义\"></a>共享语义</h3><p>直观地，对于每根导线 $w$，$P_0$ 持有两个键 $k_0^w$ 和 $k_1^w$，以及 $P_1$ 持有这些键中的一个，而不知道它对应于两个明文值中的哪一个。为了简化表示，我们假定使用单个比特值；对于 $l$ 比特的值，每个操作都并行执行多次。</p>\n<ul>\n<li><strong>被共享的值。</strong>值 $x$ 的乱码电路共享 $\\langle x \\rangle ^Y$ 被共享为 $\\langle x \\rangle ^Y_0 = k_0$ 和 $\\langle x \\rangle ^Y_1 = k_x = k_0 \\oplus xR$。</li>\n<li><strong>共享。</strong>$\\mathsf{Shr}^Y_0(x)$：$P_0$ 取随机值 $\\langle x \\rangle ^Y_0 = k_0 \\in_R {0,1}^{\\kappa}$ 然后发送 $k_x = k_0 \\oplus xR$ 给 $P_1$。</li>\n<li><strong>重构。</strong>$\\mathsf{Rec}^Y<em>i (x)$：$P</em>{1-i}$ 发送它的置换位 $\\pi = \\langle x \\rangle ^Y_{1-i}[0]$ 给 $P_i$，后者计算 $x = \\pi \\oplus \\langle x \\rangle ^Y_i[0]$。</li>\n</ul>\n<h3 id=\"操作-2\"><a href=\"#操作-2\" class=\"headerlink\" title=\"操作\"></a>操作</h3><p>使用姚氏共享，由XOR和AND门组成的布尔电路评估如下：</p>\n<ul>\n<li><strong>异或。</strong>$\\langle z \\rangle ^Y = \\langle x \\rangle ^Y \\oplus \\langle y \\rangle ^Y$ 使用 free-XOR 技术[47]进行评估：$P_i$ 本地计算 $\\langle z \\rangle ^Y_i = \\langle x \\rangle ^Y_i \\oplus \\langle y \\rangle ^Y_i$。</li>\n<li><strong>与。</strong>$\\langle z \\rangle ^Y = \\langle x \\rangle ^Y \\wedge \\langle y \\rangle ^Y$ 评估如下：$P<em>0$ 使用 $\\mathsf{Gb}</em>{\\langle z \\rangle ^Y_0}(\\langle x \\rangle ^Y_0, \\langle y \\rangle ^Y_0)$ 生成乱码表，其中 $\\mathsf{Gb}$ 是[7]中定义的乱码函数。$P_0$ 发送该表给 $P_1$，后者使用它的密钥 $\\langle x \\rangle ^Y_1$ 和 $\\langle y \\rangle ^Y_1$ 进行解密。</li>\n<li><strong>其它。</strong>对于标准功能，本文使用[45]中总结的尺寸优化的电路结构。</li>\n</ul>\n<h1 id=\"共享转换\"><a href=\"#共享转换\" class=\"headerlink\" title=\"共享转换\"></a>共享转换</h1><p>在本节中，将详细介绍在不同共享之间进行转换的方法。首先解释已经存在的或直接的转换：Y2B(§IV-A)、B2Y(§IV-B)、A2Y(§IV-C)和A2B(§IV-D)。然后，我们详细说明了B2A(§IV-E)和Y 2A(§IV-F)的改进结构。作者将共享、重构和转换操作的复杂性总结在表1。</p>\n<p><img src=\"http://images.yingwai.top/picgo/aby2t1.png\" alt=\"\"></p>\n<center>\n    <i>表1 用于l比特的值的共享、重构和转换操作的在线阶段的总计算(对称密码操作数)、通信和消息数。κ是对称安全参数。</i>\n</center>\n\n\n\n\n<h2 id=\"姚氏到布尔共享-Y2B\"><a href=\"#姚氏到布尔共享-Y2B\" class=\"headerlink\" title=\"姚氏到布尔共享(Y2B)\"></a>姚氏到布尔共享(Y2B)</h2><p>将姚共享 $\\langle x \\rangle ^Y$ 转换为布尔共享 $\\langle x \\rangle ^B$ 是最简单的转换，基本上是免费的。关键的发现是 $\\langle x \\rangle ^Y_0$ 和 $\\langle x \\rangle ^Y_1$ 的排列位已经形成了 $x$ 的有效布尔共享。因此，$P_i$ 在本地设置 $\\langle x \\rangle ^B_i = Y2B(\\langle x \\rangle ^Y_i) = \\langle x \\rangle ^Y_i[0]$。</p>\n<h2 id=\"布尔到姚氏共享-B2Y\"><a href=\"#布尔到姚氏共享-B2Y\" class=\"headerlink\" title=\"布尔到姚氏共享(B2Y)\"></a>布尔到姚氏共享(B2Y)</h2><p>将布尔共享 $\\langle x \\rangle ^B$ 转换为姚共享 $\\langle x \\rangle ^Y$ 非常类似于 $\\mathsf{Shr}^Y<em>1$ 操作(参见§III-C1)：在下文中，我们假设 $x$ 是1比特；对于 $l$ 比特的值，每个运算都并行完成 $l$ 次。设 $x_0 = \\langle x \\rangle ^B_0$ 和 $x_1 = \\langle x \\rangle ^B_1$。$P_0$ 选取 $\\langle x \\rangle ^Y_0 = k_0 \\in_R {0,1}^{\\kappa}$。双方执行 OT$^1</em>{\\kappa}$，其中 $P_0$ 作为具有输入的发送方 $(k_0 \\oplus x_0 \\cdot R;k_0 \\oplus (1−x_0) \\cdot R)$，而 $P_1$ 作为具有选择位 $x_1$ 的接收方，并且不经意地获得 $\\langle x \\rangle ^Y_1 = k_0 \\oplus (x_0 \\oplus x_1) \\cdot R = k_x$。</p>\n<h2 id=\"算术到姚氏共享-A2Y\"><a href=\"#算术到姚氏共享-A2Y\" class=\"headerlink\" title=\"算术到姚氏共享(A2Y)\"></a>算术到姚氏共享(A2Y)</h2><p>算术共享 $\\langle x \\rangle ^A$ 到Yao共享 $\\langle x \\rangle ^Y$ 的转换在[35]、[44]、[46]中概述，并且可以通过安全地评估加法电路来完成。更准确地说，各方秘密地将他们的算术份额 $x_0 = \\langle x \\rangle ^A_0$ 和 $x_1 = \\langle x \\rangle ^A_1$ 共享为 $\\langle x_0 \\rangle ^Y = \\mathsf{Shr}^Y_0(x_0)$ 和 $\\langle x_1 \\rangle ^Y = \\mathsf{Shr}^Y_1(x_1)$，并计算 $\\langle x \\rangle ^Y = \\langle x_0 \\rangle ^Y + \\langle x_1 \\rangle ^Y$。</p>\n<h2 id=\"算术到布尔共享-A2B\"><a href=\"#算术到布尔共享-A2B\" class=\"headerlink\" title=\"算术到布尔共享(A2B)\"></a>算术到布尔共享(A2B)</h2><p>可以使用布尔加法电路(类似于§IV-C中描述的A2Y转换)或通过使用算术位提取电路[17]、[18]、[21]、[70]来完成将算术共享 $\\langle x \\rangle ^A$ 转换为布尔共享 $\\langle x \\rangle ^B$。如在[69]中总结的，布尔加法电路可以被实例化为大小优化的随 $O(l)$ 大小和深度变化的变量，或者实例化为随 $O(l\\log_2l)$ 大小和 $O(\\log_2l)$ 深度变化的深度优化的变量。在本文的框架中，$Y2B$ 转换是免费的，我们简单地计算 $\\langle x \\rangle ^B = A2B(\\langle x \\rangle ^A) = Y2B(A2Y(\\langle x \\rangle ^A))$，因为我们在§V-D中的评估表明，Yao共享中的加法比布尔共享中的加法更有效。</p>\n<h2 id=\"布尔到算术共享-B2A\"><a href=\"#布尔到算术共享-B2A\" class=\"headerlink\" title=\"布尔到算术共享(B2A)\"></a>布尔到算术共享(B2A)</h2><p>将 $l$ 比特布尔共享 $\\langle x \\rangle ^B$ 转换为算术共享 $\\langle x \\rangle ^A$ 的简单解决方案是评估布尔减法电路，其中 $P_0$ 输入 $\\langle x \\rangle ^B_0$ 和随机数 $r \\in_R {0,1}^l$，并且设置 $\\langle x \\rangle ^A_0 = r$，然后 $P_1$ 输入 $\\langle x \\rangle ^B_1$ 并获得 $\\langle x \\rangle ^A_1 = x - r$。然而，评估这样的布尔减法电路将具有 $O(l)$ 大小和深度或者 $O(l \\log_2 l)$ 大小和 $O(\\log_2 l)$ 深度[69]。</p>\n<p>为了提高转换的性能，可以使用与§III-A5中描述的算术乘法三次生成类似的技术。一般的想法是对每个比特执行OT，其中我们不经意地转移了两个值，这两个值被2的幂相加相关。接收方可以获得这些值中的一个，并且通过将它们相加，各方获得有效的算术份额。</p>\n<p>更详细地说，在OT协议中，$P<em>0$ 充当发送者，$P_1$ 充当接收者。在第 $i$ 个OT中，$P_0$ 随机选择 $r_i \\in_R {0, 1}^l$ 以及输入 $(s</em>{i,0}, s<em>{i_1})$，其中 $s</em>{i,0} = (1 - \\langle x \\rangle^B<em>0[i]) \\cdot 2^i - r_i$ 以及 $s</em>{i,1} = \\langle x \\rangle^B<em>0[i] \\cdot 2^i - r_i$，而 $P_1$ 输入 $\\langle x \\rangle^B_1[i]$ 作为选择位，收到输出 $s</em>{\\langle x \\rangle ^B<em>1[i]} = (\\langle x \\rangle^B_0[i] \\oplus \\langle x \\rangle^B_1[i]) \\cdot 2^i - r_i$。最后，$P_0$ 计算 $\\langle x \\rangle^A_0 = \\sum^l</em>{i=1}r<em>i$，$P_1$ 计算 $\\langle x \\rangle^A_1$ $=\\sum^l</em>{i=1}s<em>{\\langle x \\rangle^B_1[i]}$ $=\\sum^l</em>{i=1}(\\langle x \\rangle^B<em>0[i] \\oplus \\langle x \\rangle^B_1[i]) \\cdot$ $2^i-\\sum^l</em>{i=1}r<em>i$ $=\\sum^l</em>{i=1}x[i] \\cdot 2^i -$ $\\sum^l_{i=1}r_i$ $=x - \\langle x \\rangle^A_0$。安全性和正确性类似于§III-A5的协议。</p>\n<p><strong>复杂度。</strong>观察到，由于我们传输一个随机元素和另一个作为相关性，并且只需要第 $i$ 个OT中的 $l-i$ 个最低有效位，所以我们可以使用C-OT和§III-A5中概述的相同技巧，导致(平均)C-OT$^l_{(l+1)/2}$ 和恒定轮数。相比之下，当使用布尔共享评估减法电路时，对于深度为 $O(\\log_2l)$ 的电路各方将需要评估 $O(l \\log_2 l)$次R-OT或对于深度为 $l$ 的电路评估 $2l$ 次ROT。本文的转换方法也比转换成姚共享(这已经需要 $2l$ OT)并在乱码电路中进行减法运算。</p>\n<h2 id=\"姚氏到算术共享-Y2A\"><a href=\"#姚氏到算术共享-Y2A\" class=\"headerlink\" title=\"姚氏到算术共享(Y2A)\"></a>姚氏到算术共享(Y2A)</h2><p>在[35]，[44]，[46]中描述了从姚共享 $\\langle x \\rangle ^Y$ 到算术共享 $\\langle x \\rangle ^A$ 的转换：$P<em>0$ 随机选择 $r \\in_R \\mathbb{Z}</em>{2^l}$，执行 $\\mathsf{Shr}^Y_0$，然后双方评估布尔减法电路 $\\langle d \\rangle ^Y = \\langle x \\rangle ^Y - \\langle r \\rangle ^Y$，以获得它们的算术份额为 $\\langle x \\rangle ^A_0 = r$ 和 $\\langle x \\rangle ^A_1 = \\mathsf{Rec}^Y_1(\\langle d \\rangle ^Y)$。</p>\n<p>然而，由于我们免费执行 $Y2B$，而 $B2A$ 在计算和通信方面更便宜，我们建议计算 $\\langle x \\rangle ^A = Y2A(\\langle x \\rangle ^Y) = B2A(Y2B(\\langle x \\rangle ^Y))$。</p>"},{"title":"论文笔记 ASTRA: High Throughput 3PC over Rings with Application to Secure Prediction","date":"2020-04-20T13:37:26.000Z","_content":"\n*Harsh Chaudhari, Ashish Choudhury, Arpita Patra, Ajith Suresh*\n\nACM CCSW 2019\n\nhttps://eprint.iacr.org/2019/429\n\nhttps://dl.acm.org/doi/10.1145/3338466.3358922\n\n<!--more-->\n\n\n\n![](http://images.yingwai.top/picgo/ASTRA.jpg)\n\n\n\n## 介绍\n\n### 摘要\n\n安全计算的具体效率一直是近年来许多工作关注的焦点。在本论文中，作者提出了一种具体有效的协议，用于模 $2^l$ 整数环上的安全三方计算（3PC），该协议具有半诚实模型和恶意模型上的安全性。由于环上的计算模拟了现实系统体系结构上的计算，所以环上的安全计算近来获得了发展势头。\n\n​\t\t在离线-在线模式中，本文的结构具体地呈现了最有效的在线阶段。在半诚实的设置下，本文的协议在在线阶段每个乘法门需要2个环元素的通信。在恶意设置下，本文的协议在在线阶段每个乘法门需要4个元素的通信，比最先进的协议需要的5个元素少。使用选择性中止和公平这两个安全概念来实现的公平恶意协议，与仅针对输出门的中止安全性的恶意协议相比，涉及的通信稍微多一些。\n\n​\t\t作者将本文的技术从3PC应用到安全的服务器辅助机器学习（ML）推理机制中，用于一系列预测函数——线性回归、线性SVM回归、Logistic回归和线性SVM分类。本文的设置考虑了拥有训练好的模型参数的模型所有者和查询的客户，后者愿意根据前者的模型参数来学习他查询的预测。输入和计算外包给一组三个非合谋的服务器。本文的构造既迎合了半诚实的世界，也迎合了恶意的世界，比现有的构造表现得更好。\n\n\n\n\n### 贡献\n\n* 作者遵循离线-在线模式，提出了在环 $\\mathbb{Z}_{2^l}$（包括布尔环 $\\mathbb{Z}_{2^1}$）上的3PC构造，具有最有效的在线阶段。\n\n  虽然重点放在在现阶段，但离线阶段的的成本也有注意并保持在可控范围内。\n\n* 作者给出了一系列满足半诚实安全和恶意安全的构造。\n\n  将技术应用于外包环境中的一系列预测函数的安全预测，并构建了一些容忍半诚实和恶意对手的结构。\n\n本文所有的构建都流露出的一个共同特征：在线阶段不到三对参与者之间需要进行功能依赖的通信，从而产生更好的在线性能。\n\n\n\n## 设定\n\n本文考虑一组三方 $\\mathcal{P}=\\left\\{P_0,P_1,P_2\\right\\}$，它们在同步网络中通过成对的私有和可信信道连接。要计算的函数 $f$ 被表示为环 $\\mathbb{Z}_{2^l}$ 上的电路 ckt，该环由2输入加法和乘法门组成。假设 ckt 的拓扑是公知的。术语 D​ 表示 ckt 的乘法深度，而 I、O、A、M 分别表示 ckt 中的输入线、输出线、加法门和乘法门的数目。本文使用符号 $w_x$ 来表示导线 $w$，其中值 $x$ 流经它。本文使用 $g=(w_x,w_y,w_z)$ 来表示 ckt 中具有左输入线 $w_x$、右输入线 $w_y$ 和输出线 $w_z$ 的门。在本文的协议中，将 $\\mathcal{P}$ 划分为互不相交的集合 $\\left\\{P_0\\right\\}$ 和 $\\left\\{P_1,P_2\\right\\}$，其中 $P_0$ 在离线阶段充当“分配器”进行“预处理”，在线阶段“评估者” $P_1$、$P_2$ 用它来评估 ckt。本文使用上标“$s$”和“$m$”分别区分半诚实和恶意设置中的协议。布尔环 $\\mathbb{Z}_{2^1}$ 上的协议可以通过将算术加法$(+)$和乘法$(\\times)$分别替换为异或$(\\oplus)$和与$(\\cdot)$来获得。\n\n\n\n### 共享密钥设置\n\n为了保存双方之间的通信，使用为伪随机函数（PRF）$F$ 建立预共享随机密钥的一次性设置。在3PC设置[2，30，46]中的已知协议中已经使用了类似的设置。这里 $F:{\\{0，1\\}}^\\kappa \\times {\\{0，1\\}}^\\kappa \\to X$ 是安全的PRF，同域 $X$ 是 $\\mathbb{Z}_{2^l}$。这组密钥是：\n\n* 每对参与方之间共享一个密钥— $k_{01}, k_{02}, k_{12}$，分别用于参与方$(P_0,P_1), (P_0,P_2), (P_1,P_2)$。\n* 所有各方之间的一个共享密钥— $k_{\\mathcal{p}}$。\n\n本文通过可以使用任何标准安全MPC协议实现的功能 $\\mathcal{F}_{\\rm setup}$ 来建立密钥设置模型。\n\n\n\n### 共享语义\n\n在本节中，将解释本工作中使用的秘密共享的两种变体。这两个变体都在算术（$\\mathbb{Z}_{2^l}$）和布尔环（$\\mathbb{Z}_{2^1}$）上运行。\n\n$[\\cdot]$-共享：如果 $P_1$ 和 $P_2$ 分别持有份额 $v_1$ 和 $v_2$，使得 $v=v_1+v_2$，则称值 $v$ 在$P_1,P_2$之间是 $[\\cdot]$-共享的。用 $[\\cdot]_{P_i}$ 表示 $P_i, i∈\\{1,2\\}$的 $[\\cdot]$-份额。\n\n$[\\![\\cdot]\\!]$-共享：值 $v$ 在 $P_0, P_1, P_2$ 之间是$[\\![\\cdot]\\!]$-共享的，如果\n\n* 存在值 $\\lambda_v, m_v$ 使得 $v=m_v - \\lambda_v$；\n* $P_0$ 持有 $\\lambda_{v,1}$ 和 $\\lambda_{v,2}$ 使得 $\\lambda_{v} = \\lambda_{v,1} + \\lambda_{v,2}$；\n* $P_1$ 和 $P_2$ 分别持有 $(m_v, \\lambda_{v,1})$ 和 $(m_v, \\lambda_{v,1})$。\n\n本文将各方的$[\\![\\cdot]\\!]$-共享表示为$[\\![v]\\!]_{P_0} = (\\lambda_{v,1}, \\lambda_{v,2}), [\\![v]\\!]_{P_1} = (m_v, \\lambda_{v,1}) $和 $[\\![v]\\!]_{P_2} = (m_v, \\lambda_{v,2})$。用$[\\![v]\\!] = (m_v, [\\lambda_{v}])$表示 $v$ 的$[\\![\\cdot]\\!]$-共享份额。\n\n\n\n### 秘密共享方案的线性\n\n给定 $x,y \\in \\mathbb{Z}_{2^l}$ 和公共常数 $c_1, c_2 \\in \\mathbb{Z}_{2^l}$的$[\\cdot]$-共享，各方可以局部计算 $[c_1x+c_2y]$：\n\n$$[c_1x+c_2y]=(c_1x_1+c_2y_1, c_1x_2+c_2y_2)=c_1[x]+c_2[y]$$\n\n很容易看出线性关系也扩展到$[\\![\\cdot]\\!]$-共享。线性属性使各方能够**本地**执行与公共常量的加法和乘法等操作。\n\n\n\n## 3PC协议\n\n### 半诚实下的3PC\n\n协议 $\\prod ^{\\rm s}_{\\rm 3pc}$ 由三个步骤组成—输入共享、电路评估以及输出重构。所有阶段（重构输出除外）都分为离线和在线阶段，其中独立于实际输入的步骤可以在脱机阶段执行。\n\n\n\n#### 输入共享\n\n在共享输入阶段，每一方都为自己的输入生成一个随机的$[\\![\\cdot]\\!]$-共享。以下是初始共享协议 $\\prod^{\\rm s}_{\\rm Sh}$：\n\n-----\n\n**Offline:**\n\n- If $P_i = P_0$, parties $P_0, P_j$ for $j \\in \\{1, 2\\}$ locally sample a random $\\lambda_{x,j} \\in \\mathbb{Z}_{2^l}$. Moreover, $P_i$ sets $[\\![x]\\!]_{P_i} = (\\lambda_{x,1}, \\lambda_{x,2})$.\n- If $P_i = P_1$, parties $P_0, P_1$ sample a random $\\lambda_{x,1} \\in \\mathbb{Z}_{2^l}$ while all the parties in $\\mathcal{P}$ sample a random $\\lambda_{x,2} \\in \\mathbb{Z}_{2^l}$.\n- If $P_i = P_2$, parties $P_0, P_2$ sample a random $\\lambda_{x,2} \\in \\mathbb{Z}_{2^l}$ while all the parties in $\\mathcal{P}$ sample a random $\\lambda_{x,1} \\in \\mathbb{Z}_{2^l}$.\n\n**Online:**\n\n​\t\t$P_i$ computes $\\lambda_x = \\lambda_{x,1} + \\lambda_{x,2}$ and sends $m_x = x + \\lambda_x$ to every $P_j$ for $j \\in \\{1,2\\}$ who then sets $[\\![x]\\!]_{P_j} = (m_x, \\lambda_{x,j})$.\n\n-----\n\n在离线阶段根据输入方的序号，使用不同的初始化手段，生成了 $P_0$ 的份额 $[\\![x]\\!]_{P_0}=(\\lambda_{x,1}, \\lambda_{x,2})$，而不用任何交互（因为随机数都是使用服务器两两之间的公共随机源生成的，可以理解为编程语言中把同样的随机种子输入到random函数——只要随机种子一样生成的随机数序列就一样）。\n\n\n\n#### 电路评估\n\n在电路评估阶段，各方以$[\\![\\cdot]\\!]$-共享的方式评估 ckt。以拓扑顺序评估 ckt 中的每个门 $g$：给定 $g$ 的输入，各方为 $g$ 的输出生成$[\\![\\cdot]\\!]$-共享。\n\n##### 加法\n\n如果 $g$ 是加法门 $(w_x,w_y,w_z)$，可以利用$[\\![\\cdot]\\!]$-共享的线性在本地完成。以下是加法协议 $\\prod_{\\rm Add} (w_x, w_y, w_z)$：\n\n-----\n\n**Offline:**\n\n​\t\t$P_0, P_1$ set $\\lambda_{z,1} = \\lambda_{x,1} + \\lambda_{y,1}$, while $P_0, P_2$ set $\\lambda_{z,2} = \\lambda_{x,2} + \\lambda_{y,2}$.\n\n**Online:**\n\n​\t\t$P_1$ and $P_2$ set $m_z = m_x + m_y$.\n\n-----\n\n这里的加法协议感觉在线阶段完全可以在本地完成，可以不需要在线阶段。\n\n##### 乘法\n\n如果 $g=(w_x,w_y,w_z)$ 是乘法门，则运行以下乘法协议 $\\prod ^{\\rm s}_{\\rm Mul}$：\n\n-----\n\n**Offline:**\n\n* $P_0$ and $P_1$ locally sample random $\\lambda_{z,1}, \\gamma_{xy, 1} \\in \\mathbb{Z}_{2^l}$, while $P_0$ and $P_2$ locally sample random $\\lambda_{z,2} \\in \\mathbb{Z}_{2^l}$.\n* $P_0$ computes $\\gamma_{xy} = \\lambda_x \\lambda_y$ and sends $\\gamma_{xy,2} = \\gamma_{xy} - \\gamma_{xy,1}$ to $P_2$.\n\n**Online:**\n\n* $P_i$ for $i \\in \\{1,2\\}$ locally computes $[m_z]_{P_i} = (i-1)m_xm_y - m_x[\\lambda_y]_{P_i} - m_y[\\lambda_x]_{P_i} + [\\lambda_z]_{P_i} + [\\gamma_{xy}]_{P_i}$.\n* $P_1, P_2$ mutually exchange their shares and reconstruct $m_z$.\n\n-----\n\n将上面的公式相加一下即可验证其正确性。\n\n\n\n#### 输出重构\n\n在输出重构阶段，各方重构$[\\![\\cdot]\\!]$-共享电路输出。为了重构 $[\\![y]\\!]$，可以观察到每个 $P_i$ 缺失的份额都在另外两方手里。因此另外两方的其中一方将缺失的份额发送给 $P_i$ 后，通过计算 $y = m_y - \\lambda_{y,1} - \\lambda_{y,2}$ 即可重构输出 $y$，将其称为重构协议 $\\prod ^{\\rm s}_{\\rm Rec}([\\![y]\\!], \\mathcal{P})$。\n\n把上面三个阶段总结起来，有以下的协议 $\\prod ^{\\rm s}_{\\rm 3pc}$：\n\n-----\n\n**Pre-processing (Offline Phase):**\n\n* *Input wires:* For $j = 1, ...,l$, corresponding to the circuit-input $x_j$, parties execute the offline steps of the instance $\\prod ^{\\rm s}_{\\rm Sh}(P_i, x_j)$.\n* For each gate $g$ in the topological order, execute offline steps of the instance $\\prod ^{\\rm s}_{\\rm Mul}(w_{xj}, w_{yj}, w_{zj})$ if $g$ is the $j$th multiplication gate where $j \\in \\{1,...,\\rm M\\}$ or respectively offline steps of the instance $\\prod _{\\rm Add}(w_{xj}, w_{yj}, w_{zj})$ if $g$ is the $j$th addition gate where $j \\in \\{1,...,\\rm A\\}$.\n\n**Circuit Evaluation (Online Phase):**\n\n* *Sharing Circuit-input Values:* For $j = 1, ...,l$, corresponding to the circuit-input $x_j$, parties execute the online steps of the instance $\\prod ^{\\rm s}_{\\rm Sh}(P_i, x_j)$, where $P_i$ is the party designated to provide $x_j$.\n* *Gate Evaluation:* For each gate in $g$ in ckt in the topological order, $P_1, P_2$ execute the online steps of the instance $\\prod ^{\\rm s}_{\\rm Mul}(w_{xj},w_{yj},w_{zj})$ if $g$ is the $j$th multiplication gate where $j \\in \\{1,...,\\rm M\\}$ or respectively offline steps of the instance $\\prod _{\\rm Add}(w_{xj}, w_{yj}, w_{zj})$ if $g$ is the $j$th addition gate where $j \\in \\{1,...,\\rm A\\}$.\n* *Output Reconstruction:* Let $[\\![y_1]\\!],...,[\\![y_\\rm O]\\!]$ be the shared function outputs. The parties in $\\mathcal{P}$ reconstruct $y_j$ for $j = 1,...,\\rm O$ by executing $\\prod ^{\\rm s}_{\\rm Rec}([\\![y_j]\\!], \\mathcal{P})$.\n\n-----\n\n\n\n### 恶意下的3PC\n\n跟半诚实设置下的一样，恶意设置下的3PC协议 $\\prod ^{\\rm m}_{\\rm 3pc}$ 也由输入共享、电路评估和输出重构三个部分组成。\n\n\n\n#### 输入共享和输出重构\n\n在恶意的设置下，要保证服务器之间的共享份额是一致的。在 $\\prod ^{\\rm s}_{\\rm Sh}$ 中，$\\lambda$ 的共享是一致的，因为它不需要交互就可以生成。但如果一个腐败的 $P_0$ 拥有 $x$ 并且想制造一个不一致的 $[\\![x]\\!]$-共享，它可以分别发送两个不一样的 $m_x$ 给 $P_1$ 和 $P_2$。为了检查这种情况的发生，$P_1$ 和 $P_2$ 交换 $H(m_x)$ 并在不一致的时候中止。\n\n令 $[\\![y]\\!]$ 为一个待重构的一致的共享，$[\\![y]\\!]_{P_0} = (\\lambda_{y,1}, \\lambda_{y,2})$、$[\\![y]\\!]_{P_1} = (m'_{y}, \\lambda_{y,1})$ 和 $[\\![y]\\!]_{P_2} = (m''_{y}, \\lambda_{y,2})$ 分别为三个服务器的份额。协议 $\\prod ^{\\rm m}_{\\rm Rec}([\\![y]\\!], \\mathcal{P})$ 允许每一个诚实方输出 $y$ 或 $\\perp$：\n\n-----\n\n**Online:**\n\n* $P_0$ and $P_2$ send $\\lambda_{y,2}$ and $H(\\lambda'_{y,2})$ respectively to $P_1$.\n* $P_0$ and $P_1$ send $\\lambda_{y,1}$ and $H(\\lambda'_{y,1})$ respectively to $P_2$.\n* $P_1$ and $P_1$ send $m'_{y}$ and $H(m'_{y})$ respectively to $P_0$.\n\n$P_i$ for $i \\in \\{0,1,2\\}$ abort if the received values mismatch. Else $P_i$ sets $y = m_y - \\lambda_{y,1} - \\lambda_{y,2}$.\n\n-----\n\n检查的过程中，其中一方发送哈希值可以提高效率。\n\n\n\n#### 电路评估\n\n在恶意设置下加法协议 $\\prod _{\\rm Add}$ 同样是安全的，因为它只涉及本地操作。挑战在于构造乘法协议 $\\prod ^{\\rm m}_{\\rm Mul}$，令其可以容忍其中一方腐败。可以观察到有两种情况：\n\n* $P_0$ 是腐败的：在离线阶段会令 $\\gamma_{xy} \\neq \\lambda_x \\lambda_y$\n* $P_1$ 或 $P_2$ 是腐败的：会在在线阶段扰乱，使诚实的另一方重构出一个错误的 $m_z$\n\n先看下面的情况，假如 $P_1$ 现在需要验证它重构的 $m_z$ 是否是正确的，可以向 $P_0$ 求助：$P_1$ 可以发送 $m_x, m_y$ 给 $P_0$，因为 $P_0$ 在离线阶段就已经知道 $\\lambda_x, \\lambda_y$ 和 $\\lambda_z$，因此它可以计算出 $m_z$ 并发送给 $P_1$，以此得到验证。但发送 $m_x, m_y$ 给 $P_0$ 会导致打破了原有共享的私密性，所以 $P_1$ 可以对应的值盲化后发送给 $P_0$：$m^{\\star}_x = m_x + \\delta_x$ 和 $m^{\\star}_y = m_y + \\delta_y$，然后 $P_0$ 计算 $m^{\\star}_z = -m^{\\star}_x \\lambda_y - m^{\\star}_y \\lambda_x +\\lambda_z + 2\\gamma_{xy}$。注意到：\n$$\n\\begin{align}\nm^{\\star}_z &= -m^{\\star}_x \\lambda_y - m^{\\star}_y \\lambda_x +\\lambda_z + 2\\gamma_{xy}\\\\\n &= -(m_x + \\delta_x) \\lambda_y - (m_y + \\delta_y) \\lambda_x +\\lambda_z + 2\\gamma_{xy}\\\\\n &= (m_z - m_x m_y) - \\chi\n\\end{align}\n$$\n\n假设 $P_0$ 知道 $\\chi = \\delta_x \\lambda_y + \\delta_y \\lambda_x - \\gamma_{xy}$，它就可以计算出 $m^{\\star}_z + \\chi$ 然后发送给 $P_1$。因为 $P_1$ 知道 $m_x, m_y$ 的值，因此它可以验证它重构的 $m_z$ 的正确性，对于 $P_2$ 来说也可以这样验证。\n\n现在来描述如何使 $P_0$ 获得 $\\chi$：首先直接让 $P_0$ 获得 $\\chi$ 会导致共享的私密性被破坏，因为 $P_0$ 知道 $\\lambda_x, \\lambda_y$ 和 $\\gamma_{xy}$ 的值，同时在在线阶段又得到 $m_x + \\delta_x$ 和 $m_y + \\delta_y$，导致 $P_0$ 可以推导出 $m_x, m_y$ 之间的关系。所以还要在 $\\chi$ 中加入一个随机值 $\\delta_z$ 进行盲化：$\\delta_x \\lambda_y + \\delta_y \\lambda_x + \\delta_z - \\gamma_{xy}$。\n\n生成 $\\chi$ 的过程：$P_1, P_2$ 在本地生成随机数 $\\delta_x, \\delta_y, \\delta_z \\in \\mathbb{Z}_{2^l}$，计算各自的 $\\chi$ 的 $[\\cdot]$-共享并发送给 $P_0$。对于 $i \\in \\{1,2 \\}$，令 $[\\chi]_{P_i} = \\chi_i$。$P_0$ 在本地将共享的份额相加得到 $\\chi$。在以上步骤中，腐败的一方可能会在执行过程中引入错误，使得 $P_0$ 获得的 $\\chi$ 是错误的。\n\n总而言之在离线阶段有两个问题需要解决：\n\n* 腐败的 $P_0$ 可以不正确地共享 $\\gamma_{xy}$\n* 腐败的 $P_1$ 或 $P_2$ 可以发送错误的 $\\chi$ 的 $[\\cdot]$-共享给 $P_0$\n\n为了解决这些问题，$P_0$ 一旦获得 $\\chi$，就用下面的方式计算 $a = \\delta_x - \\lambda_x$、$b = \\delta_y - \\lambda_y$ 和 $c = (\\delta_z + \\delta_x \\delta_y) - \\chi$ 的 $[\\![\\cdot]\\!]$-共享：\n$$\n\\begin{align*}\n[\\![a]\\!]_{P_0} &= (\\lambda_{x,1}, \\lambda_{x,2}), & [\\![b]\\!]_{P_0} &= (\\lambda_{y,1}, \\lambda_{y,2}), & [\\![c]\\!]_{P_0} &= (\\chi_{1}, \\chi_{2})\\\\\n [\\![a]\\!]_{P_1} &= (\\delta_x, \\lambda_{x,1}), & [\\![b]\\!]_{P_1} &= (\\delta_y, \\lambda_{y,1}), & [\\![c]\\!]_{P_1} &= (\\delta_z + \\delta_x \\delta_y, \\chi_{1})\\\\\n [\\![a]\\!]_{P_2} &= (\\delta_x, \\lambda_{x,2}), & [\\![b]\\!]_{P_2} &= (\\delta_y, \\lambda_{y,2}), & [\\![c]\\!]_{P_2} &= (\\delta_z + \\delta_x \\delta_y, \\chi_{2})\n\\end{align*}\n$$\n现在 $([\\![a]\\!], [\\![b]\\!], [\\![c]\\!])$ 是一个乘法三元组 $(c=ab)$，当且仅当 $P_0$ 正确分享了 $\\gamma_{xy}$（当它腐败时）以及重构的 $\\chi$ 是正确的（当 $P_1,P_2$ 其中之一腐败时），因为：\n$$\n\\begin{align}\nab &= (\\delta_x - \\lambda_x)(\\delta_y - \\lambda_y) = \\delta_x \\delta_y + \\lambda_x \\lambda_y - \\delta_x \\lambda_y - \\delta_y \\lambda_x \\\\\n &= (\\delta_x \\delta_y + \\delta_z) - (\\delta_x \\lambda_y + \\delta_y \\lambda_x + \\delta_z - \\gamma_{xy}) \\\\\n  &= (\\delta_x \\delta_y + \\delta_z) - \\chi = c\n\\end{align}\n$$\n然后作者给出了一个检查乘法三元组是否正确的协议，这里需要用到另一个有效的乘法三元组 $([\\![d]\\!], [\\![e]\\!], [\\![f]\\!])$，它们满足以下条件：\n\n* $d, e, f$ 都是随机且私密的\n* $f = d e$\n\n这里假设这个三元组是通过 $\\mathcal{F}_{\\rm trip}$ 生成的，在[2, 30]中有具体构造，下面是[30]中的构造：\n\n![](http://images.yingwai.top/picgo/ASTRAf1.png)\n\n用  $\\prod _{\\rm trip}$ 表示该功能的实例化，下面是作者给出检查有效性的协议 $\\prod _{\\rm prc}$：\n\n-----\n\n* Parties locally compute $[\\![\\rho]\\!] = [\\![a]\\!] - [\\![d]\\!]$ and $[\\![\\sigma]\\!] = [\\![b]\\!] - [\\![e]\\!]$.\n* Parties reconstruct $\\rho$ and $\\sigma$ by executing $\\prod ^{\\rm m}_{\\rm Rec}([\\![\\rho]\\!], \\mathcal{P})$ and $\\prod ^{\\rm m}_{\\rm Rec}([\\![\\sigma]\\!], \\mathcal{P})$ respectively.\n* Parties locally compute $[\\![\\tau]\\!] = [\\![c]\\!] - [\\![f]\\!] - \\sigma [\\![d]\\!] - \\rho [\\![e]\\!] - \\sigma \\rho$.\n* Parties reconstruct $\\tau$ by executing $\\prod ^{\\rm m}_{\\rm Rec}([\\![\\tau]\\!], \\mathcal{P})$ and output $\\perp$, if $\\tau \\neq 0$.\n\n-----\n\n协议 $\\prod _{\\rm prc}$ 需要两对秘密共享三元组 $(a, b, c)$ 和 $(d, e, f)$，验证前一个三元组是否满足 $c = a b$：\n$$\n\\begin{align}\n\\tau &= c - f - \\sigma d - \\rho e - \\sigma \\rho \\\\\n &= c - de - (b - e)d - (a - d)e - (b - e)(a - d) \\\\\n &= c - ab = \\Delta\n\\end{align}\n$$\n所以 $\\tau = 0$ 时 $(a,b,c)$ 有效，反之无效。而检验 $\\tau$ 是否为0只需要一方跟另外两方各通信一次即可：(1) $P_0$ 跟 $P_1$ 检查 $m_\\tau - \\lambda_{\\tau,1}$ 跟 $\\lambda_{\\tau, 2}$ 是否相等；(2) $P_1$ 跟 $P_2$ 检查 $m_\\tau - \\lambda_{\\tau,2}$ 跟 $\\lambda_{\\tau, 1}$ 是否相等；(3) $P_0$ 跟 $P_1$ 检查 $m_\\tau - \\lambda_{\\tau,2}$ 跟 $\\lambda_{\\tau, 1}$ 是否相等，而不是 $\\prod ^{\\rm m}_{\\rm Rec}$ 的通信三次（两次发送一次接收）。下面给出恶意设置下的乘法协议 $\\prod ^{\\rm m}_{\\rm Mul}(w_x, w_y, w_z)$：\n\n-----\n\n**Offline:**\n\n* Parties $P_0, P_1$ locally sample random $\\lambda_{z,1}, \\gamma_{xy,1} \\in \\mathbb{Z}_{2^l}$, while $P_0, P_2$ \n  locally sample a random $\\lambda_{z,2}$. $P_0$ locally computes $\\gamma_{xy}= \\lambda_x \\lambda_y$ and\n  sends $\\gamma_{xy,2} = \\gamma_{xy} - \\gamma_{xy,1}$ to $P_2$.\n* Parties execute $\\prod _{\\rm trip}$ to generate a triple $([\\![d]\\!], [\\![e]\\!], [\\![f]\\!])$.\n* Parties $P_1, P_2$ locally sample random $\\delta_x, \\delta_y, \\delta_z \\in \\mathbb{Z}_{2^l}$ and compute\n  $[\\delta_z]$ non-interactively.\n* $P_i$ for $i \\in \\{1, 2\\}$ computes $[\\chi]_{P_i} = \\delta_x[\\lambda_y]_{P_i} + \\delta_y[\\lambda_x]_{P_i} + [\\delta_z]_{P_i} − [\\gamma_{xy}]_{P_i}$ and sends $[\\chi]_{P_i}$ to $P_0$, who computes $\\chi$.\n* Parties locally compute the $[\\![\\cdot]\\!]$-shares of the values $a = \\delta_x - \\lambda_x$, $b = \\delta_y - \\lambda_y$ and $b = (\\delta_z + \\delta_x \\delta_y) - \\chi$, as described in the text.\n* Parties execute $\\prod _{\\rm prc}$ on $([\\![a]\\!], [\\![b]\\!], [\\![c]\\!])$ and $([\\![d]\\!], [\\![e]\\!], [\\![f]\\!])$.\n\n**Online:**\n\n* $P_i$ for $i \\in \\{1, 2\\}$ locally computes $[m_z]_{P_i} = (i-1)m_xm_y - m_x[\\lambda_y]_{P_i} - m_y[\\lambda_x]_{P_i} + [\\lambda_z]_{P_i} + [\\gamma_{xy}]_{P_i}$. $P_1, P_2$ mutually exchange their shares and reconstruct $m_z$.\n* $P_1$ sends $m^{\\star}_x = m_x + \\delta_x$, $m^{\\star}_y = m_y + \\delta_y$ to $P_0$, while $P_2$ sends $H(m^{\\star}_x || m^{\\star}_{y})$ to $P_0$.$P_0$ outputs $\\perp$, if the received values are inconsistent.\n* $P_0$ computes $m^{\\star}_z = -m^{\\star}_x \\lambda_y - m^{\\star}_y \\lambda_x +\\lambda_z + 2\\gamma_{xy} + \\chi$ and sends $H(m^\\star_z)$ to both $P_1$ and $P_2$.\n* $P_i$ for $i \\in \\{1, 2\\}$ abort if $H(m^\\star_z) \\neq H(m_z - m_x m_y + \\delta_z)$.\n\n-----\n\n散列值的使用提高了效率，减少了通信的开销。\n\n对于正确性，首先考虑腐败的 $P_0$ 不正确地共享使得 $\\gamma_{xy} = \\lambda_x \\lambda_y + \\Delta$ 的情况，其中 $\\Delta$ 是 $P_0$ 引入的不为零的干扰。这种情况在执行 $\\prod _{\\rm prc}$ 就会被检测到，因为最终计算出来并重构的 $\\tau \\neq 0$。同样的， $P_1$（或 $P_2$）在协议 $\\prod ^{\\rm m}_{\\rm Mul}$ 离线阶段的第四步时发送 $\\chi_1 + \\Delta$（或 $\\chi_2 + \\Delta$） 给 $P_0$ 使其重构的 $\\chi' = \\chi + \\Delta$，也会导致 $\\tau \\neq 0$ 从而被诚实方发现并中止计算。\n\n然后是另一种情况，假如 $P_1$（或 $P_2$）在重构 $m_z$ 时发送了错误的 $[m_z]_{P_i}$ 给另一方，会在最后一步验证哈希值是否相等的时候被检测出来；而在在线阶段第二步中 $P_0$ 对 $m^{\\star}_x,m^{\\star}_y$ 的一致性检查也确保了它所计算出来的 $m^{\\star}_z$ 是正确的。\n\n\n\n#### 公平的实现\n\n作者通过一种公平重构协议 $\\prod_{\\rm fRec}$ 来重构电路输出，将 $\\prod ^{\\rm m}_{\\rm 3pc}$ 的安全性提高到公平，保证交易的三方都不能通过损害别人的利益而得到自己不应得的利益。这里使用到了承诺方案，还是利用了服务器之间的公共随机源并使用PRF来为承诺方案引入随机性：\n\n-----\n\n**Offline:**\n\n* Parties $P_0, P_1$ locally sample a random $r_1 \\in \\mathbb{Z}_{2^l}$, prepare and send commitments of $\\lambda_{y,1}$ and $r_1$ to $P_2$. Similarly, parties $P_0, P_2$ locally sample a random $r_2 \\in \\mathbb{Z}_{2^l}$, prepare and send commitments of $\\lambda_{y,2}$ and $r_2$ to $P_1$. The randomness needed for both commitments are sampled from the PRF key-setup.\n* $P_1$ (resp. $P_2$) aborts if the received commitments mismatch.\n\n**Online:**\n\n* $P_1, P_2$ compute a commitment of $m_y$ using randomness sampled from their PRF key-setup and send it to $P_0$.\n* If the commitments do not match, $P_0$ sends (**abort**, $o_1$) to $P_2$, while it sends (**abort**, $o_2$) to $P_1$ and aborts, where $o_i$ denotes the opening information for the commitment of $r_i$. Else $P_0$ sends **continue** to both $P_1$ and $P_2$.\n* $P_1, P_2$ exchange the messages received from $P_0$.\n* $P_1$ aborts if it receives either (i) (**abort**, $o_2$) from $P_0$ and $o_2$ opens the commitment of $r_2$ or (ii) (**abort**, $o_1$) from $P_2$ and $o_1$ is the correct opening information of $r_1$. The case for $P_2$ is similar to that of $P_1$.\n* If no abort happens, parties obtain their missing share of $a$ as follows:\n  * $P_0, P_1$ open $\\lambda_{y,1}$ towards $P_2$.\n  * $P_0, P_2$ open $\\lambda_{y,2}$ towards $P_1$.\n  * $P_1, P_2$ open $m_y$ towards $P_0$.\n* Parties reconstruct the value $y$ using missing share that matches with the agreed upon commitment.\n\n-----\n\n当没有广播频道的时候，一个非常棘手的问题就会存在：一个腐败的 $P_0$ 可以发送不同的信号给 $P_1$ 和 $P_2$（一个为 abort 而另一个为 continue），以上的重构协议 $\\prod_{\\rm fRec}([\\![y]\\!], \\mathcal{P})$ 解决了这个问题。在离线阶段 $P_0$ 和 $P_1$ 共同计算出一个关于 $r_1$ 的承诺发送给 $P_2$，同样地 $P_0$ 和 $P_2$ 共同计算出一个关于 $r_2$ 的承诺发送给 $P_1$。这两个承诺就可以确保 $P_1$ 跟 $P_2$ 可以验证它们收到的来自 $P_0$ 的信号是否一致：例如当 $P_1$ 收到 abort 而 $P_2$ 收到 continue，在它们交换信息时，$P_1$ 就可以利用收到的 $o_2$ 证明自己收到了 abort 信号，反过来也是一样的。同时还解决了一个问题，就是当一个腐败的 $P_1$ 收到了 $P_0$ 发送的 continue 信号，但它不能在与 $P_2$ 交换信息时宣称自己收到了 abort 信号，因为它没有 $o_2$，因此无法证明，对于 $P_2$ 腐败的情况也是一样的。\n\n这里的承诺方案可以通过一个哈希函数来实现，例如：$(c, o) = (\\mathcal{H}(x||r),x||r) = Com(x;r)$\n\n\n\n## 隐私保护机器学习\n\n### 模型\n\n对于每一个预测函数，模型拥有者 $\\rm M$ 拥有一个训练好的参数向量，想为拥有一个查询向量的客户 $\\rm C$ 提供预测服务。在服务器辅助设置中，$\\rm M$ 和 $\\rm C$ 以共享方式将各自的输入外包给三个不受信任但非合谋的服务器 $\\{P_0, P_1, P_2\\}$，这些服务器通过为本文的3PC协议开发的技术以共享方式执行计算，并将输出单独重构到客户端。客户只能知道输出，除此之外什么也不知道。\n\n\n\n### 对于ML的协议\n\n#### 安全向量点积\n\n对于向量的 $[\\cdot]$-共享和 $[\\![\\cdot]\\!]$-共享，就是对应每个维度的值进行$[\\cdot]$-共享和 $[\\![\\cdot]\\!]$-共享，容易知道对于向量来说两种共享仍然是线性的。对于两个 $d$ 维向量的点积，不考虑效率的情况下可以执行 $d$ 次 $\\prod ^{\\rm s}_{\\rm Mul}$协议，再对这 $d$ 次执行的结果简单进行相加，各方就可以得到它们的份额。在这里作者给出一个更高效率的向量点积协议 $\\prod ^{\\rm s}_{\\rm dp}$：\n\n-----\n\n**Offline:**\n\n​\t\t$P_0, P_1$ sample random $\\lambda_{u,1}, \\gamma_{pq,1} \\in \\mathbb{Z}_{2^l}$, while $P_0, P_2$ sample random $\\lambda_{u,2} \\in \\mathbb{Z}_{2^l}$. $P_0$ locally computes $\\gamma_{pq} = \\vec{\\lambda_p} \\odot \\vec{\\lambda_q}$, sets $\\gamma_{pq,2} = \\gamma_{pq} - \\gamma_{pq,1}$ and sends $\\gamma_{pq,2}$ to $P_2$.\n\n**Online:**\n\n* $P_i$ for $i \\in \\{1,2\\}$ locally computes $[m_u]_{P_i} = \\sum^d_{j=1}((i-1)m_{p_j}m_{q_j} - m_{p_j}[\\lambda_{q_j}]_{P_i} - m_{q_j}[\\lambda_{p_j}]_{P_i}) + [\\gamma_{pq}]_{P_i} + [\\lambda_u]_{P_i}$.\n* $P_1$ and $P_2$ mutually exchange their share of $[m_u]$ to reconstruct $m_u$.\n\n-----\n\n上面的协议的离线阶段中，$P_0$ 仅仅共享了 $\\gamma_{pq} = \\vec{\\lambda_p} \\odot \\vec{\\lambda_q}$ 而不是每一个 $\\lambda_{p_i} \\lambda_{q_i}$；在在线阶段，$P_1, P_2$ 直接计算 $[m_u]$（其中 $u = \\vec{p} \\odot \\vec{q}$）而不是每一个 $m_{p_i q_i}$。\n\n\n\n接下来作者还对恶意设置下的点积进行了讨论：由于在乘法协议中引入了对恶意对手的额外检查，所以上面针对半诚实协议所作的优化是不适用的。对两个 $d$ 维向量的点积，只能 $d$ 次调用协议 $\\prod ^{\\rm m}_{\\rm Mul}$。不过作者还是对在线阶段的开销进行了改进：在在线阶段 $P_1$ 并行地发送 $m^{\\star}_{p_i}, m^{\\star}_{q_i}$ 给 $P_0$，而 $P_2$ 则发送对应的哈希值给 $P_0$。$P_0$ 收到这些值后进行验证，若一致则将它们“结合”所有的 $m^{\\star}_{p_i q_i}$ 然后发送一个单独的 $m^\\star_u$ 的哈希值给 $P_1, P_2$，最后 $P_1, P_2$ 在本地验证是否与 $m_u - \\sum^d_{j=1}(m_{p_j}m_{q_j} - \\delta_{u_j})$。这样做的话就节省了在线阶段的开销，不用每个 $m^{\\star}_{p_i}, m^{\\star}_{q_i}$ 都发送一次。\n\n\n\n#### 安全比较\n\n给定算术共享 $[\\![u]\\!], [\\![v]\\!]$，各方希望验证 $u$ 是否小于 $v$，等同于验证 $a$ 是否小于 $0$（其中 $a = u - v$），在定点表示中可以通过检查 ${\\rm msb}(a)$ 来完成（二进制补码中第一位为符号位）。于是可以把在给定算术共享 $[\\![a]\\!]$ 的情况下生成 ${\\rm msb}(a)$ 的布尔共享作为目标，在这里作者利用了秘密共享方案中的不对称性，放弃了 *SecureML*[48]和 *ABY3*[46]中的昂贵协议。\n\n-----\n\n**Offline:**\n\n​\t\t$P_1, P_2$ together sample a random $r, r' \\in \\mathbb{Z}_{2^l}$ and set $p= \\rm{msb}$$(r)$. Parties non-interactively generate Boolean share of $p$ as $[\\![p]\\!]^{\\rm B}_{P_0} = (0,0)$, $[\\![p]\\!]^{\\rm B}_{P_1} = (p,0)$ and $[\\![p]\\!]^{\\rm B}_{P_2} = (p,0)$.\n\n**Online:**\n\n​\t\t$P_1$ set $[a]_{P_1}=m_a - \\lambda_{a,1}$, $P_2$ set $[a]_{P_2}=- \\lambda_{a,2}$.\n\n* $P_1$ sends $[ra]_{P_1} = r[a]_{P_1} + r'$ to $P_0$, while $P_2$ sends $[ra]_{P_2} = r[a]_{P_1} - r'$ to $P_0$, who adds them to obtain $ra$.\n* $P_0$ executes $\\prod^{\\rm s}_{\\rm Sh}(P_0, q)$ over $\\mathbb{Z}_{2^1}$ to generate $[\\![q]\\!]^{\\rm B}$ where $q = {\\rm msb}(ra)$.\n* Parties locally compute $[\\![\\mbox{msb}(a)]\\!]^{\\rm B} = [\\![p]\\!]^{\\rm B} \\oplus [\\![q]\\!]^{\\rm B}$.\n\n-----\n\n上面的协议用 $\\prod ^{\\rm s}_{\\rm BitExt}([\\![a]\\!], \\mathcal{P})$ 表示。这里上面用到了一个随机数 $r$ 来对 $a$ 的值进行盲化，并且可以注意到 ${\\rm sign}(a \\cdot r) = {\\rm sign}(a) \\oplus {\\rm sign}(r)$，所以 $r$ 不会对生成共享份额造成影响且使得三者都不能从这个过程中知道关于 $a$ 的信息。\n\n对于恶意的情况，就不能仅仅依靠 $P_0$ 来生成 $[\\![{\\rm msb}(ra)]\\!]^{\\rm B}$，下面给出了修改后的协议 $\\prod ^{\\rm m}_{\\rm BitExt}([\\![a]\\!], \\mathcal{P})$：\n\n-----\n\n**Offline:**\n\n​\t\t$P_1, P_2$ sample a random $r_1 \\in \\mathbb{Z}_{2^l}$ and set $p_1 = {\\rm msb}(r_1)$ while $P_0, P_2$ sample a random $r_2 \\in \\mathbb{Z}_{2^l}$ and set $p_2 = {\\rm msb}(r_2)$.\n\n* Parties non-interactively generate $[\\![\\cdot]\\!]$-shares of $r_1$ as $[\\![r_1]\\!]_{P_0}=(0,0)$, $[\\![r_1]\\!]_{P_1}=(r_1,0)$ and $[\\![r_1]\\!]_{P_2}=(r_1,0)$.\n* Parties non-interactively generate $[\\![\\cdot]\\!]$-shares of $r_1$ as $[\\![r_2]\\!]_{P_0}=(0,-r_2)$, $[\\![r_1]\\!]_{P_1}=(0,0)$ and $[\\![r_1]\\!]_{P_2}=(0,-r_2)$.\n* Parties execute $\\prod^{\\rm m}_{\\rm Mul}$ on $r_1$ and $r_2$ to generate $[\\![r]\\!] = [\\![r_1 r_2]\\!]$.\n* Parties non-interactively generate Boolean shares of $p_1$ as $[\\![p_1]\\!]^{\\rm B}_{P_0}=(0,0)$, $[\\![p_1]\\!]^{\\rm B}_{P_1}=(p_1,0)$ and $[\\![p_1]\\!]^{\\rm B}_{P_2}=(p_1,0)$.\n* Parties non-interactively generate Boolean shares of $p_2$ as $[\\![p_2]\\!]^{\\rm B}_{P_0}=(0,p_2)$, $[\\![p_2]\\!]^{\\rm B}_{P_1}=(0,0)$ and $[\\![p_2]\\!]^{\\rm B}_{P_2}=(0,p_2)$.\n* Parties locally compute $[\\![p]\\!]^{\\rm B}=[\\![p_1]\\!]^{\\rm B} \\oplus [\\![p_2]\\!]^{\\rm B}$.\n\n**Online:**\n\n* Parties execute $\\prod ^{\\rm m}_{\\rm Mul}$ on $[\\![r]\\!]$ and $[\\![a]\\!]$ to generate $[\\![ra]\\!]$ followed by enabling $P_0, P_1$ to reconstruct $ra$ (this is done by slightly modifying the protocol $\\prod ^{\\rm m}_{\\rm Rec}$ ).\n* $P_1$ executes $\\prod ^{\\rm m}_{\\rm Sh}(P_1, q)$ over $\\mathbb{Z}_{2^1}$ to generate $[\\![q]\\!]^{\\rm B}$ where $q = {\\rm msb}(ra)$. In parallel, $P_0$ locally computes $m_q$ and sends ${\\rm H}(m_q)$ to $P_2$, who abort if the value mismatches with the hash of the value $m_q$ received from $P_1$ as part of $\\prod ^{\\rm m}_{\\rm Sh}(P_1, q)$.\n* Parties locally compute $[\\![{\\rm msb}(a)]\\!]^{\\rm B} = [\\![p]\\!]^{\\rm B} \\oplus [\\![q]\\!]^{\\rm B}$.\n\n-----\n\n\n\n#### ML预测函数\n\n* **线性回归**：$\\rm M$ 有一个 $d$ 维的模型参数向量 $\\vec{w}$ 和偏置项 $b$，$\\rm C$ 有一个 $d$ 维的查询向量 $\\vec{z}$。$\\rm C$ 获得 $f_{\\rm linr}((\\vec{w}, b),\\vec{z}) = \\vec{w} \\odot \\vec{z} + b$，其中 $\\vec{w} \\odot \\vec{z}$ 是向量 $\\vec{w}$ 和向量 $\\vec{z}$ 的点积；\n* **SVM回归**：$\\rm M$ 有$\\{\\alpha_j, y_j \\}^k_{j=1}$ 和 $d$ 维的支持向量 $\\{\\vec{x_j}\\}^k_{j=1}$，$\\rm C$ 有一个 $d$ 维的查询向量 $\\vec{z}$。$\\rm C$ 获得 $f_{\\rm svmr}((\\{\\alpha_j, y_j, \\vec{x_j} \\}^k_{j=1}, b), \\vec{z}) = \\sum^k_{j=1} \\alpha_j y_j (\\vec{x_j} \\odot \\vec{z}) + b$；\n* **逻辑回归**：$\\rm M$ 和 $\\rm C$ 的输入和线性回归类似，$\\rm M$ 还需要提供一个在 $[0,1]$ 范围内的额外输入 $t$。$\\rm C$ 获得 $f_{\\rm logr}((\\vec{w}, b, t), \\vec{z}) = {\\rm sign}((\\vec{w} \\odot \\vec{z} + b) - {\\rm ln}(\\frac{t}{1-t}))$，其中 ${\\rm sign}(\\cdot)$ 返回对象的符号位；\n* **SVM分类**：$\\rm M$ 和 $\\rm C$ 的输入和SVM回归一样，但对 $\\rm C$ 的输出变为 $f_{\\rm svmr}((\\{\\alpha_j, y_j, \\vec{x_j} \\}^k_{j=1}, b), \\vec{z}) = {\\rm sign}(\\sum^k_{j=1} \\alpha_j y_j (\\vec{x_j} \\odot \\vec{z}) + b)$。\n\n\n\n## 参考文献\n\n[1] V. A. Abril, P. Maene, N. Mertens, and N. P. Smart. 2019. *Bristol Fashion MPC Circuits.* https://homes.esat.kuleuven.be/~nsmart/MPC/.\n[2] T. Araki, A. Barak, J. Furukawa, T. Lichter, Y. Lindell, A. Nof, K. Ohara, A. Watzman, and O. Weinstein. 2017. *Optimized Honest-Majority MPC for Malicious Adversaries - Breaking the 1 Billion-Gate Per Second Barrier.* In IEEE S&P. 843–862.\n[3] T. Araki, A. Barak, J. Furukawa, Y. Lindell, A. Nof, and K. Ohara. 2016. *DEMO: High-Throughput Secure Three-Party Computation of Kerberos Ticket Generation.* In ACM CCS. 1841–1843.\n[4] T. Araki, J. Furukawa, Y. Lindell, A. Nof, and K. Ohara. 2016. *High-Throughput Semi-Honest Secure Three-Party Computation with an Honest Majority.* In ACM CCS. 805–817.\n[5] C. Baum, I. Damgård, T. Toft, and R. W. Zakarias. 2016. *Better Preprocessing for Secure Multiparty Computation.* In ACNS. 327–345.\n[6] D. Beaver. 1991. *Efficient Multiparty Protocols Using Circuit Randomization.* In CRYPTO. 420–432.\n[7] D. Beaver. 1995. *Precomputing Oblivious Transfer.* In CRYPTO. 97–109.\n[8] Z. Beerliová-Trubíniová and M. Hirt. 2006. *Efficient Multi-party Computation with Dispute Control.* In TCC. 305–328.\n[9] Z. Beerliová-Trubíniová and M. Hirt. 2008. *Perfectly-Secure MPC with Linear Communication Complexity.* In TCC. 213–230.\n[10] M. Ben-Or, S. Goldwasser, and A. Wigderson. 1988. *Completeness Theorems for Non-Cryptographic Fault-Tolerant Distributed Computation (Extended Abstract).* In ACM STOC. 1–10.\n[11] Christopher Bishop. 2006. *Pattern Recognition and Machine Learning.*\n[12] D. Bogdanov, S. Laur, and J. Willemson. 2008. *Sharemind: A Framework for Fast Privacy-Preserving Computations.* In ESORICS. 192–206.\n[13] D. Bogdanov, R. Talviste, and J. Willemson. 2012. *Deploying Secure Multi-Party Computation for Financial Data Analysis.* In FC. 57–64.\n[14] M. Byali, A. Joseph, A. Patra, and D. Ravi. 2018. *Fast Secure Computation for Small Population over the Internet.* ACM CCS (2018), 677–694.\n[15] O. Catrina and S. de Hoogh. 2010. *Secure Multiparty Linear Programming Using Fixed-Point Arithmetic.* In ESORICS. 134–150.\n[16] N. Chandran, J. A. Garay, P. Mohassel, and S. Vusirikala. 2017. *Efficient, Constant-Round and Actively Secure MPC: Beyond the Three-Party Case.* In ACM CCS. 277–294.\n[17] H. Chaudhari, A. Choudhury, A. Patra, and A. Suresh. 2019. *ASTRA: High-throughput 3PC over Rings with Application to Secure Prediction.* https://eprint.iacr.org/2019/429. In IACR Cryptology ePrint Archive.\n[18] K. Chida, D. Genkin, K. Hamada, D. Ikarashi, R. Kikuchi, Y. Lindell, and A. Nof. 2018. *Fast Large-Scale Honest-Majority MPC for Malicious Adversaries.* In CRYPTO. 34–64.\n[19] A. Choudhury and A. Patra. 2017. *An Efficient Framework for Unconditionally Secure Multiparty Computation.* IEEE Trans. Information Theory (2017), 428–468.\n[20] R. Cleve. 1986. *Limits on the Security of Coin Flips when Half the Processors Are Faulty (Extended Abstract).* In ACM STOC. 364–369.\n[21] R. Cramer, I. Damgård, D. Escudero, P. Scholl, and C. Xing. 2018. *SPDZ2k: Efficient MPC mod 2ˆk for Dishonest Majority.* CRYPTO (2018), 769–798.\n[22] R. Cramer, I. Damgård, and Y. Ishai. 2005. *Share Conversion, Pseudorandom Secret-Sharing and Applications to Secure Computation.* In TCC. 342–362.\n[23] Cryptography and Privacy Engineering Group at TU Darmstadt. 2017. ENCRYPTO Utils. https://github.com/encryptogroup/ENCRYPTO_utils.\n[24] M. Dahl. 2018. *Private Image Analysis with MPC: Training CNNs on Sensitive Data using SPDZ.* (2018).\n[25] I. Damgård, C. Orlandi, and M. Simkin. 2018. *Yet Another Compiler for Active Security or: Efficient MPC Over Arbitrary Rings.* CRYPTO (2018), 799–829.\n[26] I. Damgård, V. Pastro, N. P. Smart, and S. Zakarias. 2012. *Multiparty Computation from Somewhat Homomorphic Encryption.* In CRYPTO. 643–662.\n[27] S. de Hoogh, B. Schoenmakers, P.Chen, and H. Akker. 2014. *Practical Secure Decision Tree Learning in a Teletreatment Application.* In FC. 179–194.\n[28] H. Eerikson, M. Keller, C. Orlandi, P. Pullonen, J. Puura, and M. Simkin. 2019. *Use your Brain! Arithmetic 3PC For Any Modulus with Active Security.* IACR\nCryptology ePrint Archive (2019).\n[29] A. Esteva, B. Kuprel, R. A. Novoa, J. Ko, S. M. Swetter, H. M. Blau, and S. Thrun. 2017. *Dermatologist-level classification of skin cancer with deep neural networks.* Nature (2017), 115–118.\n[30] J. Furukawa, Y. Lindell, A. Nof, and O. Weinstein. 2017. *High-Throughput Secure Three-Party Computation for Malicious Adversaries and an Honest Majority.* In EUROCRYPT. 225–255.\n[31] A. Gascón, P. Schoppmann, B. Balle, M. Raykova, J. Doerner, S. Zahur, and D. Evans. 2016. *Secure Linear Regression on Vertically Partitioned Datasets.* IACR Cryptology ePrint Archive (2016).\n[32] M. Geisler. 2007. *Viff: Virtual ideal functionality framework.*\n[33] O. Goldreich, S. Micali, and A. Wigderson. 1987. *How to Play any Mental Game or A Completeness Theorem for Protocols with Honest Majority.* In STOC. 218–229.\n[34] S. D. Gordon, S. Ranellucci, and X. Wang. 2018. *Secure Computation with Low Communication from Cross-Checking.* In ASIACRYPT. 59–85.\n[35] Y. Ishai, R. Kumaresan, E. Kushilevitz, and A. Paskin-Cherniavsky. 2015. *Secure Computation with Minimal Interaction, Revisited.* In CRYPTO. 359–378.\n[36] S. Kamara, P. Mohassel, and M. Raykova. 2011. *Outsourcing Multi-Party Computation.* IACR Cryptology ePrint Archive (2011).\n[37] J. Katz, V. Kolesnikov, and X. Wang. 2018. *Improved Non-Interactive Zero Knowledge with Applications to Post-Quantum Signatures.* In CCS. 525–537.\n[38] M. Keller, E. Orsini, and P. Scholl. 2016. *MASCOT: Faster Malicious Arithmetic Secure Computation with Oblivious Transfer.* In ACM CCS. 830–842.\n[39] M. Keller, V. Pastro, and D. Rotaru. 2018. *Overdrive: Making SPDZ Great Again.* In EUROCRYPT. 158–189.\n[40] J. Launchbury, D. Archer, T. DuBuisson, and E. Mertens. 2014. *Application-Scale Secure Multiparty Computation.* In ESOP. 8–26.\n[41] S. Laur, H. Lipmaa, and T. Mielikäinen. 2006. *Cryptographically private support vector machines.* In ACM SIGKDD. 618–624.\n[42] Yann LeCun and Corinna Cortes. 2010. *MNIST handwritten digit database.* (2010). http://yann.lecun.com/exdb/mnist/\n[43] Y. Lindell and A. Nof. 2017. *A Framework for Constructing Fast MPC over Arithmetic Circuits with Malicious Adversaries and an Honest-Majority.* In ACM CCS. 259–276.\n[44] J. Liu, M. Juuti, Y. L., and N. Asokan. 2017. *Oblivious Neural Network Predictions via MiniONN Transformations.* In ACM CCS. 619–631.\n[45] E. Makri, D. Rotaru, N. P. Smart, and F. Vercauteren. 2018. *EPIC: Efficient Private Image Classification (or: Learning from the Masters).* CT-RSA (2018), 473–492.\n[46] P. Mohassel and P. Rindal. 2018. *ABY3: A Mixed Protocol Framework for Machine Learning.* In ACM CCS. 35–52.\n[47] P. Mohassel, M. Rosulek, and Y. Zhang. 2015. *Fast and Secure Three-party Computation: Garbled Circuit Approach.* In CCS. 591–602.\n[48] P. Mohassel and Y. Zhang. 2017. *SecureML: A System for Scalable Privacy-Preserving Machine Learning.* In IEEE S&P. 19–38.\n[49] V. Nikolaenko, S. Ioannidis, U. Weinsberg, M. Joye, N. Taft, and D. Boneh. 2013. *Privacy-preserving matrix factorization.* In ACM CCS. 801–812.\n[50] V. Nikolaenko, U. Weinsberg, S. Ioannidis, M. Joye, D. Boneh, and N. Taft. 2013. *Privacy-Preserving Ridge Regression on Hundreds of Millions of Records.* In IEEE S&P. 334–348.\n[51] P. S. Nordholt and M. Veeningen. 2018. *Minimising Communication in Honest-Majority MPC by Batchwise Multiplication Verification.* In ACNS. 321–339.\n[52] T. Orekondy, B. Schiele, and M. Fritz. 2018. *Knockoff Nets: Stealing Functionality of Black-Box Models.* CoRR (2018).\n[53] N. Papernot, P. McDaniel, I. Goodfellow, S. Jha, Z. B. Celik, and A. Swami. 2017. *Practical Black-Box Attacks Against Machine Learning.* In ASIA CCS. 506–519.\n[54] A. Patra and D. Ravi. 2018. *On the Exact Round Complexity of Secure Three-Party Computation.* CRYPTO (2018), 425–458.\n[55] M. S. Riazi, C. Weinert, O. Tkachenko, E. M. Songhori, T. Schneider, and F. Koushanfar. 2018. *Chameleon: A Hybrid Secure Computation Framework for Machine Learning Applications.* In AsiaCCS. 707–721.\n[56] F. Schroff, D. Kalenichenko, and J. Philbin. 2015. *FaceNet: A unified embedding for face recognition and clustering.* In IEEE CVPR. 815–823.\n[57] N. P. Smart and T. Wood. 2019. *Error Detection in Monotone Span Programs with Application to Communication-Efficient Multi-party Computation.* In CT-RSA. 210–229.\n[58] F. Tramèr, F. Zhang, A. Juels, M. K. Reiter, and T. Ristenpart. 2016. *Stealing Machine Learning Models via Prediction APIs.* In USENIX. 601–618.\n[59] S. Wagh, D. Gupta, and N. Chandran. 2019. *SecureNN: 3-Party Secure Computation for Neural Network Training.* PoPETs (2019), 26–49.\n[60] A. C. Yao. 1982. *Protocols for Secure Computations.* In FOCS. 160–164.","source":"_posts/论文笔记-ASTRA-High-Throughput-3PC-over-Rings-with-Application-to-Secure-Prediction.md","raw":"---\ntitle: >-\n  论文笔记 ASTRA: High Throughput 3PC over Rings with Application to Secure\n  Prediction\ndate: 2020-04-20 21:37:26\ncategories: Papers\ntags: [MPC, Neural Network, PPML, 密码学, SVM, Linear Regression, Logistic Regression, Secret Sharing]\n---\n\n*Harsh Chaudhari, Ashish Choudhury, Arpita Patra, Ajith Suresh*\n\nACM CCSW 2019\n\nhttps://eprint.iacr.org/2019/429\n\nhttps://dl.acm.org/doi/10.1145/3338466.3358922\n\n<!--more-->\n\n\n\n![](http://images.yingwai.top/picgo/ASTRA.jpg)\n\n\n\n## 介绍\n\n### 摘要\n\n安全计算的具体效率一直是近年来许多工作关注的焦点。在本论文中，作者提出了一种具体有效的协议，用于模 $2^l$ 整数环上的安全三方计算（3PC），该协议具有半诚实模型和恶意模型上的安全性。由于环上的计算模拟了现实系统体系结构上的计算，所以环上的安全计算近来获得了发展势头。\n\n​\t\t在离线-在线模式中，本文的结构具体地呈现了最有效的在线阶段。在半诚实的设置下，本文的协议在在线阶段每个乘法门需要2个环元素的通信。在恶意设置下，本文的协议在在线阶段每个乘法门需要4个元素的通信，比最先进的协议需要的5个元素少。使用选择性中止和公平这两个安全概念来实现的公平恶意协议，与仅针对输出门的中止安全性的恶意协议相比，涉及的通信稍微多一些。\n\n​\t\t作者将本文的技术从3PC应用到安全的服务器辅助机器学习（ML）推理机制中，用于一系列预测函数——线性回归、线性SVM回归、Logistic回归和线性SVM分类。本文的设置考虑了拥有训练好的模型参数的模型所有者和查询的客户，后者愿意根据前者的模型参数来学习他查询的预测。输入和计算外包给一组三个非合谋的服务器。本文的构造既迎合了半诚实的世界，也迎合了恶意的世界，比现有的构造表现得更好。\n\n\n\n\n### 贡献\n\n* 作者遵循离线-在线模式，提出了在环 $\\mathbb{Z}_{2^l}$（包括布尔环 $\\mathbb{Z}_{2^1}$）上的3PC构造，具有最有效的在线阶段。\n\n  虽然重点放在在现阶段，但离线阶段的的成本也有注意并保持在可控范围内。\n\n* 作者给出了一系列满足半诚实安全和恶意安全的构造。\n\n  将技术应用于外包环境中的一系列预测函数的安全预测，并构建了一些容忍半诚实和恶意对手的结构。\n\n本文所有的构建都流露出的一个共同特征：在线阶段不到三对参与者之间需要进行功能依赖的通信，从而产生更好的在线性能。\n\n\n\n## 设定\n\n本文考虑一组三方 $\\mathcal{P}=\\left\\{P_0,P_1,P_2\\right\\}$，它们在同步网络中通过成对的私有和可信信道连接。要计算的函数 $f$ 被表示为环 $\\mathbb{Z}_{2^l}$ 上的电路 ckt，该环由2输入加法和乘法门组成。假设 ckt 的拓扑是公知的。术语 D​ 表示 ckt 的乘法深度，而 I、O、A、M 分别表示 ckt 中的输入线、输出线、加法门和乘法门的数目。本文使用符号 $w_x$ 来表示导线 $w$，其中值 $x$ 流经它。本文使用 $g=(w_x,w_y,w_z)$ 来表示 ckt 中具有左输入线 $w_x$、右输入线 $w_y$ 和输出线 $w_z$ 的门。在本文的协议中，将 $\\mathcal{P}$ 划分为互不相交的集合 $\\left\\{P_0\\right\\}$ 和 $\\left\\{P_1,P_2\\right\\}$，其中 $P_0$ 在离线阶段充当“分配器”进行“预处理”，在线阶段“评估者” $P_1$、$P_2$ 用它来评估 ckt。本文使用上标“$s$”和“$m$”分别区分半诚实和恶意设置中的协议。布尔环 $\\mathbb{Z}_{2^1}$ 上的协议可以通过将算术加法$(+)$和乘法$(\\times)$分别替换为异或$(\\oplus)$和与$(\\cdot)$来获得。\n\n\n\n### 共享密钥设置\n\n为了保存双方之间的通信，使用为伪随机函数（PRF）$F$ 建立预共享随机密钥的一次性设置。在3PC设置[2，30，46]中的已知协议中已经使用了类似的设置。这里 $F:{\\{0，1\\}}^\\kappa \\times {\\{0，1\\}}^\\kappa \\to X$ 是安全的PRF，同域 $X$ 是 $\\mathbb{Z}_{2^l}$。这组密钥是：\n\n* 每对参与方之间共享一个密钥— $k_{01}, k_{02}, k_{12}$，分别用于参与方$(P_0,P_1), (P_0,P_2), (P_1,P_2)$。\n* 所有各方之间的一个共享密钥— $k_{\\mathcal{p}}$。\n\n本文通过可以使用任何标准安全MPC协议实现的功能 $\\mathcal{F}_{\\rm setup}$ 来建立密钥设置模型。\n\n\n\n### 共享语义\n\n在本节中，将解释本工作中使用的秘密共享的两种变体。这两个变体都在算术（$\\mathbb{Z}_{2^l}$）和布尔环（$\\mathbb{Z}_{2^1}$）上运行。\n\n$[\\cdot]$-共享：如果 $P_1$ 和 $P_2$ 分别持有份额 $v_1$ 和 $v_2$，使得 $v=v_1+v_2$，则称值 $v$ 在$P_1,P_2$之间是 $[\\cdot]$-共享的。用 $[\\cdot]_{P_i}$ 表示 $P_i, i∈\\{1,2\\}$的 $[\\cdot]$-份额。\n\n$[\\![\\cdot]\\!]$-共享：值 $v$ 在 $P_0, P_1, P_2$ 之间是$[\\![\\cdot]\\!]$-共享的，如果\n\n* 存在值 $\\lambda_v, m_v$ 使得 $v=m_v - \\lambda_v$；\n* $P_0$ 持有 $\\lambda_{v,1}$ 和 $\\lambda_{v,2}$ 使得 $\\lambda_{v} = \\lambda_{v,1} + \\lambda_{v,2}$；\n* $P_1$ 和 $P_2$ 分别持有 $(m_v, \\lambda_{v,1})$ 和 $(m_v, \\lambda_{v,1})$。\n\n本文将各方的$[\\![\\cdot]\\!]$-共享表示为$[\\![v]\\!]_{P_0} = (\\lambda_{v,1}, \\lambda_{v,2}), [\\![v]\\!]_{P_1} = (m_v, \\lambda_{v,1}) $和 $[\\![v]\\!]_{P_2} = (m_v, \\lambda_{v,2})$。用$[\\![v]\\!] = (m_v, [\\lambda_{v}])$表示 $v$ 的$[\\![\\cdot]\\!]$-共享份额。\n\n\n\n### 秘密共享方案的线性\n\n给定 $x,y \\in \\mathbb{Z}_{2^l}$ 和公共常数 $c_1, c_2 \\in \\mathbb{Z}_{2^l}$的$[\\cdot]$-共享，各方可以局部计算 $[c_1x+c_2y]$：\n\n$$[c_1x+c_2y]=(c_1x_1+c_2y_1, c_1x_2+c_2y_2)=c_1[x]+c_2[y]$$\n\n很容易看出线性关系也扩展到$[\\![\\cdot]\\!]$-共享。线性属性使各方能够**本地**执行与公共常量的加法和乘法等操作。\n\n\n\n## 3PC协议\n\n### 半诚实下的3PC\n\n协议 $\\prod ^{\\rm s}_{\\rm 3pc}$ 由三个步骤组成—输入共享、电路评估以及输出重构。所有阶段（重构输出除外）都分为离线和在线阶段，其中独立于实际输入的步骤可以在脱机阶段执行。\n\n\n\n#### 输入共享\n\n在共享输入阶段，每一方都为自己的输入生成一个随机的$[\\![\\cdot]\\!]$-共享。以下是初始共享协议 $\\prod^{\\rm s}_{\\rm Sh}$：\n\n-----\n\n**Offline:**\n\n- If $P_i = P_0$, parties $P_0, P_j$ for $j \\in \\{1, 2\\}$ locally sample a random $\\lambda_{x,j} \\in \\mathbb{Z}_{2^l}$. Moreover, $P_i$ sets $[\\![x]\\!]_{P_i} = (\\lambda_{x,1}, \\lambda_{x,2})$.\n- If $P_i = P_1$, parties $P_0, P_1$ sample a random $\\lambda_{x,1} \\in \\mathbb{Z}_{2^l}$ while all the parties in $\\mathcal{P}$ sample a random $\\lambda_{x,2} \\in \\mathbb{Z}_{2^l}$.\n- If $P_i = P_2$, parties $P_0, P_2$ sample a random $\\lambda_{x,2} \\in \\mathbb{Z}_{2^l}$ while all the parties in $\\mathcal{P}$ sample a random $\\lambda_{x,1} \\in \\mathbb{Z}_{2^l}$.\n\n**Online:**\n\n​\t\t$P_i$ computes $\\lambda_x = \\lambda_{x,1} + \\lambda_{x,2}$ and sends $m_x = x + \\lambda_x$ to every $P_j$ for $j \\in \\{1,2\\}$ who then sets $[\\![x]\\!]_{P_j} = (m_x, \\lambda_{x,j})$.\n\n-----\n\n在离线阶段根据输入方的序号，使用不同的初始化手段，生成了 $P_0$ 的份额 $[\\![x]\\!]_{P_0}=(\\lambda_{x,1}, \\lambda_{x,2})$，而不用任何交互（因为随机数都是使用服务器两两之间的公共随机源生成的，可以理解为编程语言中把同样的随机种子输入到random函数——只要随机种子一样生成的随机数序列就一样）。\n\n\n\n#### 电路评估\n\n在电路评估阶段，各方以$[\\![\\cdot]\\!]$-共享的方式评估 ckt。以拓扑顺序评估 ckt 中的每个门 $g$：给定 $g$ 的输入，各方为 $g$ 的输出生成$[\\![\\cdot]\\!]$-共享。\n\n##### 加法\n\n如果 $g$ 是加法门 $(w_x,w_y,w_z)$，可以利用$[\\![\\cdot]\\!]$-共享的线性在本地完成。以下是加法协议 $\\prod_{\\rm Add} (w_x, w_y, w_z)$：\n\n-----\n\n**Offline:**\n\n​\t\t$P_0, P_1$ set $\\lambda_{z,1} = \\lambda_{x,1} + \\lambda_{y,1}$, while $P_0, P_2$ set $\\lambda_{z,2} = \\lambda_{x,2} + \\lambda_{y,2}$.\n\n**Online:**\n\n​\t\t$P_1$ and $P_2$ set $m_z = m_x + m_y$.\n\n-----\n\n这里的加法协议感觉在线阶段完全可以在本地完成，可以不需要在线阶段。\n\n##### 乘法\n\n如果 $g=(w_x,w_y,w_z)$ 是乘法门，则运行以下乘法协议 $\\prod ^{\\rm s}_{\\rm Mul}$：\n\n-----\n\n**Offline:**\n\n* $P_0$ and $P_1$ locally sample random $\\lambda_{z,1}, \\gamma_{xy, 1} \\in \\mathbb{Z}_{2^l}$, while $P_0$ and $P_2$ locally sample random $\\lambda_{z,2} \\in \\mathbb{Z}_{2^l}$.\n* $P_0$ computes $\\gamma_{xy} = \\lambda_x \\lambda_y$ and sends $\\gamma_{xy,2} = \\gamma_{xy} - \\gamma_{xy,1}$ to $P_2$.\n\n**Online:**\n\n* $P_i$ for $i \\in \\{1,2\\}$ locally computes $[m_z]_{P_i} = (i-1)m_xm_y - m_x[\\lambda_y]_{P_i} - m_y[\\lambda_x]_{P_i} + [\\lambda_z]_{P_i} + [\\gamma_{xy}]_{P_i}$.\n* $P_1, P_2$ mutually exchange their shares and reconstruct $m_z$.\n\n-----\n\n将上面的公式相加一下即可验证其正确性。\n\n\n\n#### 输出重构\n\n在输出重构阶段，各方重构$[\\![\\cdot]\\!]$-共享电路输出。为了重构 $[\\![y]\\!]$，可以观察到每个 $P_i$ 缺失的份额都在另外两方手里。因此另外两方的其中一方将缺失的份额发送给 $P_i$ 后，通过计算 $y = m_y - \\lambda_{y,1} - \\lambda_{y,2}$ 即可重构输出 $y$，将其称为重构协议 $\\prod ^{\\rm s}_{\\rm Rec}([\\![y]\\!], \\mathcal{P})$。\n\n把上面三个阶段总结起来，有以下的协议 $\\prod ^{\\rm s}_{\\rm 3pc}$：\n\n-----\n\n**Pre-processing (Offline Phase):**\n\n* *Input wires:* For $j = 1, ...,l$, corresponding to the circuit-input $x_j$, parties execute the offline steps of the instance $\\prod ^{\\rm s}_{\\rm Sh}(P_i, x_j)$.\n* For each gate $g$ in the topological order, execute offline steps of the instance $\\prod ^{\\rm s}_{\\rm Mul}(w_{xj}, w_{yj}, w_{zj})$ if $g$ is the $j$th multiplication gate where $j \\in \\{1,...,\\rm M\\}$ or respectively offline steps of the instance $\\prod _{\\rm Add}(w_{xj}, w_{yj}, w_{zj})$ if $g$ is the $j$th addition gate where $j \\in \\{1,...,\\rm A\\}$.\n\n**Circuit Evaluation (Online Phase):**\n\n* *Sharing Circuit-input Values:* For $j = 1, ...,l$, corresponding to the circuit-input $x_j$, parties execute the online steps of the instance $\\prod ^{\\rm s}_{\\rm Sh}(P_i, x_j)$, where $P_i$ is the party designated to provide $x_j$.\n* *Gate Evaluation:* For each gate in $g$ in ckt in the topological order, $P_1, P_2$ execute the online steps of the instance $\\prod ^{\\rm s}_{\\rm Mul}(w_{xj},w_{yj},w_{zj})$ if $g$ is the $j$th multiplication gate where $j \\in \\{1,...,\\rm M\\}$ or respectively offline steps of the instance $\\prod _{\\rm Add}(w_{xj}, w_{yj}, w_{zj})$ if $g$ is the $j$th addition gate where $j \\in \\{1,...,\\rm A\\}$.\n* *Output Reconstruction:* Let $[\\![y_1]\\!],...,[\\![y_\\rm O]\\!]$ be the shared function outputs. The parties in $\\mathcal{P}$ reconstruct $y_j$ for $j = 1,...,\\rm O$ by executing $\\prod ^{\\rm s}_{\\rm Rec}([\\![y_j]\\!], \\mathcal{P})$.\n\n-----\n\n\n\n### 恶意下的3PC\n\n跟半诚实设置下的一样，恶意设置下的3PC协议 $\\prod ^{\\rm m}_{\\rm 3pc}$ 也由输入共享、电路评估和输出重构三个部分组成。\n\n\n\n#### 输入共享和输出重构\n\n在恶意的设置下，要保证服务器之间的共享份额是一致的。在 $\\prod ^{\\rm s}_{\\rm Sh}$ 中，$\\lambda$ 的共享是一致的，因为它不需要交互就可以生成。但如果一个腐败的 $P_0$ 拥有 $x$ 并且想制造一个不一致的 $[\\![x]\\!]$-共享，它可以分别发送两个不一样的 $m_x$ 给 $P_1$ 和 $P_2$。为了检查这种情况的发生，$P_1$ 和 $P_2$ 交换 $H(m_x)$ 并在不一致的时候中止。\n\n令 $[\\![y]\\!]$ 为一个待重构的一致的共享，$[\\![y]\\!]_{P_0} = (\\lambda_{y,1}, \\lambda_{y,2})$、$[\\![y]\\!]_{P_1} = (m'_{y}, \\lambda_{y,1})$ 和 $[\\![y]\\!]_{P_2} = (m''_{y}, \\lambda_{y,2})$ 分别为三个服务器的份额。协议 $\\prod ^{\\rm m}_{\\rm Rec}([\\![y]\\!], \\mathcal{P})$ 允许每一个诚实方输出 $y$ 或 $\\perp$：\n\n-----\n\n**Online:**\n\n* $P_0$ and $P_2$ send $\\lambda_{y,2}$ and $H(\\lambda'_{y,2})$ respectively to $P_1$.\n* $P_0$ and $P_1$ send $\\lambda_{y,1}$ and $H(\\lambda'_{y,1})$ respectively to $P_2$.\n* $P_1$ and $P_1$ send $m'_{y}$ and $H(m'_{y})$ respectively to $P_0$.\n\n$P_i$ for $i \\in \\{0,1,2\\}$ abort if the received values mismatch. Else $P_i$ sets $y = m_y - \\lambda_{y,1} - \\lambda_{y,2}$.\n\n-----\n\n检查的过程中，其中一方发送哈希值可以提高效率。\n\n\n\n#### 电路评估\n\n在恶意设置下加法协议 $\\prod _{\\rm Add}$ 同样是安全的，因为它只涉及本地操作。挑战在于构造乘法协议 $\\prod ^{\\rm m}_{\\rm Mul}$，令其可以容忍其中一方腐败。可以观察到有两种情况：\n\n* $P_0$ 是腐败的：在离线阶段会令 $\\gamma_{xy} \\neq \\lambda_x \\lambda_y$\n* $P_1$ 或 $P_2$ 是腐败的：会在在线阶段扰乱，使诚实的另一方重构出一个错误的 $m_z$\n\n先看下面的情况，假如 $P_1$ 现在需要验证它重构的 $m_z$ 是否是正确的，可以向 $P_0$ 求助：$P_1$ 可以发送 $m_x, m_y$ 给 $P_0$，因为 $P_0$ 在离线阶段就已经知道 $\\lambda_x, \\lambda_y$ 和 $\\lambda_z$，因此它可以计算出 $m_z$ 并发送给 $P_1$，以此得到验证。但发送 $m_x, m_y$ 给 $P_0$ 会导致打破了原有共享的私密性，所以 $P_1$ 可以对应的值盲化后发送给 $P_0$：$m^{\\star}_x = m_x + \\delta_x$ 和 $m^{\\star}_y = m_y + \\delta_y$，然后 $P_0$ 计算 $m^{\\star}_z = -m^{\\star}_x \\lambda_y - m^{\\star}_y \\lambda_x +\\lambda_z + 2\\gamma_{xy}$。注意到：\n$$\n\\begin{align}\nm^{\\star}_z &= -m^{\\star}_x \\lambda_y - m^{\\star}_y \\lambda_x +\\lambda_z + 2\\gamma_{xy}\\\\\n &= -(m_x + \\delta_x) \\lambda_y - (m_y + \\delta_y) \\lambda_x +\\lambda_z + 2\\gamma_{xy}\\\\\n &= (m_z - m_x m_y) - \\chi\n\\end{align}\n$$\n\n假设 $P_0$ 知道 $\\chi = \\delta_x \\lambda_y + \\delta_y \\lambda_x - \\gamma_{xy}$，它就可以计算出 $m^{\\star}_z + \\chi$ 然后发送给 $P_1$。因为 $P_1$ 知道 $m_x, m_y$ 的值，因此它可以验证它重构的 $m_z$ 的正确性，对于 $P_2$ 来说也可以这样验证。\n\n现在来描述如何使 $P_0$ 获得 $\\chi$：首先直接让 $P_0$ 获得 $\\chi$ 会导致共享的私密性被破坏，因为 $P_0$ 知道 $\\lambda_x, \\lambda_y$ 和 $\\gamma_{xy}$ 的值，同时在在线阶段又得到 $m_x + \\delta_x$ 和 $m_y + \\delta_y$，导致 $P_0$ 可以推导出 $m_x, m_y$ 之间的关系。所以还要在 $\\chi$ 中加入一个随机值 $\\delta_z$ 进行盲化：$\\delta_x \\lambda_y + \\delta_y \\lambda_x + \\delta_z - \\gamma_{xy}$。\n\n生成 $\\chi$ 的过程：$P_1, P_2$ 在本地生成随机数 $\\delta_x, \\delta_y, \\delta_z \\in \\mathbb{Z}_{2^l}$，计算各自的 $\\chi$ 的 $[\\cdot]$-共享并发送给 $P_0$。对于 $i \\in \\{1,2 \\}$，令 $[\\chi]_{P_i} = \\chi_i$。$P_0$ 在本地将共享的份额相加得到 $\\chi$。在以上步骤中，腐败的一方可能会在执行过程中引入错误，使得 $P_0$ 获得的 $\\chi$ 是错误的。\n\n总而言之在离线阶段有两个问题需要解决：\n\n* 腐败的 $P_0$ 可以不正确地共享 $\\gamma_{xy}$\n* 腐败的 $P_1$ 或 $P_2$ 可以发送错误的 $\\chi$ 的 $[\\cdot]$-共享给 $P_0$\n\n为了解决这些问题，$P_0$ 一旦获得 $\\chi$，就用下面的方式计算 $a = \\delta_x - \\lambda_x$、$b = \\delta_y - \\lambda_y$ 和 $c = (\\delta_z + \\delta_x \\delta_y) - \\chi$ 的 $[\\![\\cdot]\\!]$-共享：\n$$\n\\begin{align*}\n[\\![a]\\!]_{P_0} &= (\\lambda_{x,1}, \\lambda_{x,2}), & [\\![b]\\!]_{P_0} &= (\\lambda_{y,1}, \\lambda_{y,2}), & [\\![c]\\!]_{P_0} &= (\\chi_{1}, \\chi_{2})\\\\\n [\\![a]\\!]_{P_1} &= (\\delta_x, \\lambda_{x,1}), & [\\![b]\\!]_{P_1} &= (\\delta_y, \\lambda_{y,1}), & [\\![c]\\!]_{P_1} &= (\\delta_z + \\delta_x \\delta_y, \\chi_{1})\\\\\n [\\![a]\\!]_{P_2} &= (\\delta_x, \\lambda_{x,2}), & [\\![b]\\!]_{P_2} &= (\\delta_y, \\lambda_{y,2}), & [\\![c]\\!]_{P_2} &= (\\delta_z + \\delta_x \\delta_y, \\chi_{2})\n\\end{align*}\n$$\n现在 $([\\![a]\\!], [\\![b]\\!], [\\![c]\\!])$ 是一个乘法三元组 $(c=ab)$，当且仅当 $P_0$ 正确分享了 $\\gamma_{xy}$（当它腐败时）以及重构的 $\\chi$ 是正确的（当 $P_1,P_2$ 其中之一腐败时），因为：\n$$\n\\begin{align}\nab &= (\\delta_x - \\lambda_x)(\\delta_y - \\lambda_y) = \\delta_x \\delta_y + \\lambda_x \\lambda_y - \\delta_x \\lambda_y - \\delta_y \\lambda_x \\\\\n &= (\\delta_x \\delta_y + \\delta_z) - (\\delta_x \\lambda_y + \\delta_y \\lambda_x + \\delta_z - \\gamma_{xy}) \\\\\n  &= (\\delta_x \\delta_y + \\delta_z) - \\chi = c\n\\end{align}\n$$\n然后作者给出了一个检查乘法三元组是否正确的协议，这里需要用到另一个有效的乘法三元组 $([\\![d]\\!], [\\![e]\\!], [\\![f]\\!])$，它们满足以下条件：\n\n* $d, e, f$ 都是随机且私密的\n* $f = d e$\n\n这里假设这个三元组是通过 $\\mathcal{F}_{\\rm trip}$ 生成的，在[2, 30]中有具体构造，下面是[30]中的构造：\n\n![](http://images.yingwai.top/picgo/ASTRAf1.png)\n\n用  $\\prod _{\\rm trip}$ 表示该功能的实例化，下面是作者给出检查有效性的协议 $\\prod _{\\rm prc}$：\n\n-----\n\n* Parties locally compute $[\\![\\rho]\\!] = [\\![a]\\!] - [\\![d]\\!]$ and $[\\![\\sigma]\\!] = [\\![b]\\!] - [\\![e]\\!]$.\n* Parties reconstruct $\\rho$ and $\\sigma$ by executing $\\prod ^{\\rm m}_{\\rm Rec}([\\![\\rho]\\!], \\mathcal{P})$ and $\\prod ^{\\rm m}_{\\rm Rec}([\\![\\sigma]\\!], \\mathcal{P})$ respectively.\n* Parties locally compute $[\\![\\tau]\\!] = [\\![c]\\!] - [\\![f]\\!] - \\sigma [\\![d]\\!] - \\rho [\\![e]\\!] - \\sigma \\rho$.\n* Parties reconstruct $\\tau$ by executing $\\prod ^{\\rm m}_{\\rm Rec}([\\![\\tau]\\!], \\mathcal{P})$ and output $\\perp$, if $\\tau \\neq 0$.\n\n-----\n\n协议 $\\prod _{\\rm prc}$ 需要两对秘密共享三元组 $(a, b, c)$ 和 $(d, e, f)$，验证前一个三元组是否满足 $c = a b$：\n$$\n\\begin{align}\n\\tau &= c - f - \\sigma d - \\rho e - \\sigma \\rho \\\\\n &= c - de - (b - e)d - (a - d)e - (b - e)(a - d) \\\\\n &= c - ab = \\Delta\n\\end{align}\n$$\n所以 $\\tau = 0$ 时 $(a,b,c)$ 有效，反之无效。而检验 $\\tau$ 是否为0只需要一方跟另外两方各通信一次即可：(1) $P_0$ 跟 $P_1$ 检查 $m_\\tau - \\lambda_{\\tau,1}$ 跟 $\\lambda_{\\tau, 2}$ 是否相等；(2) $P_1$ 跟 $P_2$ 检查 $m_\\tau - \\lambda_{\\tau,2}$ 跟 $\\lambda_{\\tau, 1}$ 是否相等；(3) $P_0$ 跟 $P_1$ 检查 $m_\\tau - \\lambda_{\\tau,2}$ 跟 $\\lambda_{\\tau, 1}$ 是否相等，而不是 $\\prod ^{\\rm m}_{\\rm Rec}$ 的通信三次（两次发送一次接收）。下面给出恶意设置下的乘法协议 $\\prod ^{\\rm m}_{\\rm Mul}(w_x, w_y, w_z)$：\n\n-----\n\n**Offline:**\n\n* Parties $P_0, P_1$ locally sample random $\\lambda_{z,1}, \\gamma_{xy,1} \\in \\mathbb{Z}_{2^l}$, while $P_0, P_2$ \n  locally sample a random $\\lambda_{z,2}$. $P_0$ locally computes $\\gamma_{xy}= \\lambda_x \\lambda_y$ and\n  sends $\\gamma_{xy,2} = \\gamma_{xy} - \\gamma_{xy,1}$ to $P_2$.\n* Parties execute $\\prod _{\\rm trip}$ to generate a triple $([\\![d]\\!], [\\![e]\\!], [\\![f]\\!])$.\n* Parties $P_1, P_2$ locally sample random $\\delta_x, \\delta_y, \\delta_z \\in \\mathbb{Z}_{2^l}$ and compute\n  $[\\delta_z]$ non-interactively.\n* $P_i$ for $i \\in \\{1, 2\\}$ computes $[\\chi]_{P_i} = \\delta_x[\\lambda_y]_{P_i} + \\delta_y[\\lambda_x]_{P_i} + [\\delta_z]_{P_i} − [\\gamma_{xy}]_{P_i}$ and sends $[\\chi]_{P_i}$ to $P_0$, who computes $\\chi$.\n* Parties locally compute the $[\\![\\cdot]\\!]$-shares of the values $a = \\delta_x - \\lambda_x$, $b = \\delta_y - \\lambda_y$ and $b = (\\delta_z + \\delta_x \\delta_y) - \\chi$, as described in the text.\n* Parties execute $\\prod _{\\rm prc}$ on $([\\![a]\\!], [\\![b]\\!], [\\![c]\\!])$ and $([\\![d]\\!], [\\![e]\\!], [\\![f]\\!])$.\n\n**Online:**\n\n* $P_i$ for $i \\in \\{1, 2\\}$ locally computes $[m_z]_{P_i} = (i-1)m_xm_y - m_x[\\lambda_y]_{P_i} - m_y[\\lambda_x]_{P_i} + [\\lambda_z]_{P_i} + [\\gamma_{xy}]_{P_i}$. $P_1, P_2$ mutually exchange their shares and reconstruct $m_z$.\n* $P_1$ sends $m^{\\star}_x = m_x + \\delta_x$, $m^{\\star}_y = m_y + \\delta_y$ to $P_0$, while $P_2$ sends $H(m^{\\star}_x || m^{\\star}_{y})$ to $P_0$.$P_0$ outputs $\\perp$, if the received values are inconsistent.\n* $P_0$ computes $m^{\\star}_z = -m^{\\star}_x \\lambda_y - m^{\\star}_y \\lambda_x +\\lambda_z + 2\\gamma_{xy} + \\chi$ and sends $H(m^\\star_z)$ to both $P_1$ and $P_2$.\n* $P_i$ for $i \\in \\{1, 2\\}$ abort if $H(m^\\star_z) \\neq H(m_z - m_x m_y + \\delta_z)$.\n\n-----\n\n散列值的使用提高了效率，减少了通信的开销。\n\n对于正确性，首先考虑腐败的 $P_0$ 不正确地共享使得 $\\gamma_{xy} = \\lambda_x \\lambda_y + \\Delta$ 的情况，其中 $\\Delta$ 是 $P_0$ 引入的不为零的干扰。这种情况在执行 $\\prod _{\\rm prc}$ 就会被检测到，因为最终计算出来并重构的 $\\tau \\neq 0$。同样的， $P_1$（或 $P_2$）在协议 $\\prod ^{\\rm m}_{\\rm Mul}$ 离线阶段的第四步时发送 $\\chi_1 + \\Delta$（或 $\\chi_2 + \\Delta$） 给 $P_0$ 使其重构的 $\\chi' = \\chi + \\Delta$，也会导致 $\\tau \\neq 0$ 从而被诚实方发现并中止计算。\n\n然后是另一种情况，假如 $P_1$（或 $P_2$）在重构 $m_z$ 时发送了错误的 $[m_z]_{P_i}$ 给另一方，会在最后一步验证哈希值是否相等的时候被检测出来；而在在线阶段第二步中 $P_0$ 对 $m^{\\star}_x,m^{\\star}_y$ 的一致性检查也确保了它所计算出来的 $m^{\\star}_z$ 是正确的。\n\n\n\n#### 公平的实现\n\n作者通过一种公平重构协议 $\\prod_{\\rm fRec}$ 来重构电路输出，将 $\\prod ^{\\rm m}_{\\rm 3pc}$ 的安全性提高到公平，保证交易的三方都不能通过损害别人的利益而得到自己不应得的利益。这里使用到了承诺方案，还是利用了服务器之间的公共随机源并使用PRF来为承诺方案引入随机性：\n\n-----\n\n**Offline:**\n\n* Parties $P_0, P_1$ locally sample a random $r_1 \\in \\mathbb{Z}_{2^l}$, prepare and send commitments of $\\lambda_{y,1}$ and $r_1$ to $P_2$. Similarly, parties $P_0, P_2$ locally sample a random $r_2 \\in \\mathbb{Z}_{2^l}$, prepare and send commitments of $\\lambda_{y,2}$ and $r_2$ to $P_1$. The randomness needed for both commitments are sampled from the PRF key-setup.\n* $P_1$ (resp. $P_2$) aborts if the received commitments mismatch.\n\n**Online:**\n\n* $P_1, P_2$ compute a commitment of $m_y$ using randomness sampled from their PRF key-setup and send it to $P_0$.\n* If the commitments do not match, $P_0$ sends (**abort**, $o_1$) to $P_2$, while it sends (**abort**, $o_2$) to $P_1$ and aborts, where $o_i$ denotes the opening information for the commitment of $r_i$. Else $P_0$ sends **continue** to both $P_1$ and $P_2$.\n* $P_1, P_2$ exchange the messages received from $P_0$.\n* $P_1$ aborts if it receives either (i) (**abort**, $o_2$) from $P_0$ and $o_2$ opens the commitment of $r_2$ or (ii) (**abort**, $o_1$) from $P_2$ and $o_1$ is the correct opening information of $r_1$. The case for $P_2$ is similar to that of $P_1$.\n* If no abort happens, parties obtain their missing share of $a$ as follows:\n  * $P_0, P_1$ open $\\lambda_{y,1}$ towards $P_2$.\n  * $P_0, P_2$ open $\\lambda_{y,2}$ towards $P_1$.\n  * $P_1, P_2$ open $m_y$ towards $P_0$.\n* Parties reconstruct the value $y$ using missing share that matches with the agreed upon commitment.\n\n-----\n\n当没有广播频道的时候，一个非常棘手的问题就会存在：一个腐败的 $P_0$ 可以发送不同的信号给 $P_1$ 和 $P_2$（一个为 abort 而另一个为 continue），以上的重构协议 $\\prod_{\\rm fRec}([\\![y]\\!], \\mathcal{P})$ 解决了这个问题。在离线阶段 $P_0$ 和 $P_1$ 共同计算出一个关于 $r_1$ 的承诺发送给 $P_2$，同样地 $P_0$ 和 $P_2$ 共同计算出一个关于 $r_2$ 的承诺发送给 $P_1$。这两个承诺就可以确保 $P_1$ 跟 $P_2$ 可以验证它们收到的来自 $P_0$ 的信号是否一致：例如当 $P_1$ 收到 abort 而 $P_2$ 收到 continue，在它们交换信息时，$P_1$ 就可以利用收到的 $o_2$ 证明自己收到了 abort 信号，反过来也是一样的。同时还解决了一个问题，就是当一个腐败的 $P_1$ 收到了 $P_0$ 发送的 continue 信号，但它不能在与 $P_2$ 交换信息时宣称自己收到了 abort 信号，因为它没有 $o_2$，因此无法证明，对于 $P_2$ 腐败的情况也是一样的。\n\n这里的承诺方案可以通过一个哈希函数来实现，例如：$(c, o) = (\\mathcal{H}(x||r),x||r) = Com(x;r)$\n\n\n\n## 隐私保护机器学习\n\n### 模型\n\n对于每一个预测函数，模型拥有者 $\\rm M$ 拥有一个训练好的参数向量，想为拥有一个查询向量的客户 $\\rm C$ 提供预测服务。在服务器辅助设置中，$\\rm M$ 和 $\\rm C$ 以共享方式将各自的输入外包给三个不受信任但非合谋的服务器 $\\{P_0, P_1, P_2\\}$，这些服务器通过为本文的3PC协议开发的技术以共享方式执行计算，并将输出单独重构到客户端。客户只能知道输出，除此之外什么也不知道。\n\n\n\n### 对于ML的协议\n\n#### 安全向量点积\n\n对于向量的 $[\\cdot]$-共享和 $[\\![\\cdot]\\!]$-共享，就是对应每个维度的值进行$[\\cdot]$-共享和 $[\\![\\cdot]\\!]$-共享，容易知道对于向量来说两种共享仍然是线性的。对于两个 $d$ 维向量的点积，不考虑效率的情况下可以执行 $d$ 次 $\\prod ^{\\rm s}_{\\rm Mul}$协议，再对这 $d$ 次执行的结果简单进行相加，各方就可以得到它们的份额。在这里作者给出一个更高效率的向量点积协议 $\\prod ^{\\rm s}_{\\rm dp}$：\n\n-----\n\n**Offline:**\n\n​\t\t$P_0, P_1$ sample random $\\lambda_{u,1}, \\gamma_{pq,1} \\in \\mathbb{Z}_{2^l}$, while $P_0, P_2$ sample random $\\lambda_{u,2} \\in \\mathbb{Z}_{2^l}$. $P_0$ locally computes $\\gamma_{pq} = \\vec{\\lambda_p} \\odot \\vec{\\lambda_q}$, sets $\\gamma_{pq,2} = \\gamma_{pq} - \\gamma_{pq,1}$ and sends $\\gamma_{pq,2}$ to $P_2$.\n\n**Online:**\n\n* $P_i$ for $i \\in \\{1,2\\}$ locally computes $[m_u]_{P_i} = \\sum^d_{j=1}((i-1)m_{p_j}m_{q_j} - m_{p_j}[\\lambda_{q_j}]_{P_i} - m_{q_j}[\\lambda_{p_j}]_{P_i}) + [\\gamma_{pq}]_{P_i} + [\\lambda_u]_{P_i}$.\n* $P_1$ and $P_2$ mutually exchange their share of $[m_u]$ to reconstruct $m_u$.\n\n-----\n\n上面的协议的离线阶段中，$P_0$ 仅仅共享了 $\\gamma_{pq} = \\vec{\\lambda_p} \\odot \\vec{\\lambda_q}$ 而不是每一个 $\\lambda_{p_i} \\lambda_{q_i}$；在在线阶段，$P_1, P_2$ 直接计算 $[m_u]$（其中 $u = \\vec{p} \\odot \\vec{q}$）而不是每一个 $m_{p_i q_i}$。\n\n\n\n接下来作者还对恶意设置下的点积进行了讨论：由于在乘法协议中引入了对恶意对手的额外检查，所以上面针对半诚实协议所作的优化是不适用的。对两个 $d$ 维向量的点积，只能 $d$ 次调用协议 $\\prod ^{\\rm m}_{\\rm Mul}$。不过作者还是对在线阶段的开销进行了改进：在在线阶段 $P_1$ 并行地发送 $m^{\\star}_{p_i}, m^{\\star}_{q_i}$ 给 $P_0$，而 $P_2$ 则发送对应的哈希值给 $P_0$。$P_0$ 收到这些值后进行验证，若一致则将它们“结合”所有的 $m^{\\star}_{p_i q_i}$ 然后发送一个单独的 $m^\\star_u$ 的哈希值给 $P_1, P_2$，最后 $P_1, P_2$ 在本地验证是否与 $m_u - \\sum^d_{j=1}(m_{p_j}m_{q_j} - \\delta_{u_j})$。这样做的话就节省了在线阶段的开销，不用每个 $m^{\\star}_{p_i}, m^{\\star}_{q_i}$ 都发送一次。\n\n\n\n#### 安全比较\n\n给定算术共享 $[\\![u]\\!], [\\![v]\\!]$，各方希望验证 $u$ 是否小于 $v$，等同于验证 $a$ 是否小于 $0$（其中 $a = u - v$），在定点表示中可以通过检查 ${\\rm msb}(a)$ 来完成（二进制补码中第一位为符号位）。于是可以把在给定算术共享 $[\\![a]\\!]$ 的情况下生成 ${\\rm msb}(a)$ 的布尔共享作为目标，在这里作者利用了秘密共享方案中的不对称性，放弃了 *SecureML*[48]和 *ABY3*[46]中的昂贵协议。\n\n-----\n\n**Offline:**\n\n​\t\t$P_1, P_2$ together sample a random $r, r' \\in \\mathbb{Z}_{2^l}$ and set $p= \\rm{msb}$$(r)$. Parties non-interactively generate Boolean share of $p$ as $[\\![p]\\!]^{\\rm B}_{P_0} = (0,0)$, $[\\![p]\\!]^{\\rm B}_{P_1} = (p,0)$ and $[\\![p]\\!]^{\\rm B}_{P_2} = (p,0)$.\n\n**Online:**\n\n​\t\t$P_1$ set $[a]_{P_1}=m_a - \\lambda_{a,1}$, $P_2$ set $[a]_{P_2}=- \\lambda_{a,2}$.\n\n* $P_1$ sends $[ra]_{P_1} = r[a]_{P_1} + r'$ to $P_0$, while $P_2$ sends $[ra]_{P_2} = r[a]_{P_1} - r'$ to $P_0$, who adds them to obtain $ra$.\n* $P_0$ executes $\\prod^{\\rm s}_{\\rm Sh}(P_0, q)$ over $\\mathbb{Z}_{2^1}$ to generate $[\\![q]\\!]^{\\rm B}$ where $q = {\\rm msb}(ra)$.\n* Parties locally compute $[\\![\\mbox{msb}(a)]\\!]^{\\rm B} = [\\![p]\\!]^{\\rm B} \\oplus [\\![q]\\!]^{\\rm B}$.\n\n-----\n\n上面的协议用 $\\prod ^{\\rm s}_{\\rm BitExt}([\\![a]\\!], \\mathcal{P})$ 表示。这里上面用到了一个随机数 $r$ 来对 $a$ 的值进行盲化，并且可以注意到 ${\\rm sign}(a \\cdot r) = {\\rm sign}(a) \\oplus {\\rm sign}(r)$，所以 $r$ 不会对生成共享份额造成影响且使得三者都不能从这个过程中知道关于 $a$ 的信息。\n\n对于恶意的情况，就不能仅仅依靠 $P_0$ 来生成 $[\\![{\\rm msb}(ra)]\\!]^{\\rm B}$，下面给出了修改后的协议 $\\prod ^{\\rm m}_{\\rm BitExt}([\\![a]\\!], \\mathcal{P})$：\n\n-----\n\n**Offline:**\n\n​\t\t$P_1, P_2$ sample a random $r_1 \\in \\mathbb{Z}_{2^l}$ and set $p_1 = {\\rm msb}(r_1)$ while $P_0, P_2$ sample a random $r_2 \\in \\mathbb{Z}_{2^l}$ and set $p_2 = {\\rm msb}(r_2)$.\n\n* Parties non-interactively generate $[\\![\\cdot]\\!]$-shares of $r_1$ as $[\\![r_1]\\!]_{P_0}=(0,0)$, $[\\![r_1]\\!]_{P_1}=(r_1,0)$ and $[\\![r_1]\\!]_{P_2}=(r_1,0)$.\n* Parties non-interactively generate $[\\![\\cdot]\\!]$-shares of $r_1$ as $[\\![r_2]\\!]_{P_0}=(0,-r_2)$, $[\\![r_1]\\!]_{P_1}=(0,0)$ and $[\\![r_1]\\!]_{P_2}=(0,-r_2)$.\n* Parties execute $\\prod^{\\rm m}_{\\rm Mul}$ on $r_1$ and $r_2$ to generate $[\\![r]\\!] = [\\![r_1 r_2]\\!]$.\n* Parties non-interactively generate Boolean shares of $p_1$ as $[\\![p_1]\\!]^{\\rm B}_{P_0}=(0,0)$, $[\\![p_1]\\!]^{\\rm B}_{P_1}=(p_1,0)$ and $[\\![p_1]\\!]^{\\rm B}_{P_2}=(p_1,0)$.\n* Parties non-interactively generate Boolean shares of $p_2$ as $[\\![p_2]\\!]^{\\rm B}_{P_0}=(0,p_2)$, $[\\![p_2]\\!]^{\\rm B}_{P_1}=(0,0)$ and $[\\![p_2]\\!]^{\\rm B}_{P_2}=(0,p_2)$.\n* Parties locally compute $[\\![p]\\!]^{\\rm B}=[\\![p_1]\\!]^{\\rm B} \\oplus [\\![p_2]\\!]^{\\rm B}$.\n\n**Online:**\n\n* Parties execute $\\prod ^{\\rm m}_{\\rm Mul}$ on $[\\![r]\\!]$ and $[\\![a]\\!]$ to generate $[\\![ra]\\!]$ followed by enabling $P_0, P_1$ to reconstruct $ra$ (this is done by slightly modifying the protocol $\\prod ^{\\rm m}_{\\rm Rec}$ ).\n* $P_1$ executes $\\prod ^{\\rm m}_{\\rm Sh}(P_1, q)$ over $\\mathbb{Z}_{2^1}$ to generate $[\\![q]\\!]^{\\rm B}$ where $q = {\\rm msb}(ra)$. In parallel, $P_0$ locally computes $m_q$ and sends ${\\rm H}(m_q)$ to $P_2$, who abort if the value mismatches with the hash of the value $m_q$ received from $P_1$ as part of $\\prod ^{\\rm m}_{\\rm Sh}(P_1, q)$.\n* Parties locally compute $[\\![{\\rm msb}(a)]\\!]^{\\rm B} = [\\![p]\\!]^{\\rm B} \\oplus [\\![q]\\!]^{\\rm B}$.\n\n-----\n\n\n\n#### ML预测函数\n\n* **线性回归**：$\\rm M$ 有一个 $d$ 维的模型参数向量 $\\vec{w}$ 和偏置项 $b$，$\\rm C$ 有一个 $d$ 维的查询向量 $\\vec{z}$。$\\rm C$ 获得 $f_{\\rm linr}((\\vec{w}, b),\\vec{z}) = \\vec{w} \\odot \\vec{z} + b$，其中 $\\vec{w} \\odot \\vec{z}$ 是向量 $\\vec{w}$ 和向量 $\\vec{z}$ 的点积；\n* **SVM回归**：$\\rm M$ 有$\\{\\alpha_j, y_j \\}^k_{j=1}$ 和 $d$ 维的支持向量 $\\{\\vec{x_j}\\}^k_{j=1}$，$\\rm C$ 有一个 $d$ 维的查询向量 $\\vec{z}$。$\\rm C$ 获得 $f_{\\rm svmr}((\\{\\alpha_j, y_j, \\vec{x_j} \\}^k_{j=1}, b), \\vec{z}) = \\sum^k_{j=1} \\alpha_j y_j (\\vec{x_j} \\odot \\vec{z}) + b$；\n* **逻辑回归**：$\\rm M$ 和 $\\rm C$ 的输入和线性回归类似，$\\rm M$ 还需要提供一个在 $[0,1]$ 范围内的额外输入 $t$。$\\rm C$ 获得 $f_{\\rm logr}((\\vec{w}, b, t), \\vec{z}) = {\\rm sign}((\\vec{w} \\odot \\vec{z} + b) - {\\rm ln}(\\frac{t}{1-t}))$，其中 ${\\rm sign}(\\cdot)$ 返回对象的符号位；\n* **SVM分类**：$\\rm M$ 和 $\\rm C$ 的输入和SVM回归一样，但对 $\\rm C$ 的输出变为 $f_{\\rm svmr}((\\{\\alpha_j, y_j, \\vec{x_j} \\}^k_{j=1}, b), \\vec{z}) = {\\rm sign}(\\sum^k_{j=1} \\alpha_j y_j (\\vec{x_j} \\odot \\vec{z}) + b)$。\n\n\n\n## 参考文献\n\n[1] V. A. Abril, P. Maene, N. Mertens, and N. P. Smart. 2019. *Bristol Fashion MPC Circuits.* https://homes.esat.kuleuven.be/~nsmart/MPC/.\n[2] T. Araki, A. Barak, J. Furukawa, T. Lichter, Y. Lindell, A. Nof, K. Ohara, A. Watzman, and O. Weinstein. 2017. *Optimized Honest-Majority MPC for Malicious Adversaries - Breaking the 1 Billion-Gate Per Second Barrier.* In IEEE S&P. 843–862.\n[3] T. Araki, A. Barak, J. Furukawa, Y. Lindell, A. Nof, and K. Ohara. 2016. *DEMO: High-Throughput Secure Three-Party Computation of Kerberos Ticket Generation.* In ACM CCS. 1841–1843.\n[4] T. Araki, J. Furukawa, Y. Lindell, A. Nof, and K. Ohara. 2016. *High-Throughput Semi-Honest Secure Three-Party Computation with an Honest Majority.* In ACM CCS. 805–817.\n[5] C. Baum, I. Damgård, T. Toft, and R. W. Zakarias. 2016. *Better Preprocessing for Secure Multiparty Computation.* In ACNS. 327–345.\n[6] D. Beaver. 1991. *Efficient Multiparty Protocols Using Circuit Randomization.* In CRYPTO. 420–432.\n[7] D. Beaver. 1995. *Precomputing Oblivious Transfer.* In CRYPTO. 97–109.\n[8] Z. Beerliová-Trubíniová and M. Hirt. 2006. *Efficient Multi-party Computation with Dispute Control.* In TCC. 305–328.\n[9] Z. Beerliová-Trubíniová and M. Hirt. 2008. *Perfectly-Secure MPC with Linear Communication Complexity.* In TCC. 213–230.\n[10] M. Ben-Or, S. Goldwasser, and A. Wigderson. 1988. *Completeness Theorems for Non-Cryptographic Fault-Tolerant Distributed Computation (Extended Abstract).* In ACM STOC. 1–10.\n[11] Christopher Bishop. 2006. *Pattern Recognition and Machine Learning.*\n[12] D. Bogdanov, S. Laur, and J. Willemson. 2008. *Sharemind: A Framework for Fast Privacy-Preserving Computations.* In ESORICS. 192–206.\n[13] D. Bogdanov, R. Talviste, and J. Willemson. 2012. *Deploying Secure Multi-Party Computation for Financial Data Analysis.* In FC. 57–64.\n[14] M. Byali, A. Joseph, A. Patra, and D. Ravi. 2018. *Fast Secure Computation for Small Population over the Internet.* ACM CCS (2018), 677–694.\n[15] O. Catrina and S. de Hoogh. 2010. *Secure Multiparty Linear Programming Using Fixed-Point Arithmetic.* In ESORICS. 134–150.\n[16] N. Chandran, J. A. Garay, P. Mohassel, and S. Vusirikala. 2017. *Efficient, Constant-Round and Actively Secure MPC: Beyond the Three-Party Case.* In ACM CCS. 277–294.\n[17] H. Chaudhari, A. Choudhury, A. Patra, and A. Suresh. 2019. *ASTRA: High-throughput 3PC over Rings with Application to Secure Prediction.* https://eprint.iacr.org/2019/429. In IACR Cryptology ePrint Archive.\n[18] K. Chida, D. Genkin, K. Hamada, D. Ikarashi, R. Kikuchi, Y. Lindell, and A. Nof. 2018. *Fast Large-Scale Honest-Majority MPC for Malicious Adversaries.* In CRYPTO. 34–64.\n[19] A. Choudhury and A. Patra. 2017. *An Efficient Framework for Unconditionally Secure Multiparty Computation.* IEEE Trans. Information Theory (2017), 428–468.\n[20] R. Cleve. 1986. *Limits on the Security of Coin Flips when Half the Processors Are Faulty (Extended Abstract).* In ACM STOC. 364–369.\n[21] R. Cramer, I. Damgård, D. Escudero, P. Scholl, and C. Xing. 2018. *SPDZ2k: Efficient MPC mod 2ˆk for Dishonest Majority.* CRYPTO (2018), 769–798.\n[22] R. Cramer, I. Damgård, and Y. Ishai. 2005. *Share Conversion, Pseudorandom Secret-Sharing and Applications to Secure Computation.* In TCC. 342–362.\n[23] Cryptography and Privacy Engineering Group at TU Darmstadt. 2017. ENCRYPTO Utils. https://github.com/encryptogroup/ENCRYPTO_utils.\n[24] M. Dahl. 2018. *Private Image Analysis with MPC: Training CNNs on Sensitive Data using SPDZ.* (2018).\n[25] I. Damgård, C. Orlandi, and M. Simkin. 2018. *Yet Another Compiler for Active Security or: Efficient MPC Over Arbitrary Rings.* CRYPTO (2018), 799–829.\n[26] I. Damgård, V. Pastro, N. P. Smart, and S. Zakarias. 2012. *Multiparty Computation from Somewhat Homomorphic Encryption.* In CRYPTO. 643–662.\n[27] S. de Hoogh, B. Schoenmakers, P.Chen, and H. Akker. 2014. *Practical Secure Decision Tree Learning in a Teletreatment Application.* In FC. 179–194.\n[28] H. Eerikson, M. Keller, C. Orlandi, P. Pullonen, J. Puura, and M. Simkin. 2019. *Use your Brain! Arithmetic 3PC For Any Modulus with Active Security.* IACR\nCryptology ePrint Archive (2019).\n[29] A. Esteva, B. Kuprel, R. A. Novoa, J. Ko, S. M. Swetter, H. M. Blau, and S. Thrun. 2017. *Dermatologist-level classification of skin cancer with deep neural networks.* Nature (2017), 115–118.\n[30] J. Furukawa, Y. Lindell, A. Nof, and O. Weinstein. 2017. *High-Throughput Secure Three-Party Computation for Malicious Adversaries and an Honest Majority.* In EUROCRYPT. 225–255.\n[31] A. Gascón, P. Schoppmann, B. Balle, M. Raykova, J. Doerner, S. Zahur, and D. Evans. 2016. *Secure Linear Regression on Vertically Partitioned Datasets.* IACR Cryptology ePrint Archive (2016).\n[32] M. Geisler. 2007. *Viff: Virtual ideal functionality framework.*\n[33] O. Goldreich, S. Micali, and A. Wigderson. 1987. *How to Play any Mental Game or A Completeness Theorem for Protocols with Honest Majority.* In STOC. 218–229.\n[34] S. D. Gordon, S. Ranellucci, and X. Wang. 2018. *Secure Computation with Low Communication from Cross-Checking.* In ASIACRYPT. 59–85.\n[35] Y. Ishai, R. Kumaresan, E. Kushilevitz, and A. Paskin-Cherniavsky. 2015. *Secure Computation with Minimal Interaction, Revisited.* In CRYPTO. 359–378.\n[36] S. Kamara, P. Mohassel, and M. Raykova. 2011. *Outsourcing Multi-Party Computation.* IACR Cryptology ePrint Archive (2011).\n[37] J. Katz, V. Kolesnikov, and X. Wang. 2018. *Improved Non-Interactive Zero Knowledge with Applications to Post-Quantum Signatures.* In CCS. 525–537.\n[38] M. Keller, E. Orsini, and P. Scholl. 2016. *MASCOT: Faster Malicious Arithmetic Secure Computation with Oblivious Transfer.* In ACM CCS. 830–842.\n[39] M. Keller, V. Pastro, and D. Rotaru. 2018. *Overdrive: Making SPDZ Great Again.* In EUROCRYPT. 158–189.\n[40] J. Launchbury, D. Archer, T. DuBuisson, and E. Mertens. 2014. *Application-Scale Secure Multiparty Computation.* In ESOP. 8–26.\n[41] S. Laur, H. Lipmaa, and T. Mielikäinen. 2006. *Cryptographically private support vector machines.* In ACM SIGKDD. 618–624.\n[42] Yann LeCun and Corinna Cortes. 2010. *MNIST handwritten digit database.* (2010). http://yann.lecun.com/exdb/mnist/\n[43] Y. Lindell and A. Nof. 2017. *A Framework for Constructing Fast MPC over Arithmetic Circuits with Malicious Adversaries and an Honest-Majority.* In ACM CCS. 259–276.\n[44] J. Liu, M. Juuti, Y. L., and N. Asokan. 2017. *Oblivious Neural Network Predictions via MiniONN Transformations.* In ACM CCS. 619–631.\n[45] E. Makri, D. Rotaru, N. P. Smart, and F. Vercauteren. 2018. *EPIC: Efficient Private Image Classification (or: Learning from the Masters).* CT-RSA (2018), 473–492.\n[46] P. Mohassel and P. Rindal. 2018. *ABY3: A Mixed Protocol Framework for Machine Learning.* In ACM CCS. 35–52.\n[47] P. Mohassel, M. Rosulek, and Y. Zhang. 2015. *Fast and Secure Three-party Computation: Garbled Circuit Approach.* In CCS. 591–602.\n[48] P. Mohassel and Y. Zhang. 2017. *SecureML: A System for Scalable Privacy-Preserving Machine Learning.* In IEEE S&P. 19–38.\n[49] V. Nikolaenko, S. Ioannidis, U. Weinsberg, M. Joye, N. Taft, and D. Boneh. 2013. *Privacy-preserving matrix factorization.* In ACM CCS. 801–812.\n[50] V. Nikolaenko, U. Weinsberg, S. Ioannidis, M. Joye, D. Boneh, and N. Taft. 2013. *Privacy-Preserving Ridge Regression on Hundreds of Millions of Records.* In IEEE S&P. 334–348.\n[51] P. S. Nordholt and M. Veeningen. 2018. *Minimising Communication in Honest-Majority MPC by Batchwise Multiplication Verification.* In ACNS. 321–339.\n[52] T. Orekondy, B. Schiele, and M. Fritz. 2018. *Knockoff Nets: Stealing Functionality of Black-Box Models.* CoRR (2018).\n[53] N. Papernot, P. McDaniel, I. Goodfellow, S. Jha, Z. B. Celik, and A. Swami. 2017. *Practical Black-Box Attacks Against Machine Learning.* In ASIA CCS. 506–519.\n[54] A. Patra and D. Ravi. 2018. *On the Exact Round Complexity of Secure Three-Party Computation.* CRYPTO (2018), 425–458.\n[55] M. S. Riazi, C. Weinert, O. Tkachenko, E. M. Songhori, T. Schneider, and F. Koushanfar. 2018. *Chameleon: A Hybrid Secure Computation Framework for Machine Learning Applications.* In AsiaCCS. 707–721.\n[56] F. Schroff, D. Kalenichenko, and J. Philbin. 2015. *FaceNet: A unified embedding for face recognition and clustering.* In IEEE CVPR. 815–823.\n[57] N. P. Smart and T. Wood. 2019. *Error Detection in Monotone Span Programs with Application to Communication-Efficient Multi-party Computation.* In CT-RSA. 210–229.\n[58] F. Tramèr, F. Zhang, A. Juels, M. K. Reiter, and T. Ristenpart. 2016. *Stealing Machine Learning Models via Prediction APIs.* In USENIX. 601–618.\n[59] S. Wagh, D. Gupta, and N. Chandran. 2019. *SecureNN: 3-Party Secure Computation for Neural Network Training.* PoPETs (2019), 26–49.\n[60] A. C. Yao. 1982. *Protocols for Secure Computations.* In FOCS. 160–164.","slug":"论文笔记-ASTRA-High-Throughput-3PC-over-Rings-with-Application-to-Secure-Prediction","published":1,"updated":"2020-08-23T14:33:37.434Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cke79q4pi001e88pscluqhnvp","content":"<p><em>Harsh Chaudhari, Ashish Choudhury, Arpita Patra, Ajith Suresh</em></p>\n<p>ACM CCSW 2019</p>\n<p><a href=\"https://eprint.iacr.org/2019/429\" target=\"_blank\" rel=\"noopener\">https://eprint.iacr.org/2019/429</a></p>\n<p><a href=\"https://dl.acm.org/doi/10.1145/3338466.3358922\" target=\"_blank\" rel=\"noopener\">https://dl.acm.org/doi/10.1145/3338466.3358922</a></p>\n<a id=\"more\"></a>\n<p><img src=\"http://images.yingwai.top/picgo/ASTRA.jpg\" alt=\"\"></p>\n<h2 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h2><h3 id=\"摘要\"><a href=\"#摘要\" class=\"headerlink\" title=\"摘要\"></a>摘要</h3><p>安全计算的具体效率一直是近年来许多工作关注的焦点。在本论文中，作者提出了一种具体有效的协议，用于模 $2^l$ 整数环上的安全三方计算（3PC），该协议具有半诚实模型和恶意模型上的安全性。由于环上的计算模拟了现实系统体系结构上的计算，所以环上的安全计算近来获得了发展势头。</p>\n<p>​        在离线-在线模式中，本文的结构具体地呈现了最有效的在线阶段。在半诚实的设置下，本文的协议在在线阶段每个乘法门需要2个环元素的通信。在恶意设置下，本文的协议在在线阶段每个乘法门需要4个元素的通信，比最先进的协议需要的5个元素少。使用选择性中止和公平这两个安全概念来实现的公平恶意协议，与仅针对输出门的中止安全性的恶意协议相比，涉及的通信稍微多一些。</p>\n<p>​        作者将本文的技术从3PC应用到安全的服务器辅助机器学习（ML）推理机制中，用于一系列预测函数——线性回归、线性SVM回归、Logistic回归和线性SVM分类。本文的设置考虑了拥有训练好的模型参数的模型所有者和查询的客户，后者愿意根据前者的模型参数来学习他查询的预测。输入和计算外包给一组三个非合谋的服务器。本文的构造既迎合了半诚实的世界，也迎合了恶意的世界，比现有的构造表现得更好。</p>\n<h3 id=\"贡献\"><a href=\"#贡献\" class=\"headerlink\" title=\"贡献\"></a>贡献</h3><ul>\n<li><p>作者遵循离线-在线模式，提出了在环 $\\mathbb{Z}<em>{2^l}$（包括布尔环 $\\mathbb{Z}</em>{2^1}$）上的3PC构造，具有最有效的在线阶段。</p>\n<p>虽然重点放在在现阶段，但离线阶段的的成本也有注意并保持在可控范围内。</p>\n</li>\n<li><p>作者给出了一系列满足半诚实安全和恶意安全的构造。</p>\n<p>将技术应用于外包环境中的一系列预测函数的安全预测，并构建了一些容忍半诚实和恶意对手的结构。</p>\n</li>\n</ul>\n<p>本文所有的构建都流露出的一个共同特征：在线阶段不到三对参与者之间需要进行功能依赖的通信，从而产生更好的在线性能。</p>\n<h2 id=\"设定\"><a href=\"#设定\" class=\"headerlink\" title=\"设定\"></a>设定</h2><p>本文考虑一组三方 $\\mathcal{P}=\\left{P<em>0,P_1,P_2\\right}$，它们在同步网络中通过成对的私有和可信信道连接。要计算的函数 $f$ 被表示为环 $\\mathbb{Z}</em>{2^l}$ 上的电路 ckt，该环由2输入加法和乘法门组成。假设 ckt 的拓扑是公知的。术语 D​ 表示 ckt 的乘法深度，而 I、O、A、M 分别表示 ckt 中的输入线、输出线、加法门和乘法门的数目。本文使用符号 $w<em>x$ 来表示导线 $w$，其中值 $x$ 流经它。本文使用 $g=(w_x,w_y,w_z)$ 来表示 ckt 中具有左输入线 $w_x$、右输入线 $w_y$ 和输出线 $w_z$ 的门。在本文的协议中，将 $\\mathcal{P}$ 划分为互不相交的集合 $\\left{P_0\\right}$ 和 $\\left{P_1,P_2\\right}$，其中 $P_0$ 在离线阶段充当“分配器”进行“预处理”，在线阶段“评估者” $P_1$、$P_2$ 用它来评估 ckt。本文使用上标“$s$”和“$m$”分别区分半诚实和恶意设置中的协议。布尔环 $\\mathbb{Z}</em>{2^1}$ 上的协议可以通过将算术加法$(+)$和乘法$(\\times)$分别替换为异或$(\\oplus)$和与$(\\cdot)$来获得。</p>\n<h3 id=\"共享密钥设置\"><a href=\"#共享密钥设置\" class=\"headerlink\" title=\"共享密钥设置\"></a>共享密钥设置</h3><p>为了保存双方之间的通信，使用为伪随机函数（PRF）$F$ 建立预共享随机密钥的一次性设置。在3PC设置[2，30，46]中的已知协议中已经使用了类似的设置。这里 $F:^\\kappa \\times ^\\kappa \\to X$ 是安全的PRF，同域 $X$ 是 $\\mathbb{Z}_{2^l}$。这组密钥是：</p>\n<ul>\n<li>每对参与方之间共享一个密钥— $k<em>{01}, k</em>{02}, k_{12}$，分别用于参与方$(P_0,P_1), (P_0,P_2), (P_1,P_2)$。</li>\n<li>所有各方之间的一个共享密钥— $k_{\\mathcal{p}}$。</li>\n</ul>\n<p>本文通过可以使用任何标准安全MPC协议实现的功能 $\\mathcal{F}_{\\rm setup}$ 来建立密钥设置模型。</p>\n<h3 id=\"共享语义\"><a href=\"#共享语义\" class=\"headerlink\" title=\"共享语义\"></a>共享语义</h3><p>在本节中，将解释本工作中使用的秘密共享的两种变体。这两个变体都在算术（$\\mathbb{Z}<em>{2^l}$）和布尔环（$\\mathbb{Z}</em>{2^1}$）上运行。</p>\n<p>$[\\cdot]$-共享：如果 $P<em>1$ 和 $P_2$ 分别持有份额 $v_1$ 和 $v_2$，使得 $v=v_1+v_2$，则称值 $v$ 在$P_1,P_2$之间是 $[\\cdot]$-共享的。用 $[\\cdot]</em>{P_i}$ 表示 $P_i, i∈{1,2}$的 $[\\cdot]$-份额。</p>\n<p>$[![\\cdot]!]$-共享：值 $v$ 在 $P_0, P_1, P_2$ 之间是$[![\\cdot]!]$-共享的，如果</p>\n<ul>\n<li>存在值 $\\lambda_v, m_v$ 使得 $v=m_v - \\lambda_v$；</li>\n<li>$P<em>0$ 持有 $\\lambda</em>{v,1}$ 和 $\\lambda<em>{v,2}$ 使得 $\\lambda</em>{v} = \\lambda<em>{v,1} + \\lambda</em>{v,2}$；</li>\n<li>$P<em>1$ 和 $P_2$ 分别持有 $(m_v, \\lambda</em>{v,1})$ 和 $(m<em>v, \\lambda</em>{v,1})$。</li>\n</ul>\n<p>本文将各方的$[![\\cdot]!]$-共享表示为$[![v]!]<em>{P_0} = (\\lambda</em>{v,1}, \\lambda<em>{v,2}), [![v]!]</em>{P<em>1} = (m_v, \\lambda</em>{v,1}) $和 $[![v]!]<em>{P_2} = (m_v, \\lambda</em>{v,2})$。用$[![v]!] = (m<em>v, [\\lambda</em>{v}])$表示 $v$ 的$[![\\cdot]!]$-共享份额。</p>\n<h3 id=\"秘密共享方案的线性\"><a href=\"#秘密共享方案的线性\" class=\"headerlink\" title=\"秘密共享方案的线性\"></a>秘密共享方案的线性</h3><p>给定 $x,y \\in \\mathbb{Z}<em>{2^l}$ 和公共常数 $c_1, c_2 \\in \\mathbb{Z}</em>{2^l}$的$[\\cdot]$-共享，各方可以局部计算 $[c_1x+c_2y]$：</p>\n<script type=\"math/tex; mode=display\">[c_1x+c_2y]=(c_1x_1+c_2y_1, c_1x_2+c_2y_2)=c_1[x]+c_2[y]</script><p>很容易看出线性关系也扩展到$[![\\cdot]!]$-共享。线性属性使各方能够<strong>本地</strong>执行与公共常量的加法和乘法等操作。</p>\n<h2 id=\"3PC协议\"><a href=\"#3PC协议\" class=\"headerlink\" title=\"3PC协议\"></a>3PC协议</h2><h3 id=\"半诚实下的3PC\"><a href=\"#半诚实下的3PC\" class=\"headerlink\" title=\"半诚实下的3PC\"></a>半诚实下的3PC</h3><p>协议 $\\prod ^{\\rm s}_{\\rm 3pc}$ 由三个步骤组成—输入共享、电路评估以及输出重构。所有阶段（重构输出除外）都分为离线和在线阶段，其中独立于实际输入的步骤可以在脱机阶段执行。</p>\n<h4 id=\"输入共享\"><a href=\"#输入共享\" class=\"headerlink\" title=\"输入共享\"></a>输入共享</h4><p>在共享输入阶段，每一方都为自己的输入生成一个随机的$[![\\cdot]!]$-共享。以下是初始共享协议 $\\prod^{\\rm s}_{\\rm Sh}$：</p>\n<hr>\n<p><strong>Offline:</strong></p>\n<ul>\n<li>If $P<em>i = P_0$, parties $P_0, P_j$ for $j \\in {1, 2}$ locally sample a random $\\lambda</em>{x,j} \\in \\mathbb{Z}<em>{2^l}$. Moreover, $P_i$ sets $[![x]!]</em>{P<em>i} = (\\lambda</em>{x,1}, \\lambda_{x,2})$.</li>\n<li>If $P<em>i = P_1$, parties $P_0, P_1$ sample a random $\\lambda</em>{x,1} \\in \\mathbb{Z}<em>{2^l}$ while all the parties in $\\mathcal{P}$ sample a random $\\lambda</em>{x,2} \\in \\mathbb{Z}_{2^l}$.</li>\n<li>If $P<em>i = P_2$, parties $P_0, P_2$ sample a random $\\lambda</em>{x,2} \\in \\mathbb{Z}<em>{2^l}$ while all the parties in $\\mathcal{P}$ sample a random $\\lambda</em>{x,1} \\in \\mathbb{Z}_{2^l}$.</li>\n</ul>\n<p><strong>Online:</strong></p>\n<p>​        $P<em>i$ computes $\\lambda_x = \\lambda</em>{x,1} + \\lambda<em>{x,2}$ and sends $m_x = x + \\lambda_x$ to every $P_j$ for $j \\in {1,2}$ who then sets $[![x]!]</em>{P<em>j} = (m_x, \\lambda</em>{x,j})$.</p>\n<hr>\n<p>在离线阶段根据输入方的序号，使用不同的初始化手段，生成了 $P<em>0$ 的份额 $[![x]!]</em>{P<em>0}=(\\lambda</em>{x,1}, \\lambda_{x,2})$，而不用任何交互（因为随机数都是使用服务器两两之间的公共随机源生成的，可以理解为编程语言中把同样的随机种子输入到random函数——只要随机种子一样生成的随机数序列就一样）。</p>\n<h4 id=\"电路评估\"><a href=\"#电路评估\" class=\"headerlink\" title=\"电路评估\"></a>电路评估</h4><p>在电路评估阶段，各方以$[![\\cdot]!]$-共享的方式评估 ckt。以拓扑顺序评估 ckt 中的每个门 $g$：给定 $g$ 的输入，各方为 $g$ 的输出生成$[![\\cdot]!]$-共享。</p>\n<h5 id=\"加法\"><a href=\"#加法\" class=\"headerlink\" title=\"加法\"></a>加法</h5><p>如果 $g$ 是加法门 $(w<em>x,w_y,w_z)$，可以利用$[![\\cdot]!]$-共享的线性在本地完成。以下是加法协议 $\\prod</em>{\\rm Add} (w_x, w_y, w_z)$：</p>\n<hr>\n<p><strong>Offline:</strong></p>\n<p>​        $P<em>0, P_1$ set $\\lambda</em>{z,1} = \\lambda<em>{x,1} + \\lambda</em>{y,1}$, while $P<em>0, P_2$ set $\\lambda</em>{z,2} = \\lambda<em>{x,2} + \\lambda</em>{y,2}$.</p>\n<p><strong>Online:</strong></p>\n<p>​        $P_1$ and $P_2$ set $m_z = m_x + m_y$.</p>\n<hr>\n<p>这里的加法协议感觉在线阶段完全可以在本地完成，可以不需要在线阶段。</p>\n<h5 id=\"乘法\"><a href=\"#乘法\" class=\"headerlink\" title=\"乘法\"></a>乘法</h5><p>如果 $g=(w<em>x,w_y,w_z)$ 是乘法门，则运行以下乘法协议 $\\prod ^{\\rm s}</em>{\\rm Mul}$：</p>\n<hr>\n<p><strong>Offline:</strong></p>\n<ul>\n<li>$P<em>0$ and $P_1$ locally sample random $\\lambda</em>{z,1}, \\gamma<em>{xy, 1} \\in \\mathbb{Z}</em>{2^l}$, while $P<em>0$ and $P_2$ locally sample random $\\lambda</em>{z,2} \\in \\mathbb{Z}_{2^l}$.</li>\n<li>$P<em>0$ computes $\\gamma</em>{xy} = \\lambda<em>x \\lambda_y$ and sends $\\gamma</em>{xy,2} = \\gamma<em>{xy} - \\gamma</em>{xy,1}$ to $P_2$.</li>\n</ul>\n<p><strong>Online:</strong></p>\n<ul>\n<li>$P<em>i$ for $i \\in {1,2}$ locally computes $[m_z]</em>{P<em>i} = (i-1)m_xm_y - m_x[\\lambda_y]</em>{P<em>i} - m_y[\\lambda_x]</em>{P<em>i} + [\\lambda_z]</em>{P<em>i} + [\\gamma</em>{xy}]_{P_i}$.</li>\n<li>$P_1, P_2$ mutually exchange their shares and reconstruct $m_z$.</li>\n</ul>\n<hr>\n<p>将上面的公式相加一下即可验证其正确性。</p>\n<h4 id=\"输出重构\"><a href=\"#输出重构\" class=\"headerlink\" title=\"输出重构\"></a>输出重构</h4><p>在输出重构阶段，各方重构$[![\\cdot]!]$-共享电路输出。为了重构 $[![y]!]$，可以观察到每个 $P<em>i$ 缺失的份额都在另外两方手里。因此另外两方的其中一方将缺失的份额发送给 $P_i$ 后，通过计算 $y = m_y - \\lambda</em>{y,1} - \\lambda<em>{y,2}$ 即可重构输出 $y$，将其称为重构协议 $\\prod ^{\\rm s}</em>{\\rm Rec}([![y]!], \\mathcal{P})$。</p>\n<p>把上面三个阶段总结起来，有以下的协议 $\\prod ^{\\rm s}_{\\rm 3pc}$：</p>\n<hr>\n<p><strong>Pre-processing (Offline Phase):</strong></p>\n<ul>\n<li><em>Input wires:</em> For $j = 1, …,l$, corresponding to the circuit-input $x<em>j$, parties execute the offline steps of the instance $\\prod ^{\\rm s}</em>{\\rm Sh}(P_i, x_j)$.</li>\n<li>For each gate $g$ in the topological order, execute offline steps of the instance $\\prod ^{\\rm s}<em>{\\rm Mul}(w</em>{xj}, w<em>{yj}, w</em>{zj})$ if $g$ is the $j$th multiplication gate where $j \\in {1,…,\\rm M}$ or respectively offline steps of the instance $\\prod <em>{\\rm Add}(w</em>{xj}, w<em>{yj}, w</em>{zj})$ if $g$ is the $j$th addition gate where $j \\in {1,…,\\rm A}$.</li>\n</ul>\n<p><strong>Circuit Evaluation (Online Phase):</strong></p>\n<ul>\n<li><em>Sharing Circuit-input Values:</em> For $j = 1, …,l$, corresponding to the circuit-input $x<em>j$, parties execute the online steps of the instance $\\prod ^{\\rm s}</em>{\\rm Sh}(P_i, x_j)$, where $P_i$ is the party designated to provide $x_j$.</li>\n<li><em>Gate Evaluation:</em> For each gate in $g$ in ckt in the topological order, $P<em>1, P_2$ execute the online steps of the instance $\\prod ^{\\rm s}</em>{\\rm Mul}(w<em>{xj},w</em>{yj},w<em>{zj})$ if $g$ is the $j$th multiplication gate where $j \\in {1,…,\\rm M}$ or respectively offline steps of the instance $\\prod </em>{\\rm Add}(w<em>{xj}, w</em>{yj}, w_{zj})$ if $g$ is the $j$th addition gate where $j \\in {1,…,\\rm A}$.</li>\n<li><em>Output Reconstruction:</em> Let $[![y<em>1]!],…,[![y</em>\\rm O]!]$ be the shared function outputs. The parties in $\\mathcal{P}$ reconstruct $y<em>j$ for $j = 1,…,\\rm O$ by executing $\\prod ^{\\rm s}</em>{\\rm Rec}([![y_j]!], \\mathcal{P})$.</li>\n</ul>\n<hr>\n<h3 id=\"恶意下的3PC\"><a href=\"#恶意下的3PC\" class=\"headerlink\" title=\"恶意下的3PC\"></a>恶意下的3PC</h3><p>跟半诚实设置下的一样，恶意设置下的3PC协议 $\\prod ^{\\rm m}_{\\rm 3pc}$ 也由输入共享、电路评估和输出重构三个部分组成。</p>\n<h4 id=\"输入共享和输出重构\"><a href=\"#输入共享和输出重构\" class=\"headerlink\" title=\"输入共享和输出重构\"></a>输入共享和输出重构</h4><p>在恶意的设置下，要保证服务器之间的共享份额是一致的。在 $\\prod ^{\\rm s}_{\\rm Sh}$ 中，$\\lambda$ 的共享是一致的，因为它不需要交互就可以生成。但如果一个腐败的 $P_0$ 拥有 $x$ 并且想制造一个不一致的 $[![x]!]$-共享，它可以分别发送两个不一样的 $m_x$ 给 $P_1$ 和 $P_2$。为了检查这种情况的发生，$P_1$ 和 $P_2$ 交换 $H(m_x)$ 并在不一致的时候中止。</p>\n<p>令 $[![y]!]$ 为一个待重构的一致的共享，$[![y]!]<em>{P_0} = (\\lambda</em>{y,1}, \\lambda<em>{y,2})$、$[![y]!]</em>{P<em>1} = (m’</em>{y}, \\lambda<em>{y,1})$ 和 $[![y]!]</em>{P<em>2} = (m’’</em>{y}, \\lambda<em>{y,2})$ 分别为三个服务器的份额。协议 $\\prod ^{\\rm m}</em>{\\rm Rec}([![y]!], \\mathcal{P})$ 允许每一个诚实方输出 $y$ 或 $\\perp$：</p>\n<hr>\n<p><strong>Online:</strong></p>\n<ul>\n<li>$P<em>0$ and $P_2$ send $\\lambda</em>{y,2}$ and $H(\\lambda’_{y,2})$ respectively to $P_1$.</li>\n<li>$P<em>0$ and $P_1$ send $\\lambda</em>{y,1}$ and $H(\\lambda’_{y,1})$ respectively to $P_2$.</li>\n<li>$P<em>1$ and $P_1$ send $m’</em>{y}$ and $H(m’_{y})$ respectively to $P_0$.</li>\n</ul>\n<p>$P<em>i$ for $i \\in {0,1,2}$ abort if the received values mismatch. Else $P_i$ sets $y = m_y - \\lambda</em>{y,1} - \\lambda_{y,2}$.</p>\n<hr>\n<p>检查的过程中，其中一方发送哈希值可以提高效率。</p>\n<h4 id=\"电路评估-1\"><a href=\"#电路评估-1\" class=\"headerlink\" title=\"电路评估\"></a>电路评估</h4><p>在恶意设置下加法协议 $\\prod <em>{\\rm Add}$ 同样是安全的，因为它只涉及本地操作。挑战在于构造乘法协议 $\\prod ^{\\rm m}</em>{\\rm Mul}$，令其可以容忍其中一方腐败。可以观察到有两种情况：</p>\n<ul>\n<li>$P<em>0$ 是腐败的：在离线阶段会令 $\\gamma</em>{xy} \\neq \\lambda_x \\lambda_y$</li>\n<li>$P_1$ 或 $P_2$ 是腐败的：会在在线阶段扰乱，使诚实的另一方重构出一个错误的 $m_z$</li>\n</ul>\n<p>先看下面的情况，假如 $P<em>1$ 现在需要验证它重构的 $m_z$ 是否是正确的，可以向 $P_0$ 求助：$P_1$ 可以发送 $m_x, m_y$ 给 $P_0$，因为 $P_0$ 在离线阶段就已经知道 $\\lambda_x, \\lambda_y$ 和 $\\lambda_z$，因此它可以计算出 $m_z$ 并发送给 $P_1$，以此得到验证。但发送 $m_x, m_y$ 给 $P_0$ 会导致打破了原有共享的私密性，所以 $P_1$ 可以对应的值盲化后发送给 $P_0$：$m^{\\star}_x = m_x + \\delta_x$ 和 $m^{\\star}_y = m_y + \\delta_y$，然后 $P_0$ 计算 $m^{\\star}_z = -m^{\\star}_x \\lambda_y - m^{\\star}_y \\lambda_x +\\lambda_z + 2\\gamma</em>{xy}$。注意到：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{align}\nm^{\\star}_z &= -m^{\\star}_x \\lambda_y - m^{\\star}_y \\lambda_x +\\lambda_z + 2\\gamma_{xy}\\\\\n &= -(m_x + \\delta_x) \\lambda_y - (m_y + \\delta_y) \\lambda_x +\\lambda_z + 2\\gamma_{xy}\\\\\n &= (m_z - m_x m_y) - \\chi\n\\end{align}</script><p>假设 $P<em>0$ 知道 $\\chi = \\delta_x \\lambda_y + \\delta_y \\lambda_x - \\gamma</em>{xy}$，它就可以计算出 $m^{\\star}_z + \\chi$ 然后发送给 $P_1$。因为 $P_1$ 知道 $m_x, m_y$ 的值，因此它可以验证它重构的 $m_z$ 的正确性，对于 $P_2$ 来说也可以这样验证。</p>\n<p>现在来描述如何使 $P<em>0$ 获得 $\\chi$：首先直接让 $P_0$ 获得 $\\chi$ 会导致共享的私密性被破坏，因为 $P_0$ 知道 $\\lambda_x, \\lambda_y$ 和 $\\gamma</em>{xy}$ 的值，同时在在线阶段又得到 $m<em>x + \\delta_x$ 和 $m_y + \\delta_y$，导致 $P_0$ 可以推导出 $m_x, m_y$ 之间的关系。所以还要在 $\\chi$ 中加入一个随机值 $\\delta_z$ 进行盲化：$\\delta_x \\lambda_y + \\delta_y \\lambda_x + \\delta_z - \\gamma</em>{xy}$。</p>\n<p>生成 $\\chi$ 的过程：$P<em>1, P_2$ 在本地生成随机数 $\\delta_x, \\delta_y, \\delta_z \\in \\mathbb{Z}</em>{2^l}$，计算各自的 $\\chi$ 的 $[\\cdot]$-共享并发送给 $P<em>0$。对于 $i \\in {1,2 }$，令 $[\\chi]</em>{P_i} = \\chi_i$。$P_0$ 在本地将共享的份额相加得到 $\\chi$。在以上步骤中，腐败的一方可能会在执行过程中引入错误，使得 $P_0$ 获得的 $\\chi$ 是错误的。</p>\n<p>总而言之在离线阶段有两个问题需要解决：</p>\n<ul>\n<li>腐败的 $P<em>0$ 可以不正确地共享 $\\gamma</em>{xy}$</li>\n<li>腐败的 $P_1$ 或 $P_2$ 可以发送错误的 $\\chi$ 的 $[\\cdot]$-共享给 $P_0$</li>\n</ul>\n<p>为了解决这些问题，$P_0$ 一旦获得 $\\chi$，就用下面的方式计算 $a = \\delta_x - \\lambda_x$、$b = \\delta_y - \\lambda_y$ 和 $c = (\\delta_z + \\delta_x \\delta_y) - \\chi$ 的 $[![\\cdot]!]$-共享：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{align*}\n[\\![a]\\!]_{P_0} &= (\\lambda_{x,1}, \\lambda_{x,2}), & [\\![b]\\!]_{P_0} &= (\\lambda_{y,1}, \\lambda_{y,2}), & [\\![c]\\!]_{P_0} &= (\\chi_{1}, \\chi_{2})\\\\\n [\\![a]\\!]_{P_1} &= (\\delta_x, \\lambda_{x,1}), & [\\![b]\\!]_{P_1} &= (\\delta_y, \\lambda_{y,1}), & [\\![c]\\!]_{P_1} &= (\\delta_z + \\delta_x \\delta_y, \\chi_{1})\\\\\n [\\![a]\\!]_{P_2} &= (\\delta_x, \\lambda_{x,2}), & [\\![b]\\!]_{P_2} &= (\\delta_y, \\lambda_{y,2}), & [\\![c]\\!]_{P_2} &= (\\delta_z + \\delta_x \\delta_y, \\chi_{2})\n\\end{align*}</script><p>现在 $([![a]!], [![b]!], [![c]!])$ 是一个乘法三元组 $(c=ab)$，当且仅当 $P<em>0$ 正确分享了 $\\gamma</em>{xy}$（当它腐败时）以及重构的 $\\chi$ 是正确的（当 $P_1,P_2$ 其中之一腐败时），因为：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{align}\nab &= (\\delta_x - \\lambda_x)(\\delta_y - \\lambda_y) = \\delta_x \\delta_y + \\lambda_x \\lambda_y - \\delta_x \\lambda_y - \\delta_y \\lambda_x \\\\\n &= (\\delta_x \\delta_y + \\delta_z) - (\\delta_x \\lambda_y + \\delta_y \\lambda_x + \\delta_z - \\gamma_{xy}) \\\\\n  &= (\\delta_x \\delta_y + \\delta_z) - \\chi = c\n\\end{align}</script><p>然后作者给出了一个检查乘法三元组是否正确的协议，这里需要用到另一个有效的乘法三元组 $([![d]!], [![e]!], [![f]!])$，它们满足以下条件：</p>\n<ul>\n<li>$d, e, f$ 都是随机且私密的</li>\n<li>$f = d e$</li>\n</ul>\n<p>这里假设这个三元组是通过 $\\mathcal{F}_{\\rm trip}$ 生成的，在[2, 30]中有具体构造，下面是[30]中的构造：</p>\n<p><img src=\"http://images.yingwai.top/picgo/ASTRAf1.png\" alt=\"\"></p>\n<p>用  $\\prod <em>{\\rm trip}$ 表示该功能的实例化，下面是作者给出检查有效性的协议 $\\prod </em>{\\rm prc}$：</p>\n<hr>\n<ul>\n<li>Parties locally compute $[![\\rho]!] = [![a]!] - [![d]!]$ and $[![\\sigma]!] = [![b]!] - [![e]!]$.</li>\n<li>Parties reconstruct $\\rho$ and $\\sigma$ by executing $\\prod ^{\\rm m}<em>{\\rm Rec}([![\\rho]!], \\mathcal{P})$ and $\\prod ^{\\rm m}</em>{\\rm Rec}([![\\sigma]!], \\mathcal{P})$ respectively.</li>\n<li>Parties locally compute $[![\\tau]!] = [![c]!] - [![f]!] - \\sigma [![d]!] - \\rho [![e]!] - \\sigma \\rho$.</li>\n<li>Parties reconstruct $\\tau$ by executing $\\prod ^{\\rm m}_{\\rm Rec}([![\\tau]!], \\mathcal{P})$ and output $\\perp$, if $\\tau \\neq 0$.</li>\n</ul>\n<hr>\n<p>协议 $\\prod _{\\rm prc}$ 需要两对秘密共享三元组 $(a, b, c)$ 和 $(d, e, f)$，验证前一个三元组是否满足 $c = a b$：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{align}\n\\tau &= c - f - \\sigma d - \\rho e - \\sigma \\rho \\\\\n &= c - de - (b - e)d - (a - d)e - (b - e)(a - d) \\\\\n &= c - ab = \\Delta\n\\end{align}</script><p>所以 $\\tau = 0$ 时 $(a,b,c)$ 有效，反之无效。而检验 $\\tau$ 是否为0只需要一方跟另外两方各通信一次即可：(1) $P<em>0$ 跟 $P_1$ 检查 $m</em>\\tau - \\lambda<em>{\\tau,1}$ 跟 $\\lambda</em>{\\tau, 2}$ 是否相等；(2) $P<em>1$ 跟 $P_2$ 检查 $m</em>\\tau - \\lambda<em>{\\tau,2}$ 跟 $\\lambda</em>{\\tau, 1}$ 是否相等；(3) $P<em>0$ 跟 $P_1$ 检查 $m</em>\\tau - \\lambda<em>{\\tau,2}$ 跟 $\\lambda</em>{\\tau, 1}$ 是否相等，而不是 $\\prod ^{\\rm m}<em>{\\rm Rec}$ 的通信三次（两次发送一次接收）。下面给出恶意设置下的乘法协议 $\\prod ^{\\rm m}</em>{\\rm Mul}(w_x, w_y, w_z)$：</p>\n<hr>\n<p><strong>Offline:</strong></p>\n<ul>\n<li>Parties $P<em>0, P_1$ locally sample random $\\lambda</em>{z,1}, \\gamma<em>{xy,1} \\in \\mathbb{Z}</em>{2^l}$, while $P<em>0, P_2$<br>locally sample a random $\\lambda</em>{z,2}$. $P<em>0$ locally computes $\\gamma</em>{xy}= \\lambda<em>x \\lambda_y$ and<br>sends $\\gamma</em>{xy,2} = \\gamma<em>{xy} - \\gamma</em>{xy,1}$ to $P_2$.</li>\n<li>Parties execute $\\prod _{\\rm trip}$ to generate a triple $([![d]!], [![e]!], [![f]!])$.</li>\n<li>Parties $P<em>1, P_2$ locally sample random $\\delta_x, \\delta_y, \\delta_z \\in \\mathbb{Z}</em>{2^l}$ and compute<br>$[\\delta_z]$ non-interactively.</li>\n<li>$P<em>i$ for $i \\in {1, 2}$ computes $[\\chi]</em>{P<em>i} = \\delta_x[\\lambda_y]</em>{P<em>i} + \\delta_y[\\lambda_x]</em>{P<em>i} + [\\delta_z]</em>{P<em>i} − [\\gamma</em>{xy}]<em>{P_i}$ and sends $[\\chi]</em>{P_i}$ to $P_0$, who computes $\\chi$.</li>\n<li>Parties locally compute the $[![\\cdot]!]$-shares of the values $a = \\delta_x - \\lambda_x$, $b = \\delta_y - \\lambda_y$ and $b = (\\delta_z + \\delta_x \\delta_y) - \\chi$, as described in the text.</li>\n<li>Parties execute $\\prod _{\\rm prc}$ on $([![a]!], [![b]!], [![c]!])$ and $([![d]!], [![e]!], [![f]!])$.</li>\n</ul>\n<p><strong>Online:</strong></p>\n<ul>\n<li>$P<em>i$ for $i \\in {1, 2}$ locally computes $[m_z]</em>{P<em>i} = (i-1)m_xm_y - m_x[\\lambda_y]</em>{P<em>i} - m_y[\\lambda_x]</em>{P<em>i} + [\\lambda_z]</em>{P<em>i} + [\\gamma</em>{xy}]_{P_i}$. $P_1, P_2$ mutually exchange their shares and reconstruct $m_z$.</li>\n<li>$P<em>1$ sends $m^{\\star}_x = m_x + \\delta_x$, $m^{\\star}_y = m_y + \\delta_y$ to $P_0$, while $P_2$ sends $H(m^{\\star}_x || m^{\\star}</em>{y})$ to $P_0$.$P_0$ outputs $\\perp$, if the received values are inconsistent.</li>\n<li>$P<em>0$ computes $m^{\\star}_z = -m^{\\star}_x \\lambda_y - m^{\\star}_y \\lambda_x +\\lambda_z + 2\\gamma</em>{xy} + \\chi$ and sends $H(m^\\star_z)$ to both $P_1$ and $P_2$.</li>\n<li>$P_i$ for $i \\in {1, 2}$ abort if $H(m^\\star_z) \\neq H(m_z - m_x m_y + \\delta_z)$.</li>\n</ul>\n<hr>\n<p>散列值的使用提高了效率，减少了通信的开销。</p>\n<p>对于正确性，首先考虑腐败的 $P<em>0$ 不正确地共享使得 $\\gamma</em>{xy} = \\lambda<em>x \\lambda_y + \\Delta$ 的情况，其中 $\\Delta$ 是 $P_0$ 引入的不为零的干扰。这种情况在执行 $\\prod </em>{\\rm prc}$ 就会被检测到，因为最终计算出来并重构的 $\\tau \\neq 0$。同样的， $P<em>1$（或 $P_2$）在协议 $\\prod ^{\\rm m}</em>{\\rm Mul}$ 离线阶段的第四步时发送 $\\chi_1 + \\Delta$（或 $\\chi_2 + \\Delta$） 给 $P_0$ 使其重构的 $\\chi’ = \\chi + \\Delta$，也会导致 $\\tau \\neq 0$ 从而被诚实方发现并中止计算。</p>\n<p>然后是另一种情况，假如 $P<em>1$（或 $P_2$）在重构 $m_z$ 时发送了错误的 $[m_z]</em>{P_i}$ 给另一方，会在最后一步验证哈希值是否相等的时候被检测出来；而在在线阶段第二步中 $P_0$ 对 $m^{\\star}_x,m^{\\star}_y$ 的一致性检查也确保了它所计算出来的 $m^{\\star}_z$ 是正确的。</p>\n<h4 id=\"公平的实现\"><a href=\"#公平的实现\" class=\"headerlink\" title=\"公平的实现\"></a>公平的实现</h4><p>作者通过一种公平重构协议 $\\prod<em>{\\rm fRec}$ 来重构电路输出，将 $\\prod ^{\\rm m}</em>{\\rm 3pc}$ 的安全性提高到公平，保证交易的三方都不能通过损害别人的利益而得到自己不应得的利益。这里使用到了承诺方案，还是利用了服务器之间的公共随机源并使用PRF来为承诺方案引入随机性：</p>\n<hr>\n<p><strong>Offline:</strong></p>\n<ul>\n<li>Parties $P<em>0, P_1$ locally sample a random $r_1 \\in \\mathbb{Z}</em>{2^l}$, prepare and send commitments of $\\lambda<em>{y,1}$ and $r_1$ to $P_2$. Similarly, parties $P_0, P_2$ locally sample a random $r_2 \\in \\mathbb{Z}</em>{2^l}$, prepare and send commitments of $\\lambda_{y,2}$ and $r_2$ to $P_1$. The randomness needed for both commitments are sampled from the PRF key-setup.</li>\n<li>$P_1$ (resp. $P_2$) aborts if the received commitments mismatch.</li>\n</ul>\n<p><strong>Online:</strong></p>\n<ul>\n<li>$P_1, P_2$ compute a commitment of $m_y$ using randomness sampled from their PRF key-setup and send it to $P_0$.</li>\n<li>If the commitments do not match, $P_0$ sends (<strong>abort</strong>, $o_1$) to $P_2$, while it sends (<strong>abort</strong>, $o_2$) to $P_1$ and aborts, where $o_i$ denotes the opening information for the commitment of $r_i$. Else $P_0$ sends <strong>continue</strong> to both $P_1$ and $P_2$.</li>\n<li>$P_1, P_2$ exchange the messages received from $P_0$.</li>\n<li>$P_1$ aborts if it receives either (i) (<strong>abort</strong>, $o_2$) from $P_0$ and $o_2$ opens the commitment of $r_2$ or (ii) (<strong>abort</strong>, $o_1$) from $P_2$ and $o_1$ is the correct opening information of $r_1$. The case for $P_2$ is similar to that of $P_1$.</li>\n<li>If no abort happens, parties obtain their missing share of $a$ as follows:<ul>\n<li>$P<em>0, P_1$ open $\\lambda</em>{y,1}$ towards $P_2$.</li>\n<li>$P<em>0, P_2$ open $\\lambda</em>{y,2}$ towards $P_1$.</li>\n<li>$P_1, P_2$ open $m_y$ towards $P_0$.</li>\n</ul>\n</li>\n<li>Parties reconstruct the value $y$ using missing share that matches with the agreed upon commitment.</li>\n</ul>\n<hr>\n<p>当没有广播频道的时候，一个非常棘手的问题就会存在：一个腐败的 $P<em>0$ 可以发送不同的信号给 $P_1$ 和 $P_2$（一个为 abort 而另一个为 continue），以上的重构协议 $\\prod</em>{\\rm fRec}([![y]!], \\mathcal{P})$ 解决了这个问题。在离线阶段 $P_0$ 和 $P_1$ 共同计算出一个关于 $r_1$ 的承诺发送给 $P_2$，同样地 $P_0$ 和 $P_2$ 共同计算出一个关于 $r_2$ 的承诺发送给 $P_1$。这两个承诺就可以确保 $P_1$ 跟 $P_2$ 可以验证它们收到的来自 $P_0$ 的信号是否一致：例如当 $P_1$ 收到 abort 而 $P_2$ 收到 continue，在它们交换信息时，$P_1$ 就可以利用收到的 $o_2$ 证明自己收到了 abort 信号，反过来也是一样的。同时还解决了一个问题，就是当一个腐败的 $P_1$ 收到了 $P_0$ 发送的 continue 信号，但它不能在与 $P_2$ 交换信息时宣称自己收到了 abort 信号，因为它没有 $o_2$，因此无法证明，对于 $P_2$ 腐败的情况也是一样的。</p>\n<p>这里的承诺方案可以通过一个哈希函数来实现，例如：$(c, o) = (\\mathcal{H}(x||r),x||r) = Com(x;r)$</p>\n<h2 id=\"隐私保护机器学习\"><a href=\"#隐私保护机器学习\" class=\"headerlink\" title=\"隐私保护机器学习\"></a>隐私保护机器学习</h2><h3 id=\"模型\"><a href=\"#模型\" class=\"headerlink\" title=\"模型\"></a>模型</h3><p>对于每一个预测函数，模型拥有者 $\\rm M$ 拥有一个训练好的参数向量，想为拥有一个查询向量的客户 $\\rm C$ 提供预测服务。在服务器辅助设置中，$\\rm M$ 和 $\\rm C$ 以共享方式将各自的输入外包给三个不受信任但非合谋的服务器 ${P_0, P_1, P_2}$，这些服务器通过为本文的3PC协议开发的技术以共享方式执行计算，并将输出单独重构到客户端。客户只能知道输出，除此之外什么也不知道。</p>\n<h3 id=\"对于ML的协议\"><a href=\"#对于ML的协议\" class=\"headerlink\" title=\"对于ML的协议\"></a>对于ML的协议</h3><h4 id=\"安全向量点积\"><a href=\"#安全向量点积\" class=\"headerlink\" title=\"安全向量点积\"></a>安全向量点积</h4><p>对于向量的 $[\\cdot]$-共享和 $[![\\cdot]!]$-共享，就是对应每个维度的值进行$[\\cdot]$-共享和 $[![\\cdot]!]$-共享，容易知道对于向量来说两种共享仍然是线性的。对于两个 $d$ 维向量的点积，不考虑效率的情况下可以执行 $d$ 次 $\\prod ^{\\rm s}<em>{\\rm Mul}$协议，再对这 $d$ 次执行的结果简单进行相加，各方就可以得到它们的份额。在这里作者给出一个更高效率的向量点积协议 $\\prod ^{\\rm s}</em>{\\rm dp}$：</p>\n<hr>\n<p><strong>Offline:</strong></p>\n<p>​        $P<em>0, P_1$ sample random $\\lambda</em>{u,1}, \\gamma<em>{pq,1} \\in \\mathbb{Z}</em>{2^l}$, while $P<em>0, P_2$ sample random $\\lambda</em>{u,2} \\in \\mathbb{Z}<em>{2^l}$. $P_0$ locally computes $\\gamma</em>{pq} = \\vec{\\lambda<em>p} \\odot \\vec{\\lambda_q}$, sets $\\gamma</em>{pq,2} = \\gamma<em>{pq} - \\gamma</em>{pq,1}$ and sends $\\gamma_{pq,2}$ to $P_2$.</p>\n<p><strong>Online:</strong></p>\n<ul>\n<li>$P<em>i$ for $i \\in {1,2}$ locally computes $[m_u]</em>{P<em>i} = \\sum^d</em>{j=1}((i-1)m<em>{p_j}m</em>{q<em>j} - m</em>{p<em>j}[\\lambda</em>{q<em>j}]</em>{P<em>i} - m</em>{q<em>j}[\\lambda</em>{p<em>j}]</em>{P<em>i}) + [\\gamma</em>{pq}]<em>{P_i} + [\\lambda_u]</em>{P_i}$.</li>\n<li>$P_1$ and $P_2$ mutually exchange their share of $[m_u]$ to reconstruct $m_u$.</li>\n</ul>\n<hr>\n<p>上面的协议的离线阶段中，$P<em>0$ 仅仅共享了 $\\gamma</em>{pq} = \\vec{\\lambda<em>p} \\odot \\vec{\\lambda_q}$ 而不是每一个 $\\lambda</em>{p<em>i} \\lambda</em>{q<em>i}$；在在线阶段，$P_1, P_2$ 直接计算 $[m_u]$（其中 $u = \\vec{p} \\odot \\vec{q}$）而不是每一个 $m</em>{p_i q_i}$。</p>\n<p>接下来作者还对恶意设置下的点积进行了讨论：由于在乘法协议中引入了对恶意对手的额外检查，所以上面针对半诚实协议所作的优化是不适用的。对两个 $d$ 维向量的点积，只能 $d$ 次调用协议 $\\prod ^{\\rm m}<em>{\\rm Mul}$。不过作者还是对在线阶段的开销进行了改进：在在线阶段 $P_1$ 并行地发送 $m^{\\star}</em>{p<em>i}, m^{\\star}</em>{q<em>i}$ 给 $P_0$，而 $P_2$ 则发送对应的哈希值给 $P_0$。$P_0$ 收到这些值后进行验证，若一致则将它们“结合”所有的 $m^{\\star}</em>{p<em>i q_i}$ 然后发送一个单独的 $m^\\star_u$ 的哈希值给 $P_1, P_2$，最后 $P_1, P_2$ 在本地验证是否与 $m_u - \\sum^d</em>{j=1}(m<em>{p_j}m</em>{q<em>j} - \\delta</em>{u<em>j})$。这样做的话就节省了在线阶段的开销，不用每个 $m^{\\star}</em>{p<em>i}, m^{\\star}</em>{q_i}$ 都发送一次。</p>\n<h4 id=\"安全比较\"><a href=\"#安全比较\" class=\"headerlink\" title=\"安全比较\"></a>安全比较</h4><p>给定算术共享 $[![u]!], [![v]!]$，各方希望验证 $u$ 是否小于 $v$，等同于验证 $a$ 是否小于 $0$（其中 $a = u - v$），在定点表示中可以通过检查 ${\\rm msb}(a)$ 来完成（二进制补码中第一位为符号位）。于是可以把在给定算术共享 $[![a]!]$ 的情况下生成 ${\\rm msb}(a)$ 的布尔共享作为目标，在这里作者利用了秘密共享方案中的不对称性，放弃了 <em>SecureML</em>[48]和 <em>ABY3</em>[46]中的昂贵协议。</p>\n<hr>\n<p><strong>Offline:</strong></p>\n<p>​        $P<em>1, P_2$ together sample a random $r, r’ \\in \\mathbb{Z}</em>{2^l}$ and set $p= \\rm{msb}$$(r)$. Parties non-interactively generate Boolean share of $p$ as $[![p]!]^{\\rm B}<em>{P_0} = (0,0)$, $[![p]!]^{\\rm B}</em>{P<em>1} = (p,0)$ and $[![p]!]^{\\rm B}</em>{P_2} = (p,0)$.</p>\n<p><strong>Online:</strong></p>\n<p>​        $P<em>1$ set $[a]</em>{P<em>1}=m_a - \\lambda</em>{a,1}$, $P<em>2$ set $[a]</em>{P<em>2}=- \\lambda</em>{a,2}$.</p>\n<ul>\n<li>$P<em>1$ sends $[ra]</em>{P<em>1} = r[a]</em>{P<em>1} + r’$ to $P_0$, while $P_2$ sends $[ra]</em>{P<em>2} = r[a]</em>{P_1} - r’$ to $P_0$, who adds them to obtain $ra$.</li>\n<li>$P<em>0$ executes $\\prod^{\\rm s}</em>{\\rm Sh}(P<em>0, q)$ over $\\mathbb{Z}</em>{2^1}$ to generate $[![q]!]^{\\rm B}$ where $q = {\\rm msb}(ra)$.</li>\n<li>Parties locally compute $[![\\mbox{msb}(a)]!]^{\\rm B} = [![p]!]^{\\rm B} \\oplus [![q]!]^{\\rm B}$.</li>\n</ul>\n<hr>\n<p>上面的协议用 $\\prod ^{\\rm s}_{\\rm BitExt}([![a]!], \\mathcal{P})$ 表示。这里上面用到了一个随机数 $r$ 来对 $a$ 的值进行盲化，并且可以注意到 ${\\rm sign}(a \\cdot r) = {\\rm sign}(a) \\oplus {\\rm sign}(r)$，所以 $r$ 不会对生成共享份额造成影响且使得三者都不能从这个过程中知道关于 $a$ 的信息。</p>\n<p>对于恶意的情况，就不能仅仅依靠 $P<em>0$ 来生成 $[![{\\rm msb}(ra)]!]^{\\rm B}$，下面给出了修改后的协议 $\\prod ^{\\rm m}</em>{\\rm BitExt}([![a]!], \\mathcal{P})$：</p>\n<hr>\n<p><strong>Offline:</strong></p>\n<p>​        $P<em>1, P_2$ sample a random $r_1 \\in \\mathbb{Z}</em>{2^l}$ and set $p<em>1 = {\\rm msb}(r_1)$ while $P_0, P_2$ sample a random $r_2 \\in \\mathbb{Z}</em>{2^l}$ and set $p_2 = {\\rm msb}(r_2)$.</p>\n<ul>\n<li>Parties non-interactively generate $[![\\cdot]!]$-shares of $r<em>1$ as $[![r_1]!]</em>{P<em>0}=(0,0)$, $[![r_1]!]</em>{P<em>1}=(r_1,0)$ and $[![r_1]!]</em>{P_2}=(r_1,0)$.</li>\n<li>Parties non-interactively generate $[![\\cdot]!]$-shares of $r<em>1$ as $[![r_2]!]</em>{P<em>0}=(0,-r_2)$, $[![r_1]!]</em>{P<em>1}=(0,0)$ and $[![r_1]!]</em>{P_2}=(0,-r_2)$.</li>\n<li>Parties execute $\\prod^{\\rm m}_{\\rm Mul}$ on $r_1$ and $r_2$ to generate $[![r]!] = [![r_1 r_2]!]$.</li>\n<li>Parties non-interactively generate Boolean shares of $p<em>1$ as $[![p_1]!]^{\\rm B}</em>{P<em>0}=(0,0)$, $[![p_1]!]^{\\rm B}</em>{P<em>1}=(p_1,0)$ and $[![p_1]!]^{\\rm B}</em>{P_2}=(p_1,0)$.</li>\n<li>Parties non-interactively generate Boolean shares of $p<em>2$ as $[![p_2]!]^{\\rm B}</em>{P<em>0}=(0,p_2)$, $[![p_2]!]^{\\rm B}</em>{P<em>1}=(0,0)$ and $[![p_2]!]^{\\rm B}</em>{P_2}=(0,p_2)$.</li>\n<li>Parties locally compute $[![p]!]^{\\rm B}=[![p_1]!]^{\\rm B} \\oplus [![p_2]!]^{\\rm B}$.</li>\n</ul>\n<p><strong>Online:</strong></p>\n<ul>\n<li>Parties execute $\\prod ^{\\rm m}<em>{\\rm Mul}$ on $[![r]!]$ and $[![a]!]$ to generate $[![ra]!]$ followed by enabling $P_0, P_1$ to reconstruct $ra$ (this is done by slightly modifying the protocol $\\prod ^{\\rm m}</em>{\\rm Rec}$ ).</li>\n<li>$P<em>1$ executes $\\prod ^{\\rm m}</em>{\\rm Sh}(P<em>1, q)$ over $\\mathbb{Z}</em>{2^1}$ to generate $[![q]!]^{\\rm B}$ where $q = {\\rm msb}(ra)$. In parallel, $P<em>0$ locally computes $m_q$ and sends ${\\rm H}(m_q)$ to $P_2$, who abort if the value mismatches with the hash of the value $m_q$ received from $P_1$ as part of $\\prod ^{\\rm m}</em>{\\rm Sh}(P_1, q)$.</li>\n<li>Parties locally compute $[![{\\rm msb}(a)]!]^{\\rm B} = [![p]!]^{\\rm B} \\oplus [![q]!]^{\\rm B}$.</li>\n</ul>\n<hr>\n<h4 id=\"ML预测函数\"><a href=\"#ML预测函数\" class=\"headerlink\" title=\"ML预测函数\"></a>ML预测函数</h4><ul>\n<li><strong>线性回归</strong>：$\\rm M$ 有一个 $d$ 维的模型参数向量 $\\vec{w}$ 和偏置项 $b$，$\\rm C$ 有一个 $d$ 维的查询向量 $\\vec{z}$。$\\rm C$ 获得 $f_{\\rm linr}((\\vec{w}, b),\\vec{z}) = \\vec{w} \\odot \\vec{z} + b$，其中 $\\vec{w} \\odot \\vec{z}$ 是向量 $\\vec{w}$ 和向量 $\\vec{z}$ 的点积；</li>\n<li><strong>SVM回归</strong>：$\\rm M$ 有${\\alpha<em>j, y_j }^k</em>{j=1}$ 和 $d$ 维的支持向量 ${\\vec{x<em>j}}^k</em>{j=1}$，$\\rm C$ 有一个 $d$ 维的查询向量 $\\vec{z}$。$\\rm C$ 获得 $f<em>{\\rm svmr}(({\\alpha_j, y_j, \\vec{x_j} }^k</em>{j=1}, b), \\vec{z}) = \\sum^k_{j=1} \\alpha_j y_j (\\vec{x_j} \\odot \\vec{z}) + b$；</li>\n<li><strong>逻辑回归</strong>：$\\rm M$ 和 $\\rm C$ 的输入和线性回归类似，$\\rm M$ 还需要提供一个在 $[0,1]$ 范围内的额外输入 $t$。$\\rm C$ 获得 $f_{\\rm logr}((\\vec{w}, b, t), \\vec{z}) = {\\rm sign}((\\vec{w} \\odot \\vec{z} + b) - {\\rm ln}(\\frac{t}{1-t}))$，其中 ${\\rm sign}(\\cdot)$ 返回对象的符号位；</li>\n<li><strong>SVM分类</strong>：$\\rm M$ 和 $\\rm C$ 的输入和SVM回归一样，但对 $\\rm C$ 的输出变为 $f<em>{\\rm svmr}(({\\alpha_j, y_j, \\vec{x_j} }^k</em>{j=1}, b), \\vec{z}) = {\\rm sign}(\\sum^k_{j=1} \\alpha_j y_j (\\vec{x_j} \\odot \\vec{z}) + b)$。</li>\n</ul>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><p>[1] V. A. Abril, P. Maene, N. Mertens, and N. P. Smart. 2019. <em>Bristol Fashion MPC Circuits.</em> <a href=\"https://homes.esat.kuleuven.be/~nsmart/MPC/\" target=\"_blank\" rel=\"noopener\">https://homes.esat.kuleuven.be/~nsmart/MPC/</a>.<br>[2] T. Araki, A. Barak, J. Furukawa, T. Lichter, Y. Lindell, A. Nof, K. Ohara, A. Watzman, and O. Weinstein. 2017. <em>Optimized Honest-Majority MPC for Malicious Adversaries - Breaking the 1 Billion-Gate Per Second Barrier.</em> In IEEE S&amp;P. 843–862.<br>[3] T. Araki, A. Barak, J. Furukawa, Y. Lindell, A. Nof, and K. Ohara. 2016. <em>DEMO: High-Throughput Secure Three-Party Computation of Kerberos Ticket Generation.</em> In ACM CCS. 1841–1843.<br>[4] T. Araki, J. Furukawa, Y. Lindell, A. Nof, and K. Ohara. 2016. <em>High-Throughput Semi-Honest Secure Three-Party Computation with an Honest Majority.</em> In ACM CCS. 805–817.<br>[5] C. Baum, I. Damgård, T. Toft, and R. W. Zakarias. 2016. <em>Better Preprocessing for Secure Multiparty Computation.</em> In ACNS. 327–345.<br>[6] D. Beaver. 1991. <em>Efficient Multiparty Protocols Using Circuit Randomization.</em> In CRYPTO. 420–432.<br>[7] D. Beaver. 1995. <em>Precomputing Oblivious Transfer.</em> In CRYPTO. 97–109.<br>[8] Z. Beerliová-Trubíniová and M. Hirt. 2006. <em>Efficient Multi-party Computation with Dispute Control.</em> In TCC. 305–328.<br>[9] Z. Beerliová-Trubíniová and M. Hirt. 2008. <em>Perfectly-Secure MPC with Linear Communication Complexity.</em> In TCC. 213–230.<br>[10] M. Ben-Or, S. Goldwasser, and A. Wigderson. 1988. <em>Completeness Theorems for Non-Cryptographic Fault-Tolerant Distributed Computation (Extended Abstract).</em> In ACM STOC. 1–10.<br>[11] Christopher Bishop. 2006. <em>Pattern Recognition and Machine Learning.</em><br>[12] D. Bogdanov, S. Laur, and J. Willemson. 2008. <em>Sharemind: A Framework for Fast Privacy-Preserving Computations.</em> In ESORICS. 192–206.<br>[13] D. Bogdanov, R. Talviste, and J. Willemson. 2012. <em>Deploying Secure Multi-Party Computation for Financial Data Analysis.</em> In FC. 57–64.<br>[14] M. Byali, A. Joseph, A. Patra, and D. Ravi. 2018. <em>Fast Secure Computation for Small Population over the Internet.</em> ACM CCS (2018), 677–694.<br>[15] O. Catrina and S. de Hoogh. 2010. <em>Secure Multiparty Linear Programming Using Fixed-Point Arithmetic.</em> In ESORICS. 134–150.<br>[16] N. Chandran, J. A. Garay, P. Mohassel, and S. Vusirikala. 2017. <em>Efficient, Constant-Round and Actively Secure MPC: Beyond the Three-Party Case.</em> In ACM CCS. 277–294.<br>[17] H. Chaudhari, A. Choudhury, A. Patra, and A. Suresh. 2019. <em>ASTRA: High-throughput 3PC over Rings with Application to Secure Prediction.</em> <a href=\"https://eprint.iacr.org/2019/429\" target=\"_blank\" rel=\"noopener\">https://eprint.iacr.org/2019/429</a>. In IACR Cryptology ePrint Archive.<br>[18] K. Chida, D. Genkin, K. Hamada, D. Ikarashi, R. Kikuchi, Y. Lindell, and A. Nof. 2018. <em>Fast Large-Scale Honest-Majority MPC for Malicious Adversaries.</em> In CRYPTO. 34–64.<br>[19] A. Choudhury and A. Patra. 2017. <em>An Efficient Framework for Unconditionally Secure Multiparty Computation.</em> IEEE Trans. Information Theory (2017), 428–468.<br>[20] R. Cleve. 1986. <em>Limits on the Security of Coin Flips when Half the Processors Are Faulty (Extended Abstract).</em> In ACM STOC. 364–369.<br>[21] R. Cramer, I. Damgård, D. Escudero, P. Scholl, and C. Xing. 2018. <em>SPDZ2k: Efficient MPC mod 2ˆk for Dishonest Majority.</em> CRYPTO (2018), 769–798.<br>[22] R. Cramer, I. Damgård, and Y. Ishai. 2005. <em>Share Conversion, Pseudorandom Secret-Sharing and Applications to Secure Computation.</em> In TCC. 342–362.<br>[23] Cryptography and Privacy Engineering Group at TU Darmstadt. 2017. ENCRYPTO Utils. <a href=\"https://github.com/encryptogroup/ENCRYPTO_utils\" target=\"_blank\" rel=\"noopener\">https://github.com/encryptogroup/ENCRYPTO_utils</a>.<br>[24] M. Dahl. 2018. <em>Private Image Analysis with MPC: Training CNNs on Sensitive Data using SPDZ.</em> (2018).<br>[25] I. Damgård, C. Orlandi, and M. Simkin. 2018. <em>Yet Another Compiler for Active Security or: Efficient MPC Over Arbitrary Rings.</em> CRYPTO (2018), 799–829.<br>[26] I. Damgård, V. Pastro, N. P. Smart, and S. Zakarias. 2012. <em>Multiparty Computation from Somewhat Homomorphic Encryption.</em> In CRYPTO. 643–662.<br>[27] S. de Hoogh, B. Schoenmakers, P.Chen, and H. Akker. 2014. <em>Practical Secure Decision Tree Learning in a Teletreatment Application.</em> In FC. 179–194.<br>[28] H. Eerikson, M. Keller, C. Orlandi, P. Pullonen, J. Puura, and M. Simkin. 2019. <em>Use your Brain! Arithmetic 3PC For Any Modulus with Active Security.</em> IACR<br>Cryptology ePrint Archive (2019).<br>[29] A. Esteva, B. Kuprel, R. A. Novoa, J. Ko, S. M. Swetter, H. M. Blau, and S. Thrun. 2017. <em>Dermatologist-level classification of skin cancer with deep neural networks.</em> Nature (2017), 115–118.<br>[30] J. Furukawa, Y. Lindell, A. Nof, and O. Weinstein. 2017. <em>High-Throughput Secure Three-Party Computation for Malicious Adversaries and an Honest Majority.</em> In EUROCRYPT. 225–255.<br>[31] A. Gascón, P. Schoppmann, B. Balle, M. Raykova, J. Doerner, S. Zahur, and D. Evans. 2016. <em>Secure Linear Regression on Vertically Partitioned Datasets.</em> IACR Cryptology ePrint Archive (2016).<br>[32] M. Geisler. 2007. <em>Viff: Virtual ideal functionality framework.</em><br>[33] O. Goldreich, S. Micali, and A. Wigderson. 1987. <em>How to Play any Mental Game or A Completeness Theorem for Protocols with Honest Majority.</em> In STOC. 218–229.<br>[34] S. D. Gordon, S. Ranellucci, and X. Wang. 2018. <em>Secure Computation with Low Communication from Cross-Checking.</em> In ASIACRYPT. 59–85.<br>[35] Y. Ishai, R. Kumaresan, E. Kushilevitz, and A. Paskin-Cherniavsky. 2015. <em>Secure Computation with Minimal Interaction, Revisited.</em> In CRYPTO. 359–378.<br>[36] S. Kamara, P. Mohassel, and M. Raykova. 2011. <em>Outsourcing Multi-Party Computation.</em> IACR Cryptology ePrint Archive (2011).<br>[37] J. Katz, V. Kolesnikov, and X. Wang. 2018. <em>Improved Non-Interactive Zero Knowledge with Applications to Post-Quantum Signatures.</em> In CCS. 525–537.<br>[38] M. Keller, E. Orsini, and P. Scholl. 2016. <em>MASCOT: Faster Malicious Arithmetic Secure Computation with Oblivious Transfer.</em> In ACM CCS. 830–842.<br>[39] M. Keller, V. Pastro, and D. Rotaru. 2018. <em>Overdrive: Making SPDZ Great Again.</em> In EUROCRYPT. 158–189.<br>[40] J. Launchbury, D. Archer, T. DuBuisson, and E. Mertens. 2014. <em>Application-Scale Secure Multiparty Computation.</em> In ESOP. 8–26.<br>[41] S. Laur, H. Lipmaa, and T. Mielikäinen. 2006. <em>Cryptographically private support vector machines.</em> In ACM SIGKDD. 618–624.<br>[42] Yann LeCun and Corinna Cortes. 2010. <em>MNIST handwritten digit database.</em> (2010). <a href=\"http://yann.lecun.com/exdb/mnist/\" target=\"_blank\" rel=\"noopener\">http://yann.lecun.com/exdb/mnist/</a><br>[43] Y. Lindell and A. Nof. 2017. <em>A Framework for Constructing Fast MPC over Arithmetic Circuits with Malicious Adversaries and an Honest-Majority.</em> In ACM CCS. 259–276.<br>[44] J. Liu, M. Juuti, Y. L., and N. Asokan. 2017. <em>Oblivious Neural Network Predictions via MiniONN Transformations.</em> In ACM CCS. 619–631.<br>[45] E. Makri, D. Rotaru, N. P. Smart, and F. Vercauteren. 2018. <em>EPIC: Efficient Private Image Classification (or: Learning from the Masters).</em> CT-RSA (2018), 473–492.<br>[46] P. Mohassel and P. Rindal. 2018. <em>ABY3: A Mixed Protocol Framework for Machine Learning.</em> In ACM CCS. 35–52.<br>[47] P. Mohassel, M. Rosulek, and Y. Zhang. 2015. <em>Fast and Secure Three-party Computation: Garbled Circuit Approach.</em> In CCS. 591–602.<br>[48] P. Mohassel and Y. Zhang. 2017. <em>SecureML: A System for Scalable Privacy-Preserving Machine Learning.</em> In IEEE S&amp;P. 19–38.<br>[49] V. Nikolaenko, S. Ioannidis, U. Weinsberg, M. Joye, N. Taft, and D. Boneh. 2013. <em>Privacy-preserving matrix factorization.</em> In ACM CCS. 801–812.<br>[50] V. Nikolaenko, U. Weinsberg, S. Ioannidis, M. Joye, D. Boneh, and N. Taft. 2013. <em>Privacy-Preserving Ridge Regression on Hundreds of Millions of Records.</em> In IEEE S&amp;P. 334–348.<br>[51] P. S. Nordholt and M. Veeningen. 2018. <em>Minimising Communication in Honest-Majority MPC by Batchwise Multiplication Verification.</em> In ACNS. 321–339.<br>[52] T. Orekondy, B. Schiele, and M. Fritz. 2018. <em>Knockoff Nets: Stealing Functionality of Black-Box Models.</em> CoRR (2018).<br>[53] N. Papernot, P. McDaniel, I. Goodfellow, S. Jha, Z. B. Celik, and A. Swami. 2017. <em>Practical Black-Box Attacks Against Machine Learning.</em> In ASIA CCS. 506–519.<br>[54] A. Patra and D. Ravi. 2018. <em>On the Exact Round Complexity of Secure Three-Party Computation.</em> CRYPTO (2018), 425–458.<br>[55] M. S. Riazi, C. Weinert, O. Tkachenko, E. M. Songhori, T. Schneider, and F. Koushanfar. 2018. <em>Chameleon: A Hybrid Secure Computation Framework for Machine Learning Applications.</em> In AsiaCCS. 707–721.<br>[56] F. Schroff, D. Kalenichenko, and J. Philbin. 2015. <em>FaceNet: A unified embedding for face recognition and clustering.</em> In IEEE CVPR. 815–823.<br>[57] N. P. Smart and T. Wood. 2019. <em>Error Detection in Monotone Span Programs with Application to Communication-Efficient Multi-party Computation.</em> In CT-RSA. 210–229.<br>[58] F. Tramèr, F. Zhang, A. Juels, M. K. Reiter, and T. Ristenpart. 2016. <em>Stealing Machine Learning Models via Prediction APIs.</em> In USENIX. 601–618.<br>[59] S. Wagh, D. Gupta, and N. Chandran. 2019. <em>SecureNN: 3-Party Secure Computation for Neural Network Training.</em> PoPETs (2019), 26–49.<br>[60] A. C. Yao. 1982. <em>Protocols for Secure Computations.</em> In FOCS. 160–164.</p>\n","site":{"data":{}},"excerpt":"<p><em>Harsh Chaudhari, Ashish Choudhury, Arpita Patra, Ajith Suresh</em></p>\n<p>ACM CCSW 2019</p>\n<p><a href=\"https://eprint.iacr.org/2019/429\" target=\"_blank\" rel=\"noopener\">https://eprint.iacr.org/2019/429</a></p>\n<p><a href=\"https://dl.acm.org/doi/10.1145/3338466.3358922\" target=\"_blank\" rel=\"noopener\">https://dl.acm.org/doi/10.1145/3338466.3358922</a></p>","more":"<p><img src=\"http://images.yingwai.top/picgo/ASTRA.jpg\" alt=\"\"></p>\n<h2 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h2><h3 id=\"摘要\"><a href=\"#摘要\" class=\"headerlink\" title=\"摘要\"></a>摘要</h3><p>安全计算的具体效率一直是近年来许多工作关注的焦点。在本论文中，作者提出了一种具体有效的协议，用于模 $2^l$ 整数环上的安全三方计算（3PC），该协议具有半诚实模型和恶意模型上的安全性。由于环上的计算模拟了现实系统体系结构上的计算，所以环上的安全计算近来获得了发展势头。</p>\n<p>​        在离线-在线模式中，本文的结构具体地呈现了最有效的在线阶段。在半诚实的设置下，本文的协议在在线阶段每个乘法门需要2个环元素的通信。在恶意设置下，本文的协议在在线阶段每个乘法门需要4个元素的通信，比最先进的协议需要的5个元素少。使用选择性中止和公平这两个安全概念来实现的公平恶意协议，与仅针对输出门的中止安全性的恶意协议相比，涉及的通信稍微多一些。</p>\n<p>​        作者将本文的技术从3PC应用到安全的服务器辅助机器学习（ML）推理机制中，用于一系列预测函数——线性回归、线性SVM回归、Logistic回归和线性SVM分类。本文的设置考虑了拥有训练好的模型参数的模型所有者和查询的客户，后者愿意根据前者的模型参数来学习他查询的预测。输入和计算外包给一组三个非合谋的服务器。本文的构造既迎合了半诚实的世界，也迎合了恶意的世界，比现有的构造表现得更好。</p>\n<h3 id=\"贡献\"><a href=\"#贡献\" class=\"headerlink\" title=\"贡献\"></a>贡献</h3><ul>\n<li><p>作者遵循离线-在线模式，提出了在环 $\\mathbb{Z}<em>{2^l}$（包括布尔环 $\\mathbb{Z}</em>{2^1}$）上的3PC构造，具有最有效的在线阶段。</p>\n<p>虽然重点放在在现阶段，但离线阶段的的成本也有注意并保持在可控范围内。</p>\n</li>\n<li><p>作者给出了一系列满足半诚实安全和恶意安全的构造。</p>\n<p>将技术应用于外包环境中的一系列预测函数的安全预测，并构建了一些容忍半诚实和恶意对手的结构。</p>\n</li>\n</ul>\n<p>本文所有的构建都流露出的一个共同特征：在线阶段不到三对参与者之间需要进行功能依赖的通信，从而产生更好的在线性能。</p>\n<h2 id=\"设定\"><a href=\"#设定\" class=\"headerlink\" title=\"设定\"></a>设定</h2><p>本文考虑一组三方 $\\mathcal{P}=\\left{P<em>0,P_1,P_2\\right}$，它们在同步网络中通过成对的私有和可信信道连接。要计算的函数 $f$ 被表示为环 $\\mathbb{Z}</em>{2^l}$ 上的电路 ckt，该环由2输入加法和乘法门组成。假设 ckt 的拓扑是公知的。术语 D​ 表示 ckt 的乘法深度，而 I、O、A、M 分别表示 ckt 中的输入线、输出线、加法门和乘法门的数目。本文使用符号 $w<em>x$ 来表示导线 $w$，其中值 $x$ 流经它。本文使用 $g=(w_x,w_y,w_z)$ 来表示 ckt 中具有左输入线 $w_x$、右输入线 $w_y$ 和输出线 $w_z$ 的门。在本文的协议中，将 $\\mathcal{P}$ 划分为互不相交的集合 $\\left{P_0\\right}$ 和 $\\left{P_1,P_2\\right}$，其中 $P_0$ 在离线阶段充当“分配器”进行“预处理”，在线阶段“评估者” $P_1$、$P_2$ 用它来评估 ckt。本文使用上标“$s$”和“$m$”分别区分半诚实和恶意设置中的协议。布尔环 $\\mathbb{Z}</em>{2^1}$ 上的协议可以通过将算术加法$(+)$和乘法$(\\times)$分别替换为异或$(\\oplus)$和与$(\\cdot)$来获得。</p>\n<h3 id=\"共享密钥设置\"><a href=\"#共享密钥设置\" class=\"headerlink\" title=\"共享密钥设置\"></a>共享密钥设置</h3><p>为了保存双方之间的通信，使用为伪随机函数（PRF）$F$ 建立预共享随机密钥的一次性设置。在3PC设置[2，30，46]中的已知协议中已经使用了类似的设置。这里 $F:^\\kappa \\times ^\\kappa \\to X$ 是安全的PRF，同域 $X$ 是 $\\mathbb{Z}_{2^l}$。这组密钥是：</p>\n<ul>\n<li>每对参与方之间共享一个密钥— $k<em>{01}, k</em>{02}, k_{12}$，分别用于参与方$(P_0,P_1), (P_0,P_2), (P_1,P_2)$。</li>\n<li>所有各方之间的一个共享密钥— $k_{\\mathcal{p}}$。</li>\n</ul>\n<p>本文通过可以使用任何标准安全MPC协议实现的功能 $\\mathcal{F}_{\\rm setup}$ 来建立密钥设置模型。</p>\n<h3 id=\"共享语义\"><a href=\"#共享语义\" class=\"headerlink\" title=\"共享语义\"></a>共享语义</h3><p>在本节中，将解释本工作中使用的秘密共享的两种变体。这两个变体都在算术（$\\mathbb{Z}<em>{2^l}$）和布尔环（$\\mathbb{Z}</em>{2^1}$）上运行。</p>\n<p>$[\\cdot]$-共享：如果 $P<em>1$ 和 $P_2$ 分别持有份额 $v_1$ 和 $v_2$，使得 $v=v_1+v_2$，则称值 $v$ 在$P_1,P_2$之间是 $[\\cdot]$-共享的。用 $[\\cdot]</em>{P_i}$ 表示 $P_i, i∈{1,2}$的 $[\\cdot]$-份额。</p>\n<p>$[![\\cdot]!]$-共享：值 $v$ 在 $P_0, P_1, P_2$ 之间是$[![\\cdot]!]$-共享的，如果</p>\n<ul>\n<li>存在值 $\\lambda_v, m_v$ 使得 $v=m_v - \\lambda_v$；</li>\n<li>$P<em>0$ 持有 $\\lambda</em>{v,1}$ 和 $\\lambda<em>{v,2}$ 使得 $\\lambda</em>{v} = \\lambda<em>{v,1} + \\lambda</em>{v,2}$；</li>\n<li>$P<em>1$ 和 $P_2$ 分别持有 $(m_v, \\lambda</em>{v,1})$ 和 $(m<em>v, \\lambda</em>{v,1})$。</li>\n</ul>\n<p>本文将各方的$[![\\cdot]!]$-共享表示为$[![v]!]<em>{P_0} = (\\lambda</em>{v,1}, \\lambda<em>{v,2}), [![v]!]</em>{P<em>1} = (m_v, \\lambda</em>{v,1}) $和 $[![v]!]<em>{P_2} = (m_v, \\lambda</em>{v,2})$。用$[![v]!] = (m<em>v, [\\lambda</em>{v}])$表示 $v$ 的$[![\\cdot]!]$-共享份额。</p>\n<h3 id=\"秘密共享方案的线性\"><a href=\"#秘密共享方案的线性\" class=\"headerlink\" title=\"秘密共享方案的线性\"></a>秘密共享方案的线性</h3><p>给定 $x,y \\in \\mathbb{Z}<em>{2^l}$ 和公共常数 $c_1, c_2 \\in \\mathbb{Z}</em>{2^l}$的$[\\cdot]$-共享，各方可以局部计算 $[c_1x+c_2y]$：</p>\n<script type=\"math/tex; mode=display\">[c_1x+c_2y]=(c_1x_1+c_2y_1, c_1x_2+c_2y_2)=c_1[x]+c_2[y]</script><p>很容易看出线性关系也扩展到$[![\\cdot]!]$-共享。线性属性使各方能够<strong>本地</strong>执行与公共常量的加法和乘法等操作。</p>\n<h2 id=\"3PC协议\"><a href=\"#3PC协议\" class=\"headerlink\" title=\"3PC协议\"></a>3PC协议</h2><h3 id=\"半诚实下的3PC\"><a href=\"#半诚实下的3PC\" class=\"headerlink\" title=\"半诚实下的3PC\"></a>半诚实下的3PC</h3><p>协议 $\\prod ^{\\rm s}_{\\rm 3pc}$ 由三个步骤组成—输入共享、电路评估以及输出重构。所有阶段（重构输出除外）都分为离线和在线阶段，其中独立于实际输入的步骤可以在脱机阶段执行。</p>\n<h4 id=\"输入共享\"><a href=\"#输入共享\" class=\"headerlink\" title=\"输入共享\"></a>输入共享</h4><p>在共享输入阶段，每一方都为自己的输入生成一个随机的$[![\\cdot]!]$-共享。以下是初始共享协议 $\\prod^{\\rm s}_{\\rm Sh}$：</p>\n<hr>\n<p><strong>Offline:</strong></p>\n<ul>\n<li>If $P<em>i = P_0$, parties $P_0, P_j$ for $j \\in {1, 2}$ locally sample a random $\\lambda</em>{x,j} \\in \\mathbb{Z}<em>{2^l}$. Moreover, $P_i$ sets $[![x]!]</em>{P<em>i} = (\\lambda</em>{x,1}, \\lambda_{x,2})$.</li>\n<li>If $P<em>i = P_1$, parties $P_0, P_1$ sample a random $\\lambda</em>{x,1} \\in \\mathbb{Z}<em>{2^l}$ while all the parties in $\\mathcal{P}$ sample a random $\\lambda</em>{x,2} \\in \\mathbb{Z}_{2^l}$.</li>\n<li>If $P<em>i = P_2$, parties $P_0, P_2$ sample a random $\\lambda</em>{x,2} \\in \\mathbb{Z}<em>{2^l}$ while all the parties in $\\mathcal{P}$ sample a random $\\lambda</em>{x,1} \\in \\mathbb{Z}_{2^l}$.</li>\n</ul>\n<p><strong>Online:</strong></p>\n<p>​        $P<em>i$ computes $\\lambda_x = \\lambda</em>{x,1} + \\lambda<em>{x,2}$ and sends $m_x = x + \\lambda_x$ to every $P_j$ for $j \\in {1,2}$ who then sets $[![x]!]</em>{P<em>j} = (m_x, \\lambda</em>{x,j})$.</p>\n<hr>\n<p>在离线阶段根据输入方的序号，使用不同的初始化手段，生成了 $P<em>0$ 的份额 $[![x]!]</em>{P<em>0}=(\\lambda</em>{x,1}, \\lambda_{x,2})$，而不用任何交互（因为随机数都是使用服务器两两之间的公共随机源生成的，可以理解为编程语言中把同样的随机种子输入到random函数——只要随机种子一样生成的随机数序列就一样）。</p>\n<h4 id=\"电路评估\"><a href=\"#电路评估\" class=\"headerlink\" title=\"电路评估\"></a>电路评估</h4><p>在电路评估阶段，各方以$[![\\cdot]!]$-共享的方式评估 ckt。以拓扑顺序评估 ckt 中的每个门 $g$：给定 $g$ 的输入，各方为 $g$ 的输出生成$[![\\cdot]!]$-共享。</p>\n<h5 id=\"加法\"><a href=\"#加法\" class=\"headerlink\" title=\"加法\"></a>加法</h5><p>如果 $g$ 是加法门 $(w<em>x,w_y,w_z)$，可以利用$[![\\cdot]!]$-共享的线性在本地完成。以下是加法协议 $\\prod</em>{\\rm Add} (w_x, w_y, w_z)$：</p>\n<hr>\n<p><strong>Offline:</strong></p>\n<p>​        $P<em>0, P_1$ set $\\lambda</em>{z,1} = \\lambda<em>{x,1} + \\lambda</em>{y,1}$, while $P<em>0, P_2$ set $\\lambda</em>{z,2} = \\lambda<em>{x,2} + \\lambda</em>{y,2}$.</p>\n<p><strong>Online:</strong></p>\n<p>​        $P_1$ and $P_2$ set $m_z = m_x + m_y$.</p>\n<hr>\n<p>这里的加法协议感觉在线阶段完全可以在本地完成，可以不需要在线阶段。</p>\n<h5 id=\"乘法\"><a href=\"#乘法\" class=\"headerlink\" title=\"乘法\"></a>乘法</h5><p>如果 $g=(w<em>x,w_y,w_z)$ 是乘法门，则运行以下乘法协议 $\\prod ^{\\rm s}</em>{\\rm Mul}$：</p>\n<hr>\n<p><strong>Offline:</strong></p>\n<ul>\n<li>$P<em>0$ and $P_1$ locally sample random $\\lambda</em>{z,1}, \\gamma<em>{xy, 1} \\in \\mathbb{Z}</em>{2^l}$, while $P<em>0$ and $P_2$ locally sample random $\\lambda</em>{z,2} \\in \\mathbb{Z}_{2^l}$.</li>\n<li>$P<em>0$ computes $\\gamma</em>{xy} = \\lambda<em>x \\lambda_y$ and sends $\\gamma</em>{xy,2} = \\gamma<em>{xy} - \\gamma</em>{xy,1}$ to $P_2$.</li>\n</ul>\n<p><strong>Online:</strong></p>\n<ul>\n<li>$P<em>i$ for $i \\in {1,2}$ locally computes $[m_z]</em>{P<em>i} = (i-1)m_xm_y - m_x[\\lambda_y]</em>{P<em>i} - m_y[\\lambda_x]</em>{P<em>i} + [\\lambda_z]</em>{P<em>i} + [\\gamma</em>{xy}]_{P_i}$.</li>\n<li>$P_1, P_2$ mutually exchange their shares and reconstruct $m_z$.</li>\n</ul>\n<hr>\n<p>将上面的公式相加一下即可验证其正确性。</p>\n<h4 id=\"输出重构\"><a href=\"#输出重构\" class=\"headerlink\" title=\"输出重构\"></a>输出重构</h4><p>在输出重构阶段，各方重构$[![\\cdot]!]$-共享电路输出。为了重构 $[![y]!]$，可以观察到每个 $P<em>i$ 缺失的份额都在另外两方手里。因此另外两方的其中一方将缺失的份额发送给 $P_i$ 后，通过计算 $y = m_y - \\lambda</em>{y,1} - \\lambda<em>{y,2}$ 即可重构输出 $y$，将其称为重构协议 $\\prod ^{\\rm s}</em>{\\rm Rec}([![y]!], \\mathcal{P})$。</p>\n<p>把上面三个阶段总结起来，有以下的协议 $\\prod ^{\\rm s}_{\\rm 3pc}$：</p>\n<hr>\n<p><strong>Pre-processing (Offline Phase):</strong></p>\n<ul>\n<li><em>Input wires:</em> For $j = 1, …,l$, corresponding to the circuit-input $x<em>j$, parties execute the offline steps of the instance $\\prod ^{\\rm s}</em>{\\rm Sh}(P_i, x_j)$.</li>\n<li>For each gate $g$ in the topological order, execute offline steps of the instance $\\prod ^{\\rm s}<em>{\\rm Mul}(w</em>{xj}, w<em>{yj}, w</em>{zj})$ if $g$ is the $j$th multiplication gate where $j \\in {1,…,\\rm M}$ or respectively offline steps of the instance $\\prod <em>{\\rm Add}(w</em>{xj}, w<em>{yj}, w</em>{zj})$ if $g$ is the $j$th addition gate where $j \\in {1,…,\\rm A}$.</li>\n</ul>\n<p><strong>Circuit Evaluation (Online Phase):</strong></p>\n<ul>\n<li><em>Sharing Circuit-input Values:</em> For $j = 1, …,l$, corresponding to the circuit-input $x<em>j$, parties execute the online steps of the instance $\\prod ^{\\rm s}</em>{\\rm Sh}(P_i, x_j)$, where $P_i$ is the party designated to provide $x_j$.</li>\n<li><em>Gate Evaluation:</em> For each gate in $g$ in ckt in the topological order, $P<em>1, P_2$ execute the online steps of the instance $\\prod ^{\\rm s}</em>{\\rm Mul}(w<em>{xj},w</em>{yj},w<em>{zj})$ if $g$ is the $j$th multiplication gate where $j \\in {1,…,\\rm M}$ or respectively offline steps of the instance $\\prod </em>{\\rm Add}(w<em>{xj}, w</em>{yj}, w_{zj})$ if $g$ is the $j$th addition gate where $j \\in {1,…,\\rm A}$.</li>\n<li><em>Output Reconstruction:</em> Let $[![y<em>1]!],…,[![y</em>\\rm O]!]$ be the shared function outputs. The parties in $\\mathcal{P}$ reconstruct $y<em>j$ for $j = 1,…,\\rm O$ by executing $\\prod ^{\\rm s}</em>{\\rm Rec}([![y_j]!], \\mathcal{P})$.</li>\n</ul>\n<hr>\n<h3 id=\"恶意下的3PC\"><a href=\"#恶意下的3PC\" class=\"headerlink\" title=\"恶意下的3PC\"></a>恶意下的3PC</h3><p>跟半诚实设置下的一样，恶意设置下的3PC协议 $\\prod ^{\\rm m}_{\\rm 3pc}$ 也由输入共享、电路评估和输出重构三个部分组成。</p>\n<h4 id=\"输入共享和输出重构\"><a href=\"#输入共享和输出重构\" class=\"headerlink\" title=\"输入共享和输出重构\"></a>输入共享和输出重构</h4><p>在恶意的设置下，要保证服务器之间的共享份额是一致的。在 $\\prod ^{\\rm s}_{\\rm Sh}$ 中，$\\lambda$ 的共享是一致的，因为它不需要交互就可以生成。但如果一个腐败的 $P_0$ 拥有 $x$ 并且想制造一个不一致的 $[![x]!]$-共享，它可以分别发送两个不一样的 $m_x$ 给 $P_1$ 和 $P_2$。为了检查这种情况的发生，$P_1$ 和 $P_2$ 交换 $H(m_x)$ 并在不一致的时候中止。</p>\n<p>令 $[![y]!]$ 为一个待重构的一致的共享，$[![y]!]<em>{P_0} = (\\lambda</em>{y,1}, \\lambda<em>{y,2})$、$[![y]!]</em>{P<em>1} = (m’</em>{y}, \\lambda<em>{y,1})$ 和 $[![y]!]</em>{P<em>2} = (m’’</em>{y}, \\lambda<em>{y,2})$ 分别为三个服务器的份额。协议 $\\prod ^{\\rm m}</em>{\\rm Rec}([![y]!], \\mathcal{P})$ 允许每一个诚实方输出 $y$ 或 $\\perp$：</p>\n<hr>\n<p><strong>Online:</strong></p>\n<ul>\n<li>$P<em>0$ and $P_2$ send $\\lambda</em>{y,2}$ and $H(\\lambda’_{y,2})$ respectively to $P_1$.</li>\n<li>$P<em>0$ and $P_1$ send $\\lambda</em>{y,1}$ and $H(\\lambda’_{y,1})$ respectively to $P_2$.</li>\n<li>$P<em>1$ and $P_1$ send $m’</em>{y}$ and $H(m’_{y})$ respectively to $P_0$.</li>\n</ul>\n<p>$P<em>i$ for $i \\in {0,1,2}$ abort if the received values mismatch. Else $P_i$ sets $y = m_y - \\lambda</em>{y,1} - \\lambda_{y,2}$.</p>\n<hr>\n<p>检查的过程中，其中一方发送哈希值可以提高效率。</p>\n<h4 id=\"电路评估-1\"><a href=\"#电路评估-1\" class=\"headerlink\" title=\"电路评估\"></a>电路评估</h4><p>在恶意设置下加法协议 $\\prod <em>{\\rm Add}$ 同样是安全的，因为它只涉及本地操作。挑战在于构造乘法协议 $\\prod ^{\\rm m}</em>{\\rm Mul}$，令其可以容忍其中一方腐败。可以观察到有两种情况：</p>\n<ul>\n<li>$P<em>0$ 是腐败的：在离线阶段会令 $\\gamma</em>{xy} \\neq \\lambda_x \\lambda_y$</li>\n<li>$P_1$ 或 $P_2$ 是腐败的：会在在线阶段扰乱，使诚实的另一方重构出一个错误的 $m_z$</li>\n</ul>\n<p>先看下面的情况，假如 $P<em>1$ 现在需要验证它重构的 $m_z$ 是否是正确的，可以向 $P_0$ 求助：$P_1$ 可以发送 $m_x, m_y$ 给 $P_0$，因为 $P_0$ 在离线阶段就已经知道 $\\lambda_x, \\lambda_y$ 和 $\\lambda_z$，因此它可以计算出 $m_z$ 并发送给 $P_1$，以此得到验证。但发送 $m_x, m_y$ 给 $P_0$ 会导致打破了原有共享的私密性，所以 $P_1$ 可以对应的值盲化后发送给 $P_0$：$m^{\\star}_x = m_x + \\delta_x$ 和 $m^{\\star}_y = m_y + \\delta_y$，然后 $P_0$ 计算 $m^{\\star}_z = -m^{\\star}_x \\lambda_y - m^{\\star}_y \\lambda_x +\\lambda_z + 2\\gamma</em>{xy}$。注意到：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{align}\nm^{\\star}_z &= -m^{\\star}_x \\lambda_y - m^{\\star}_y \\lambda_x +\\lambda_z + 2\\gamma_{xy}\\\\\n &= -(m_x + \\delta_x) \\lambda_y - (m_y + \\delta_y) \\lambda_x +\\lambda_z + 2\\gamma_{xy}\\\\\n &= (m_z - m_x m_y) - \\chi\n\\end{align}</script><p>假设 $P<em>0$ 知道 $\\chi = \\delta_x \\lambda_y + \\delta_y \\lambda_x - \\gamma</em>{xy}$，它就可以计算出 $m^{\\star}_z + \\chi$ 然后发送给 $P_1$。因为 $P_1$ 知道 $m_x, m_y$ 的值，因此它可以验证它重构的 $m_z$ 的正确性，对于 $P_2$ 来说也可以这样验证。</p>\n<p>现在来描述如何使 $P<em>0$ 获得 $\\chi$：首先直接让 $P_0$ 获得 $\\chi$ 会导致共享的私密性被破坏，因为 $P_0$ 知道 $\\lambda_x, \\lambda_y$ 和 $\\gamma</em>{xy}$ 的值，同时在在线阶段又得到 $m<em>x + \\delta_x$ 和 $m_y + \\delta_y$，导致 $P_0$ 可以推导出 $m_x, m_y$ 之间的关系。所以还要在 $\\chi$ 中加入一个随机值 $\\delta_z$ 进行盲化：$\\delta_x \\lambda_y + \\delta_y \\lambda_x + \\delta_z - \\gamma</em>{xy}$。</p>\n<p>生成 $\\chi$ 的过程：$P<em>1, P_2$ 在本地生成随机数 $\\delta_x, \\delta_y, \\delta_z \\in \\mathbb{Z}</em>{2^l}$，计算各自的 $\\chi$ 的 $[\\cdot]$-共享并发送给 $P<em>0$。对于 $i \\in {1,2 }$，令 $[\\chi]</em>{P_i} = \\chi_i$。$P_0$ 在本地将共享的份额相加得到 $\\chi$。在以上步骤中，腐败的一方可能会在执行过程中引入错误，使得 $P_0$ 获得的 $\\chi$ 是错误的。</p>\n<p>总而言之在离线阶段有两个问题需要解决：</p>\n<ul>\n<li>腐败的 $P<em>0$ 可以不正确地共享 $\\gamma</em>{xy}$</li>\n<li>腐败的 $P_1$ 或 $P_2$ 可以发送错误的 $\\chi$ 的 $[\\cdot]$-共享给 $P_0$</li>\n</ul>\n<p>为了解决这些问题，$P_0$ 一旦获得 $\\chi$，就用下面的方式计算 $a = \\delta_x - \\lambda_x$、$b = \\delta_y - \\lambda_y$ 和 $c = (\\delta_z + \\delta_x \\delta_y) - \\chi$ 的 $[![\\cdot]!]$-共享：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{align*}\n[\\![a]\\!]_{P_0} &= (\\lambda_{x,1}, \\lambda_{x,2}), & [\\![b]\\!]_{P_0} &= (\\lambda_{y,1}, \\lambda_{y,2}), & [\\![c]\\!]_{P_0} &= (\\chi_{1}, \\chi_{2})\\\\\n [\\![a]\\!]_{P_1} &= (\\delta_x, \\lambda_{x,1}), & [\\![b]\\!]_{P_1} &= (\\delta_y, \\lambda_{y,1}), & [\\![c]\\!]_{P_1} &= (\\delta_z + \\delta_x \\delta_y, \\chi_{1})\\\\\n [\\![a]\\!]_{P_2} &= (\\delta_x, \\lambda_{x,2}), & [\\![b]\\!]_{P_2} &= (\\delta_y, \\lambda_{y,2}), & [\\![c]\\!]_{P_2} &= (\\delta_z + \\delta_x \\delta_y, \\chi_{2})\n\\end{align*}</script><p>现在 $([![a]!], [![b]!], [![c]!])$ 是一个乘法三元组 $(c=ab)$，当且仅当 $P<em>0$ 正确分享了 $\\gamma</em>{xy}$（当它腐败时）以及重构的 $\\chi$ 是正确的（当 $P_1,P_2$ 其中之一腐败时），因为：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{align}\nab &= (\\delta_x - \\lambda_x)(\\delta_y - \\lambda_y) = \\delta_x \\delta_y + \\lambda_x \\lambda_y - \\delta_x \\lambda_y - \\delta_y \\lambda_x \\\\\n &= (\\delta_x \\delta_y + \\delta_z) - (\\delta_x \\lambda_y + \\delta_y \\lambda_x + \\delta_z - \\gamma_{xy}) \\\\\n  &= (\\delta_x \\delta_y + \\delta_z) - \\chi = c\n\\end{align}</script><p>然后作者给出了一个检查乘法三元组是否正确的协议，这里需要用到另一个有效的乘法三元组 $([![d]!], [![e]!], [![f]!])$，它们满足以下条件：</p>\n<ul>\n<li>$d, e, f$ 都是随机且私密的</li>\n<li>$f = d e$</li>\n</ul>\n<p>这里假设这个三元组是通过 $\\mathcal{F}_{\\rm trip}$ 生成的，在[2, 30]中有具体构造，下面是[30]中的构造：</p>\n<p><img src=\"http://images.yingwai.top/picgo/ASTRAf1.png\" alt=\"\"></p>\n<p>用  $\\prod <em>{\\rm trip}$ 表示该功能的实例化，下面是作者给出检查有效性的协议 $\\prod </em>{\\rm prc}$：</p>\n<hr>\n<ul>\n<li>Parties locally compute $[![\\rho]!] = [![a]!] - [![d]!]$ and $[![\\sigma]!] = [![b]!] - [![e]!]$.</li>\n<li>Parties reconstruct $\\rho$ and $\\sigma$ by executing $\\prod ^{\\rm m}<em>{\\rm Rec}([![\\rho]!], \\mathcal{P})$ and $\\prod ^{\\rm m}</em>{\\rm Rec}([![\\sigma]!], \\mathcal{P})$ respectively.</li>\n<li>Parties locally compute $[![\\tau]!] = [![c]!] - [![f]!] - \\sigma [![d]!] - \\rho [![e]!] - \\sigma \\rho$.</li>\n<li>Parties reconstruct $\\tau$ by executing $\\prod ^{\\rm m}_{\\rm Rec}([![\\tau]!], \\mathcal{P})$ and output $\\perp$, if $\\tau \\neq 0$.</li>\n</ul>\n<hr>\n<p>协议 $\\prod _{\\rm prc}$ 需要两对秘密共享三元组 $(a, b, c)$ 和 $(d, e, f)$，验证前一个三元组是否满足 $c = a b$：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{align}\n\\tau &= c - f - \\sigma d - \\rho e - \\sigma \\rho \\\\\n &= c - de - (b - e)d - (a - d)e - (b - e)(a - d) \\\\\n &= c - ab = \\Delta\n\\end{align}</script><p>所以 $\\tau = 0$ 时 $(a,b,c)$ 有效，反之无效。而检验 $\\tau$ 是否为0只需要一方跟另外两方各通信一次即可：(1) $P<em>0$ 跟 $P_1$ 检查 $m</em>\\tau - \\lambda<em>{\\tau,1}$ 跟 $\\lambda</em>{\\tau, 2}$ 是否相等；(2) $P<em>1$ 跟 $P_2$ 检查 $m</em>\\tau - \\lambda<em>{\\tau,2}$ 跟 $\\lambda</em>{\\tau, 1}$ 是否相等；(3) $P<em>0$ 跟 $P_1$ 检查 $m</em>\\tau - \\lambda<em>{\\tau,2}$ 跟 $\\lambda</em>{\\tau, 1}$ 是否相等，而不是 $\\prod ^{\\rm m}<em>{\\rm Rec}$ 的通信三次（两次发送一次接收）。下面给出恶意设置下的乘法协议 $\\prod ^{\\rm m}</em>{\\rm Mul}(w_x, w_y, w_z)$：</p>\n<hr>\n<p><strong>Offline:</strong></p>\n<ul>\n<li>Parties $P<em>0, P_1$ locally sample random $\\lambda</em>{z,1}, \\gamma<em>{xy,1} \\in \\mathbb{Z}</em>{2^l}$, while $P<em>0, P_2$<br>locally sample a random $\\lambda</em>{z,2}$. $P<em>0$ locally computes $\\gamma</em>{xy}= \\lambda<em>x \\lambda_y$ and<br>sends $\\gamma</em>{xy,2} = \\gamma<em>{xy} - \\gamma</em>{xy,1}$ to $P_2$.</li>\n<li>Parties execute $\\prod _{\\rm trip}$ to generate a triple $([![d]!], [![e]!], [![f]!])$.</li>\n<li>Parties $P<em>1, P_2$ locally sample random $\\delta_x, \\delta_y, \\delta_z \\in \\mathbb{Z}</em>{2^l}$ and compute<br>$[\\delta_z]$ non-interactively.</li>\n<li>$P<em>i$ for $i \\in {1, 2}$ computes $[\\chi]</em>{P<em>i} = \\delta_x[\\lambda_y]</em>{P<em>i} + \\delta_y[\\lambda_x]</em>{P<em>i} + [\\delta_z]</em>{P<em>i} − [\\gamma</em>{xy}]<em>{P_i}$ and sends $[\\chi]</em>{P_i}$ to $P_0$, who computes $\\chi$.</li>\n<li>Parties locally compute the $[![\\cdot]!]$-shares of the values $a = \\delta_x - \\lambda_x$, $b = \\delta_y - \\lambda_y$ and $b = (\\delta_z + \\delta_x \\delta_y) - \\chi$, as described in the text.</li>\n<li>Parties execute $\\prod _{\\rm prc}$ on $([![a]!], [![b]!], [![c]!])$ and $([![d]!], [![e]!], [![f]!])$.</li>\n</ul>\n<p><strong>Online:</strong></p>\n<ul>\n<li>$P<em>i$ for $i \\in {1, 2}$ locally computes $[m_z]</em>{P<em>i} = (i-1)m_xm_y - m_x[\\lambda_y]</em>{P<em>i} - m_y[\\lambda_x]</em>{P<em>i} + [\\lambda_z]</em>{P<em>i} + [\\gamma</em>{xy}]_{P_i}$. $P_1, P_2$ mutually exchange their shares and reconstruct $m_z$.</li>\n<li>$P<em>1$ sends $m^{\\star}_x = m_x + \\delta_x$, $m^{\\star}_y = m_y + \\delta_y$ to $P_0$, while $P_2$ sends $H(m^{\\star}_x || m^{\\star}</em>{y})$ to $P_0$.$P_0$ outputs $\\perp$, if the received values are inconsistent.</li>\n<li>$P<em>0$ computes $m^{\\star}_z = -m^{\\star}_x \\lambda_y - m^{\\star}_y \\lambda_x +\\lambda_z + 2\\gamma</em>{xy} + \\chi$ and sends $H(m^\\star_z)$ to both $P_1$ and $P_2$.</li>\n<li>$P_i$ for $i \\in {1, 2}$ abort if $H(m^\\star_z) \\neq H(m_z - m_x m_y + \\delta_z)$.</li>\n</ul>\n<hr>\n<p>散列值的使用提高了效率，减少了通信的开销。</p>\n<p>对于正确性，首先考虑腐败的 $P<em>0$ 不正确地共享使得 $\\gamma</em>{xy} = \\lambda<em>x \\lambda_y + \\Delta$ 的情况，其中 $\\Delta$ 是 $P_0$ 引入的不为零的干扰。这种情况在执行 $\\prod </em>{\\rm prc}$ 就会被检测到，因为最终计算出来并重构的 $\\tau \\neq 0$。同样的， $P<em>1$（或 $P_2$）在协议 $\\prod ^{\\rm m}</em>{\\rm Mul}$ 离线阶段的第四步时发送 $\\chi_1 + \\Delta$（或 $\\chi_2 + \\Delta$） 给 $P_0$ 使其重构的 $\\chi’ = \\chi + \\Delta$，也会导致 $\\tau \\neq 0$ 从而被诚实方发现并中止计算。</p>\n<p>然后是另一种情况，假如 $P<em>1$（或 $P_2$）在重构 $m_z$ 时发送了错误的 $[m_z]</em>{P_i}$ 给另一方，会在最后一步验证哈希值是否相等的时候被检测出来；而在在线阶段第二步中 $P_0$ 对 $m^{\\star}_x,m^{\\star}_y$ 的一致性检查也确保了它所计算出来的 $m^{\\star}_z$ 是正确的。</p>\n<h4 id=\"公平的实现\"><a href=\"#公平的实现\" class=\"headerlink\" title=\"公平的实现\"></a>公平的实现</h4><p>作者通过一种公平重构协议 $\\prod<em>{\\rm fRec}$ 来重构电路输出，将 $\\prod ^{\\rm m}</em>{\\rm 3pc}$ 的安全性提高到公平，保证交易的三方都不能通过损害别人的利益而得到自己不应得的利益。这里使用到了承诺方案，还是利用了服务器之间的公共随机源并使用PRF来为承诺方案引入随机性：</p>\n<hr>\n<p><strong>Offline:</strong></p>\n<ul>\n<li>Parties $P<em>0, P_1$ locally sample a random $r_1 \\in \\mathbb{Z}</em>{2^l}$, prepare and send commitments of $\\lambda<em>{y,1}$ and $r_1$ to $P_2$. Similarly, parties $P_0, P_2$ locally sample a random $r_2 \\in \\mathbb{Z}</em>{2^l}$, prepare and send commitments of $\\lambda_{y,2}$ and $r_2$ to $P_1$. The randomness needed for both commitments are sampled from the PRF key-setup.</li>\n<li>$P_1$ (resp. $P_2$) aborts if the received commitments mismatch.</li>\n</ul>\n<p><strong>Online:</strong></p>\n<ul>\n<li>$P_1, P_2$ compute a commitment of $m_y$ using randomness sampled from their PRF key-setup and send it to $P_0$.</li>\n<li>If the commitments do not match, $P_0$ sends (<strong>abort</strong>, $o_1$) to $P_2$, while it sends (<strong>abort</strong>, $o_2$) to $P_1$ and aborts, where $o_i$ denotes the opening information for the commitment of $r_i$. Else $P_0$ sends <strong>continue</strong> to both $P_1$ and $P_2$.</li>\n<li>$P_1, P_2$ exchange the messages received from $P_0$.</li>\n<li>$P_1$ aborts if it receives either (i) (<strong>abort</strong>, $o_2$) from $P_0$ and $o_2$ opens the commitment of $r_2$ or (ii) (<strong>abort</strong>, $o_1$) from $P_2$ and $o_1$ is the correct opening information of $r_1$. The case for $P_2$ is similar to that of $P_1$.</li>\n<li>If no abort happens, parties obtain their missing share of $a$ as follows:<ul>\n<li>$P<em>0, P_1$ open $\\lambda</em>{y,1}$ towards $P_2$.</li>\n<li>$P<em>0, P_2$ open $\\lambda</em>{y,2}$ towards $P_1$.</li>\n<li>$P_1, P_2$ open $m_y$ towards $P_0$.</li>\n</ul>\n</li>\n<li>Parties reconstruct the value $y$ using missing share that matches with the agreed upon commitment.</li>\n</ul>\n<hr>\n<p>当没有广播频道的时候，一个非常棘手的问题就会存在：一个腐败的 $P<em>0$ 可以发送不同的信号给 $P_1$ 和 $P_2$（一个为 abort 而另一个为 continue），以上的重构协议 $\\prod</em>{\\rm fRec}([![y]!], \\mathcal{P})$ 解决了这个问题。在离线阶段 $P_0$ 和 $P_1$ 共同计算出一个关于 $r_1$ 的承诺发送给 $P_2$，同样地 $P_0$ 和 $P_2$ 共同计算出一个关于 $r_2$ 的承诺发送给 $P_1$。这两个承诺就可以确保 $P_1$ 跟 $P_2$ 可以验证它们收到的来自 $P_0$ 的信号是否一致：例如当 $P_1$ 收到 abort 而 $P_2$ 收到 continue，在它们交换信息时，$P_1$ 就可以利用收到的 $o_2$ 证明自己收到了 abort 信号，反过来也是一样的。同时还解决了一个问题，就是当一个腐败的 $P_1$ 收到了 $P_0$ 发送的 continue 信号，但它不能在与 $P_2$ 交换信息时宣称自己收到了 abort 信号，因为它没有 $o_2$，因此无法证明，对于 $P_2$ 腐败的情况也是一样的。</p>\n<p>这里的承诺方案可以通过一个哈希函数来实现，例如：$(c, o) = (\\mathcal{H}(x||r),x||r) = Com(x;r)$</p>\n<h2 id=\"隐私保护机器学习\"><a href=\"#隐私保护机器学习\" class=\"headerlink\" title=\"隐私保护机器学习\"></a>隐私保护机器学习</h2><h3 id=\"模型\"><a href=\"#模型\" class=\"headerlink\" title=\"模型\"></a>模型</h3><p>对于每一个预测函数，模型拥有者 $\\rm M$ 拥有一个训练好的参数向量，想为拥有一个查询向量的客户 $\\rm C$ 提供预测服务。在服务器辅助设置中，$\\rm M$ 和 $\\rm C$ 以共享方式将各自的输入外包给三个不受信任但非合谋的服务器 ${P_0, P_1, P_2}$，这些服务器通过为本文的3PC协议开发的技术以共享方式执行计算，并将输出单独重构到客户端。客户只能知道输出，除此之外什么也不知道。</p>\n<h3 id=\"对于ML的协议\"><a href=\"#对于ML的协议\" class=\"headerlink\" title=\"对于ML的协议\"></a>对于ML的协议</h3><h4 id=\"安全向量点积\"><a href=\"#安全向量点积\" class=\"headerlink\" title=\"安全向量点积\"></a>安全向量点积</h4><p>对于向量的 $[\\cdot]$-共享和 $[![\\cdot]!]$-共享，就是对应每个维度的值进行$[\\cdot]$-共享和 $[![\\cdot]!]$-共享，容易知道对于向量来说两种共享仍然是线性的。对于两个 $d$ 维向量的点积，不考虑效率的情况下可以执行 $d$ 次 $\\prod ^{\\rm s}<em>{\\rm Mul}$协议，再对这 $d$ 次执行的结果简单进行相加，各方就可以得到它们的份额。在这里作者给出一个更高效率的向量点积协议 $\\prod ^{\\rm s}</em>{\\rm dp}$：</p>\n<hr>\n<p><strong>Offline:</strong></p>\n<p>​        $P<em>0, P_1$ sample random $\\lambda</em>{u,1}, \\gamma<em>{pq,1} \\in \\mathbb{Z}</em>{2^l}$, while $P<em>0, P_2$ sample random $\\lambda</em>{u,2} \\in \\mathbb{Z}<em>{2^l}$. $P_0$ locally computes $\\gamma</em>{pq} = \\vec{\\lambda<em>p} \\odot \\vec{\\lambda_q}$, sets $\\gamma</em>{pq,2} = \\gamma<em>{pq} - \\gamma</em>{pq,1}$ and sends $\\gamma_{pq,2}$ to $P_2$.</p>\n<p><strong>Online:</strong></p>\n<ul>\n<li>$P<em>i$ for $i \\in {1,2}$ locally computes $[m_u]</em>{P<em>i} = \\sum^d</em>{j=1}((i-1)m<em>{p_j}m</em>{q<em>j} - m</em>{p<em>j}[\\lambda</em>{q<em>j}]</em>{P<em>i} - m</em>{q<em>j}[\\lambda</em>{p<em>j}]</em>{P<em>i}) + [\\gamma</em>{pq}]<em>{P_i} + [\\lambda_u]</em>{P_i}$.</li>\n<li>$P_1$ and $P_2$ mutually exchange their share of $[m_u]$ to reconstruct $m_u$.</li>\n</ul>\n<hr>\n<p>上面的协议的离线阶段中，$P<em>0$ 仅仅共享了 $\\gamma</em>{pq} = \\vec{\\lambda<em>p} \\odot \\vec{\\lambda_q}$ 而不是每一个 $\\lambda</em>{p<em>i} \\lambda</em>{q<em>i}$；在在线阶段，$P_1, P_2$ 直接计算 $[m_u]$（其中 $u = \\vec{p} \\odot \\vec{q}$）而不是每一个 $m</em>{p_i q_i}$。</p>\n<p>接下来作者还对恶意设置下的点积进行了讨论：由于在乘法协议中引入了对恶意对手的额外检查，所以上面针对半诚实协议所作的优化是不适用的。对两个 $d$ 维向量的点积，只能 $d$ 次调用协议 $\\prod ^{\\rm m}<em>{\\rm Mul}$。不过作者还是对在线阶段的开销进行了改进：在在线阶段 $P_1$ 并行地发送 $m^{\\star}</em>{p<em>i}, m^{\\star}</em>{q<em>i}$ 给 $P_0$，而 $P_2$ 则发送对应的哈希值给 $P_0$。$P_0$ 收到这些值后进行验证，若一致则将它们“结合”所有的 $m^{\\star}</em>{p<em>i q_i}$ 然后发送一个单独的 $m^\\star_u$ 的哈希值给 $P_1, P_2$，最后 $P_1, P_2$ 在本地验证是否与 $m_u - \\sum^d</em>{j=1}(m<em>{p_j}m</em>{q<em>j} - \\delta</em>{u<em>j})$。这样做的话就节省了在线阶段的开销，不用每个 $m^{\\star}</em>{p<em>i}, m^{\\star}</em>{q_i}$ 都发送一次。</p>\n<h4 id=\"安全比较\"><a href=\"#安全比较\" class=\"headerlink\" title=\"安全比较\"></a>安全比较</h4><p>给定算术共享 $[![u]!], [![v]!]$，各方希望验证 $u$ 是否小于 $v$，等同于验证 $a$ 是否小于 $0$（其中 $a = u - v$），在定点表示中可以通过检查 ${\\rm msb}(a)$ 来完成（二进制补码中第一位为符号位）。于是可以把在给定算术共享 $[![a]!]$ 的情况下生成 ${\\rm msb}(a)$ 的布尔共享作为目标，在这里作者利用了秘密共享方案中的不对称性，放弃了 <em>SecureML</em>[48]和 <em>ABY3</em>[46]中的昂贵协议。</p>\n<hr>\n<p><strong>Offline:</strong></p>\n<p>​        $P<em>1, P_2$ together sample a random $r, r’ \\in \\mathbb{Z}</em>{2^l}$ and set $p= \\rm{msb}$$(r)$. Parties non-interactively generate Boolean share of $p$ as $[![p]!]^{\\rm B}<em>{P_0} = (0,0)$, $[![p]!]^{\\rm B}</em>{P<em>1} = (p,0)$ and $[![p]!]^{\\rm B}</em>{P_2} = (p,0)$.</p>\n<p><strong>Online:</strong></p>\n<p>​        $P<em>1$ set $[a]</em>{P<em>1}=m_a - \\lambda</em>{a,1}$, $P<em>2$ set $[a]</em>{P<em>2}=- \\lambda</em>{a,2}$.</p>\n<ul>\n<li>$P<em>1$ sends $[ra]</em>{P<em>1} = r[a]</em>{P<em>1} + r’$ to $P_0$, while $P_2$ sends $[ra]</em>{P<em>2} = r[a]</em>{P_1} - r’$ to $P_0$, who adds them to obtain $ra$.</li>\n<li>$P<em>0$ executes $\\prod^{\\rm s}</em>{\\rm Sh}(P<em>0, q)$ over $\\mathbb{Z}</em>{2^1}$ to generate $[![q]!]^{\\rm B}$ where $q = {\\rm msb}(ra)$.</li>\n<li>Parties locally compute $[![\\mbox{msb}(a)]!]^{\\rm B} = [![p]!]^{\\rm B} \\oplus [![q]!]^{\\rm B}$.</li>\n</ul>\n<hr>\n<p>上面的协议用 $\\prod ^{\\rm s}_{\\rm BitExt}([![a]!], \\mathcal{P})$ 表示。这里上面用到了一个随机数 $r$ 来对 $a$ 的值进行盲化，并且可以注意到 ${\\rm sign}(a \\cdot r) = {\\rm sign}(a) \\oplus {\\rm sign}(r)$，所以 $r$ 不会对生成共享份额造成影响且使得三者都不能从这个过程中知道关于 $a$ 的信息。</p>\n<p>对于恶意的情况，就不能仅仅依靠 $P<em>0$ 来生成 $[![{\\rm msb}(ra)]!]^{\\rm B}$，下面给出了修改后的协议 $\\prod ^{\\rm m}</em>{\\rm BitExt}([![a]!], \\mathcal{P})$：</p>\n<hr>\n<p><strong>Offline:</strong></p>\n<p>​        $P<em>1, P_2$ sample a random $r_1 \\in \\mathbb{Z}</em>{2^l}$ and set $p<em>1 = {\\rm msb}(r_1)$ while $P_0, P_2$ sample a random $r_2 \\in \\mathbb{Z}</em>{2^l}$ and set $p_2 = {\\rm msb}(r_2)$.</p>\n<ul>\n<li>Parties non-interactively generate $[![\\cdot]!]$-shares of $r<em>1$ as $[![r_1]!]</em>{P<em>0}=(0,0)$, $[![r_1]!]</em>{P<em>1}=(r_1,0)$ and $[![r_1]!]</em>{P_2}=(r_1,0)$.</li>\n<li>Parties non-interactively generate $[![\\cdot]!]$-shares of $r<em>1$ as $[![r_2]!]</em>{P<em>0}=(0,-r_2)$, $[![r_1]!]</em>{P<em>1}=(0,0)$ and $[![r_1]!]</em>{P_2}=(0,-r_2)$.</li>\n<li>Parties execute $\\prod^{\\rm m}_{\\rm Mul}$ on $r_1$ and $r_2$ to generate $[![r]!] = [![r_1 r_2]!]$.</li>\n<li>Parties non-interactively generate Boolean shares of $p<em>1$ as $[![p_1]!]^{\\rm B}</em>{P<em>0}=(0,0)$, $[![p_1]!]^{\\rm B}</em>{P<em>1}=(p_1,0)$ and $[![p_1]!]^{\\rm B}</em>{P_2}=(p_1,0)$.</li>\n<li>Parties non-interactively generate Boolean shares of $p<em>2$ as $[![p_2]!]^{\\rm B}</em>{P<em>0}=(0,p_2)$, $[![p_2]!]^{\\rm B}</em>{P<em>1}=(0,0)$ and $[![p_2]!]^{\\rm B}</em>{P_2}=(0,p_2)$.</li>\n<li>Parties locally compute $[![p]!]^{\\rm B}=[![p_1]!]^{\\rm B} \\oplus [![p_2]!]^{\\rm B}$.</li>\n</ul>\n<p><strong>Online:</strong></p>\n<ul>\n<li>Parties execute $\\prod ^{\\rm m}<em>{\\rm Mul}$ on $[![r]!]$ and $[![a]!]$ to generate $[![ra]!]$ followed by enabling $P_0, P_1$ to reconstruct $ra$ (this is done by slightly modifying the protocol $\\prod ^{\\rm m}</em>{\\rm Rec}$ ).</li>\n<li>$P<em>1$ executes $\\prod ^{\\rm m}</em>{\\rm Sh}(P<em>1, q)$ over $\\mathbb{Z}</em>{2^1}$ to generate $[![q]!]^{\\rm B}$ where $q = {\\rm msb}(ra)$. In parallel, $P<em>0$ locally computes $m_q$ and sends ${\\rm H}(m_q)$ to $P_2$, who abort if the value mismatches with the hash of the value $m_q$ received from $P_1$ as part of $\\prod ^{\\rm m}</em>{\\rm Sh}(P_1, q)$.</li>\n<li>Parties locally compute $[![{\\rm msb}(a)]!]^{\\rm B} = [![p]!]^{\\rm B} \\oplus [![q]!]^{\\rm B}$.</li>\n</ul>\n<hr>\n<h4 id=\"ML预测函数\"><a href=\"#ML预测函数\" class=\"headerlink\" title=\"ML预测函数\"></a>ML预测函数</h4><ul>\n<li><strong>线性回归</strong>：$\\rm M$ 有一个 $d$ 维的模型参数向量 $\\vec{w}$ 和偏置项 $b$，$\\rm C$ 有一个 $d$ 维的查询向量 $\\vec{z}$。$\\rm C$ 获得 $f_{\\rm linr}((\\vec{w}, b),\\vec{z}) = \\vec{w} \\odot \\vec{z} + b$，其中 $\\vec{w} \\odot \\vec{z}$ 是向量 $\\vec{w}$ 和向量 $\\vec{z}$ 的点积；</li>\n<li><strong>SVM回归</strong>：$\\rm M$ 有${\\alpha<em>j, y_j }^k</em>{j=1}$ 和 $d$ 维的支持向量 ${\\vec{x<em>j}}^k</em>{j=1}$，$\\rm C$ 有一个 $d$ 维的查询向量 $\\vec{z}$。$\\rm C$ 获得 $f<em>{\\rm svmr}(({\\alpha_j, y_j, \\vec{x_j} }^k</em>{j=1}, b), \\vec{z}) = \\sum^k_{j=1} \\alpha_j y_j (\\vec{x_j} \\odot \\vec{z}) + b$；</li>\n<li><strong>逻辑回归</strong>：$\\rm M$ 和 $\\rm C$ 的输入和线性回归类似，$\\rm M$ 还需要提供一个在 $[0,1]$ 范围内的额外输入 $t$。$\\rm C$ 获得 $f_{\\rm logr}((\\vec{w}, b, t), \\vec{z}) = {\\rm sign}((\\vec{w} \\odot \\vec{z} + b) - {\\rm ln}(\\frac{t}{1-t}))$，其中 ${\\rm sign}(\\cdot)$ 返回对象的符号位；</li>\n<li><strong>SVM分类</strong>：$\\rm M$ 和 $\\rm C$ 的输入和SVM回归一样，但对 $\\rm C$ 的输出变为 $f<em>{\\rm svmr}(({\\alpha_j, y_j, \\vec{x_j} }^k</em>{j=1}, b), \\vec{z}) = {\\rm sign}(\\sum^k_{j=1} \\alpha_j y_j (\\vec{x_j} \\odot \\vec{z}) + b)$。</li>\n</ul>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><p>[1] V. A. Abril, P. Maene, N. Mertens, and N. P. Smart. 2019. <em>Bristol Fashion MPC Circuits.</em> <a href=\"https://homes.esat.kuleuven.be/~nsmart/MPC/\" target=\"_blank\" rel=\"noopener\">https://homes.esat.kuleuven.be/~nsmart/MPC/</a>.<br>[2] T. Araki, A. Barak, J. Furukawa, T. Lichter, Y. Lindell, A. Nof, K. Ohara, A. Watzman, and O. Weinstein. 2017. <em>Optimized Honest-Majority MPC for Malicious Adversaries - Breaking the 1 Billion-Gate Per Second Barrier.</em> In IEEE S&amp;P. 843–862.<br>[3] T. Araki, A. Barak, J. Furukawa, Y. Lindell, A. Nof, and K. Ohara. 2016. <em>DEMO: High-Throughput Secure Three-Party Computation of Kerberos Ticket Generation.</em> In ACM CCS. 1841–1843.<br>[4] T. Araki, J. Furukawa, Y. Lindell, A. Nof, and K. Ohara. 2016. <em>High-Throughput Semi-Honest Secure Three-Party Computation with an Honest Majority.</em> In ACM CCS. 805–817.<br>[5] C. Baum, I. Damgård, T. Toft, and R. W. Zakarias. 2016. <em>Better Preprocessing for Secure Multiparty Computation.</em> In ACNS. 327–345.<br>[6] D. Beaver. 1991. <em>Efficient Multiparty Protocols Using Circuit Randomization.</em> In CRYPTO. 420–432.<br>[7] D. Beaver. 1995. <em>Precomputing Oblivious Transfer.</em> In CRYPTO. 97–109.<br>[8] Z. Beerliová-Trubíniová and M. Hirt. 2006. <em>Efficient Multi-party Computation with Dispute Control.</em> In TCC. 305–328.<br>[9] Z. Beerliová-Trubíniová and M. Hirt. 2008. <em>Perfectly-Secure MPC with Linear Communication Complexity.</em> In TCC. 213–230.<br>[10] M. Ben-Or, S. Goldwasser, and A. Wigderson. 1988. <em>Completeness Theorems for Non-Cryptographic Fault-Tolerant Distributed Computation (Extended Abstract).</em> In ACM STOC. 1–10.<br>[11] Christopher Bishop. 2006. <em>Pattern Recognition and Machine Learning.</em><br>[12] D. Bogdanov, S. Laur, and J. Willemson. 2008. <em>Sharemind: A Framework for Fast Privacy-Preserving Computations.</em> In ESORICS. 192–206.<br>[13] D. Bogdanov, R. Talviste, and J. Willemson. 2012. <em>Deploying Secure Multi-Party Computation for Financial Data Analysis.</em> In FC. 57–64.<br>[14] M. Byali, A. Joseph, A. Patra, and D. Ravi. 2018. <em>Fast Secure Computation for Small Population over the Internet.</em> ACM CCS (2018), 677–694.<br>[15] O. Catrina and S. de Hoogh. 2010. <em>Secure Multiparty Linear Programming Using Fixed-Point Arithmetic.</em> In ESORICS. 134–150.<br>[16] N. Chandran, J. A. Garay, P. Mohassel, and S. Vusirikala. 2017. <em>Efficient, Constant-Round and Actively Secure MPC: Beyond the Three-Party Case.</em> In ACM CCS. 277–294.<br>[17] H. Chaudhari, A. Choudhury, A. Patra, and A. Suresh. 2019. <em>ASTRA: High-throughput 3PC over Rings with Application to Secure Prediction.</em> <a href=\"https://eprint.iacr.org/2019/429\" target=\"_blank\" rel=\"noopener\">https://eprint.iacr.org/2019/429</a>. In IACR Cryptology ePrint Archive.<br>[18] K. Chida, D. Genkin, K. Hamada, D. Ikarashi, R. Kikuchi, Y. Lindell, and A. Nof. 2018. <em>Fast Large-Scale Honest-Majority MPC for Malicious Adversaries.</em> In CRYPTO. 34–64.<br>[19] A. Choudhury and A. Patra. 2017. <em>An Efficient Framework for Unconditionally Secure Multiparty Computation.</em> IEEE Trans. Information Theory (2017), 428–468.<br>[20] R. Cleve. 1986. <em>Limits on the Security of Coin Flips when Half the Processors Are Faulty (Extended Abstract).</em> In ACM STOC. 364–369.<br>[21] R. Cramer, I. Damgård, D. Escudero, P. Scholl, and C. Xing. 2018. <em>SPDZ2k: Efficient MPC mod 2ˆk for Dishonest Majority.</em> CRYPTO (2018), 769–798.<br>[22] R. Cramer, I. Damgård, and Y. Ishai. 2005. <em>Share Conversion, Pseudorandom Secret-Sharing and Applications to Secure Computation.</em> In TCC. 342–362.<br>[23] Cryptography and Privacy Engineering Group at TU Darmstadt. 2017. ENCRYPTO Utils. <a href=\"https://github.com/encryptogroup/ENCRYPTO_utils\" target=\"_blank\" rel=\"noopener\">https://github.com/encryptogroup/ENCRYPTO_utils</a>.<br>[24] M. Dahl. 2018. <em>Private Image Analysis with MPC: Training CNNs on Sensitive Data using SPDZ.</em> (2018).<br>[25] I. Damgård, C. Orlandi, and M. Simkin. 2018. <em>Yet Another Compiler for Active Security or: Efficient MPC Over Arbitrary Rings.</em> CRYPTO (2018), 799–829.<br>[26] I. Damgård, V. Pastro, N. P. Smart, and S. Zakarias. 2012. <em>Multiparty Computation from Somewhat Homomorphic Encryption.</em> In CRYPTO. 643–662.<br>[27] S. de Hoogh, B. Schoenmakers, P.Chen, and H. Akker. 2014. <em>Practical Secure Decision Tree Learning in a Teletreatment Application.</em> In FC. 179–194.<br>[28] H. Eerikson, M. Keller, C. Orlandi, P. Pullonen, J. Puura, and M. Simkin. 2019. <em>Use your Brain! Arithmetic 3PC For Any Modulus with Active Security.</em> IACR<br>Cryptology ePrint Archive (2019).<br>[29] A. Esteva, B. Kuprel, R. A. Novoa, J. Ko, S. M. Swetter, H. M. Blau, and S. Thrun. 2017. <em>Dermatologist-level classification of skin cancer with deep neural networks.</em> Nature (2017), 115–118.<br>[30] J. Furukawa, Y. Lindell, A. Nof, and O. Weinstein. 2017. <em>High-Throughput Secure Three-Party Computation for Malicious Adversaries and an Honest Majority.</em> In EUROCRYPT. 225–255.<br>[31] A. Gascón, P. Schoppmann, B. Balle, M. Raykova, J. Doerner, S. Zahur, and D. Evans. 2016. <em>Secure Linear Regression on Vertically Partitioned Datasets.</em> IACR Cryptology ePrint Archive (2016).<br>[32] M. Geisler. 2007. <em>Viff: Virtual ideal functionality framework.</em><br>[33] O. Goldreich, S. Micali, and A. Wigderson. 1987. <em>How to Play any Mental Game or A Completeness Theorem for Protocols with Honest Majority.</em> In STOC. 218–229.<br>[34] S. D. Gordon, S. Ranellucci, and X. Wang. 2018. <em>Secure Computation with Low Communication from Cross-Checking.</em> In ASIACRYPT. 59–85.<br>[35] Y. Ishai, R. Kumaresan, E. Kushilevitz, and A. Paskin-Cherniavsky. 2015. <em>Secure Computation with Minimal Interaction, Revisited.</em> In CRYPTO. 359–378.<br>[36] S. Kamara, P. Mohassel, and M. Raykova. 2011. <em>Outsourcing Multi-Party Computation.</em> IACR Cryptology ePrint Archive (2011).<br>[37] J. Katz, V. Kolesnikov, and X. Wang. 2018. <em>Improved Non-Interactive Zero Knowledge with Applications to Post-Quantum Signatures.</em> In CCS. 525–537.<br>[38] M. Keller, E. Orsini, and P. Scholl. 2016. <em>MASCOT: Faster Malicious Arithmetic Secure Computation with Oblivious Transfer.</em> In ACM CCS. 830–842.<br>[39] M. Keller, V. Pastro, and D. Rotaru. 2018. <em>Overdrive: Making SPDZ Great Again.</em> In EUROCRYPT. 158–189.<br>[40] J. Launchbury, D. Archer, T. DuBuisson, and E. Mertens. 2014. <em>Application-Scale Secure Multiparty Computation.</em> In ESOP. 8–26.<br>[41] S. Laur, H. Lipmaa, and T. Mielikäinen. 2006. <em>Cryptographically private support vector machines.</em> In ACM SIGKDD. 618–624.<br>[42] Yann LeCun and Corinna Cortes. 2010. <em>MNIST handwritten digit database.</em> (2010). <a href=\"http://yann.lecun.com/exdb/mnist/\" target=\"_blank\" rel=\"noopener\">http://yann.lecun.com/exdb/mnist/</a><br>[43] Y. Lindell and A. Nof. 2017. <em>A Framework for Constructing Fast MPC over Arithmetic Circuits with Malicious Adversaries and an Honest-Majority.</em> In ACM CCS. 259–276.<br>[44] J. Liu, M. Juuti, Y. L., and N. Asokan. 2017. <em>Oblivious Neural Network Predictions via MiniONN Transformations.</em> In ACM CCS. 619–631.<br>[45] E. Makri, D. Rotaru, N. P. Smart, and F. Vercauteren. 2018. <em>EPIC: Efficient Private Image Classification (or: Learning from the Masters).</em> CT-RSA (2018), 473–492.<br>[46] P. Mohassel and P. Rindal. 2018. <em>ABY3: A Mixed Protocol Framework for Machine Learning.</em> In ACM CCS. 35–52.<br>[47] P. Mohassel, M. Rosulek, and Y. Zhang. 2015. <em>Fast and Secure Three-party Computation: Garbled Circuit Approach.</em> In CCS. 591–602.<br>[48] P. Mohassel and Y. Zhang. 2017. <em>SecureML: A System for Scalable Privacy-Preserving Machine Learning.</em> In IEEE S&amp;P. 19–38.<br>[49] V. Nikolaenko, S. Ioannidis, U. Weinsberg, M. Joye, N. Taft, and D. Boneh. 2013. <em>Privacy-preserving matrix factorization.</em> In ACM CCS. 801–812.<br>[50] V. Nikolaenko, U. Weinsberg, S. Ioannidis, M. Joye, D. Boneh, and N. Taft. 2013. <em>Privacy-Preserving Ridge Regression on Hundreds of Millions of Records.</em> In IEEE S&amp;P. 334–348.<br>[51] P. S. Nordholt and M. Veeningen. 2018. <em>Minimising Communication in Honest-Majority MPC by Batchwise Multiplication Verification.</em> In ACNS. 321–339.<br>[52] T. Orekondy, B. Schiele, and M. Fritz. 2018. <em>Knockoff Nets: Stealing Functionality of Black-Box Models.</em> CoRR (2018).<br>[53] N. Papernot, P. McDaniel, I. Goodfellow, S. Jha, Z. B. Celik, and A. Swami. 2017. <em>Practical Black-Box Attacks Against Machine Learning.</em> In ASIA CCS. 506–519.<br>[54] A. Patra and D. Ravi. 2018. <em>On the Exact Round Complexity of Secure Three-Party Computation.</em> CRYPTO (2018), 425–458.<br>[55] M. S. Riazi, C. Weinert, O. Tkachenko, E. M. Songhori, T. Schneider, and F. Koushanfar. 2018. <em>Chameleon: A Hybrid Secure Computation Framework for Machine Learning Applications.</em> In AsiaCCS. 707–721.<br>[56] F. Schroff, D. Kalenichenko, and J. Philbin. 2015. <em>FaceNet: A unified embedding for face recognition and clustering.</em> In IEEE CVPR. 815–823.<br>[57] N. P. Smart and T. Wood. 2019. <em>Error Detection in Monotone Span Programs with Application to Communication-Efficient Multi-party Computation.</em> In CT-RSA. 210–229.<br>[58] F. Tramèr, F. Zhang, A. Juels, M. K. Reiter, and T. Ristenpart. 2016. <em>Stealing Machine Learning Models via Prediction APIs.</em> In USENIX. 601–618.<br>[59] S. Wagh, D. Gupta, and N. Chandran. 2019. <em>SecureNN: 3-Party Secure Computation for Neural Network Training.</em> PoPETs (2019), 26–49.<br>[60] A. C. Yao. 1982. <em>Protocols for Secure Computations.</em> In FOCS. 160–164.</p>"},{"title":"论文笔记 Designing an e-commerce recommender system based on collaborative filtering using a data mining approach","date":"2020-05-18T13:10:49.000Z","_content":"\n*Samira Khodabandehlou*\n\nhttps://scholar.google.com/scholar?hl=zh-CN&as_sdt=0%2C5&q=Designing+an+e-commerce+recommender+system+based+on+collaborative+filtering+using+a+data+mining+approach&btnG=\n\n<!--more-->\n\n![](http://images.yingwai.top/picgo/Designing an e-commerce recommender system based on collaborative filtering using a data mining approach.jpg)\n\n\n\n# 摘要\n\n电子商务推荐系统已经转变为客户非常重要的决策辅助工具，利用信息技术和客户信息提供在线个性化推荐。同时，协同过滤推荐系统是电子商务系统成功的关键组成部分之一。尽管有协同过滤现在的普及和成功，这些系统仍然面临着一系列严重的限制，包括冷启动、user-item矩阵稀疏、可扩展性和用户兴趣在这段时间内的变化，这些都阻碍了对客户的准确推荐。虽然已有很多研究提出了克服这些局限性的方法，但还没有提供一个全面的模型来降低这些局限性：1)在产品类别层面上基于LRFM变量进行客户细分，以评估与公司的客户关系的长度、最近程度、频率和购买产品类别的金额；2)在每个聚类级别上基于用户-类别矩阵提取关联规则；3)根据人口统计变量进行客户细分；4)改变用户-项目矩阵并降低其维数；5)通过将细分方法的结果与CF加权组合来开发新的相似度函数。根据所获得的结果，本研究提出的系统消除了传统的CF约束，为客户的偏好提供了更准确、更合适的建议。\n\n**关键词：**协同过滤；数据挖掘；电子商务；推荐系统；时态信息。\n\n\n\n本研究的主要目标包括：找出传统协同过滤在向合适的用户推荐合适商品方面的局限性，提出一个全面的、全新的推荐系统来消除传统CF的局限性，用真实的数据对推荐系统进行评估，以提供更准确、更符合顾客口味的推荐。\n\n\n\n# 理论背景\n\n## 推荐系统\n\n**推荐系统**是提高电子商务环境中决策过程质量的有用工具，因为它们通过提供必要的信息和有用的建议来帮助在线决策者选择与他们的愿望和要求一致的项目(Shambour and Lu，2015；Son，2016)。事实上，识别用户偏好的能力是个性化RS的核心(Kim等人，2011年)。Ricci等人。(2011)将RS定义为特定类型的信息系统，该信息系统：\n\n1. 帮助客户选择他们没有亲身体验的项目；\n2. 向顾客推荐商品；\n3. 通过为客户提供信息来帮助他们决定购买哪种商品。\n\n创建推荐系统有五个阶段：收集数据、分析用户信息、计算相似度、选择邻居、预测并提出前N个项目的列表(Yahya和Al-Shamri，2016)。这些系统出现在20世纪90年代中期，通常分为三类(Lee，2010；Resnick，1994)：\n\n1. **协同过滤**：这些系统根据一组被称为邻居的相似用户或相似项目的得分提供推荐(Kim等人，2005年)。CF是Netflix和Amazon等著名电子商务公司使用的最受欢迎的RS之一(Hernando等人，2016；Kim等人，2005年)。这些系统又根据它们用于预测用户偏好的算法类型分为两类(Ghazarian和Nematbakhsh，2014)：\n\n   * **Memory-based**：这些系统使用用户项目评分矩阵和KNN算法来识别用户的邻居并预测他们的偏好(Ghazarian和Nematbakhsh，2014年；Hernando等人，2016年；Kim等人，2011年)，其中使用皮尔逊相关系数等方法计算用户之间的相似性(Bobadilla等人，2012年)。在本研究中，使用KNN算法和皮尔逊相关系数来提供建议。\n   * **Model-based**：这些系统使用分段等方法处理用户的档案数据以提供建议，从而改进计算(Ghazarian和Nematbakhsh，2014；Hernando等人，2016)。\n\n   尽管CF方法很受欢迎并取得了成功，但它们仍然面临着一些严重的限制。这些限制包括：\n\n   * **冷启动**：在多个用户购买某个项目之前，系统不能向某人推荐该项目。这个问题被称为冷启动。用户的冷启动是指最近加入推荐系统并且没有关于他或她的足够信息的用户(Elahi等人，2016；Hu和Pu，2011；Kim等人，2011；Lee，2010；Son，2016；Sharma和Ray，2016)。\n   * **可伸缩性**：由于客户数据和产品数据的绝对数量，系统必须花费大量的金钱和时间来提取所有客户之间的相似性，导致其生产率较低(Hu和Pu，2011；Hernando等人，2016；Keramati和Khaleghi，2014；Lee，2010)。\n   * **user-item矩阵的稀疏性**：由于用户数量巨大，一个项目通常没有足够的分数或购买，导致user-item矩阵稀疏(Adomavicius和Tuzhlin，2005；Ghazarian和Nematbakhsh，2014；Karimi Alavije等人，2015，Sharma和Ray，2016)。\n   * **用户偏好的改变**：用户的品味和偏好可能会随着时间的推移而改变。例如，一位最近生了孩子的母亲可能对购买婴儿服装感兴趣，她最近的购买可能反映了这种新的关注。这是当；她可能从来没有对这样的物品有任何兴趣(Ding等人，2006年；岩田，2008年；Lee等人，2008年)。(Ding et al.，2006；Iwata，2008；Lee et al.，2008)。\n\n   上述限制可能会对RS的性能产生负面影响，从而限制系统创建有意义和准确的推荐。\n\n2. **基于内容的过滤器(Content-Based Filter，CBF)**：该方法基于这样的概念，即用户对他们以前感兴趣的项目感兴趣。因此，这些系统根据项目和产品之间的相似性提供建议(Anderson和Hiralall，2009年；Elahi等人，2016年)。因此，这种方法取决于物品的规格和与这些规格相关的用户配置文件的可用性(Anderson and Hiralall，2009)。这是因为在互联网上存储大量不同种类电子产品的目录是一项非常困难的任务(Bobadilla等人，2012年)。因此，音乐或视频文件等一些产品的内容分析非常困难；这个问题使得CF比CBF要好得多(Anderson和Hiralall，2009；Kim等人，2011)。与CBF相比，CF在电子商务中具有更高的灵活性和与RS的兼容性，使其成为最常用和最有用的RS系统之一(Burke，2002；Iwata，2008；Wang and Wu，2012)。因此，在本研究中，使用CF的概念作为主要的推荐机制。\n\n3. 混合方法：一些RS使用上述系统的组合来减少它们的限制；更多细节将在下面的实验背景部分提供(Burke，2002；Keramati和Khaleghi，2014)。\n\n\n\n## 客户细分\n\n客户细分是一种非常有用的数据挖掘方法，用于在电子商务的RS中找到“邻居”，在电子商务中，使用特定的方法，如聚类，来选择一些用户作为邻居，以改进偏好的预测(Khodabandehlou和Niknafs，2016；Li等人，2011年)。\n\n在RS中，选择合适的属性进行分割是影响系统性能的重要因素之一。最近购买、频率和货币模型(RFM)的属性是基于分析客户购买行为的一种很好的客户细分方法，它已经成功地用于许多RS(Keramati和Khaleghi，2014；Khodabandehlou和Zivari Rahman，2017；Lee，2010)。各种研究表明，在RFM模型中加入L(客户关系长度)指标将导致对客户的更准确分析，并将提高细分的质量(Li等人，2011年)。因此，在本研究中，LRFM模型被用于客户细分和识别具有相似购买行为的客户类别。\n\n此外，分割算法对识别出的片段的质量起着重要的作用。在聚类算法中，K-Means算法被认为是最成功和最合适的分割方法(Khodabandehlou和Niknafs，2016)，在许多研究中证明了它与RS的兼容性(Keramati和Khaleghi，2014；Karimi Alavije等人，2015；Li等人，2011年)。K-Means是一种数据挖掘方法，它需要K的初始值，即聚类的数量，才能运行。确定最佳簇数的合适方法是自组织映射(SOM)算法。该算法是一种无监督神经网络，可以从数据中识别未知模式，并估计合适的聚类数量(Abidi和Ong，2000；Mosayebian等人，2012)。\n\n相关研究建议在RS中结合K-Means和SOM算法使用两阶段分割方法，以获得更准确的结果(Keramati和Khaleghi，2014；Mosayebian等人，2012年)。因此，本研究将利用这一模式进行客户细分。\n\n\n\n## 关联规则\n\n关联规则是数据挖掘的重要方法之一，用于分析RS大型数据库中各种商品之间的市场篮子。分析购物篮已经成为发现用户购物车之间关系的流行系统(Hsu等人，2004；Liu and Shih，2005a)。Apriori算法是最常见的关联规则之一(Hsu等人，2004；Liu和Shih，2005a，2005b)，用于在已经购买了另一件物品时找到购买特定物品的概率模式。在RS中，已经形成了许多关于不同用户的购买行为的规则(Keramati和Khaleghi，2014；Liu和Shih，2005a，2005b)。在这些规则吸引程度的衡量标准中，我们可以提到支持性规则和置信度规则，它们分别指发现的规则的传播度和可接受性(Hsu等人，2004；Keramati和Khaleghi，2014；Karimi Alavije等人，2015；Liu和Shih，2005a，2005b)。\n\n\n\n# 评估措施\n\n评价推荐系统的性能是保证推荐系统通用性的重要一步。有一些评价RSS准确性或性能的众所周知的度量；诸如精确度、覆盖率和F度量(为了在这两个度量之间创建平衡)，它们可以很好地显示推荐系统的性能(Bobadilla等人，2012年；Elahi等人，2016；Ghazarian和Nematbakhsh，2014；Shambour和Lu，2015；Son，2016)。因此，为了评估所提出的研究模型的性能，采用了这些测量方法。\n\n在公式(1)和(2)中，喜爱的项目是指必须推荐给用户的一组产品或项目，而推荐的项目是已经由系统推荐给用户的项目的集合。精确度表示推荐集合中正确推荐的百分比，并评估这些推荐的精确度和准确性。通过公式(1)计算：\n$$\n{\\rm Precision}=\\frac{\\rm Recommended \\ Items\\cap Favorite \\  Items}{\\rm Recommended \\  Items} \\tag{1}\n$$\n覆盖率表示已经向用户建议了多少用户喜欢的项目的百分比，并使用公式(2)计算：\n$$\n{\\rm Coverage}=\\frac{\\rm Recommended \\ Items\\cap Favorite \\  Items}{\\rm Favorite \\  Items} \\tag{2}\n$$\nF-MEASURE是精度和覆盖范围的调和平均值，使用公式(3)计算：\n$$\n{\\rm F - measure}=\\frac{2 \\times \\rm Coverage \\cap Precision}{\\rm Coverage + Precision} \\tag{3}\n$$\n\n\n\n# 研究框架\n\n在设计和开发RSS时，真实、高质量的数据是非常重要的。本研究使用的这组数据与伊朗一家销售服装的网站的真实数据相关，时间范围为2015年1月21日至2016年1月21日(12个月)。此数据集涉及2542个客户和17,000条记录。在这家商店里，产品分为女装、男装、童装、女装、男装、女包和鞋、男包和鞋等七大类。据此，本研究提出的系统框架由八个主要阶段组成。在第一阶段，准备数据。该阶段由数据清理、数据整合、数据转换三个子阶段组成。在第二阶段，基于LRFM模型进行客户细分。在阶段3，基于product category-user矩阵提取关联规则。在阶段4中，完成user-item矩阵的改变。阶段5显示了基于CF的相似度计算。在阶段6中，根据人口统计特征对客户进行细分。在阶段7中，基于新的相似性函数来确定邻居。在最后阶段，推荐是根据用户的需求和特点量身定做的。在下文中，我们将对所有这些阶段进行详细说明。建议系统的总体框架如图1所示。\n\n![](http://images.yingwai.top/picgo/derf1.png)\n\n<center>\n    <i>图1 建议的研究系统的总体架构</i>\n</center>\n\n\n## 数据准备\n\n数据准备(也称为数据预处理)是RSS开发过程中不可或缺的一步，占整个RSS开发所需时间的60%-70%。此步骤包括数据清理、数据集成和数据转换三个阶段。\n\n### 数据清理\n\n数据清理过程包括完成缺失值、识别和消除离群值数据以及解决数据之间的冲突。此外，在此阶段，必须删除不相关或无用的字段或属性，如有必要，从初始数据集形成新的变量。在此阶段，将不完美的记录和信息不完整的客户从主数据集中剔除，数据集的记录从17,000条减少到15,386条，客户数量从2,542个减少到2,080个。为每个产品类别计算RFM变量。\n\n### 数据集成\n\n为了更好地理解数据，并对每个数据集中的数据进行更好的科学管理，数据集成(将两个或多个数据集合并集成在一起)是必要的，这是数据准备的第二阶段。在这一阶段，客户交易数据与他们的个人资料数据(年龄、性别、教育程度、婚姻状况和职业)集成在一起。\n\n### 数据转换\n\n在此阶段，必须将数据转换为适合数据挖掘和设计RS的不同形式。数据集中的字符串变量(如性别)将转换为数值变量和值。\n\n\n\n## 基于LRFM模型的分割\n\n本研究采用两阶段聚类法，结合SOM(确定最佳聚类数)和K-Means(创建聚类)方法进行分割。\n\n在此阶段，根据产品类别的RFM变量(每个产品类别的RFM变量的值分别计算)和L变量(客户关系的长度)进行客户细分。对于给定的客户，表1中给出了这些变量的样本，根据这些变量进行了细分。\n\n在本研究中，将LRFM模型用于产品类别层面的客户细分有三个原因，包括以下几个方面：\n\n1. 通过减少user-item矩阵中的客户数量，提高了该方法的生产率和效率，从而降低了矩阵的可扩展性和稀疏性问题。\n2. 这个模型不仅决定了顾客的价值，而且可以清楚地反映顾客的兴趣和偏好，例如，如果某一种产品的购买频率对于两个给定的顾客来说是相似的，可以推断这两个人对购买这两种商品的兴趣是一样的。M和R的变量也是以相同的方式推导出来的。\n3. 模型中的产品类别变量R涉及客户最近的品味和偏好，由于最近的购买更能反映客户当前的兴趣和偏好，它将提供更准确的推荐，更符合客户当前的兴趣。\n\n![](http://images.yingwai.top/picgo/dert1.png)\n\n<center>\n    <i>表1 基于LRFM模型的客户细分属性</i>\n</center>\n\n\n\n## 基于product category-user矩阵的关联规则提取\n\n为了提取关联规则，本研究使用了Apriori算法。在此阶段，使用product category-user矩阵(客户从单个产品类别购买的次数)的交易数据在前一阶段的每个聚类的级别提取关联规则。提取的规则用于确定每个目标客户的前N个推荐产品类别的列表。推荐的每个产品类别的优先级取决于其规则的可信度和支持措施。信任度和支持度值越大的产品类别，推荐优先级越高。此阶段中提取的规则的输出(即每个目标客户的预测产品类别)将作为下一阶段的输入。产品类别级规则提取的目的是减少user-item矩阵中的产品数量，有效缓解矩阵的可扩展性和稀疏性问题。\n\n\n\n## 更改user-item矩阵\n\n在CF系统中，user-item矩阵(包括购买/不购买项目的二进制数据或用户给予项目的分数)是关于购买偏好对客户进行聚类并确定目标客户的邻居的基础。然而，由于电子商务中商品种类繁多，该矩阵经常面临数据稀疏的问题。研究表明，推荐质量取决于user-item矩阵的密度。\n\n为了使该矩阵更加密集，以这样的方式使用分段和关联规则阶段的结果，即在用于确定目标客户的邻居的user-item矩阵中，他或她将仅与他或她的集群中的用户进行比较，并且项目将限于为目标客户预测的项目。由于减少了用户数和项目数，缓解了可伸缩性问题，提高了RS的速度和准确性。\n\n在他们的研究中，Lee等人。(2008)证明，最近进行的购买更能反映用户当前的偏好，最近添加到网站上出售的项目对用户更具吸引力。因此，基于表2，对于每个项目，考虑用户购买项目的时间(PT)和项目已经可供购买的时间(LT)(启动时间)的两个参数，并且改变user-item矩阵。\n\n![](http://images.yingwai.top/picgo/dert2.png)\n\n<center>\n    <i>表2 基于时间信息更改user-item矩阵</i>\n</center>\n\n\n\n\n\n为了确定PT和LT变量的得分，在这个改变的矩阵中，首先根据这两个参数的潜伏期将这两个参数分为五类。因此，PT参数的分数包括过去购买(分数1)、过去购买(分数2)、最近购买(分数3)、最近购买(分数4)和最近购买(分数5)。对于LT参数，得分类似。根据表3，在user-item矩阵中，对于用户给出的分数，使用组合分数。例如，对于(2，5)的组合，分数将等于7(5+2)。在计算混合得分时，这两个参数的权重都是相同的。\n\n![](http://images.yingwai.top/picgo/dert3.png)\n\n<center>\n    <i>表3 对LT和PT参数进行评分</i>\n</center>\n\n\n因此，创建了25(5×5)个双重组合，其中所有客户由55、54、53、…的组合表示。，11，其中，客户最好的类别是组合55(最近购买时间和最近上线时间的类别)和得分10，而客户最差的类别用11(最老的购买时间和最老的上线时间)表示，得分为2。根据这种评分方法，可以将客户划分为集群，并计算其相似度。创建这个新的user-item矩阵的目的是考虑用户随时间的喜好，从而提高推荐的准确性。\n\n\n\n## 基于CF的相似度计算\n\n在CF系统中，计算每个目标客户与其他客户之间的相似度的方法有很多。最流行的方法之一是使用皮尔逊相关系数，与其他传统的统计方法相比，它提供了最好的预测和推荐结果(Bobadilla等人)。(2012年)。在皮尔逊的相关方法中，使用公式(4)测量两个给定客户$u$和$u'$之间的相似性：\n$$\nSim(u, u') = \\frac{\\sum^n_{i=1}(r_{ui}-\\bar{r}_u)(r_{u'i}-\\bar{r}_{u'})}{\\sqrt{\\sum^n_{i=1}(r_{ui}-\\bar{r}_u)^2\\sum^n_{i=1}(r_{u'i}-\\bar{r}_{u'})^2}} \\tag{4}\n$$\n在这个等式中，$n$是两个用户得分的项目数，$i$是两个用户得分的项目集合，$r_{ui}$是用户$u$给出的项目$i$的得分，$\\bar{r}_u$是用户的平均得分。在本研究中，使用基于新的user-item矩阵的Pearson相关方法，计算客户偏好之间的相似度，然后将该阶段的结果(基于CF的相似度)用于预测客户的偏好。\n\n\n\n## 基于人口统计属性的细分\n\n在这个阶段，使用两阶段聚类方法，根据年龄、性别、教育程度、婚姻状况和职业等人口统计变量对客户进行细分，然后计算他们的簇内相似度。因此，如果两个客户具有相似的人口统计属性，他们对某些项目的态度会相似，这在CF方法中没有反映出来。在本研究中，基于这些变量进行客户细分的目的是为了更好地选择新用户的邻居，通过克服冷启动问题有效改善推荐过程。\n\n\n\n## 基于新的相似度函数确定邻域\n\n在此阶段，将前一阶段得到的聚类相似度(基于人口统计属性)和CF相似度合并到一个新的相似度函数中，以缓解冷启动问题。因为在用户最近加入系统的情况下，新的相似性函数并不完全依赖于user-item矩阵。通过该函数可以得到相似度。相似度函数(Hsim)通过簇内相似度(ClusSim)和基于CF的相似度(Sim)的加权和计算如下(5)：\n$$\nHsim(u,u')=(1-\\alpha) \\times Sim(u,u') + \\alpha \\times clusSim(u,u') \\tag{5}\n$$\n在利用上述公式计算客户之间的相似度后，选择与目标客户相似度最高的K个客户作为该客户的邻居。\n\n\n\n## 提供推荐\n\n在识别前一阶段目标客户的邻居后，通过计算这些邻居给出的得分的加权平均，预测目标客户的偏好。基于公式(6)，利用邻居得分的加权平均值$(r_{u',i})$，预测用户$u$对于项目$i$，$(r_{u,i})$的得分如下：\n$$\nr_{u,i} = \\frac{1}{n} \\sum_{u' \\in U} Hsim(u,u') \\times r_{u',i} \\tag{6}\n$$\n$U$表示评价项目$i$的用户$u$的邻居。用户$u$和$u'$，$(r_{u',i})$越相似，将以更高的加权比率用于预测$(r_{u,i})$。最后，将预测评分最高的$N$个项目推荐给目标用户。\n\n\n\n# 评估提出的推荐方法\n\n为了评估结果，将使用的数据集分为训练集和测试集。训练数据用于推荐系统，测试数据用于评估系统结果的准确性。训练数据涵盖2015年1月25日至11月16日期间，包括2015年11月16日至2016年1月21日期间交易的测试数据。\n\n![](http://images.yingwai.top/picgo/dert4.png)\n\n<center>\n    <i>表4 传统CF推荐系统与提出的CF推荐系统的评价方法比较</i>\n</center>\n\n\n\n在此阶段，将比较所提出的方法与传统CF推荐系统在不同N值(推荐项目数)下以及基于使用精确度、覆盖率和F度量的测试数据的结果的准确性。\n\n基于SOM算法，基于LRFM变量的最优聚类数为6个，基于人口统计变量的最优聚类数为5个。表4列出了基于不同N值的评估措施的传统方法和提出的方法的准确性。对于所有这些方法，参数K(邻居数目)的值都等于40。\n\n根据表4的结果，在每个准则下，所提出的系统都比传统系统具有更好的性能。事实上，传统系统(基于F-Measure)在5个推荐项目上的准确率为43.27%，而在所提出的系统中，该准确率为55.59%。在20个推荐项目中，传统方法的准确率为62.43%，其推荐系统的准确率为81.4%。在30个项目中，传统系统的准确率为68.54%，在提出的系统中，准确率为96.59%，表明该系统在30个项目上的准确率比传统系统提高了约28%。\n\n![](http://images.yingwai.top/picgo/derf2.png)\n\n<center>\n    <i>图2 比较传统方法和建议方法在不同N值下的性能(颜色请参见在线版本)</i>\n</center>\n\n\n![](http://images.yingwai.top/picgo/derf3.png)\n\n<center>\n    <i>图3 评估不同K值对建议方法性能的影响(有关颜色，请参阅在线版本)</i>\n</center>\n\n\n在此基础上，将推荐项数增加到N=30，两种方法的性能都有所提高。然而，增加数据数量并不会导致结果准确性的显著变化和提高。因此，将推荐项目的数量增加到某个阈值可以提高建议推荐的质量；该阈值等于N=30。为了更好地比较这两种方法的性能，图2描述了F-Measure准则的变化趋势。\n\n为了评估参数K的变化在所建议的研究方法的性能中的作用，图3中描述了三个不同N值的F测量值。基于图3，对于N参数的所有三个值，将邻居数增加到K=40将提高所提出的方法的性能。但是，进一步增加该参数会降低方法的精确度，从而对推荐质量产生负面影响。\n\n\n\n# 结论及建议\n\n本研究从冷启动、可扩展性、稀疏用户-项目矩阵以及用户兴趣的变化等方面考虑了电子商务中RS的基本和常见限制，以期解决或缓解这些限制。因此，为了克服这些局限性，人们利用一套数据挖掘方法，提出了一个综合性的电子商务推荐系统。综合研究结果，该系统的性能优于传统的CF系统。研究的总体结果表明，与传统系统相比，新的推荐系统的准确率有了显着的提高。因此，该系统对30个项目的推荐准确率比传统系统提高了约28%。此外，根据结果，系统在推荐30个项目时的准确率达到了最高水平；因此，当推荐项目数量超过30个时，传统系统和所提出的系统的准确率都没有明显的变化，因此，当推荐项目的数量超过30时，传统系统和本文提出的系统的准确率都没有明显的变化。例如，当推荐50个项目时，传统系统的准确率为68/84，新建议系统的准确率为94/45，这表明推荐项目的数量从30个增加到50个，准确率略有下降。因此，建议推荐项目的最大值为30个，因为这可能会导致计算和项目选择的复杂性。下面简要介绍一下研究成果和研究创新之处：\n\n* 在RS的开发过程中，在产品类别层面采用基于LRFM变量的细分方法，可以改进客户间相似度的确定方法，从而更准确、更恰当地选择目标客户的邻居。由于LRFM模型是识别客户购买行为和反映其偏好的合适方法之一，因此基于该模型在产品类别层次上进行细分，可以区分客户在购买产品类别时的偏好，并将具有相似品味和兴趣的客户归入同一聚类。例如，如果两个给定客户购买商品的频率相似，则可以得出结论，这两个客户对购买该产品类别中的商品表现出相同的兴趣水平。R和M的变量可以以相同的方式推断。另一方面，在产品类别水平上的变量R考虑了客户的利益，并且由于最近的购买更能反映客户的偏好，这将导致更准确的推荐。由于用户的喜好会随着时间的推移而改变，因此RS提供与客户当前兴趣相容的项目的能力会受到影响，这有时会导致推荐与客户当前喜好完全无关的项目。此外，在用户-项目矩阵中使用该分割的结果将降低矩阵的维数，将缓解KNN算法的稀疏矩阵和可伸缩性问题，这导致KNN算法的性能提高，因为在这种情况下，目标客户仅与用户-项目矩阵中他或她自己的集群内的客户相比较。因此，通过减少矩阵中的用户数，提高了KNN算法的速度和精度，改善了RS的整体性能。根据这一讨论和研究结果，可以安全地得出结论，使用LRFM模型可以加快提供建议的过程，并允许创建符合客户当前利益的准确建议。\n* 基于product category-user矩阵的关联规则提取提高了推荐方法的性能。这些规则通过评估产品类别之间的关系，预测他们购买的概率，并向目标客户推荐一套产品类别。将user-item矩阵限制为这些推荐产品类别中的项将降低矩阵的维数，有效地缓解了KNN算法的稀疏矩阵和可伸缩性问题。在该方法中，仅从从这些规则获得的产品类别中向目标客户提供推荐项目。结果表明，该方法通过减少矩阵中的项数，提高了KNN算法的速度和精度，有效地改善了RS的整体性能，研究结果表明该方法具有较好的性能。\n* 在RS的设计过程中考虑商品的购买时间以及它们在电子商务网站上的上线时间，将会提高推荐的质量。换言之，比起过去的购买，多留意顾客最近的购买，以及比起其他商品，多留意最近在网站上推出的商品，便可以更了解顾客现时的喜好，帮助他们找到更吸引人、更合意的商品。考虑到这些问题，RS才能更好地实现他们的最终目标，即向适当的个人提供适当的物品。在本研究中，这两个变量被用来创建一个新的用户-项目矩阵，并在表4和图2的基础上取得了很好的结果。\n* 为了更好地使推荐与用户的喜好相一致，人口特征的作用是无可否认的，因为大多数个人购买都取决于他们的年龄、性别、教育水平等。当它与其他变量如购买行为变量(包括LRFM和user-item矩阵)一起考虑时，这一作用更为显著，这是本研究通过定义一个新的相似性函数得出的。\n\n考虑到上述问题，本研究通过关注这些问题，利用各种数据挖掘方法，试图改进和完善以往关于CF系统的研究，以期提出一个准确率和性能最高的电子商务推荐系统。\n\n以下是对未来研究的一些建议：\n\n1. 将CF方法和CBF方法相结合，开发了所提出的模型。\n2. 研究基于个性特征的客户细分、其他人口统计变量(如地址和收入)以及其他行为变量(如购买商品的总数)对建议系统性能的影响。\n3. 将所提出的方法应用于其他行业的数据集，以提供更强的通用性。\n4. 使用大数据对提出的模型进行进一步评估，这些数据可以从大型网店获得。\n\n与过去的大多数研究一样，这项研究在实施和评估方面存在一些局限性，包括：\n\n1. 使用的数据集的时间段限制为一年；\n2. 研究数据仅限于一家网上服装店；\n3. 正在研究的商店顾客数量有限。","source":"_posts/论文笔记-Designing-an-e-commerce-recommender-system-based-on-collaborative-filtering-using-a-data-mining-approach.md","raw":"---\ntitle: >-\n  论文笔记 Designing an e-commerce recommender system based on collaborative\n  filtering using a data mining approach\ndate: 2020-05-18 21:10:49\ncategories: Papers\ntags: [数据挖掘, 推荐系统]\n---\n\n*Samira Khodabandehlou*\n\nhttps://scholar.google.com/scholar?hl=zh-CN&as_sdt=0%2C5&q=Designing+an+e-commerce+recommender+system+based+on+collaborative+filtering+using+a+data+mining+approach&btnG=\n\n<!--more-->\n\n![](http://images.yingwai.top/picgo/Designing an e-commerce recommender system based on collaborative filtering using a data mining approach.jpg)\n\n\n\n# 摘要\n\n电子商务推荐系统已经转变为客户非常重要的决策辅助工具，利用信息技术和客户信息提供在线个性化推荐。同时，协同过滤推荐系统是电子商务系统成功的关键组成部分之一。尽管有协同过滤现在的普及和成功，这些系统仍然面临着一系列严重的限制，包括冷启动、user-item矩阵稀疏、可扩展性和用户兴趣在这段时间内的变化，这些都阻碍了对客户的准确推荐。虽然已有很多研究提出了克服这些局限性的方法，但还没有提供一个全面的模型来降低这些局限性：1)在产品类别层面上基于LRFM变量进行客户细分，以评估与公司的客户关系的长度、最近程度、频率和购买产品类别的金额；2)在每个聚类级别上基于用户-类别矩阵提取关联规则；3)根据人口统计变量进行客户细分；4)改变用户-项目矩阵并降低其维数；5)通过将细分方法的结果与CF加权组合来开发新的相似度函数。根据所获得的结果，本研究提出的系统消除了传统的CF约束，为客户的偏好提供了更准确、更合适的建议。\n\n**关键词：**协同过滤；数据挖掘；电子商务；推荐系统；时态信息。\n\n\n\n本研究的主要目标包括：找出传统协同过滤在向合适的用户推荐合适商品方面的局限性，提出一个全面的、全新的推荐系统来消除传统CF的局限性，用真实的数据对推荐系统进行评估，以提供更准确、更符合顾客口味的推荐。\n\n\n\n# 理论背景\n\n## 推荐系统\n\n**推荐系统**是提高电子商务环境中决策过程质量的有用工具，因为它们通过提供必要的信息和有用的建议来帮助在线决策者选择与他们的愿望和要求一致的项目(Shambour and Lu，2015；Son，2016)。事实上，识别用户偏好的能力是个性化RS的核心(Kim等人，2011年)。Ricci等人。(2011)将RS定义为特定类型的信息系统，该信息系统：\n\n1. 帮助客户选择他们没有亲身体验的项目；\n2. 向顾客推荐商品；\n3. 通过为客户提供信息来帮助他们决定购买哪种商品。\n\n创建推荐系统有五个阶段：收集数据、分析用户信息、计算相似度、选择邻居、预测并提出前N个项目的列表(Yahya和Al-Shamri，2016)。这些系统出现在20世纪90年代中期，通常分为三类(Lee，2010；Resnick，1994)：\n\n1. **协同过滤**：这些系统根据一组被称为邻居的相似用户或相似项目的得分提供推荐(Kim等人，2005年)。CF是Netflix和Amazon等著名电子商务公司使用的最受欢迎的RS之一(Hernando等人，2016；Kim等人，2005年)。这些系统又根据它们用于预测用户偏好的算法类型分为两类(Ghazarian和Nematbakhsh，2014)：\n\n   * **Memory-based**：这些系统使用用户项目评分矩阵和KNN算法来识别用户的邻居并预测他们的偏好(Ghazarian和Nematbakhsh，2014年；Hernando等人，2016年；Kim等人，2011年)，其中使用皮尔逊相关系数等方法计算用户之间的相似性(Bobadilla等人，2012年)。在本研究中，使用KNN算法和皮尔逊相关系数来提供建议。\n   * **Model-based**：这些系统使用分段等方法处理用户的档案数据以提供建议，从而改进计算(Ghazarian和Nematbakhsh，2014；Hernando等人，2016)。\n\n   尽管CF方法很受欢迎并取得了成功，但它们仍然面临着一些严重的限制。这些限制包括：\n\n   * **冷启动**：在多个用户购买某个项目之前，系统不能向某人推荐该项目。这个问题被称为冷启动。用户的冷启动是指最近加入推荐系统并且没有关于他或她的足够信息的用户(Elahi等人，2016；Hu和Pu，2011；Kim等人，2011；Lee，2010；Son，2016；Sharma和Ray，2016)。\n   * **可伸缩性**：由于客户数据和产品数据的绝对数量，系统必须花费大量的金钱和时间来提取所有客户之间的相似性，导致其生产率较低(Hu和Pu，2011；Hernando等人，2016；Keramati和Khaleghi，2014；Lee，2010)。\n   * **user-item矩阵的稀疏性**：由于用户数量巨大，一个项目通常没有足够的分数或购买，导致user-item矩阵稀疏(Adomavicius和Tuzhlin，2005；Ghazarian和Nematbakhsh，2014；Karimi Alavije等人，2015，Sharma和Ray，2016)。\n   * **用户偏好的改变**：用户的品味和偏好可能会随着时间的推移而改变。例如，一位最近生了孩子的母亲可能对购买婴儿服装感兴趣，她最近的购买可能反映了这种新的关注。这是当；她可能从来没有对这样的物品有任何兴趣(Ding等人，2006年；岩田，2008年；Lee等人，2008年)。(Ding et al.，2006；Iwata，2008；Lee et al.，2008)。\n\n   上述限制可能会对RS的性能产生负面影响，从而限制系统创建有意义和准确的推荐。\n\n2. **基于内容的过滤器(Content-Based Filter，CBF)**：该方法基于这样的概念，即用户对他们以前感兴趣的项目感兴趣。因此，这些系统根据项目和产品之间的相似性提供建议(Anderson和Hiralall，2009年；Elahi等人，2016年)。因此，这种方法取决于物品的规格和与这些规格相关的用户配置文件的可用性(Anderson and Hiralall，2009)。这是因为在互联网上存储大量不同种类电子产品的目录是一项非常困难的任务(Bobadilla等人，2012年)。因此，音乐或视频文件等一些产品的内容分析非常困难；这个问题使得CF比CBF要好得多(Anderson和Hiralall，2009；Kim等人，2011)。与CBF相比，CF在电子商务中具有更高的灵活性和与RS的兼容性，使其成为最常用和最有用的RS系统之一(Burke，2002；Iwata，2008；Wang and Wu，2012)。因此，在本研究中，使用CF的概念作为主要的推荐机制。\n\n3. 混合方法：一些RS使用上述系统的组合来减少它们的限制；更多细节将在下面的实验背景部分提供(Burke，2002；Keramati和Khaleghi，2014)。\n\n\n\n## 客户细分\n\n客户细分是一种非常有用的数据挖掘方法，用于在电子商务的RS中找到“邻居”，在电子商务中，使用特定的方法，如聚类，来选择一些用户作为邻居，以改进偏好的预测(Khodabandehlou和Niknafs，2016；Li等人，2011年)。\n\n在RS中，选择合适的属性进行分割是影响系统性能的重要因素之一。最近购买、频率和货币模型(RFM)的属性是基于分析客户购买行为的一种很好的客户细分方法，它已经成功地用于许多RS(Keramati和Khaleghi，2014；Khodabandehlou和Zivari Rahman，2017；Lee，2010)。各种研究表明，在RFM模型中加入L(客户关系长度)指标将导致对客户的更准确分析，并将提高细分的质量(Li等人，2011年)。因此，在本研究中，LRFM模型被用于客户细分和识别具有相似购买行为的客户类别。\n\n此外，分割算法对识别出的片段的质量起着重要的作用。在聚类算法中，K-Means算法被认为是最成功和最合适的分割方法(Khodabandehlou和Niknafs，2016)，在许多研究中证明了它与RS的兼容性(Keramati和Khaleghi，2014；Karimi Alavije等人，2015；Li等人，2011年)。K-Means是一种数据挖掘方法，它需要K的初始值，即聚类的数量，才能运行。确定最佳簇数的合适方法是自组织映射(SOM)算法。该算法是一种无监督神经网络，可以从数据中识别未知模式，并估计合适的聚类数量(Abidi和Ong，2000；Mosayebian等人，2012)。\n\n相关研究建议在RS中结合K-Means和SOM算法使用两阶段分割方法，以获得更准确的结果(Keramati和Khaleghi，2014；Mosayebian等人，2012年)。因此，本研究将利用这一模式进行客户细分。\n\n\n\n## 关联规则\n\n关联规则是数据挖掘的重要方法之一，用于分析RS大型数据库中各种商品之间的市场篮子。分析购物篮已经成为发现用户购物车之间关系的流行系统(Hsu等人，2004；Liu and Shih，2005a)。Apriori算法是最常见的关联规则之一(Hsu等人，2004；Liu和Shih，2005a，2005b)，用于在已经购买了另一件物品时找到购买特定物品的概率模式。在RS中，已经形成了许多关于不同用户的购买行为的规则(Keramati和Khaleghi，2014；Liu和Shih，2005a，2005b)。在这些规则吸引程度的衡量标准中，我们可以提到支持性规则和置信度规则，它们分别指发现的规则的传播度和可接受性(Hsu等人，2004；Keramati和Khaleghi，2014；Karimi Alavije等人，2015；Liu和Shih，2005a，2005b)。\n\n\n\n# 评估措施\n\n评价推荐系统的性能是保证推荐系统通用性的重要一步。有一些评价RSS准确性或性能的众所周知的度量；诸如精确度、覆盖率和F度量(为了在这两个度量之间创建平衡)，它们可以很好地显示推荐系统的性能(Bobadilla等人，2012年；Elahi等人，2016；Ghazarian和Nematbakhsh，2014；Shambour和Lu，2015；Son，2016)。因此，为了评估所提出的研究模型的性能，采用了这些测量方法。\n\n在公式(1)和(2)中，喜爱的项目是指必须推荐给用户的一组产品或项目，而推荐的项目是已经由系统推荐给用户的项目的集合。精确度表示推荐集合中正确推荐的百分比，并评估这些推荐的精确度和准确性。通过公式(1)计算：\n$$\n{\\rm Precision}=\\frac{\\rm Recommended \\ Items\\cap Favorite \\  Items}{\\rm Recommended \\  Items} \\tag{1}\n$$\n覆盖率表示已经向用户建议了多少用户喜欢的项目的百分比，并使用公式(2)计算：\n$$\n{\\rm Coverage}=\\frac{\\rm Recommended \\ Items\\cap Favorite \\  Items}{\\rm Favorite \\  Items} \\tag{2}\n$$\nF-MEASURE是精度和覆盖范围的调和平均值，使用公式(3)计算：\n$$\n{\\rm F - measure}=\\frac{2 \\times \\rm Coverage \\cap Precision}{\\rm Coverage + Precision} \\tag{3}\n$$\n\n\n\n# 研究框架\n\n在设计和开发RSS时，真实、高质量的数据是非常重要的。本研究使用的这组数据与伊朗一家销售服装的网站的真实数据相关，时间范围为2015年1月21日至2016年1月21日(12个月)。此数据集涉及2542个客户和17,000条记录。在这家商店里，产品分为女装、男装、童装、女装、男装、女包和鞋、男包和鞋等七大类。据此，本研究提出的系统框架由八个主要阶段组成。在第一阶段，准备数据。该阶段由数据清理、数据整合、数据转换三个子阶段组成。在第二阶段，基于LRFM模型进行客户细分。在阶段3，基于product category-user矩阵提取关联规则。在阶段4中，完成user-item矩阵的改变。阶段5显示了基于CF的相似度计算。在阶段6中，根据人口统计特征对客户进行细分。在阶段7中，基于新的相似性函数来确定邻居。在最后阶段，推荐是根据用户的需求和特点量身定做的。在下文中，我们将对所有这些阶段进行详细说明。建议系统的总体框架如图1所示。\n\n![](http://images.yingwai.top/picgo/derf1.png)\n\n<center>\n    <i>图1 建议的研究系统的总体架构</i>\n</center>\n\n\n## 数据准备\n\n数据准备(也称为数据预处理)是RSS开发过程中不可或缺的一步，占整个RSS开发所需时间的60%-70%。此步骤包括数据清理、数据集成和数据转换三个阶段。\n\n### 数据清理\n\n数据清理过程包括完成缺失值、识别和消除离群值数据以及解决数据之间的冲突。此外，在此阶段，必须删除不相关或无用的字段或属性，如有必要，从初始数据集形成新的变量。在此阶段，将不完美的记录和信息不完整的客户从主数据集中剔除，数据集的记录从17,000条减少到15,386条，客户数量从2,542个减少到2,080个。为每个产品类别计算RFM变量。\n\n### 数据集成\n\n为了更好地理解数据，并对每个数据集中的数据进行更好的科学管理，数据集成(将两个或多个数据集合并集成在一起)是必要的，这是数据准备的第二阶段。在这一阶段，客户交易数据与他们的个人资料数据(年龄、性别、教育程度、婚姻状况和职业)集成在一起。\n\n### 数据转换\n\n在此阶段，必须将数据转换为适合数据挖掘和设计RS的不同形式。数据集中的字符串变量(如性别)将转换为数值变量和值。\n\n\n\n## 基于LRFM模型的分割\n\n本研究采用两阶段聚类法，结合SOM(确定最佳聚类数)和K-Means(创建聚类)方法进行分割。\n\n在此阶段，根据产品类别的RFM变量(每个产品类别的RFM变量的值分别计算)和L变量(客户关系的长度)进行客户细分。对于给定的客户，表1中给出了这些变量的样本，根据这些变量进行了细分。\n\n在本研究中，将LRFM模型用于产品类别层面的客户细分有三个原因，包括以下几个方面：\n\n1. 通过减少user-item矩阵中的客户数量，提高了该方法的生产率和效率，从而降低了矩阵的可扩展性和稀疏性问题。\n2. 这个模型不仅决定了顾客的价值，而且可以清楚地反映顾客的兴趣和偏好，例如，如果某一种产品的购买频率对于两个给定的顾客来说是相似的，可以推断这两个人对购买这两种商品的兴趣是一样的。M和R的变量也是以相同的方式推导出来的。\n3. 模型中的产品类别变量R涉及客户最近的品味和偏好，由于最近的购买更能反映客户当前的兴趣和偏好，它将提供更准确的推荐，更符合客户当前的兴趣。\n\n![](http://images.yingwai.top/picgo/dert1.png)\n\n<center>\n    <i>表1 基于LRFM模型的客户细分属性</i>\n</center>\n\n\n\n## 基于product category-user矩阵的关联规则提取\n\n为了提取关联规则，本研究使用了Apriori算法。在此阶段，使用product category-user矩阵(客户从单个产品类别购买的次数)的交易数据在前一阶段的每个聚类的级别提取关联规则。提取的规则用于确定每个目标客户的前N个推荐产品类别的列表。推荐的每个产品类别的优先级取决于其规则的可信度和支持措施。信任度和支持度值越大的产品类别，推荐优先级越高。此阶段中提取的规则的输出(即每个目标客户的预测产品类别)将作为下一阶段的输入。产品类别级规则提取的目的是减少user-item矩阵中的产品数量，有效缓解矩阵的可扩展性和稀疏性问题。\n\n\n\n## 更改user-item矩阵\n\n在CF系统中，user-item矩阵(包括购买/不购买项目的二进制数据或用户给予项目的分数)是关于购买偏好对客户进行聚类并确定目标客户的邻居的基础。然而，由于电子商务中商品种类繁多，该矩阵经常面临数据稀疏的问题。研究表明，推荐质量取决于user-item矩阵的密度。\n\n为了使该矩阵更加密集，以这样的方式使用分段和关联规则阶段的结果，即在用于确定目标客户的邻居的user-item矩阵中，他或她将仅与他或她的集群中的用户进行比较，并且项目将限于为目标客户预测的项目。由于减少了用户数和项目数，缓解了可伸缩性问题，提高了RS的速度和准确性。\n\n在他们的研究中，Lee等人。(2008)证明，最近进行的购买更能反映用户当前的偏好，最近添加到网站上出售的项目对用户更具吸引力。因此，基于表2，对于每个项目，考虑用户购买项目的时间(PT)和项目已经可供购买的时间(LT)(启动时间)的两个参数，并且改变user-item矩阵。\n\n![](http://images.yingwai.top/picgo/dert2.png)\n\n<center>\n    <i>表2 基于时间信息更改user-item矩阵</i>\n</center>\n\n\n\n\n\n为了确定PT和LT变量的得分，在这个改变的矩阵中，首先根据这两个参数的潜伏期将这两个参数分为五类。因此，PT参数的分数包括过去购买(分数1)、过去购买(分数2)、最近购买(分数3)、最近购买(分数4)和最近购买(分数5)。对于LT参数，得分类似。根据表3，在user-item矩阵中，对于用户给出的分数，使用组合分数。例如，对于(2，5)的组合，分数将等于7(5+2)。在计算混合得分时，这两个参数的权重都是相同的。\n\n![](http://images.yingwai.top/picgo/dert3.png)\n\n<center>\n    <i>表3 对LT和PT参数进行评分</i>\n</center>\n\n\n因此，创建了25(5×5)个双重组合，其中所有客户由55、54、53、…的组合表示。，11，其中，客户最好的类别是组合55(最近购买时间和最近上线时间的类别)和得分10，而客户最差的类别用11(最老的购买时间和最老的上线时间)表示，得分为2。根据这种评分方法，可以将客户划分为集群，并计算其相似度。创建这个新的user-item矩阵的目的是考虑用户随时间的喜好，从而提高推荐的准确性。\n\n\n\n## 基于CF的相似度计算\n\n在CF系统中，计算每个目标客户与其他客户之间的相似度的方法有很多。最流行的方法之一是使用皮尔逊相关系数，与其他传统的统计方法相比，它提供了最好的预测和推荐结果(Bobadilla等人)。(2012年)。在皮尔逊的相关方法中，使用公式(4)测量两个给定客户$u$和$u'$之间的相似性：\n$$\nSim(u, u') = \\frac{\\sum^n_{i=1}(r_{ui}-\\bar{r}_u)(r_{u'i}-\\bar{r}_{u'})}{\\sqrt{\\sum^n_{i=1}(r_{ui}-\\bar{r}_u)^2\\sum^n_{i=1}(r_{u'i}-\\bar{r}_{u'})^2}} \\tag{4}\n$$\n在这个等式中，$n$是两个用户得分的项目数，$i$是两个用户得分的项目集合，$r_{ui}$是用户$u$给出的项目$i$的得分，$\\bar{r}_u$是用户的平均得分。在本研究中，使用基于新的user-item矩阵的Pearson相关方法，计算客户偏好之间的相似度，然后将该阶段的结果(基于CF的相似度)用于预测客户的偏好。\n\n\n\n## 基于人口统计属性的细分\n\n在这个阶段，使用两阶段聚类方法，根据年龄、性别、教育程度、婚姻状况和职业等人口统计变量对客户进行细分，然后计算他们的簇内相似度。因此，如果两个客户具有相似的人口统计属性，他们对某些项目的态度会相似，这在CF方法中没有反映出来。在本研究中，基于这些变量进行客户细分的目的是为了更好地选择新用户的邻居，通过克服冷启动问题有效改善推荐过程。\n\n\n\n## 基于新的相似度函数确定邻域\n\n在此阶段，将前一阶段得到的聚类相似度(基于人口统计属性)和CF相似度合并到一个新的相似度函数中，以缓解冷启动问题。因为在用户最近加入系统的情况下，新的相似性函数并不完全依赖于user-item矩阵。通过该函数可以得到相似度。相似度函数(Hsim)通过簇内相似度(ClusSim)和基于CF的相似度(Sim)的加权和计算如下(5)：\n$$\nHsim(u,u')=(1-\\alpha) \\times Sim(u,u') + \\alpha \\times clusSim(u,u') \\tag{5}\n$$\n在利用上述公式计算客户之间的相似度后，选择与目标客户相似度最高的K个客户作为该客户的邻居。\n\n\n\n## 提供推荐\n\n在识别前一阶段目标客户的邻居后，通过计算这些邻居给出的得分的加权平均，预测目标客户的偏好。基于公式(6)，利用邻居得分的加权平均值$(r_{u',i})$，预测用户$u$对于项目$i$，$(r_{u,i})$的得分如下：\n$$\nr_{u,i} = \\frac{1}{n} \\sum_{u' \\in U} Hsim(u,u') \\times r_{u',i} \\tag{6}\n$$\n$U$表示评价项目$i$的用户$u$的邻居。用户$u$和$u'$，$(r_{u',i})$越相似，将以更高的加权比率用于预测$(r_{u,i})$。最后，将预测评分最高的$N$个项目推荐给目标用户。\n\n\n\n# 评估提出的推荐方法\n\n为了评估结果，将使用的数据集分为训练集和测试集。训练数据用于推荐系统，测试数据用于评估系统结果的准确性。训练数据涵盖2015年1月25日至11月16日期间，包括2015年11月16日至2016年1月21日期间交易的测试数据。\n\n![](http://images.yingwai.top/picgo/dert4.png)\n\n<center>\n    <i>表4 传统CF推荐系统与提出的CF推荐系统的评价方法比较</i>\n</center>\n\n\n\n在此阶段，将比较所提出的方法与传统CF推荐系统在不同N值(推荐项目数)下以及基于使用精确度、覆盖率和F度量的测试数据的结果的准确性。\n\n基于SOM算法，基于LRFM变量的最优聚类数为6个，基于人口统计变量的最优聚类数为5个。表4列出了基于不同N值的评估措施的传统方法和提出的方法的准确性。对于所有这些方法，参数K(邻居数目)的值都等于40。\n\n根据表4的结果，在每个准则下，所提出的系统都比传统系统具有更好的性能。事实上，传统系统(基于F-Measure)在5个推荐项目上的准确率为43.27%，而在所提出的系统中，该准确率为55.59%。在20个推荐项目中，传统方法的准确率为62.43%，其推荐系统的准确率为81.4%。在30个项目中，传统系统的准确率为68.54%，在提出的系统中，准确率为96.59%，表明该系统在30个项目上的准确率比传统系统提高了约28%。\n\n![](http://images.yingwai.top/picgo/derf2.png)\n\n<center>\n    <i>图2 比较传统方法和建议方法在不同N值下的性能(颜色请参见在线版本)</i>\n</center>\n\n\n![](http://images.yingwai.top/picgo/derf3.png)\n\n<center>\n    <i>图3 评估不同K值对建议方法性能的影响(有关颜色，请参阅在线版本)</i>\n</center>\n\n\n在此基础上，将推荐项数增加到N=30，两种方法的性能都有所提高。然而，增加数据数量并不会导致结果准确性的显著变化和提高。因此，将推荐项目的数量增加到某个阈值可以提高建议推荐的质量；该阈值等于N=30。为了更好地比较这两种方法的性能，图2描述了F-Measure准则的变化趋势。\n\n为了评估参数K的变化在所建议的研究方法的性能中的作用，图3中描述了三个不同N值的F测量值。基于图3，对于N参数的所有三个值，将邻居数增加到K=40将提高所提出的方法的性能。但是，进一步增加该参数会降低方法的精确度，从而对推荐质量产生负面影响。\n\n\n\n# 结论及建议\n\n本研究从冷启动、可扩展性、稀疏用户-项目矩阵以及用户兴趣的变化等方面考虑了电子商务中RS的基本和常见限制，以期解决或缓解这些限制。因此，为了克服这些局限性，人们利用一套数据挖掘方法，提出了一个综合性的电子商务推荐系统。综合研究结果，该系统的性能优于传统的CF系统。研究的总体结果表明，与传统系统相比，新的推荐系统的准确率有了显着的提高。因此，该系统对30个项目的推荐准确率比传统系统提高了约28%。此外，根据结果，系统在推荐30个项目时的准确率达到了最高水平；因此，当推荐项目数量超过30个时，传统系统和所提出的系统的准确率都没有明显的变化，因此，当推荐项目的数量超过30时，传统系统和本文提出的系统的准确率都没有明显的变化。例如，当推荐50个项目时，传统系统的准确率为68/84，新建议系统的准确率为94/45，这表明推荐项目的数量从30个增加到50个，准确率略有下降。因此，建议推荐项目的最大值为30个，因为这可能会导致计算和项目选择的复杂性。下面简要介绍一下研究成果和研究创新之处：\n\n* 在RS的开发过程中，在产品类别层面采用基于LRFM变量的细分方法，可以改进客户间相似度的确定方法，从而更准确、更恰当地选择目标客户的邻居。由于LRFM模型是识别客户购买行为和反映其偏好的合适方法之一，因此基于该模型在产品类别层次上进行细分，可以区分客户在购买产品类别时的偏好，并将具有相似品味和兴趣的客户归入同一聚类。例如，如果两个给定客户购买商品的频率相似，则可以得出结论，这两个客户对购买该产品类别中的商品表现出相同的兴趣水平。R和M的变量可以以相同的方式推断。另一方面，在产品类别水平上的变量R考虑了客户的利益，并且由于最近的购买更能反映客户的偏好，这将导致更准确的推荐。由于用户的喜好会随着时间的推移而改变，因此RS提供与客户当前兴趣相容的项目的能力会受到影响，这有时会导致推荐与客户当前喜好完全无关的项目。此外，在用户-项目矩阵中使用该分割的结果将降低矩阵的维数，将缓解KNN算法的稀疏矩阵和可伸缩性问题，这导致KNN算法的性能提高，因为在这种情况下，目标客户仅与用户-项目矩阵中他或她自己的集群内的客户相比较。因此，通过减少矩阵中的用户数，提高了KNN算法的速度和精度，改善了RS的整体性能。根据这一讨论和研究结果，可以安全地得出结论，使用LRFM模型可以加快提供建议的过程，并允许创建符合客户当前利益的准确建议。\n* 基于product category-user矩阵的关联规则提取提高了推荐方法的性能。这些规则通过评估产品类别之间的关系，预测他们购买的概率，并向目标客户推荐一套产品类别。将user-item矩阵限制为这些推荐产品类别中的项将降低矩阵的维数，有效地缓解了KNN算法的稀疏矩阵和可伸缩性问题。在该方法中，仅从从这些规则获得的产品类别中向目标客户提供推荐项目。结果表明，该方法通过减少矩阵中的项数，提高了KNN算法的速度和精度，有效地改善了RS的整体性能，研究结果表明该方法具有较好的性能。\n* 在RS的设计过程中考虑商品的购买时间以及它们在电子商务网站上的上线时间，将会提高推荐的质量。换言之，比起过去的购买，多留意顾客最近的购买，以及比起其他商品，多留意最近在网站上推出的商品，便可以更了解顾客现时的喜好，帮助他们找到更吸引人、更合意的商品。考虑到这些问题，RS才能更好地实现他们的最终目标，即向适当的个人提供适当的物品。在本研究中，这两个变量被用来创建一个新的用户-项目矩阵，并在表4和图2的基础上取得了很好的结果。\n* 为了更好地使推荐与用户的喜好相一致，人口特征的作用是无可否认的，因为大多数个人购买都取决于他们的年龄、性别、教育水平等。当它与其他变量如购买行为变量(包括LRFM和user-item矩阵)一起考虑时，这一作用更为显著，这是本研究通过定义一个新的相似性函数得出的。\n\n考虑到上述问题，本研究通过关注这些问题，利用各种数据挖掘方法，试图改进和完善以往关于CF系统的研究，以期提出一个准确率和性能最高的电子商务推荐系统。\n\n以下是对未来研究的一些建议：\n\n1. 将CF方法和CBF方法相结合，开发了所提出的模型。\n2. 研究基于个性特征的客户细分、其他人口统计变量(如地址和收入)以及其他行为变量(如购买商品的总数)对建议系统性能的影响。\n3. 将所提出的方法应用于其他行业的数据集，以提供更强的通用性。\n4. 使用大数据对提出的模型进行进一步评估，这些数据可以从大型网店获得。\n\n与过去的大多数研究一样，这项研究在实施和评估方面存在一些局限性，包括：\n\n1. 使用的数据集的时间段限制为一年；\n2. 研究数据仅限于一家网上服装店；\n3. 正在研究的商店顾客数量有限。","slug":"论文笔记-Designing-an-e-commerce-recommender-system-based-on-collaborative-filtering-using-a-data-mining-approach","published":1,"updated":"2020-08-23T14:33:37.434Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cke79q4pj001h88ps93ru5blo","content":"<p><em>Samira Khodabandehlou</em></p>\n<p><a href=\"https://scholar.google.com/scholar?hl=zh-CN&amp;as_sdt=0%2C5&amp;q=Designing+an+e-commerce+recommender+system+based+on+collaborative+filtering+using+a+data+mining+approach&amp;btnG=\" target=\"_blank\" rel=\"noopener\">https://scholar.google.com/scholar?hl=zh-CN&amp;as_sdt=0%2C5&amp;q=Designing+an+e-commerce+recommender+system+based+on+collaborative+filtering+using+a+data+mining+approach&amp;btnG=</a></p>\n<a id=\"more\"></a>\n<p><img src=\"http://images.yingwai.top/picgo/Designing an e-commerce recommender system based on collaborative filtering using a data mining approach.jpg\" alt=\"\"></p>\n<h1 id=\"摘要\"><a href=\"#摘要\" class=\"headerlink\" title=\"摘要\"></a>摘要</h1><p>电子商务推荐系统已经转变为客户非常重要的决策辅助工具，利用信息技术和客户信息提供在线个性化推荐。同时，协同过滤推荐系统是电子商务系统成功的关键组成部分之一。尽管有协同过滤现在的普及和成功，这些系统仍然面临着一系列严重的限制，包括冷启动、user-item矩阵稀疏、可扩展性和用户兴趣在这段时间内的变化，这些都阻碍了对客户的准确推荐。虽然已有很多研究提出了克服这些局限性的方法，但还没有提供一个全面的模型来降低这些局限性：1)在产品类别层面上基于LRFM变量进行客户细分，以评估与公司的客户关系的长度、最近程度、频率和购买产品类别的金额；2)在每个聚类级别上基于用户-类别矩阵提取关联规则；3)根据人口统计变量进行客户细分；4)改变用户-项目矩阵并降低其维数；5)通过将细分方法的结果与CF加权组合来开发新的相似度函数。根据所获得的结果，本研究提出的系统消除了传统的CF约束，为客户的偏好提供了更准确、更合适的建议。</p>\n<p><strong>关键词：</strong>协同过滤；数据挖掘；电子商务；推荐系统；时态信息。</p>\n<p>本研究的主要目标包括：找出传统协同过滤在向合适的用户推荐合适商品方面的局限性，提出一个全面的、全新的推荐系统来消除传统CF的局限性，用真实的数据对推荐系统进行评估，以提供更准确、更符合顾客口味的推荐。</p>\n<h1 id=\"理论背景\"><a href=\"#理论背景\" class=\"headerlink\" title=\"理论背景\"></a>理论背景</h1><h2 id=\"推荐系统\"><a href=\"#推荐系统\" class=\"headerlink\" title=\"推荐系统\"></a>推荐系统</h2><p><strong>推荐系统</strong>是提高电子商务环境中决策过程质量的有用工具，因为它们通过提供必要的信息和有用的建议来帮助在线决策者选择与他们的愿望和要求一致的项目(Shambour and Lu，2015；Son，2016)。事实上，识别用户偏好的能力是个性化RS的核心(Kim等人，2011年)。Ricci等人。(2011)将RS定义为特定类型的信息系统，该信息系统：</p>\n<ol>\n<li>帮助客户选择他们没有亲身体验的项目；</li>\n<li>向顾客推荐商品；</li>\n<li>通过为客户提供信息来帮助他们决定购买哪种商品。</li>\n</ol>\n<p>创建推荐系统有五个阶段：收集数据、分析用户信息、计算相似度、选择邻居、预测并提出前N个项目的列表(Yahya和Al-Shamri，2016)。这些系统出现在20世纪90年代中期，通常分为三类(Lee，2010；Resnick，1994)：</p>\n<ol>\n<li><p><strong>协同过滤</strong>：这些系统根据一组被称为邻居的相似用户或相似项目的得分提供推荐(Kim等人，2005年)。CF是Netflix和Amazon等著名电子商务公司使用的最受欢迎的RS之一(Hernando等人，2016；Kim等人，2005年)。这些系统又根据它们用于预测用户偏好的算法类型分为两类(Ghazarian和Nematbakhsh，2014)：</p>\n<ul>\n<li><strong>Memory-based</strong>：这些系统使用用户项目评分矩阵和KNN算法来识别用户的邻居并预测他们的偏好(Ghazarian和Nematbakhsh，2014年；Hernando等人，2016年；Kim等人，2011年)，其中使用皮尔逊相关系数等方法计算用户之间的相似性(Bobadilla等人，2012年)。在本研究中，使用KNN算法和皮尔逊相关系数来提供建议。</li>\n<li><strong>Model-based</strong>：这些系统使用分段等方法处理用户的档案数据以提供建议，从而改进计算(Ghazarian和Nematbakhsh，2014；Hernando等人，2016)。</li>\n</ul>\n<p>尽管CF方法很受欢迎并取得了成功，但它们仍然面临着一些严重的限制。这些限制包括：</p>\n<ul>\n<li><strong>冷启动</strong>：在多个用户购买某个项目之前，系统不能向某人推荐该项目。这个问题被称为冷启动。用户的冷启动是指最近加入推荐系统并且没有关于他或她的足够信息的用户(Elahi等人，2016；Hu和Pu，2011；Kim等人，2011；Lee，2010；Son，2016；Sharma和Ray，2016)。</li>\n<li><strong>可伸缩性</strong>：由于客户数据和产品数据的绝对数量，系统必须花费大量的金钱和时间来提取所有客户之间的相似性，导致其生产率较低(Hu和Pu，2011；Hernando等人，2016；Keramati和Khaleghi，2014；Lee，2010)。</li>\n<li><strong>user-item矩阵的稀疏性</strong>：由于用户数量巨大，一个项目通常没有足够的分数或购买，导致user-item矩阵稀疏(Adomavicius和Tuzhlin，2005；Ghazarian和Nematbakhsh，2014；Karimi Alavije等人，2015，Sharma和Ray，2016)。</li>\n<li><strong>用户偏好的改变</strong>：用户的品味和偏好可能会随着时间的推移而改变。例如，一位最近生了孩子的母亲可能对购买婴儿服装感兴趣，她最近的购买可能反映了这种新的关注。这是当；她可能从来没有对这样的物品有任何兴趣(Ding等人，2006年；岩田，2008年；Lee等人，2008年)。(Ding et al.，2006；Iwata，2008；Lee et al.，2008)。</li>\n</ul>\n<p>上述限制可能会对RS的性能产生负面影响，从而限制系统创建有意义和准确的推荐。</p>\n</li>\n<li><p><strong>基于内容的过滤器(Content-Based Filter，CBF)</strong>：该方法基于这样的概念，即用户对他们以前感兴趣的项目感兴趣。因此，这些系统根据项目和产品之间的相似性提供建议(Anderson和Hiralall，2009年；Elahi等人，2016年)。因此，这种方法取决于物品的规格和与这些规格相关的用户配置文件的可用性(Anderson and Hiralall，2009)。这是因为在互联网上存储大量不同种类电子产品的目录是一项非常困难的任务(Bobadilla等人，2012年)。因此，音乐或视频文件等一些产品的内容分析非常困难；这个问题使得CF比CBF要好得多(Anderson和Hiralall，2009；Kim等人，2011)。与CBF相比，CF在电子商务中具有更高的灵活性和与RS的兼容性，使其成为最常用和最有用的RS系统之一(Burke，2002；Iwata，2008；Wang and Wu，2012)。因此，在本研究中，使用CF的概念作为主要的推荐机制。</p>\n</li>\n<li><p>混合方法：一些RS使用上述系统的组合来减少它们的限制；更多细节将在下面的实验背景部分提供(Burke，2002；Keramati和Khaleghi，2014)。</p>\n</li>\n</ol>\n<h2 id=\"客户细分\"><a href=\"#客户细分\" class=\"headerlink\" title=\"客户细分\"></a>客户细分</h2><p>客户细分是一种非常有用的数据挖掘方法，用于在电子商务的RS中找到“邻居”，在电子商务中，使用特定的方法，如聚类，来选择一些用户作为邻居，以改进偏好的预测(Khodabandehlou和Niknafs，2016；Li等人，2011年)。</p>\n<p>在RS中，选择合适的属性进行分割是影响系统性能的重要因素之一。最近购买、频率和货币模型(RFM)的属性是基于分析客户购买行为的一种很好的客户细分方法，它已经成功地用于许多RS(Keramati和Khaleghi，2014；Khodabandehlou和Zivari Rahman，2017；Lee，2010)。各种研究表明，在RFM模型中加入L(客户关系长度)指标将导致对客户的更准确分析，并将提高细分的质量(Li等人，2011年)。因此，在本研究中，LRFM模型被用于客户细分和识别具有相似购买行为的客户类别。</p>\n<p>此外，分割算法对识别出的片段的质量起着重要的作用。在聚类算法中，K-Means算法被认为是最成功和最合适的分割方法(Khodabandehlou和Niknafs，2016)，在许多研究中证明了它与RS的兼容性(Keramati和Khaleghi，2014；Karimi Alavije等人，2015；Li等人，2011年)。K-Means是一种数据挖掘方法，它需要K的初始值，即聚类的数量，才能运行。确定最佳簇数的合适方法是自组织映射(SOM)算法。该算法是一种无监督神经网络，可以从数据中识别未知模式，并估计合适的聚类数量(Abidi和Ong，2000；Mosayebian等人，2012)。</p>\n<p>相关研究建议在RS中结合K-Means和SOM算法使用两阶段分割方法，以获得更准确的结果(Keramati和Khaleghi，2014；Mosayebian等人，2012年)。因此，本研究将利用这一模式进行客户细分。</p>\n<h2 id=\"关联规则\"><a href=\"#关联规则\" class=\"headerlink\" title=\"关联规则\"></a>关联规则</h2><p>关联规则是数据挖掘的重要方法之一，用于分析RS大型数据库中各种商品之间的市场篮子。分析购物篮已经成为发现用户购物车之间关系的流行系统(Hsu等人，2004；Liu and Shih，2005a)。Apriori算法是最常见的关联规则之一(Hsu等人，2004；Liu和Shih，2005a，2005b)，用于在已经购买了另一件物品时找到购买特定物品的概率模式。在RS中，已经形成了许多关于不同用户的购买行为的规则(Keramati和Khaleghi，2014；Liu和Shih，2005a，2005b)。在这些规则吸引程度的衡量标准中，我们可以提到支持性规则和置信度规则，它们分别指发现的规则的传播度和可接受性(Hsu等人，2004；Keramati和Khaleghi，2014；Karimi Alavije等人，2015；Liu和Shih，2005a，2005b)。</p>\n<h1 id=\"评估措施\"><a href=\"#评估措施\" class=\"headerlink\" title=\"评估措施\"></a>评估措施</h1><p>评价推荐系统的性能是保证推荐系统通用性的重要一步。有一些评价RSS准确性或性能的众所周知的度量；诸如精确度、覆盖率和F度量(为了在这两个度量之间创建平衡)，它们可以很好地显示推荐系统的性能(Bobadilla等人，2012年；Elahi等人，2016；Ghazarian和Nematbakhsh，2014；Shambour和Lu，2015；Son，2016)。因此，为了评估所提出的研究模型的性能，采用了这些测量方法。</p>\n<p>在公式(1)和(2)中，喜爱的项目是指必须推荐给用户的一组产品或项目，而推荐的项目是已经由系统推荐给用户的项目的集合。精确度表示推荐集合中正确推荐的百分比，并评估这些推荐的精确度和准确性。通过公式(1)计算：</p>\n<script type=\"math/tex; mode=display\">\n{\\rm Precision}=\\frac{\\rm Recommended \\ Items\\cap Favorite \\  Items}{\\rm Recommended \\  Items} \\tag{1}</script><p>覆盖率表示已经向用户建议了多少用户喜欢的项目的百分比，并使用公式(2)计算：</p>\n<script type=\"math/tex; mode=display\">\n{\\rm Coverage}=\\frac{\\rm Recommended \\ Items\\cap Favorite \\  Items}{\\rm Favorite \\  Items} \\tag{2}</script><p>F-MEASURE是精度和覆盖范围的调和平均值，使用公式(3)计算：</p>\n<script type=\"math/tex; mode=display\">\n{\\rm F - measure}=\\frac{2 \\times \\rm Coverage \\cap Precision}{\\rm Coverage + Precision} \\tag{3}</script><h1 id=\"研究框架\"><a href=\"#研究框架\" class=\"headerlink\" title=\"研究框架\"></a>研究框架</h1><p>在设计和开发RSS时，真实、高质量的数据是非常重要的。本研究使用的这组数据与伊朗一家销售服装的网站的真实数据相关，时间范围为2015年1月21日至2016年1月21日(12个月)。此数据集涉及2542个客户和17,000条记录。在这家商店里，产品分为女装、男装、童装、女装、男装、女包和鞋、男包和鞋等七大类。据此，本研究提出的系统框架由八个主要阶段组成。在第一阶段，准备数据。该阶段由数据清理、数据整合、数据转换三个子阶段组成。在第二阶段，基于LRFM模型进行客户细分。在阶段3，基于product category-user矩阵提取关联规则。在阶段4中，完成user-item矩阵的改变。阶段5显示了基于CF的相似度计算。在阶段6中，根据人口统计特征对客户进行细分。在阶段7中，基于新的相似性函数来确定邻居。在最后阶段，推荐是根据用户的需求和特点量身定做的。在下文中，我们将对所有这些阶段进行详细说明。建议系统的总体框架如图1所示。</p>\n<p><img src=\"http://images.yingwai.top/picgo/derf1.png\" alt=\"\"></p>\n<center>\n    <i>图1 建议的研究系统的总体架构</i>\n</center>\n\n\n<h2 id=\"数据准备\"><a href=\"#数据准备\" class=\"headerlink\" title=\"数据准备\"></a>数据准备</h2><p>数据准备(也称为数据预处理)是RSS开发过程中不可或缺的一步，占整个RSS开发所需时间的60%-70%。此步骤包括数据清理、数据集成和数据转换三个阶段。</p>\n<h3 id=\"数据清理\"><a href=\"#数据清理\" class=\"headerlink\" title=\"数据清理\"></a>数据清理</h3><p>数据清理过程包括完成缺失值、识别和消除离群值数据以及解决数据之间的冲突。此外，在此阶段，必须删除不相关或无用的字段或属性，如有必要，从初始数据集形成新的变量。在此阶段，将不完美的记录和信息不完整的客户从主数据集中剔除，数据集的记录从17,000条减少到15,386条，客户数量从2,542个减少到2,080个。为每个产品类别计算RFM变量。</p>\n<h3 id=\"数据集成\"><a href=\"#数据集成\" class=\"headerlink\" title=\"数据集成\"></a>数据集成</h3><p>为了更好地理解数据，并对每个数据集中的数据进行更好的科学管理，数据集成(将两个或多个数据集合并集成在一起)是必要的，这是数据准备的第二阶段。在这一阶段，客户交易数据与他们的个人资料数据(年龄、性别、教育程度、婚姻状况和职业)集成在一起。</p>\n<h3 id=\"数据转换\"><a href=\"#数据转换\" class=\"headerlink\" title=\"数据转换\"></a>数据转换</h3><p>在此阶段，必须将数据转换为适合数据挖掘和设计RS的不同形式。数据集中的字符串变量(如性别)将转换为数值变量和值。</p>\n<h2 id=\"基于LRFM模型的分割\"><a href=\"#基于LRFM模型的分割\" class=\"headerlink\" title=\"基于LRFM模型的分割\"></a>基于LRFM模型的分割</h2><p>本研究采用两阶段聚类法，结合SOM(确定最佳聚类数)和K-Means(创建聚类)方法进行分割。</p>\n<p>在此阶段，根据产品类别的RFM变量(每个产品类别的RFM变量的值分别计算)和L变量(客户关系的长度)进行客户细分。对于给定的客户，表1中给出了这些变量的样本，根据这些变量进行了细分。</p>\n<p>在本研究中，将LRFM模型用于产品类别层面的客户细分有三个原因，包括以下几个方面：</p>\n<ol>\n<li>通过减少user-item矩阵中的客户数量，提高了该方法的生产率和效率，从而降低了矩阵的可扩展性和稀疏性问题。</li>\n<li>这个模型不仅决定了顾客的价值，而且可以清楚地反映顾客的兴趣和偏好，例如，如果某一种产品的购买频率对于两个给定的顾客来说是相似的，可以推断这两个人对购买这两种商品的兴趣是一样的。M和R的变量也是以相同的方式推导出来的。</li>\n<li>模型中的产品类别变量R涉及客户最近的品味和偏好，由于最近的购买更能反映客户当前的兴趣和偏好，它将提供更准确的推荐，更符合客户当前的兴趣。</li>\n</ol>\n<p><img src=\"http://images.yingwai.top/picgo/dert1.png\" alt=\"\"></p>\n<center>\n    <i>表1 基于LRFM模型的客户细分属性</i>\n</center>\n\n\n\n<h2 id=\"基于product-category-user矩阵的关联规则提取\"><a href=\"#基于product-category-user矩阵的关联规则提取\" class=\"headerlink\" title=\"基于product category-user矩阵的关联规则提取\"></a>基于product category-user矩阵的关联规则提取</h2><p>为了提取关联规则，本研究使用了Apriori算法。在此阶段，使用product category-user矩阵(客户从单个产品类别购买的次数)的交易数据在前一阶段的每个聚类的级别提取关联规则。提取的规则用于确定每个目标客户的前N个推荐产品类别的列表。推荐的每个产品类别的优先级取决于其规则的可信度和支持措施。信任度和支持度值越大的产品类别，推荐优先级越高。此阶段中提取的规则的输出(即每个目标客户的预测产品类别)将作为下一阶段的输入。产品类别级规则提取的目的是减少user-item矩阵中的产品数量，有效缓解矩阵的可扩展性和稀疏性问题。</p>\n<h2 id=\"更改user-item矩阵\"><a href=\"#更改user-item矩阵\" class=\"headerlink\" title=\"更改user-item矩阵\"></a>更改user-item矩阵</h2><p>在CF系统中，user-item矩阵(包括购买/不购买项目的二进制数据或用户给予项目的分数)是关于购买偏好对客户进行聚类并确定目标客户的邻居的基础。然而，由于电子商务中商品种类繁多，该矩阵经常面临数据稀疏的问题。研究表明，推荐质量取决于user-item矩阵的密度。</p>\n<p>为了使该矩阵更加密集，以这样的方式使用分段和关联规则阶段的结果，即在用于确定目标客户的邻居的user-item矩阵中，他或她将仅与他或她的集群中的用户进行比较，并且项目将限于为目标客户预测的项目。由于减少了用户数和项目数，缓解了可伸缩性问题，提高了RS的速度和准确性。</p>\n<p>在他们的研究中，Lee等人。(2008)证明，最近进行的购买更能反映用户当前的偏好，最近添加到网站上出售的项目对用户更具吸引力。因此，基于表2，对于每个项目，考虑用户购买项目的时间(PT)和项目已经可供购买的时间(LT)(启动时间)的两个参数，并且改变user-item矩阵。</p>\n<p><img src=\"http://images.yingwai.top/picgo/dert2.png\" alt=\"\"></p>\n<center>\n    <i>表2 基于时间信息更改user-item矩阵</i>\n</center>\n\n\n\n\n\n<p>为了确定PT和LT变量的得分，在这个改变的矩阵中，首先根据这两个参数的潜伏期将这两个参数分为五类。因此，PT参数的分数包括过去购买(分数1)、过去购买(分数2)、最近购买(分数3)、最近购买(分数4)和最近购买(分数5)。对于LT参数，得分类似。根据表3，在user-item矩阵中，对于用户给出的分数，使用组合分数。例如，对于(2，5)的组合，分数将等于7(5+2)。在计算混合得分时，这两个参数的权重都是相同的。</p>\n<p><img src=\"http://images.yingwai.top/picgo/dert3.png\" alt=\"\"></p>\n<center>\n    <i>表3 对LT和PT参数进行评分</i>\n</center>\n\n\n<p>因此，创建了25(5×5)个双重组合，其中所有客户由55、54、53、…的组合表示。，11，其中，客户最好的类别是组合55(最近购买时间和最近上线时间的类别)和得分10，而客户最差的类别用11(最老的购买时间和最老的上线时间)表示，得分为2。根据这种评分方法，可以将客户划分为集群，并计算其相似度。创建这个新的user-item矩阵的目的是考虑用户随时间的喜好，从而提高推荐的准确性。</p>\n<h2 id=\"基于CF的相似度计算\"><a href=\"#基于CF的相似度计算\" class=\"headerlink\" title=\"基于CF的相似度计算\"></a>基于CF的相似度计算</h2><p>在CF系统中，计算每个目标客户与其他客户之间的相似度的方法有很多。最流行的方法之一是使用皮尔逊相关系数，与其他传统的统计方法相比，它提供了最好的预测和推荐结果(Bobadilla等人)。(2012年)。在皮尔逊的相关方法中，使用公式(4)测量两个给定客户$u$和$u’$之间的相似性：</p>\n<script type=\"math/tex; mode=display\">\nSim(u, u') = \\frac{\\sum^n_{i=1}(r_{ui}-\\bar{r}_u)(r_{u'i}-\\bar{r}_{u'})}{\\sqrt{\\sum^n_{i=1}(r_{ui}-\\bar{r}_u)^2\\sum^n_{i=1}(r_{u'i}-\\bar{r}_{u'})^2}} \\tag{4}</script><p>在这个等式中，$n$是两个用户得分的项目数，$i$是两个用户得分的项目集合，$r_{ui}$是用户$u$给出的项目$i$的得分，$\\bar{r}_u$是用户的平均得分。在本研究中，使用基于新的user-item矩阵的Pearson相关方法，计算客户偏好之间的相似度，然后将该阶段的结果(基于CF的相似度)用于预测客户的偏好。</p>\n<h2 id=\"基于人口统计属性的细分\"><a href=\"#基于人口统计属性的细分\" class=\"headerlink\" title=\"基于人口统计属性的细分\"></a>基于人口统计属性的细分</h2><p>在这个阶段，使用两阶段聚类方法，根据年龄、性别、教育程度、婚姻状况和职业等人口统计变量对客户进行细分，然后计算他们的簇内相似度。因此，如果两个客户具有相似的人口统计属性，他们对某些项目的态度会相似，这在CF方法中没有反映出来。在本研究中，基于这些变量进行客户细分的目的是为了更好地选择新用户的邻居，通过克服冷启动问题有效改善推荐过程。</p>\n<h2 id=\"基于新的相似度函数确定邻域\"><a href=\"#基于新的相似度函数确定邻域\" class=\"headerlink\" title=\"基于新的相似度函数确定邻域\"></a>基于新的相似度函数确定邻域</h2><p>在此阶段，将前一阶段得到的聚类相似度(基于人口统计属性)和CF相似度合并到一个新的相似度函数中，以缓解冷启动问题。因为在用户最近加入系统的情况下，新的相似性函数并不完全依赖于user-item矩阵。通过该函数可以得到相似度。相似度函数(Hsim)通过簇内相似度(ClusSim)和基于CF的相似度(Sim)的加权和计算如下(5)：</p>\n<script type=\"math/tex; mode=display\">\nHsim(u,u')=(1-\\alpha) \\times Sim(u,u') + \\alpha \\times clusSim(u,u') \\tag{5}</script><p>在利用上述公式计算客户之间的相似度后，选择与目标客户相似度最高的K个客户作为该客户的邻居。</p>\n<h2 id=\"提供推荐\"><a href=\"#提供推荐\" class=\"headerlink\" title=\"提供推荐\"></a>提供推荐</h2><p>在识别前一阶段目标客户的邻居后，通过计算这些邻居给出的得分的加权平均，预测目标客户的偏好。基于公式(6)，利用邻居得分的加权平均值$(r<em>{u’,i})$，预测用户$u$对于项目$i$，$(r</em>{u,i})$的得分如下：</p>\n<script type=\"math/tex; mode=display\">\nr_{u,i} = \\frac{1}{n} \\sum_{u' \\in U} Hsim(u,u') \\times r_{u',i} \\tag{6}</script><p>$U$表示评价项目$i$的用户$u$的邻居。用户$u$和$u’$，$(r<em>{u’,i})$越相似，将以更高的加权比率用于预测$(r</em>{u,i})$。最后，将预测评分最高的$N$个项目推荐给目标用户。</p>\n<h1 id=\"评估提出的推荐方法\"><a href=\"#评估提出的推荐方法\" class=\"headerlink\" title=\"评估提出的推荐方法\"></a>评估提出的推荐方法</h1><p>为了评估结果，将使用的数据集分为训练集和测试集。训练数据用于推荐系统，测试数据用于评估系统结果的准确性。训练数据涵盖2015年1月25日至11月16日期间，包括2015年11月16日至2016年1月21日期间交易的测试数据。</p>\n<p><img src=\"http://images.yingwai.top/picgo/dert4.png\" alt=\"\"></p>\n<center>\n    <i>表4 传统CF推荐系统与提出的CF推荐系统的评价方法比较</i>\n</center>\n\n\n\n<p>在此阶段，将比较所提出的方法与传统CF推荐系统在不同N值(推荐项目数)下以及基于使用精确度、覆盖率和F度量的测试数据的结果的准确性。</p>\n<p>基于SOM算法，基于LRFM变量的最优聚类数为6个，基于人口统计变量的最优聚类数为5个。表4列出了基于不同N值的评估措施的传统方法和提出的方法的准确性。对于所有这些方法，参数K(邻居数目)的值都等于40。</p>\n<p>根据表4的结果，在每个准则下，所提出的系统都比传统系统具有更好的性能。事实上，传统系统(基于F-Measure)在5个推荐项目上的准确率为43.27%，而在所提出的系统中，该准确率为55.59%。在20个推荐项目中，传统方法的准确率为62.43%，其推荐系统的准确率为81.4%。在30个项目中，传统系统的准确率为68.54%，在提出的系统中，准确率为96.59%，表明该系统在30个项目上的准确率比传统系统提高了约28%。</p>\n<p><img src=\"http://images.yingwai.top/picgo/derf2.png\" alt=\"\"></p>\n<center>\n    <i>图2 比较传统方法和建议方法在不同N值下的性能(颜色请参见在线版本)</i>\n</center>\n\n\n<p><img src=\"http://images.yingwai.top/picgo/derf3.png\" alt=\"\"></p>\n<center>\n    <i>图3 评估不同K值对建议方法性能的影响(有关颜色，请参阅在线版本)</i>\n</center>\n\n\n<p>在此基础上，将推荐项数增加到N=30，两种方法的性能都有所提高。然而，增加数据数量并不会导致结果准确性的显著变化和提高。因此，将推荐项目的数量增加到某个阈值可以提高建议推荐的质量；该阈值等于N=30。为了更好地比较这两种方法的性能，图2描述了F-Measure准则的变化趋势。</p>\n<p>为了评估参数K的变化在所建议的研究方法的性能中的作用，图3中描述了三个不同N值的F测量值。基于图3，对于N参数的所有三个值，将邻居数增加到K=40将提高所提出的方法的性能。但是，进一步增加该参数会降低方法的精确度，从而对推荐质量产生负面影响。</p>\n<h1 id=\"结论及建议\"><a href=\"#结论及建议\" class=\"headerlink\" title=\"结论及建议\"></a>结论及建议</h1><p>本研究从冷启动、可扩展性、稀疏用户-项目矩阵以及用户兴趣的变化等方面考虑了电子商务中RS的基本和常见限制，以期解决或缓解这些限制。因此，为了克服这些局限性，人们利用一套数据挖掘方法，提出了一个综合性的电子商务推荐系统。综合研究结果，该系统的性能优于传统的CF系统。研究的总体结果表明，与传统系统相比，新的推荐系统的准确率有了显着的提高。因此，该系统对30个项目的推荐准确率比传统系统提高了约28%。此外，根据结果，系统在推荐30个项目时的准确率达到了最高水平；因此，当推荐项目数量超过30个时，传统系统和所提出的系统的准确率都没有明显的变化，因此，当推荐项目的数量超过30时，传统系统和本文提出的系统的准确率都没有明显的变化。例如，当推荐50个项目时，传统系统的准确率为68/84，新建议系统的准确率为94/45，这表明推荐项目的数量从30个增加到50个，准确率略有下降。因此，建议推荐项目的最大值为30个，因为这可能会导致计算和项目选择的复杂性。下面简要介绍一下研究成果和研究创新之处：</p>\n<ul>\n<li>在RS的开发过程中，在产品类别层面采用基于LRFM变量的细分方法，可以改进客户间相似度的确定方法，从而更准确、更恰当地选择目标客户的邻居。由于LRFM模型是识别客户购买行为和反映其偏好的合适方法之一，因此基于该模型在产品类别层次上进行细分，可以区分客户在购买产品类别时的偏好，并将具有相似品味和兴趣的客户归入同一聚类。例如，如果两个给定客户购买商品的频率相似，则可以得出结论，这两个客户对购买该产品类别中的商品表现出相同的兴趣水平。R和M的变量可以以相同的方式推断。另一方面，在产品类别水平上的变量R考虑了客户的利益，并且由于最近的购买更能反映客户的偏好，这将导致更准确的推荐。由于用户的喜好会随着时间的推移而改变，因此RS提供与客户当前兴趣相容的项目的能力会受到影响，这有时会导致推荐与客户当前喜好完全无关的项目。此外，在用户-项目矩阵中使用该分割的结果将降低矩阵的维数，将缓解KNN算法的稀疏矩阵和可伸缩性问题，这导致KNN算法的性能提高，因为在这种情况下，目标客户仅与用户-项目矩阵中他或她自己的集群内的客户相比较。因此，通过减少矩阵中的用户数，提高了KNN算法的速度和精度，改善了RS的整体性能。根据这一讨论和研究结果，可以安全地得出结论，使用LRFM模型可以加快提供建议的过程，并允许创建符合客户当前利益的准确建议。</li>\n<li>基于product category-user矩阵的关联规则提取提高了推荐方法的性能。这些规则通过评估产品类别之间的关系，预测他们购买的概率，并向目标客户推荐一套产品类别。将user-item矩阵限制为这些推荐产品类别中的项将降低矩阵的维数，有效地缓解了KNN算法的稀疏矩阵和可伸缩性问题。在该方法中，仅从从这些规则获得的产品类别中向目标客户提供推荐项目。结果表明，该方法通过减少矩阵中的项数，提高了KNN算法的速度和精度，有效地改善了RS的整体性能，研究结果表明该方法具有较好的性能。</li>\n<li>在RS的设计过程中考虑商品的购买时间以及它们在电子商务网站上的上线时间，将会提高推荐的质量。换言之，比起过去的购买，多留意顾客最近的购买，以及比起其他商品，多留意最近在网站上推出的商品，便可以更了解顾客现时的喜好，帮助他们找到更吸引人、更合意的商品。考虑到这些问题，RS才能更好地实现他们的最终目标，即向适当的个人提供适当的物品。在本研究中，这两个变量被用来创建一个新的用户-项目矩阵，并在表4和图2的基础上取得了很好的结果。</li>\n<li>为了更好地使推荐与用户的喜好相一致，人口特征的作用是无可否认的，因为大多数个人购买都取决于他们的年龄、性别、教育水平等。当它与其他变量如购买行为变量(包括LRFM和user-item矩阵)一起考虑时，这一作用更为显著，这是本研究通过定义一个新的相似性函数得出的。</li>\n</ul>\n<p>考虑到上述问题，本研究通过关注这些问题，利用各种数据挖掘方法，试图改进和完善以往关于CF系统的研究，以期提出一个准确率和性能最高的电子商务推荐系统。</p>\n<p>以下是对未来研究的一些建议：</p>\n<ol>\n<li>将CF方法和CBF方法相结合，开发了所提出的模型。</li>\n<li>研究基于个性特征的客户细分、其他人口统计变量(如地址和收入)以及其他行为变量(如购买商品的总数)对建议系统性能的影响。</li>\n<li>将所提出的方法应用于其他行业的数据集，以提供更强的通用性。</li>\n<li>使用大数据对提出的模型进行进一步评估，这些数据可以从大型网店获得。</li>\n</ol>\n<p>与过去的大多数研究一样，这项研究在实施和评估方面存在一些局限性，包括：</p>\n<ol>\n<li>使用的数据集的时间段限制为一年；</li>\n<li>研究数据仅限于一家网上服装店；</li>\n<li>正在研究的商店顾客数量有限。</li>\n</ol>\n","site":{"data":{}},"excerpt":"<p><em>Samira Khodabandehlou</em></p>\n<p><a href=\"https://scholar.google.com/scholar?hl=zh-CN&amp;as_sdt=0%2C5&amp;q=Designing+an+e-commerce+recommender+system+based+on+collaborative+filtering+using+a+data+mining+approach&amp;btnG=\" target=\"_blank\" rel=\"noopener\">https://scholar.google.com/scholar?hl=zh-CN&amp;as_sdt=0%2C5&amp;q=Designing+an+e-commerce+recommender+system+based+on+collaborative+filtering+using+a+data+mining+approach&amp;btnG=</a></p>","more":"<p><img src=\"http://images.yingwai.top/picgo/Designing an e-commerce recommender system based on collaborative filtering using a data mining approach.jpg\" alt=\"\"></p>\n<h1 id=\"摘要\"><a href=\"#摘要\" class=\"headerlink\" title=\"摘要\"></a>摘要</h1><p>电子商务推荐系统已经转变为客户非常重要的决策辅助工具，利用信息技术和客户信息提供在线个性化推荐。同时，协同过滤推荐系统是电子商务系统成功的关键组成部分之一。尽管有协同过滤现在的普及和成功，这些系统仍然面临着一系列严重的限制，包括冷启动、user-item矩阵稀疏、可扩展性和用户兴趣在这段时间内的变化，这些都阻碍了对客户的准确推荐。虽然已有很多研究提出了克服这些局限性的方法，但还没有提供一个全面的模型来降低这些局限性：1)在产品类别层面上基于LRFM变量进行客户细分，以评估与公司的客户关系的长度、最近程度、频率和购买产品类别的金额；2)在每个聚类级别上基于用户-类别矩阵提取关联规则；3)根据人口统计变量进行客户细分；4)改变用户-项目矩阵并降低其维数；5)通过将细分方法的结果与CF加权组合来开发新的相似度函数。根据所获得的结果，本研究提出的系统消除了传统的CF约束，为客户的偏好提供了更准确、更合适的建议。</p>\n<p><strong>关键词：</strong>协同过滤；数据挖掘；电子商务；推荐系统；时态信息。</p>\n<p>本研究的主要目标包括：找出传统协同过滤在向合适的用户推荐合适商品方面的局限性，提出一个全面的、全新的推荐系统来消除传统CF的局限性，用真实的数据对推荐系统进行评估，以提供更准确、更符合顾客口味的推荐。</p>\n<h1 id=\"理论背景\"><a href=\"#理论背景\" class=\"headerlink\" title=\"理论背景\"></a>理论背景</h1><h2 id=\"推荐系统\"><a href=\"#推荐系统\" class=\"headerlink\" title=\"推荐系统\"></a>推荐系统</h2><p><strong>推荐系统</strong>是提高电子商务环境中决策过程质量的有用工具，因为它们通过提供必要的信息和有用的建议来帮助在线决策者选择与他们的愿望和要求一致的项目(Shambour and Lu，2015；Son，2016)。事实上，识别用户偏好的能力是个性化RS的核心(Kim等人，2011年)。Ricci等人。(2011)将RS定义为特定类型的信息系统，该信息系统：</p>\n<ol>\n<li>帮助客户选择他们没有亲身体验的项目；</li>\n<li>向顾客推荐商品；</li>\n<li>通过为客户提供信息来帮助他们决定购买哪种商品。</li>\n</ol>\n<p>创建推荐系统有五个阶段：收集数据、分析用户信息、计算相似度、选择邻居、预测并提出前N个项目的列表(Yahya和Al-Shamri，2016)。这些系统出现在20世纪90年代中期，通常分为三类(Lee，2010；Resnick，1994)：</p>\n<ol>\n<li><p><strong>协同过滤</strong>：这些系统根据一组被称为邻居的相似用户或相似项目的得分提供推荐(Kim等人，2005年)。CF是Netflix和Amazon等著名电子商务公司使用的最受欢迎的RS之一(Hernando等人，2016；Kim等人，2005年)。这些系统又根据它们用于预测用户偏好的算法类型分为两类(Ghazarian和Nematbakhsh，2014)：</p>\n<ul>\n<li><strong>Memory-based</strong>：这些系统使用用户项目评分矩阵和KNN算法来识别用户的邻居并预测他们的偏好(Ghazarian和Nematbakhsh，2014年；Hernando等人，2016年；Kim等人，2011年)，其中使用皮尔逊相关系数等方法计算用户之间的相似性(Bobadilla等人，2012年)。在本研究中，使用KNN算法和皮尔逊相关系数来提供建议。</li>\n<li><strong>Model-based</strong>：这些系统使用分段等方法处理用户的档案数据以提供建议，从而改进计算(Ghazarian和Nematbakhsh，2014；Hernando等人，2016)。</li>\n</ul>\n<p>尽管CF方法很受欢迎并取得了成功，但它们仍然面临着一些严重的限制。这些限制包括：</p>\n<ul>\n<li><strong>冷启动</strong>：在多个用户购买某个项目之前，系统不能向某人推荐该项目。这个问题被称为冷启动。用户的冷启动是指最近加入推荐系统并且没有关于他或她的足够信息的用户(Elahi等人，2016；Hu和Pu，2011；Kim等人，2011；Lee，2010；Son，2016；Sharma和Ray，2016)。</li>\n<li><strong>可伸缩性</strong>：由于客户数据和产品数据的绝对数量，系统必须花费大量的金钱和时间来提取所有客户之间的相似性，导致其生产率较低(Hu和Pu，2011；Hernando等人，2016；Keramati和Khaleghi，2014；Lee，2010)。</li>\n<li><strong>user-item矩阵的稀疏性</strong>：由于用户数量巨大，一个项目通常没有足够的分数或购买，导致user-item矩阵稀疏(Adomavicius和Tuzhlin，2005；Ghazarian和Nematbakhsh，2014；Karimi Alavije等人，2015，Sharma和Ray，2016)。</li>\n<li><strong>用户偏好的改变</strong>：用户的品味和偏好可能会随着时间的推移而改变。例如，一位最近生了孩子的母亲可能对购买婴儿服装感兴趣，她最近的购买可能反映了这种新的关注。这是当；她可能从来没有对这样的物品有任何兴趣(Ding等人，2006年；岩田，2008年；Lee等人，2008年)。(Ding et al.，2006；Iwata，2008；Lee et al.，2008)。</li>\n</ul>\n<p>上述限制可能会对RS的性能产生负面影响，从而限制系统创建有意义和准确的推荐。</p>\n</li>\n<li><p><strong>基于内容的过滤器(Content-Based Filter，CBF)</strong>：该方法基于这样的概念，即用户对他们以前感兴趣的项目感兴趣。因此，这些系统根据项目和产品之间的相似性提供建议(Anderson和Hiralall，2009年；Elahi等人，2016年)。因此，这种方法取决于物品的规格和与这些规格相关的用户配置文件的可用性(Anderson and Hiralall，2009)。这是因为在互联网上存储大量不同种类电子产品的目录是一项非常困难的任务(Bobadilla等人，2012年)。因此，音乐或视频文件等一些产品的内容分析非常困难；这个问题使得CF比CBF要好得多(Anderson和Hiralall，2009；Kim等人，2011)。与CBF相比，CF在电子商务中具有更高的灵活性和与RS的兼容性，使其成为最常用和最有用的RS系统之一(Burke，2002；Iwata，2008；Wang and Wu，2012)。因此，在本研究中，使用CF的概念作为主要的推荐机制。</p>\n</li>\n<li><p>混合方法：一些RS使用上述系统的组合来减少它们的限制；更多细节将在下面的实验背景部分提供(Burke，2002；Keramati和Khaleghi，2014)。</p>\n</li>\n</ol>\n<h2 id=\"客户细分\"><a href=\"#客户细分\" class=\"headerlink\" title=\"客户细分\"></a>客户细分</h2><p>客户细分是一种非常有用的数据挖掘方法，用于在电子商务的RS中找到“邻居”，在电子商务中，使用特定的方法，如聚类，来选择一些用户作为邻居，以改进偏好的预测(Khodabandehlou和Niknafs，2016；Li等人，2011年)。</p>\n<p>在RS中，选择合适的属性进行分割是影响系统性能的重要因素之一。最近购买、频率和货币模型(RFM)的属性是基于分析客户购买行为的一种很好的客户细分方法，它已经成功地用于许多RS(Keramati和Khaleghi，2014；Khodabandehlou和Zivari Rahman，2017；Lee，2010)。各种研究表明，在RFM模型中加入L(客户关系长度)指标将导致对客户的更准确分析，并将提高细分的质量(Li等人，2011年)。因此，在本研究中，LRFM模型被用于客户细分和识别具有相似购买行为的客户类别。</p>\n<p>此外，分割算法对识别出的片段的质量起着重要的作用。在聚类算法中，K-Means算法被认为是最成功和最合适的分割方法(Khodabandehlou和Niknafs，2016)，在许多研究中证明了它与RS的兼容性(Keramati和Khaleghi，2014；Karimi Alavije等人，2015；Li等人，2011年)。K-Means是一种数据挖掘方法，它需要K的初始值，即聚类的数量，才能运行。确定最佳簇数的合适方法是自组织映射(SOM)算法。该算法是一种无监督神经网络，可以从数据中识别未知模式，并估计合适的聚类数量(Abidi和Ong，2000；Mosayebian等人，2012)。</p>\n<p>相关研究建议在RS中结合K-Means和SOM算法使用两阶段分割方法，以获得更准确的结果(Keramati和Khaleghi，2014；Mosayebian等人，2012年)。因此，本研究将利用这一模式进行客户细分。</p>\n<h2 id=\"关联规则\"><a href=\"#关联规则\" class=\"headerlink\" title=\"关联规则\"></a>关联规则</h2><p>关联规则是数据挖掘的重要方法之一，用于分析RS大型数据库中各种商品之间的市场篮子。分析购物篮已经成为发现用户购物车之间关系的流行系统(Hsu等人，2004；Liu and Shih，2005a)。Apriori算法是最常见的关联规则之一(Hsu等人，2004；Liu和Shih，2005a，2005b)，用于在已经购买了另一件物品时找到购买特定物品的概率模式。在RS中，已经形成了许多关于不同用户的购买行为的规则(Keramati和Khaleghi，2014；Liu和Shih，2005a，2005b)。在这些规则吸引程度的衡量标准中，我们可以提到支持性规则和置信度规则，它们分别指发现的规则的传播度和可接受性(Hsu等人，2004；Keramati和Khaleghi，2014；Karimi Alavije等人，2015；Liu和Shih，2005a，2005b)。</p>\n<h1 id=\"评估措施\"><a href=\"#评估措施\" class=\"headerlink\" title=\"评估措施\"></a>评估措施</h1><p>评价推荐系统的性能是保证推荐系统通用性的重要一步。有一些评价RSS准确性或性能的众所周知的度量；诸如精确度、覆盖率和F度量(为了在这两个度量之间创建平衡)，它们可以很好地显示推荐系统的性能(Bobadilla等人，2012年；Elahi等人，2016；Ghazarian和Nematbakhsh，2014；Shambour和Lu，2015；Son，2016)。因此，为了评估所提出的研究模型的性能，采用了这些测量方法。</p>\n<p>在公式(1)和(2)中，喜爱的项目是指必须推荐给用户的一组产品或项目，而推荐的项目是已经由系统推荐给用户的项目的集合。精确度表示推荐集合中正确推荐的百分比，并评估这些推荐的精确度和准确性。通过公式(1)计算：</p>\n<script type=\"math/tex; mode=display\">\n{\\rm Precision}=\\frac{\\rm Recommended \\ Items\\cap Favorite \\  Items}{\\rm Recommended \\  Items} \\tag{1}</script><p>覆盖率表示已经向用户建议了多少用户喜欢的项目的百分比，并使用公式(2)计算：</p>\n<script type=\"math/tex; mode=display\">\n{\\rm Coverage}=\\frac{\\rm Recommended \\ Items\\cap Favorite \\  Items}{\\rm Favorite \\  Items} \\tag{2}</script><p>F-MEASURE是精度和覆盖范围的调和平均值，使用公式(3)计算：</p>\n<script type=\"math/tex; mode=display\">\n{\\rm F - measure}=\\frac{2 \\times \\rm Coverage \\cap Precision}{\\rm Coverage + Precision} \\tag{3}</script><h1 id=\"研究框架\"><a href=\"#研究框架\" class=\"headerlink\" title=\"研究框架\"></a>研究框架</h1><p>在设计和开发RSS时，真实、高质量的数据是非常重要的。本研究使用的这组数据与伊朗一家销售服装的网站的真实数据相关，时间范围为2015年1月21日至2016年1月21日(12个月)。此数据集涉及2542个客户和17,000条记录。在这家商店里，产品分为女装、男装、童装、女装、男装、女包和鞋、男包和鞋等七大类。据此，本研究提出的系统框架由八个主要阶段组成。在第一阶段，准备数据。该阶段由数据清理、数据整合、数据转换三个子阶段组成。在第二阶段，基于LRFM模型进行客户细分。在阶段3，基于product category-user矩阵提取关联规则。在阶段4中，完成user-item矩阵的改变。阶段5显示了基于CF的相似度计算。在阶段6中，根据人口统计特征对客户进行细分。在阶段7中，基于新的相似性函数来确定邻居。在最后阶段，推荐是根据用户的需求和特点量身定做的。在下文中，我们将对所有这些阶段进行详细说明。建议系统的总体框架如图1所示。</p>\n<p><img src=\"http://images.yingwai.top/picgo/derf1.png\" alt=\"\"></p>\n<center>\n    <i>图1 建议的研究系统的总体架构</i>\n</center>\n\n\n<h2 id=\"数据准备\"><a href=\"#数据准备\" class=\"headerlink\" title=\"数据准备\"></a>数据准备</h2><p>数据准备(也称为数据预处理)是RSS开发过程中不可或缺的一步，占整个RSS开发所需时间的60%-70%。此步骤包括数据清理、数据集成和数据转换三个阶段。</p>\n<h3 id=\"数据清理\"><a href=\"#数据清理\" class=\"headerlink\" title=\"数据清理\"></a>数据清理</h3><p>数据清理过程包括完成缺失值、识别和消除离群值数据以及解决数据之间的冲突。此外，在此阶段，必须删除不相关或无用的字段或属性，如有必要，从初始数据集形成新的变量。在此阶段，将不完美的记录和信息不完整的客户从主数据集中剔除，数据集的记录从17,000条减少到15,386条，客户数量从2,542个减少到2,080个。为每个产品类别计算RFM变量。</p>\n<h3 id=\"数据集成\"><a href=\"#数据集成\" class=\"headerlink\" title=\"数据集成\"></a>数据集成</h3><p>为了更好地理解数据，并对每个数据集中的数据进行更好的科学管理，数据集成(将两个或多个数据集合并集成在一起)是必要的，这是数据准备的第二阶段。在这一阶段，客户交易数据与他们的个人资料数据(年龄、性别、教育程度、婚姻状况和职业)集成在一起。</p>\n<h3 id=\"数据转换\"><a href=\"#数据转换\" class=\"headerlink\" title=\"数据转换\"></a>数据转换</h3><p>在此阶段，必须将数据转换为适合数据挖掘和设计RS的不同形式。数据集中的字符串变量(如性别)将转换为数值变量和值。</p>\n<h2 id=\"基于LRFM模型的分割\"><a href=\"#基于LRFM模型的分割\" class=\"headerlink\" title=\"基于LRFM模型的分割\"></a>基于LRFM模型的分割</h2><p>本研究采用两阶段聚类法，结合SOM(确定最佳聚类数)和K-Means(创建聚类)方法进行分割。</p>\n<p>在此阶段，根据产品类别的RFM变量(每个产品类别的RFM变量的值分别计算)和L变量(客户关系的长度)进行客户细分。对于给定的客户，表1中给出了这些变量的样本，根据这些变量进行了细分。</p>\n<p>在本研究中，将LRFM模型用于产品类别层面的客户细分有三个原因，包括以下几个方面：</p>\n<ol>\n<li>通过减少user-item矩阵中的客户数量，提高了该方法的生产率和效率，从而降低了矩阵的可扩展性和稀疏性问题。</li>\n<li>这个模型不仅决定了顾客的价值，而且可以清楚地反映顾客的兴趣和偏好，例如，如果某一种产品的购买频率对于两个给定的顾客来说是相似的，可以推断这两个人对购买这两种商品的兴趣是一样的。M和R的变量也是以相同的方式推导出来的。</li>\n<li>模型中的产品类别变量R涉及客户最近的品味和偏好，由于最近的购买更能反映客户当前的兴趣和偏好，它将提供更准确的推荐，更符合客户当前的兴趣。</li>\n</ol>\n<p><img src=\"http://images.yingwai.top/picgo/dert1.png\" alt=\"\"></p>\n<center>\n    <i>表1 基于LRFM模型的客户细分属性</i>\n</center>\n\n\n\n<h2 id=\"基于product-category-user矩阵的关联规则提取\"><a href=\"#基于product-category-user矩阵的关联规则提取\" class=\"headerlink\" title=\"基于product category-user矩阵的关联规则提取\"></a>基于product category-user矩阵的关联规则提取</h2><p>为了提取关联规则，本研究使用了Apriori算法。在此阶段，使用product category-user矩阵(客户从单个产品类别购买的次数)的交易数据在前一阶段的每个聚类的级别提取关联规则。提取的规则用于确定每个目标客户的前N个推荐产品类别的列表。推荐的每个产品类别的优先级取决于其规则的可信度和支持措施。信任度和支持度值越大的产品类别，推荐优先级越高。此阶段中提取的规则的输出(即每个目标客户的预测产品类别)将作为下一阶段的输入。产品类别级规则提取的目的是减少user-item矩阵中的产品数量，有效缓解矩阵的可扩展性和稀疏性问题。</p>\n<h2 id=\"更改user-item矩阵\"><a href=\"#更改user-item矩阵\" class=\"headerlink\" title=\"更改user-item矩阵\"></a>更改user-item矩阵</h2><p>在CF系统中，user-item矩阵(包括购买/不购买项目的二进制数据或用户给予项目的分数)是关于购买偏好对客户进行聚类并确定目标客户的邻居的基础。然而，由于电子商务中商品种类繁多，该矩阵经常面临数据稀疏的问题。研究表明，推荐质量取决于user-item矩阵的密度。</p>\n<p>为了使该矩阵更加密集，以这样的方式使用分段和关联规则阶段的结果，即在用于确定目标客户的邻居的user-item矩阵中，他或她将仅与他或她的集群中的用户进行比较，并且项目将限于为目标客户预测的项目。由于减少了用户数和项目数，缓解了可伸缩性问题，提高了RS的速度和准确性。</p>\n<p>在他们的研究中，Lee等人。(2008)证明，最近进行的购买更能反映用户当前的偏好，最近添加到网站上出售的项目对用户更具吸引力。因此，基于表2，对于每个项目，考虑用户购买项目的时间(PT)和项目已经可供购买的时间(LT)(启动时间)的两个参数，并且改变user-item矩阵。</p>\n<p><img src=\"http://images.yingwai.top/picgo/dert2.png\" alt=\"\"></p>\n<center>\n    <i>表2 基于时间信息更改user-item矩阵</i>\n</center>\n\n\n\n\n\n<p>为了确定PT和LT变量的得分，在这个改变的矩阵中，首先根据这两个参数的潜伏期将这两个参数分为五类。因此，PT参数的分数包括过去购买(分数1)、过去购买(分数2)、最近购买(分数3)、最近购买(分数4)和最近购买(分数5)。对于LT参数，得分类似。根据表3，在user-item矩阵中，对于用户给出的分数，使用组合分数。例如，对于(2，5)的组合，分数将等于7(5+2)。在计算混合得分时，这两个参数的权重都是相同的。</p>\n<p><img src=\"http://images.yingwai.top/picgo/dert3.png\" alt=\"\"></p>\n<center>\n    <i>表3 对LT和PT参数进行评分</i>\n</center>\n\n\n<p>因此，创建了25(5×5)个双重组合，其中所有客户由55、54、53、…的组合表示。，11，其中，客户最好的类别是组合55(最近购买时间和最近上线时间的类别)和得分10，而客户最差的类别用11(最老的购买时间和最老的上线时间)表示，得分为2。根据这种评分方法，可以将客户划分为集群，并计算其相似度。创建这个新的user-item矩阵的目的是考虑用户随时间的喜好，从而提高推荐的准确性。</p>\n<h2 id=\"基于CF的相似度计算\"><a href=\"#基于CF的相似度计算\" class=\"headerlink\" title=\"基于CF的相似度计算\"></a>基于CF的相似度计算</h2><p>在CF系统中，计算每个目标客户与其他客户之间的相似度的方法有很多。最流行的方法之一是使用皮尔逊相关系数，与其他传统的统计方法相比，它提供了最好的预测和推荐结果(Bobadilla等人)。(2012年)。在皮尔逊的相关方法中，使用公式(4)测量两个给定客户$u$和$u’$之间的相似性：</p>\n<script type=\"math/tex; mode=display\">\nSim(u, u') = \\frac{\\sum^n_{i=1}(r_{ui}-\\bar{r}_u)(r_{u'i}-\\bar{r}_{u'})}{\\sqrt{\\sum^n_{i=1}(r_{ui}-\\bar{r}_u)^2\\sum^n_{i=1}(r_{u'i}-\\bar{r}_{u'})^2}} \\tag{4}</script><p>在这个等式中，$n$是两个用户得分的项目数，$i$是两个用户得分的项目集合，$r_{ui}$是用户$u$给出的项目$i$的得分，$\\bar{r}_u$是用户的平均得分。在本研究中，使用基于新的user-item矩阵的Pearson相关方法，计算客户偏好之间的相似度，然后将该阶段的结果(基于CF的相似度)用于预测客户的偏好。</p>\n<h2 id=\"基于人口统计属性的细分\"><a href=\"#基于人口统计属性的细分\" class=\"headerlink\" title=\"基于人口统计属性的细分\"></a>基于人口统计属性的细分</h2><p>在这个阶段，使用两阶段聚类方法，根据年龄、性别、教育程度、婚姻状况和职业等人口统计变量对客户进行细分，然后计算他们的簇内相似度。因此，如果两个客户具有相似的人口统计属性，他们对某些项目的态度会相似，这在CF方法中没有反映出来。在本研究中，基于这些变量进行客户细分的目的是为了更好地选择新用户的邻居，通过克服冷启动问题有效改善推荐过程。</p>\n<h2 id=\"基于新的相似度函数确定邻域\"><a href=\"#基于新的相似度函数确定邻域\" class=\"headerlink\" title=\"基于新的相似度函数确定邻域\"></a>基于新的相似度函数确定邻域</h2><p>在此阶段，将前一阶段得到的聚类相似度(基于人口统计属性)和CF相似度合并到一个新的相似度函数中，以缓解冷启动问题。因为在用户最近加入系统的情况下，新的相似性函数并不完全依赖于user-item矩阵。通过该函数可以得到相似度。相似度函数(Hsim)通过簇内相似度(ClusSim)和基于CF的相似度(Sim)的加权和计算如下(5)：</p>\n<script type=\"math/tex; mode=display\">\nHsim(u,u')=(1-\\alpha) \\times Sim(u,u') + \\alpha \\times clusSim(u,u') \\tag{5}</script><p>在利用上述公式计算客户之间的相似度后，选择与目标客户相似度最高的K个客户作为该客户的邻居。</p>\n<h2 id=\"提供推荐\"><a href=\"#提供推荐\" class=\"headerlink\" title=\"提供推荐\"></a>提供推荐</h2><p>在识别前一阶段目标客户的邻居后，通过计算这些邻居给出的得分的加权平均，预测目标客户的偏好。基于公式(6)，利用邻居得分的加权平均值$(r<em>{u’,i})$，预测用户$u$对于项目$i$，$(r</em>{u,i})$的得分如下：</p>\n<script type=\"math/tex; mode=display\">\nr_{u,i} = \\frac{1}{n} \\sum_{u' \\in U} Hsim(u,u') \\times r_{u',i} \\tag{6}</script><p>$U$表示评价项目$i$的用户$u$的邻居。用户$u$和$u’$，$(r<em>{u’,i})$越相似，将以更高的加权比率用于预测$(r</em>{u,i})$。最后，将预测评分最高的$N$个项目推荐给目标用户。</p>\n<h1 id=\"评估提出的推荐方法\"><a href=\"#评估提出的推荐方法\" class=\"headerlink\" title=\"评估提出的推荐方法\"></a>评估提出的推荐方法</h1><p>为了评估结果，将使用的数据集分为训练集和测试集。训练数据用于推荐系统，测试数据用于评估系统结果的准确性。训练数据涵盖2015年1月25日至11月16日期间，包括2015年11月16日至2016年1月21日期间交易的测试数据。</p>\n<p><img src=\"http://images.yingwai.top/picgo/dert4.png\" alt=\"\"></p>\n<center>\n    <i>表4 传统CF推荐系统与提出的CF推荐系统的评价方法比较</i>\n</center>\n\n\n\n<p>在此阶段，将比较所提出的方法与传统CF推荐系统在不同N值(推荐项目数)下以及基于使用精确度、覆盖率和F度量的测试数据的结果的准确性。</p>\n<p>基于SOM算法，基于LRFM变量的最优聚类数为6个，基于人口统计变量的最优聚类数为5个。表4列出了基于不同N值的评估措施的传统方法和提出的方法的准确性。对于所有这些方法，参数K(邻居数目)的值都等于40。</p>\n<p>根据表4的结果，在每个准则下，所提出的系统都比传统系统具有更好的性能。事实上，传统系统(基于F-Measure)在5个推荐项目上的准确率为43.27%，而在所提出的系统中，该准确率为55.59%。在20个推荐项目中，传统方法的准确率为62.43%，其推荐系统的准确率为81.4%。在30个项目中，传统系统的准确率为68.54%，在提出的系统中，准确率为96.59%，表明该系统在30个项目上的准确率比传统系统提高了约28%。</p>\n<p><img src=\"http://images.yingwai.top/picgo/derf2.png\" alt=\"\"></p>\n<center>\n    <i>图2 比较传统方法和建议方法在不同N值下的性能(颜色请参见在线版本)</i>\n</center>\n\n\n<p><img src=\"http://images.yingwai.top/picgo/derf3.png\" alt=\"\"></p>\n<center>\n    <i>图3 评估不同K值对建议方法性能的影响(有关颜色，请参阅在线版本)</i>\n</center>\n\n\n<p>在此基础上，将推荐项数增加到N=30，两种方法的性能都有所提高。然而，增加数据数量并不会导致结果准确性的显著变化和提高。因此，将推荐项目的数量增加到某个阈值可以提高建议推荐的质量；该阈值等于N=30。为了更好地比较这两种方法的性能，图2描述了F-Measure准则的变化趋势。</p>\n<p>为了评估参数K的变化在所建议的研究方法的性能中的作用，图3中描述了三个不同N值的F测量值。基于图3，对于N参数的所有三个值，将邻居数增加到K=40将提高所提出的方法的性能。但是，进一步增加该参数会降低方法的精确度，从而对推荐质量产生负面影响。</p>\n<h1 id=\"结论及建议\"><a href=\"#结论及建议\" class=\"headerlink\" title=\"结论及建议\"></a>结论及建议</h1><p>本研究从冷启动、可扩展性、稀疏用户-项目矩阵以及用户兴趣的变化等方面考虑了电子商务中RS的基本和常见限制，以期解决或缓解这些限制。因此，为了克服这些局限性，人们利用一套数据挖掘方法，提出了一个综合性的电子商务推荐系统。综合研究结果，该系统的性能优于传统的CF系统。研究的总体结果表明，与传统系统相比，新的推荐系统的准确率有了显着的提高。因此，该系统对30个项目的推荐准确率比传统系统提高了约28%。此外，根据结果，系统在推荐30个项目时的准确率达到了最高水平；因此，当推荐项目数量超过30个时，传统系统和所提出的系统的准确率都没有明显的变化，因此，当推荐项目的数量超过30时，传统系统和本文提出的系统的准确率都没有明显的变化。例如，当推荐50个项目时，传统系统的准确率为68/84，新建议系统的准确率为94/45，这表明推荐项目的数量从30个增加到50个，准确率略有下降。因此，建议推荐项目的最大值为30个，因为这可能会导致计算和项目选择的复杂性。下面简要介绍一下研究成果和研究创新之处：</p>\n<ul>\n<li>在RS的开发过程中，在产品类别层面采用基于LRFM变量的细分方法，可以改进客户间相似度的确定方法，从而更准确、更恰当地选择目标客户的邻居。由于LRFM模型是识别客户购买行为和反映其偏好的合适方法之一，因此基于该模型在产品类别层次上进行细分，可以区分客户在购买产品类别时的偏好，并将具有相似品味和兴趣的客户归入同一聚类。例如，如果两个给定客户购买商品的频率相似，则可以得出结论，这两个客户对购买该产品类别中的商品表现出相同的兴趣水平。R和M的变量可以以相同的方式推断。另一方面，在产品类别水平上的变量R考虑了客户的利益，并且由于最近的购买更能反映客户的偏好，这将导致更准确的推荐。由于用户的喜好会随着时间的推移而改变，因此RS提供与客户当前兴趣相容的项目的能力会受到影响，这有时会导致推荐与客户当前喜好完全无关的项目。此外，在用户-项目矩阵中使用该分割的结果将降低矩阵的维数，将缓解KNN算法的稀疏矩阵和可伸缩性问题，这导致KNN算法的性能提高，因为在这种情况下，目标客户仅与用户-项目矩阵中他或她自己的集群内的客户相比较。因此，通过减少矩阵中的用户数，提高了KNN算法的速度和精度，改善了RS的整体性能。根据这一讨论和研究结果，可以安全地得出结论，使用LRFM模型可以加快提供建议的过程，并允许创建符合客户当前利益的准确建议。</li>\n<li>基于product category-user矩阵的关联规则提取提高了推荐方法的性能。这些规则通过评估产品类别之间的关系，预测他们购买的概率，并向目标客户推荐一套产品类别。将user-item矩阵限制为这些推荐产品类别中的项将降低矩阵的维数，有效地缓解了KNN算法的稀疏矩阵和可伸缩性问题。在该方法中，仅从从这些规则获得的产品类别中向目标客户提供推荐项目。结果表明，该方法通过减少矩阵中的项数，提高了KNN算法的速度和精度，有效地改善了RS的整体性能，研究结果表明该方法具有较好的性能。</li>\n<li>在RS的设计过程中考虑商品的购买时间以及它们在电子商务网站上的上线时间，将会提高推荐的质量。换言之，比起过去的购买，多留意顾客最近的购买，以及比起其他商品，多留意最近在网站上推出的商品，便可以更了解顾客现时的喜好，帮助他们找到更吸引人、更合意的商品。考虑到这些问题，RS才能更好地实现他们的最终目标，即向适当的个人提供适当的物品。在本研究中，这两个变量被用来创建一个新的用户-项目矩阵，并在表4和图2的基础上取得了很好的结果。</li>\n<li>为了更好地使推荐与用户的喜好相一致，人口特征的作用是无可否认的，因为大多数个人购买都取决于他们的年龄、性别、教育水平等。当它与其他变量如购买行为变量(包括LRFM和user-item矩阵)一起考虑时，这一作用更为显著，这是本研究通过定义一个新的相似性函数得出的。</li>\n</ul>\n<p>考虑到上述问题，本研究通过关注这些问题，利用各种数据挖掘方法，试图改进和完善以往关于CF系统的研究，以期提出一个准确率和性能最高的电子商务推荐系统。</p>\n<p>以下是对未来研究的一些建议：</p>\n<ol>\n<li>将CF方法和CBF方法相结合，开发了所提出的模型。</li>\n<li>研究基于个性特征的客户细分、其他人口统计变量(如地址和收入)以及其他行为变量(如购买商品的总数)对建议系统性能的影响。</li>\n<li>将所提出的方法应用于其他行业的数据集，以提供更强的通用性。</li>\n<li>使用大数据对提出的模型进行进一步评估，这些数据可以从大型网店获得。</li>\n</ol>\n<p>与过去的大多数研究一样，这项研究在实施和评估方面存在一些局限性，包括：</p>\n<ol>\n<li>使用的数据集的时间段限制为一年；</li>\n<li>研究数据仅限于一家网上服装店；</li>\n<li>正在研究的商店顾客数量有限。</li>\n</ol>"},{"title":"论文笔记 ABY3: A Mixed Protocol Framework for Machine Learning","date":"2020-06-18T12:06:46.000Z","_content":"\n*Payman Mohassel, Peter Rindal*\n\nCCS 2018\n\nhttps://dl.acm.org/doi/10.1145/3243734.3243760\n\n<!--more-->\n\n![](http://images.yingwai.top/picgo/ABY3.png)\n\n# 本文贡献\n\n* 新的共享十进制数近似定点乘法协议；\n* 提出了三方的ABY框架，其中许多转换都是基于新技术，并在本文中首次进行了设计和优化；\n* 提高了矩阵乘法的效率；\n* 有效的分段多项式函数评估。\n\n\n\n# 计算模型\n\n本文采用三方的重复共享，即把一个数 $x$ 拆成三份，各方都拥有三份中的两份，下面是ABY三种共享形式：\n\n![](http://images.yingwai.top/picgo/aby3ppt4.png)\n\n在这种设置下，三方交互式地计算函数 $f(x)$，本篇文章主要针对机器学习中的算法。\n\n![](http://images.yingwai.top/picgo/aby3ppt2.png)\n\n\n\n## 加法\n\n在秘密共享的情况下，计算两个数 $[\\![x]\\!], [\\![y]\\!]$ 的和 $[\\![z]\\!] = [\\![x]\\!] + [\\![y]\\!]$ 比较简单，各方直接将其对应的份额在本地相加即可，不需要交互：\n$$\nz_i = x_i + y_i\n$$\n\n\n## 乘法\n\n计算两个数 $[\\![x]\\!], [\\![y]\\!]$ 的积 $[\\![z]\\!] = [\\![x]\\!] * [\\![y]\\!]$ 则复杂一点。在两方共享的情况下，需要借助额外的乘法三元组来计算，开销非常大。而三方下的复制共享这时候就起作用了，将 $xy$ 展开可以观察到有九项，每一项是两个份额的乘积，因此每一方只需要计算其可以计算的九项中的其中三项即可保持结果 $z$ 继续在三方中是加法共享的。计算完成后再把对应的结果发送给另一方，即可保持 $z$ 是重复共享的。\n\n![](http://images.yingwai.top/picgo/aby3ppt3.png)\n\n可以看到乘法操作只包含了本地操作和各方各一次发送，开销比两方的情况下小很多。\n\n\n\n# 本文的框架\n\n## 定点运算\n\n定点值定义为使用二进制补码表示的一个 $k$ 位整数，其中底部 $d$ 位表示小数，即对于正值，位 $i$ 表示 $2$ 的 $(i−d)$ 次方。由于预计结果将保持在 $2^k$ 以下，因此可以使用相应的整数运算来执行加法和减法。乘法也可以以相同的方式执行，但是十进制位的数量加倍，因此必须除以 $2^d$ 以保持 $d$ 个十进制位不变。\n\n在得到乘法结果后，各方可以直接把本地的份额后 $d$ 位截断，但这样会**把原本份额相加的进位也截断了**，导致截断后重构出来的 $\\tilde{x} \\neq x$。作者参考了[SecureML](https://yuyingwai.cn/2020/06/17/论文笔记-SecureML-A-System-for-Scalable-Privacy-Preserving-Machine-Learning/)中的两方协议，给出了他们自己的在三方下的实现：\n\n![](http://images.yingwai.top/picgo/aby3f1.png)\n\n一开始作者的想法是把 $x'$ 的截断 $x = x'/2^d$ 拆成 $[\\![x]\\!] := (x_1, x_2, x_3) = (x'_1/2^d, (x'_2 + x'_3)/2^d-r, r)$，其中 $r$ 是 $\\mathbb{Z}^k_2$ 中的随机数，但发现这样做有两轮通信的限制，于是进一步优化得到上面的协议。\n\n\n\n## 矢量化乘法\n\n两个向量作内积定义为 $\\vec{x} \\cdot \\vec{y} := \\sum^n_{i=1} x_i y_i$。在本文的背景下计算内积，朴素的做法是对两个向量的每一个元素都执行一次乘法+截断协议，但这样需要通信 $O(n)$ 次通信。\n\n于是作者进行了优化：各方只需要在本地将两个向量 $\\vec{x},\\vec{y}$ 的 $n$ 个分量计算相乘的份额，然后把这 $n$ 个积相加就得到了 $z'$ 的3/3共享，最后执行上一小节中的截断协议将 $[\\![z']\\!]$ 截断为 $[\\![z]\\!]:= (z'+r')/2^d - [\\![r]\\!]$。\n\n这样做不仅可以减少通信开销，而且误差也比执行 $n$ 次乘法+截断协议低（总共只进行了一次截断，相对于整体内积的误差为 $2^{-d}$）。\n\n\n\n## 共享转换\n\n机器学习中有很多不同的函数，而不同的函数有适合其计算的不同共享方式：算术共享适合计算乘法和加法，而二进制共享适合计算非线性函数、最大池化以及平均值等。两方的情况可以参考[ABY](https://yuyingwai.cn/2020/06/11/论文笔记-ABY-A-Framework-for-Efficient-Mixed-Protocol-Secure-Two-Party-Computation/)，本文给出了三方下的共享转换。\n\n![](http://images.yingwai.top/picgo/aby3ppt6.png)\n\n\n\n### 位分解\n\n$[\\![x]\\!]^A \\rightarrow [\\![\\vec{x}]\\!]^B$\n\n最基础的想法是各方将其份额 $[\\![x]\\!]^A = (x_1, x_2, x_3)$ 输入到布尔电路中计算它们的和，但可以进行优化。观察到 $[\\![x]\\!]^A = (x_1, x_2, x_3)$ 可以转换为 $[\\![x_1]\\!]^B := (x_1,0,0), [\\![x_2]\\!]^B := (0,x_2,0), [\\![x_3]\\!]^B := (0,0,x_3)$ 而不需要交互。\n\n这里没太看懂，用到了各种加法器。作者首先观察到 $x_1 + x_2 + x_3$ 的计算可以减少成执行 $k$ 个相互独立的全加器计算 $2c+s$：$\\mathsf{FA}(x_1[i], x_2[i], x_3[i-1]) \\rightarrow (c[i], s[i])$，其中 $i \\in \\{0,...,k-1\\}$。然后再使用平行前缀加法器计算 $2[\\![c]\\!]^B + [\\![s]\\!]^B$。对于半诚实的情况，$P_2$ 可以提供 $(x_1 + x_2)$ 作为输入计算 $[\\![x]\\!]^B := [\\![x_1 + x_2]\\!]^B + [\\![x_3]\\!]^B$。\n\n\n\n### 位提取\n\n$[\\![x]\\!]^A \\rightarrow [\\![x[i]]\\!]^B$\n\n跟上面的情况类似，只是这次是提取比特串中的单一比特，把上一小节的电路中不必要的门去掉即可。\n\n\n\n### 位组合\n\n$[\\![x]\\!]^B \\rightarrow [\\![x]\\!]^A$\n\n用到的还是与上面类似的电路，只是操作顺序有点变化。首先 $P_1, P_2$ 输入一个随机共享 $[\\![-x_2]\\!]^B$，$P_2, P_3$ 同样输入一个随机共享 $[\\![-x_3]\\!]^B$，这两个将会是最终的转换结果的部分。这里可以利用两方间的密钥作为随机种子来生成随机数。\n\n然后三方计算 $\\mathsf{FA}([\\![x[i]]\\!]^B, [\\![-x_2[i]]\\!]^B, [\\![-x_3[i]]\\!]^B) \\rightarrow ([\\![c[i]]\\!]^B, [\\![s[i]]\\!]^B)$，其中 $i \\in \\{0,...,k-1\\}$。然后使用并行前缀加法器计算 $[\\![x_1]\\!]^B := 2[\\![c]\\!]^B + [\\![s]\\!]^B$。同样在半诚实下可以进一步优化，$P_2$ 提供 $(-x_2, -x_3)$ 作为输入计算 $[\\![x_1]\\!]^B := [\\![x]\\!]^B + [\\![-x_2 - x_3]\\!]^B$，$x_1$ 对 $P_1, P_3$ 开放，最后的共享定义为 $[\\![x]\\!]^A := (x_1, x_2, x_3)$。\n\n\n\n### 位注入\n\n$[\\![x]\\!]^B \\rightarrow [\\![x]\\!]^A$\n\n当需要将以二进制共享方式编码的单个位 $x$ 提升为算术共享 $[\\![x]\\!]^A$ 时，通常会出现另一种特殊情况，参考3.4。\n\n\n\n### 联合姚输入\n\n在姚共享中，对于一个比特 $x$，$P_1$（评估者）拥有 $k^x_{\\mathsf{x}}$ 而另外两方拥有 $k^0_{\\mathsf{x}} \\in \\{0,1\\}^{\\kappa}$ 和一个全局随机串 $\\Delta \\in \\{0,1\\}^{\\kappa}$ 使得 $k^1_{\\mathsf{x}} := k^0_{\\mathsf{x}} \\oplus \\Delta$。转换到姚共享和从姚共享转换的一个有用的原语是双方提供双方都知道的输入的能力。比如说 $P_1, P_2$ 知道一个比特 $x$，想生成共享 $[\\![x]\\!]^Y$。在半诚实设置中比较简单，$P_2$ 可以本地生成并发送 $[\\![x]\\!]^Y$ 给 $P_1$。但是在恶意设置下 $P_1$ 需要在不知道 $\\Delta$ 的情况下验证 $[\\![x]\\!]^Y$ 正确地将 $x$ 编码。于是 $P_3$ 可以帮助 $P_1$ 进行验证：$P_2, P_3$ 同时发送 $k^0_{\\mathsf{x}}$ 和 $k^1_{\\mathsf{x}}$ 的承诺方案给 $P_1$ ，后者可以检查两个承诺是否一致以及是否能打开承诺。\n\n\n\n### 姚共享到二进制共享\n\n$[\\![x]\\!]^Y \\rightarrow [\\![x]\\!]^B$\n\n在两方的情况下，密钥的最低有效位（置换位）形成 $x$ 的两方共享，即 $x \\oplus p_{\\mathsf{x}} = k^x_{\\mathsf{x}}[0]$，其中 $p_{\\mathsf{x}} = k^0_{\\mathsf{x}}[0]$。三方下 $P_3$ 也知道 $p_{\\mathsf{x}}$，首先 $P_1,P_2$ 本地生成随机比特 $r$ 然后 $P_1$ 将 $k^x_{\\mathsf{x}}[0] \\oplus r = x \\oplus p_{\\mathsf{x}} \\oplus r$ 发送给 $P_3$。于是就完成了共享的转换，原本的共享被转换为 $[\\![x]\\!]^B = (x \\oplus p_{\\mathsf{x}} \\oplus r, r, p_{\\mathsf{x}})$。\n\n在恶意的设置下，需要确认 $P_1$ 发送给 $P_3$ 的 $x \\oplus b \\oplus r$ 中的 $b = p_{\\mathsf{x}}$。首先 $P_1, P_2$ 选取 $k^r_{\\mathsf{r}} \\leftarrow \\{0,1\\}^{\\kappa}$，后者发送 $k^0_{\\mathsf{r}} := k^r_{\\mathsf{r}} \\oplus (r \\Delta)$ 给 $P_3$。然后 $P_2,P_3$ 发送承诺 $C_0 = \\mathsf{Comm}(k^{p_{\\mathsf{x}}}_{\\mathsf{y}}), C_1 = \\mathsf{Comm}(k^{\\overline{p_{\\mathsf{x}}}}_{\\mathsf{y}})$ 给 $P_1$，其中 $k^0_{\\mathsf{y}} := k^0_{\\mathsf{x}} \\oplus k^0_{\\mathsf{r}}$。$P_1$ 发送 $k^{x \\oplus r}_{\\mathsf{y}} := k^x_{\\mathsf{x} } \\oplus k^r_{\\mathsf{r}}$ 给 $P_3$，后者验证其是否在集合 $\\{k^0_{\\mathsf{y}}, k^1_{\\mathsf{y}}\\}$ 中。$P_1$ 同样验证承诺 $C_{p_{\\mathsf{x}} \\oplus x \\oplus r}$ 是否可以打开为 $k^{x \\oplus r}_{\\mathsf{y}}$ 以及 $C_0, C_1$ 是否一致。注意到 $x \\oplus p_{\\mathsf{x}} = k^x_{\\mathsf{x}}[0]$，于是三方就可以计算共享 $[\\![x]\\!]^B = (x \\oplus p_{\\mathsf{x}} \\oplus r, r, p_{\\mathsf{x}})$。观察到 $P_3$ 将 $x \\oplus p_{\\mathsf{x}} \\oplus r$ 计算为 $k^{x \\oplus r}_{\\mathsf{y}}[0] \\oplus p_{\\mathsf{r}}$。\n\n\n\n### 二进制共享到姚共享\n\n$[\\![x]\\!]^B \\rightarrow [\\![x]\\!]^Y$\n\n设 $[\\![x]\\!]^B = (x_1, x_2, x_3)$。各方使用前面讨论的程序共同输入份额 $[\\![x_1]\\!]^Y,[\\![x_2]\\!]^Y,[\\![x_3]\\!]^Y$ 作为联合姚输入。然后可以使用乱码电路来计算最终份额，该电路计算三个值的异或 $[\\![x]\\!]^Y := [\\![x_1]\\!]^Y \\oplus [\\![x_2]\\!]^Y \\oplus [\\![x_3]\\!]^Y$ 。使用Free-XOR技术，这不需要三方之间的任何通信，并且可以由 $P_1$ 本地计算。在半诚实的设置中，可以基于 $P_2$ 知道 $x_2$ 和 $x_3$ 这一事实来进一步优化。因此，它们可以本地计算 $x_2 \\oplus x_3$，并将 $[\\![x_2 \\oplus x_3]\\!]^Y$ 发送给 $P_1$，后者本地计算 $[\\![x]\\!]^Y := [\\![x_1]\\!]^Y \\oplus [\\![x_2 \\oplus x_3]\\!]^Y$。\n\n\n\n### 姚共享到算术共享\n\n$[\\![x]\\!]^Y \\rightarrow [\\![x]\\!]^A$\n\n自然的想法是将姚共享先转换成二进制共享，再用位组合中的方法转换为算术共享。作者在这里也给出了优化方案，还是使用到了乱码电路，对这部分看得不是很懂。\n\n\n\n### 算术共享到姚共享\n\n$[\\![x]\\!]^A \\rightarrow [\\![x]\\!]^Y$\n\n各方联合输入 $[\\![x]\\!]^A = (x_1, x_2, x_3)$ 的共享 $[\\![x_1]\\!]^Y,[\\![x_2]\\!]^Y,[\\![x_3]\\!]^Y$。然后使用一个乱码电路生成 $[\\![x]\\!]^Y := [\\![x_1]\\!]^Y + [\\![x_2]\\!]^Y + [\\![x_3]\\!]^Y$。\n\n\n\n## 计算 $[\\![a]\\!]^A [\\![b]\\!]^B = [\\![ab]\\!]^A$\n\n虽然将共享转换后再计算上面的公式也可以，但作者在这里给出了更有效的特定协议。在训练Logistic回归和神经网络模型中通常用于逼近非线性激活函数的分段线性或多项式函数的计算需要重复该操作。\n\n\n\n### 半诚实\n\n#### 三方OT\n\n作者首先给出了三方下的不经意传输协议，在两方的OT中有两个角色：sender和receiver。在这里作者添加了一个*helper*的角色，他不会收到输出且知道receiver的选择位。这个对于(sender, receiver, helper)的功能记为 $((m_0, m_1),c, c) \\mapsto (\\perp, m_c, \\perp)$。\n\n首先sender和helper选取随机串 $w_0, w_1 \\leftarrow \\{0,1\\}^k$。sender将消息盲化：$m_0 \\oplus w_0, m_1 \\oplus w_1$ 然后发送给receiver。helper知道receiver希望收到消息 $m_c$，这样helper可以发送 $w_c$ 给receiver来让后者重构 $m_c$。\n\n\n\n#### 计算 $a[\\![b]\\!]^B = [\\![ab]\\!]^A$\n\n最简单的一种情况是 $P_1$ 知道的一个公共值 $a \\in \\mathbb{Z}_{2^k}$ 和一个共享比特 $b \\in \\{0,1\\}$ 的乘法。首先 $P_3$ (sender)选取随机数 $r \\leftarrow \\mathbb{Z}_{2^k}$ 和定义两个消息 $m_i := (i \\oplus b_1 \\oplus b_3)a - r$，其中 $i \\in \\{0,1\\}$。$P_2$ (receiver)为了学习消息 $m_{b_2} = (b_2 \\oplus b_1 \\oplus b_3)a - r = ba - r$，定义他的输入为 $b_2$。注意到 $P_1$ (helper)也知道 $b_2$，因此这里可以使用前面提到的三方OT。然后三方本地生成重复0共享 $(s_1, s_2, s_3)$ 来计算 $[\\![c]\\!] = [\\![ab]\\!] = (s_1 + r, ab-r+s_3, s_3)$。但是为了令这个2/3秘密共享合法，$c_2 = ab - r + s_3$ 要发送给 $P_1$，导致需要总共两轮通信。或者可以(并行地)重复执行三方OT过程，$P_3$ 担任sender输入 $(i+b_2+b_3)a - r + s_3$，其中 $i \\in \\{0,1\\}$。于是 $P_1$ (receiver)输入 $b_2$，在第一轮中获知消息 $c_2$（非 $m_{b_2}$），总共 $6k$ 比特和 $1$ 轮通信。\n\n\n\n#### 计算 $[\\![a]\\!]^A [\\![b]\\!]^B = [\\![ab]\\!]^A$\n\n在半诚实下，并行地执行两次 $a[\\![b]\\!]^B = [\\![ab]\\!]^A$ 过程就足够了。关键在于观察到上述计算中的 $a$ 不必是公开的。也就是说，$P_1$ 可以私下选择 $a$ 的值。利用这一点，可以观察到表达式可以写成 $[\\![a]\\!][\\![b]\\!]^B = a_1[\\![b]\\!]^B + (a_2 + a_3)[\\![b]\\!]^B$。$P_1$ 充当第一次的sender，$P_3$ 充当第二次的sender。每一方总共在 $1$ 轮上传送 $4k$ 比特。\n\n\n\n### 恶意\n\n#### 计算 $a[\\![b]\\!]^B = [\\![ab]\\!]^A$\n\n因为 $P_1$ 可以任意选择他输入到OT的值 $a$，所以半诚实方法在恶意设置下不适用。为了避开这一点，作者在这里先执行对 $b$ 的*位注入*。即计算 $[\\![b]\\!]^B \\rightarrow [\\![b]\\!]^A$ 然后 $a[\\![b]\\!]^A = [\\![ab]\\!]^A$。在3.3节中提到，各方可以在本地计算共享 $[\\![b_1]\\!]^A, [\\![b_2]\\!]^A, [\\![b_2]\\!]^A$，其中 $[\\![b]\\!]^B = (b_1, b_2, b_3)$。现在可以通过计算 $[\\![b_1 \\oplus b_2]\\!]^A = [\\![d]\\!]^A :=$ $[\\![b_1]\\!]^A + [\\![b_2]\\!]^A - 2[\\![b_1]\\!]^A[\\![b_2]\\!]^A$ 和 $[\\![b]\\!]^A := [\\![d \\oplus b_3]\\!]^A$ 在算术电路中模拟这些值的异或。然后可以将最终结果计算为 $[\\![ab]\\!]^A := a[\\![b]\\!]^A$，其中每一方用 $a$ 去乘以自己 $b$ 的份额。\n\n\n\n#### 计算 $[\\![a]\\!]^A [\\![b]\\!]^B = [\\![ab]\\!]^A$\n\n同样，这里可以重复位注入过程，将 $[\\![b]\\!]^B$ 转换为 $[\\![b]\\!]^A$，然后使用乘法协议计算 $[\\![a]\\!]^A[\\![b]\\!]^A$。\n\n\n\n## 多项式分段函数\n\n设 $f_1,...,f_m$ 表示具有公共系数的多项式以及有 $-\\infty = c_0 < c_1 < ... < c_{m-1} < c_m = \\infty$ 使得 $c_{i-1}<x \\leq c_i$ 时 $f(x) = f_i(x)$。本文的方法是先计算向量 $b_1,...,b_m \\in \\{0,1\\}$ 的秘密共享值使得 $b_i = 1 \\Leftrightarrow c_{i-1} < x \\leq c_i$，然后 $f$ 可以计算为 $f(x) = \\sum_i b_i f_i(x)$。\n\n![](http://images.yingwai.top/picgo/aby3ppt5.png)\n\n比如说要比较 $[\\![x]\\!]$ 与 $c$ 的大小，可以看成提取 $[\\![x-c]\\!]$ 的最高有效位(MSB)（为1时 $x-c<0$）。这里可以对 $[\\![x-c]\\!]$ 使用5.3中的位提取来获得二进制共享 $[\\![b]\\!]^B := [\\![\\mathsf{msb}(x-c)]\\!]^B$。\n\n每个 $f_i$ 函数被表示为多项式 $f_i([\\![x]\\!]) = a_{i,j}[\\![x]\\!]^j + ... + a_{i,1}[\\![x]\\!] + a_{i,0}$，其中所有的 $a_{i,l}$ 都是公知的常数。当 $f_i$ 为0次多项式时，使用3.4中的技术可以将计算 $b_if_i([\\![x]\\!])$ 优化为 $a_{i,0}[\\![b]\\!]^B$。另外当 $f_i$ 的系数为整数时，给定 $[\\![x]\\!]^l$，$a_{i,l} [\\![x]\\!]^l$ 的计算可以在本地进行。但是当 $a_{i,j}$ 有非零小数时，将按照3.1的方法执行交互式截断。\n\n\n\n# 应用到机器学习\n\n作者还给出了本文框架分别在线性回归、逻辑回归以及神经网络中的应用。\n\n\n\n## 线性回归\n\n![](http://images.yingwai.top/picgo/aby3ppt7.png)\n\n线性回归是比较简单的一种模型，前向运算和更新权重都只包含了加法和乘法操作，因此只要利用前面提到的加法和乘法协议就可以完成一个线性回归模型的训练。\n\n\n\n## 逻辑回归\n\n![](http://images.yingwai.top/picgo/aby3ppt8.png)\n\n逻辑回归是在线性回归的基础上增加了一个Sigmoid函数，因为在秘密共享的情况下计算指数函数很困难，因此可以定义一个近似函数或用多项式去逼近。文中3.5节给出了计算此类函数的方法，这里近似函数可以使用[SecureML](https://yuyingwai.cn/2020/06/17/论文笔记-SecureML-A-System-for-Scalable-Privacy-Preserving-Machine-Learning/)中定义的：\n$$\nf(x) = \\left\\{ \\begin{array}{lcl}0, & \\mbox{if} & x < - \\frac{1}{2} \\\\x + \\frac{1}{2}, & \\mbox{if} & - \\frac{1}{2} \\leq x \\leq \\frac{1}{2} \\\\1, & \\mbox{if} & x > \\frac{1}{2}\\end{array}\\right.\n$$\n![](http://images.yingwai.top/picgo/smlf5.png)\n\n\n\n## 神经网络\n\n![](http://images.yingwai.top/picgo/aby3ppt9.png)\n\n一个神经网络由很多个神经元组成，每一个神经元可以看成是与逻辑回归计算一致的单元，只是最后的非线性函数不一定是Sigmoid函数（替换成ReLU）。","source":"_posts/论文笔记-ABY3-A-Mixed-Protocol-Framework-for-Machine-Learning.md","raw":"---\ntitle: '论文笔记 ABY3: A Mixed Protocol Framework for Machine Learning'\ndate: 2020-06-18 20:06:46\ncategories: Papers\ntags: [PPML, MPC, Neural Network, Linear Regression, Logistic Regression, Secret Sharing]\n---\n\n*Payman Mohassel, Peter Rindal*\n\nCCS 2018\n\nhttps://dl.acm.org/doi/10.1145/3243734.3243760\n\n<!--more-->\n\n![](http://images.yingwai.top/picgo/ABY3.png)\n\n# 本文贡献\n\n* 新的共享十进制数近似定点乘法协议；\n* 提出了三方的ABY框架，其中许多转换都是基于新技术，并在本文中首次进行了设计和优化；\n* 提高了矩阵乘法的效率；\n* 有效的分段多项式函数评估。\n\n\n\n# 计算模型\n\n本文采用三方的重复共享，即把一个数 $x$ 拆成三份，各方都拥有三份中的两份，下面是ABY三种共享形式：\n\n![](http://images.yingwai.top/picgo/aby3ppt4.png)\n\n在这种设置下，三方交互式地计算函数 $f(x)$，本篇文章主要针对机器学习中的算法。\n\n![](http://images.yingwai.top/picgo/aby3ppt2.png)\n\n\n\n## 加法\n\n在秘密共享的情况下，计算两个数 $[\\![x]\\!], [\\![y]\\!]$ 的和 $[\\![z]\\!] = [\\![x]\\!] + [\\![y]\\!]$ 比较简单，各方直接将其对应的份额在本地相加即可，不需要交互：\n$$\nz_i = x_i + y_i\n$$\n\n\n## 乘法\n\n计算两个数 $[\\![x]\\!], [\\![y]\\!]$ 的积 $[\\![z]\\!] = [\\![x]\\!] * [\\![y]\\!]$ 则复杂一点。在两方共享的情况下，需要借助额外的乘法三元组来计算，开销非常大。而三方下的复制共享这时候就起作用了，将 $xy$ 展开可以观察到有九项，每一项是两个份额的乘积，因此每一方只需要计算其可以计算的九项中的其中三项即可保持结果 $z$ 继续在三方中是加法共享的。计算完成后再把对应的结果发送给另一方，即可保持 $z$ 是重复共享的。\n\n![](http://images.yingwai.top/picgo/aby3ppt3.png)\n\n可以看到乘法操作只包含了本地操作和各方各一次发送，开销比两方的情况下小很多。\n\n\n\n# 本文的框架\n\n## 定点运算\n\n定点值定义为使用二进制补码表示的一个 $k$ 位整数，其中底部 $d$ 位表示小数，即对于正值，位 $i$ 表示 $2$ 的 $(i−d)$ 次方。由于预计结果将保持在 $2^k$ 以下，因此可以使用相应的整数运算来执行加法和减法。乘法也可以以相同的方式执行，但是十进制位的数量加倍，因此必须除以 $2^d$ 以保持 $d$ 个十进制位不变。\n\n在得到乘法结果后，各方可以直接把本地的份额后 $d$ 位截断，但这样会**把原本份额相加的进位也截断了**，导致截断后重构出来的 $\\tilde{x} \\neq x$。作者参考了[SecureML](https://yuyingwai.cn/2020/06/17/论文笔记-SecureML-A-System-for-Scalable-Privacy-Preserving-Machine-Learning/)中的两方协议，给出了他们自己的在三方下的实现：\n\n![](http://images.yingwai.top/picgo/aby3f1.png)\n\n一开始作者的想法是把 $x'$ 的截断 $x = x'/2^d$ 拆成 $[\\![x]\\!] := (x_1, x_2, x_3) = (x'_1/2^d, (x'_2 + x'_3)/2^d-r, r)$，其中 $r$ 是 $\\mathbb{Z}^k_2$ 中的随机数，但发现这样做有两轮通信的限制，于是进一步优化得到上面的协议。\n\n\n\n## 矢量化乘法\n\n两个向量作内积定义为 $\\vec{x} \\cdot \\vec{y} := \\sum^n_{i=1} x_i y_i$。在本文的背景下计算内积，朴素的做法是对两个向量的每一个元素都执行一次乘法+截断协议，但这样需要通信 $O(n)$ 次通信。\n\n于是作者进行了优化：各方只需要在本地将两个向量 $\\vec{x},\\vec{y}$ 的 $n$ 个分量计算相乘的份额，然后把这 $n$ 个积相加就得到了 $z'$ 的3/3共享，最后执行上一小节中的截断协议将 $[\\![z']\\!]$ 截断为 $[\\![z]\\!]:= (z'+r')/2^d - [\\![r]\\!]$。\n\n这样做不仅可以减少通信开销，而且误差也比执行 $n$ 次乘法+截断协议低（总共只进行了一次截断，相对于整体内积的误差为 $2^{-d}$）。\n\n\n\n## 共享转换\n\n机器学习中有很多不同的函数，而不同的函数有适合其计算的不同共享方式：算术共享适合计算乘法和加法，而二进制共享适合计算非线性函数、最大池化以及平均值等。两方的情况可以参考[ABY](https://yuyingwai.cn/2020/06/11/论文笔记-ABY-A-Framework-for-Efficient-Mixed-Protocol-Secure-Two-Party-Computation/)，本文给出了三方下的共享转换。\n\n![](http://images.yingwai.top/picgo/aby3ppt6.png)\n\n\n\n### 位分解\n\n$[\\![x]\\!]^A \\rightarrow [\\![\\vec{x}]\\!]^B$\n\n最基础的想法是各方将其份额 $[\\![x]\\!]^A = (x_1, x_2, x_3)$ 输入到布尔电路中计算它们的和，但可以进行优化。观察到 $[\\![x]\\!]^A = (x_1, x_2, x_3)$ 可以转换为 $[\\![x_1]\\!]^B := (x_1,0,0), [\\![x_2]\\!]^B := (0,x_2,0), [\\![x_3]\\!]^B := (0,0,x_3)$ 而不需要交互。\n\n这里没太看懂，用到了各种加法器。作者首先观察到 $x_1 + x_2 + x_3$ 的计算可以减少成执行 $k$ 个相互独立的全加器计算 $2c+s$：$\\mathsf{FA}(x_1[i], x_2[i], x_3[i-1]) \\rightarrow (c[i], s[i])$，其中 $i \\in \\{0,...,k-1\\}$。然后再使用平行前缀加法器计算 $2[\\![c]\\!]^B + [\\![s]\\!]^B$。对于半诚实的情况，$P_2$ 可以提供 $(x_1 + x_2)$ 作为输入计算 $[\\![x]\\!]^B := [\\![x_1 + x_2]\\!]^B + [\\![x_3]\\!]^B$。\n\n\n\n### 位提取\n\n$[\\![x]\\!]^A \\rightarrow [\\![x[i]]\\!]^B$\n\n跟上面的情况类似，只是这次是提取比特串中的单一比特，把上一小节的电路中不必要的门去掉即可。\n\n\n\n### 位组合\n\n$[\\![x]\\!]^B \\rightarrow [\\![x]\\!]^A$\n\n用到的还是与上面类似的电路，只是操作顺序有点变化。首先 $P_1, P_2$ 输入一个随机共享 $[\\![-x_2]\\!]^B$，$P_2, P_3$ 同样输入一个随机共享 $[\\![-x_3]\\!]^B$，这两个将会是最终的转换结果的部分。这里可以利用两方间的密钥作为随机种子来生成随机数。\n\n然后三方计算 $\\mathsf{FA}([\\![x[i]]\\!]^B, [\\![-x_2[i]]\\!]^B, [\\![-x_3[i]]\\!]^B) \\rightarrow ([\\![c[i]]\\!]^B, [\\![s[i]]\\!]^B)$，其中 $i \\in \\{0,...,k-1\\}$。然后使用并行前缀加法器计算 $[\\![x_1]\\!]^B := 2[\\![c]\\!]^B + [\\![s]\\!]^B$。同样在半诚实下可以进一步优化，$P_2$ 提供 $(-x_2, -x_3)$ 作为输入计算 $[\\![x_1]\\!]^B := [\\![x]\\!]^B + [\\![-x_2 - x_3]\\!]^B$，$x_1$ 对 $P_1, P_3$ 开放，最后的共享定义为 $[\\![x]\\!]^A := (x_1, x_2, x_3)$。\n\n\n\n### 位注入\n\n$[\\![x]\\!]^B \\rightarrow [\\![x]\\!]^A$\n\n当需要将以二进制共享方式编码的单个位 $x$ 提升为算术共享 $[\\![x]\\!]^A$ 时，通常会出现另一种特殊情况，参考3.4。\n\n\n\n### 联合姚输入\n\n在姚共享中，对于一个比特 $x$，$P_1$（评估者）拥有 $k^x_{\\mathsf{x}}$ 而另外两方拥有 $k^0_{\\mathsf{x}} \\in \\{0,1\\}^{\\kappa}$ 和一个全局随机串 $\\Delta \\in \\{0,1\\}^{\\kappa}$ 使得 $k^1_{\\mathsf{x}} := k^0_{\\mathsf{x}} \\oplus \\Delta$。转换到姚共享和从姚共享转换的一个有用的原语是双方提供双方都知道的输入的能力。比如说 $P_1, P_2$ 知道一个比特 $x$，想生成共享 $[\\![x]\\!]^Y$。在半诚实设置中比较简单，$P_2$ 可以本地生成并发送 $[\\![x]\\!]^Y$ 给 $P_1$。但是在恶意设置下 $P_1$ 需要在不知道 $\\Delta$ 的情况下验证 $[\\![x]\\!]^Y$ 正确地将 $x$ 编码。于是 $P_3$ 可以帮助 $P_1$ 进行验证：$P_2, P_3$ 同时发送 $k^0_{\\mathsf{x}}$ 和 $k^1_{\\mathsf{x}}$ 的承诺方案给 $P_1$ ，后者可以检查两个承诺是否一致以及是否能打开承诺。\n\n\n\n### 姚共享到二进制共享\n\n$[\\![x]\\!]^Y \\rightarrow [\\![x]\\!]^B$\n\n在两方的情况下，密钥的最低有效位（置换位）形成 $x$ 的两方共享，即 $x \\oplus p_{\\mathsf{x}} = k^x_{\\mathsf{x}}[0]$，其中 $p_{\\mathsf{x}} = k^0_{\\mathsf{x}}[0]$。三方下 $P_3$ 也知道 $p_{\\mathsf{x}}$，首先 $P_1,P_2$ 本地生成随机比特 $r$ 然后 $P_1$ 将 $k^x_{\\mathsf{x}}[0] \\oplus r = x \\oplus p_{\\mathsf{x}} \\oplus r$ 发送给 $P_3$。于是就完成了共享的转换，原本的共享被转换为 $[\\![x]\\!]^B = (x \\oplus p_{\\mathsf{x}} \\oplus r, r, p_{\\mathsf{x}})$。\n\n在恶意的设置下，需要确认 $P_1$ 发送给 $P_3$ 的 $x \\oplus b \\oplus r$ 中的 $b = p_{\\mathsf{x}}$。首先 $P_1, P_2$ 选取 $k^r_{\\mathsf{r}} \\leftarrow \\{0,1\\}^{\\kappa}$，后者发送 $k^0_{\\mathsf{r}} := k^r_{\\mathsf{r}} \\oplus (r \\Delta)$ 给 $P_3$。然后 $P_2,P_3$ 发送承诺 $C_0 = \\mathsf{Comm}(k^{p_{\\mathsf{x}}}_{\\mathsf{y}}), C_1 = \\mathsf{Comm}(k^{\\overline{p_{\\mathsf{x}}}}_{\\mathsf{y}})$ 给 $P_1$，其中 $k^0_{\\mathsf{y}} := k^0_{\\mathsf{x}} \\oplus k^0_{\\mathsf{r}}$。$P_1$ 发送 $k^{x \\oplus r}_{\\mathsf{y}} := k^x_{\\mathsf{x} } \\oplus k^r_{\\mathsf{r}}$ 给 $P_3$，后者验证其是否在集合 $\\{k^0_{\\mathsf{y}}, k^1_{\\mathsf{y}}\\}$ 中。$P_1$ 同样验证承诺 $C_{p_{\\mathsf{x}} \\oplus x \\oplus r}$ 是否可以打开为 $k^{x \\oplus r}_{\\mathsf{y}}$ 以及 $C_0, C_1$ 是否一致。注意到 $x \\oplus p_{\\mathsf{x}} = k^x_{\\mathsf{x}}[0]$，于是三方就可以计算共享 $[\\![x]\\!]^B = (x \\oplus p_{\\mathsf{x}} \\oplus r, r, p_{\\mathsf{x}})$。观察到 $P_3$ 将 $x \\oplus p_{\\mathsf{x}} \\oplus r$ 计算为 $k^{x \\oplus r}_{\\mathsf{y}}[0] \\oplus p_{\\mathsf{r}}$。\n\n\n\n### 二进制共享到姚共享\n\n$[\\![x]\\!]^B \\rightarrow [\\![x]\\!]^Y$\n\n设 $[\\![x]\\!]^B = (x_1, x_2, x_3)$。各方使用前面讨论的程序共同输入份额 $[\\![x_1]\\!]^Y,[\\![x_2]\\!]^Y,[\\![x_3]\\!]^Y$ 作为联合姚输入。然后可以使用乱码电路来计算最终份额，该电路计算三个值的异或 $[\\![x]\\!]^Y := [\\![x_1]\\!]^Y \\oplus [\\![x_2]\\!]^Y \\oplus [\\![x_3]\\!]^Y$ 。使用Free-XOR技术，这不需要三方之间的任何通信，并且可以由 $P_1$ 本地计算。在半诚实的设置中，可以基于 $P_2$ 知道 $x_2$ 和 $x_3$ 这一事实来进一步优化。因此，它们可以本地计算 $x_2 \\oplus x_3$，并将 $[\\![x_2 \\oplus x_3]\\!]^Y$ 发送给 $P_1$，后者本地计算 $[\\![x]\\!]^Y := [\\![x_1]\\!]^Y \\oplus [\\![x_2 \\oplus x_3]\\!]^Y$。\n\n\n\n### 姚共享到算术共享\n\n$[\\![x]\\!]^Y \\rightarrow [\\![x]\\!]^A$\n\n自然的想法是将姚共享先转换成二进制共享，再用位组合中的方法转换为算术共享。作者在这里也给出了优化方案，还是使用到了乱码电路，对这部分看得不是很懂。\n\n\n\n### 算术共享到姚共享\n\n$[\\![x]\\!]^A \\rightarrow [\\![x]\\!]^Y$\n\n各方联合输入 $[\\![x]\\!]^A = (x_1, x_2, x_3)$ 的共享 $[\\![x_1]\\!]^Y,[\\![x_2]\\!]^Y,[\\![x_3]\\!]^Y$。然后使用一个乱码电路生成 $[\\![x]\\!]^Y := [\\![x_1]\\!]^Y + [\\![x_2]\\!]^Y + [\\![x_3]\\!]^Y$。\n\n\n\n## 计算 $[\\![a]\\!]^A [\\![b]\\!]^B = [\\![ab]\\!]^A$\n\n虽然将共享转换后再计算上面的公式也可以，但作者在这里给出了更有效的特定协议。在训练Logistic回归和神经网络模型中通常用于逼近非线性激活函数的分段线性或多项式函数的计算需要重复该操作。\n\n\n\n### 半诚实\n\n#### 三方OT\n\n作者首先给出了三方下的不经意传输协议，在两方的OT中有两个角色：sender和receiver。在这里作者添加了一个*helper*的角色，他不会收到输出且知道receiver的选择位。这个对于(sender, receiver, helper)的功能记为 $((m_0, m_1),c, c) \\mapsto (\\perp, m_c, \\perp)$。\n\n首先sender和helper选取随机串 $w_0, w_1 \\leftarrow \\{0,1\\}^k$。sender将消息盲化：$m_0 \\oplus w_0, m_1 \\oplus w_1$ 然后发送给receiver。helper知道receiver希望收到消息 $m_c$，这样helper可以发送 $w_c$ 给receiver来让后者重构 $m_c$。\n\n\n\n#### 计算 $a[\\![b]\\!]^B = [\\![ab]\\!]^A$\n\n最简单的一种情况是 $P_1$ 知道的一个公共值 $a \\in \\mathbb{Z}_{2^k}$ 和一个共享比特 $b \\in \\{0,1\\}$ 的乘法。首先 $P_3$ (sender)选取随机数 $r \\leftarrow \\mathbb{Z}_{2^k}$ 和定义两个消息 $m_i := (i \\oplus b_1 \\oplus b_3)a - r$，其中 $i \\in \\{0,1\\}$。$P_2$ (receiver)为了学习消息 $m_{b_2} = (b_2 \\oplus b_1 \\oplus b_3)a - r = ba - r$，定义他的输入为 $b_2$。注意到 $P_1$ (helper)也知道 $b_2$，因此这里可以使用前面提到的三方OT。然后三方本地生成重复0共享 $(s_1, s_2, s_3)$ 来计算 $[\\![c]\\!] = [\\![ab]\\!] = (s_1 + r, ab-r+s_3, s_3)$。但是为了令这个2/3秘密共享合法，$c_2 = ab - r + s_3$ 要发送给 $P_1$，导致需要总共两轮通信。或者可以(并行地)重复执行三方OT过程，$P_3$ 担任sender输入 $(i+b_2+b_3)a - r + s_3$，其中 $i \\in \\{0,1\\}$。于是 $P_1$ (receiver)输入 $b_2$，在第一轮中获知消息 $c_2$（非 $m_{b_2}$），总共 $6k$ 比特和 $1$ 轮通信。\n\n\n\n#### 计算 $[\\![a]\\!]^A [\\![b]\\!]^B = [\\![ab]\\!]^A$\n\n在半诚实下，并行地执行两次 $a[\\![b]\\!]^B = [\\![ab]\\!]^A$ 过程就足够了。关键在于观察到上述计算中的 $a$ 不必是公开的。也就是说，$P_1$ 可以私下选择 $a$ 的值。利用这一点，可以观察到表达式可以写成 $[\\![a]\\!][\\![b]\\!]^B = a_1[\\![b]\\!]^B + (a_2 + a_3)[\\![b]\\!]^B$。$P_1$ 充当第一次的sender，$P_3$ 充当第二次的sender。每一方总共在 $1$ 轮上传送 $4k$ 比特。\n\n\n\n### 恶意\n\n#### 计算 $a[\\![b]\\!]^B = [\\![ab]\\!]^A$\n\n因为 $P_1$ 可以任意选择他输入到OT的值 $a$，所以半诚实方法在恶意设置下不适用。为了避开这一点，作者在这里先执行对 $b$ 的*位注入*。即计算 $[\\![b]\\!]^B \\rightarrow [\\![b]\\!]^A$ 然后 $a[\\![b]\\!]^A = [\\![ab]\\!]^A$。在3.3节中提到，各方可以在本地计算共享 $[\\![b_1]\\!]^A, [\\![b_2]\\!]^A, [\\![b_2]\\!]^A$，其中 $[\\![b]\\!]^B = (b_1, b_2, b_3)$。现在可以通过计算 $[\\![b_1 \\oplus b_2]\\!]^A = [\\![d]\\!]^A :=$ $[\\![b_1]\\!]^A + [\\![b_2]\\!]^A - 2[\\![b_1]\\!]^A[\\![b_2]\\!]^A$ 和 $[\\![b]\\!]^A := [\\![d \\oplus b_3]\\!]^A$ 在算术电路中模拟这些值的异或。然后可以将最终结果计算为 $[\\![ab]\\!]^A := a[\\![b]\\!]^A$，其中每一方用 $a$ 去乘以自己 $b$ 的份额。\n\n\n\n#### 计算 $[\\![a]\\!]^A [\\![b]\\!]^B = [\\![ab]\\!]^A$\n\n同样，这里可以重复位注入过程，将 $[\\![b]\\!]^B$ 转换为 $[\\![b]\\!]^A$，然后使用乘法协议计算 $[\\![a]\\!]^A[\\![b]\\!]^A$。\n\n\n\n## 多项式分段函数\n\n设 $f_1,...,f_m$ 表示具有公共系数的多项式以及有 $-\\infty = c_0 < c_1 < ... < c_{m-1} < c_m = \\infty$ 使得 $c_{i-1}<x \\leq c_i$ 时 $f(x) = f_i(x)$。本文的方法是先计算向量 $b_1,...,b_m \\in \\{0,1\\}$ 的秘密共享值使得 $b_i = 1 \\Leftrightarrow c_{i-1} < x \\leq c_i$，然后 $f$ 可以计算为 $f(x) = \\sum_i b_i f_i(x)$。\n\n![](http://images.yingwai.top/picgo/aby3ppt5.png)\n\n比如说要比较 $[\\![x]\\!]$ 与 $c$ 的大小，可以看成提取 $[\\![x-c]\\!]$ 的最高有效位(MSB)（为1时 $x-c<0$）。这里可以对 $[\\![x-c]\\!]$ 使用5.3中的位提取来获得二进制共享 $[\\![b]\\!]^B := [\\![\\mathsf{msb}(x-c)]\\!]^B$。\n\n每个 $f_i$ 函数被表示为多项式 $f_i([\\![x]\\!]) = a_{i,j}[\\![x]\\!]^j + ... + a_{i,1}[\\![x]\\!] + a_{i,0}$，其中所有的 $a_{i,l}$ 都是公知的常数。当 $f_i$ 为0次多项式时，使用3.4中的技术可以将计算 $b_if_i([\\![x]\\!])$ 优化为 $a_{i,0}[\\![b]\\!]^B$。另外当 $f_i$ 的系数为整数时，给定 $[\\![x]\\!]^l$，$a_{i,l} [\\![x]\\!]^l$ 的计算可以在本地进行。但是当 $a_{i,j}$ 有非零小数时，将按照3.1的方法执行交互式截断。\n\n\n\n# 应用到机器学习\n\n作者还给出了本文框架分别在线性回归、逻辑回归以及神经网络中的应用。\n\n\n\n## 线性回归\n\n![](http://images.yingwai.top/picgo/aby3ppt7.png)\n\n线性回归是比较简单的一种模型，前向运算和更新权重都只包含了加法和乘法操作，因此只要利用前面提到的加法和乘法协议就可以完成一个线性回归模型的训练。\n\n\n\n## 逻辑回归\n\n![](http://images.yingwai.top/picgo/aby3ppt8.png)\n\n逻辑回归是在线性回归的基础上增加了一个Sigmoid函数，因为在秘密共享的情况下计算指数函数很困难，因此可以定义一个近似函数或用多项式去逼近。文中3.5节给出了计算此类函数的方法，这里近似函数可以使用[SecureML](https://yuyingwai.cn/2020/06/17/论文笔记-SecureML-A-System-for-Scalable-Privacy-Preserving-Machine-Learning/)中定义的：\n$$\nf(x) = \\left\\{ \\begin{array}{lcl}0, & \\mbox{if} & x < - \\frac{1}{2} \\\\x + \\frac{1}{2}, & \\mbox{if} & - \\frac{1}{2} \\leq x \\leq \\frac{1}{2} \\\\1, & \\mbox{if} & x > \\frac{1}{2}\\end{array}\\right.\n$$\n![](http://images.yingwai.top/picgo/smlf5.png)\n\n\n\n## 神经网络\n\n![](http://images.yingwai.top/picgo/aby3ppt9.png)\n\n一个神经网络由很多个神经元组成，每一个神经元可以看成是与逻辑回归计算一致的单元，只是最后的非线性函数不一定是Sigmoid函数（替换成ReLU）。","slug":"论文笔记-ABY3-A-Mixed-Protocol-Framework-for-Machine-Learning","published":1,"updated":"2020-08-23T14:33:37.433Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cke79q4pk001l88ps93ss48fq","content":"<p><em>Payman Mohassel, Peter Rindal</em></p>\n<p>CCS 2018</p>\n<p><a href=\"https://dl.acm.org/doi/10.1145/3243734.3243760\" target=\"_blank\" rel=\"noopener\">https://dl.acm.org/doi/10.1145/3243734.3243760</a></p>\n<a id=\"more\"></a>\n<p><img src=\"http://images.yingwai.top/picgo/ABY3.png\" alt=\"\"></p>\n<h1 id=\"本文贡献\"><a href=\"#本文贡献\" class=\"headerlink\" title=\"本文贡献\"></a>本文贡献</h1><ul>\n<li>新的共享十进制数近似定点乘法协议；</li>\n<li>提出了三方的ABY框架，其中许多转换都是基于新技术，并在本文中首次进行了设计和优化；</li>\n<li>提高了矩阵乘法的效率；</li>\n<li>有效的分段多项式函数评估。</li>\n</ul>\n<h1 id=\"计算模型\"><a href=\"#计算模型\" class=\"headerlink\" title=\"计算模型\"></a>计算模型</h1><p>本文采用三方的重复共享，即把一个数 $x$ 拆成三份，各方都拥有三份中的两份，下面是ABY三种共享形式：</p>\n<p><img src=\"http://images.yingwai.top/picgo/aby3ppt4.png\" alt=\"\"></p>\n<p>在这种设置下，三方交互式地计算函数 $f(x)$，本篇文章主要针对机器学习中的算法。</p>\n<p><img src=\"http://images.yingwai.top/picgo/aby3ppt2.png\" alt=\"\"></p>\n<h2 id=\"加法\"><a href=\"#加法\" class=\"headerlink\" title=\"加法\"></a>加法</h2><p>在秘密共享的情况下，计算两个数 $[![x]!], [![y]!]$ 的和 $[![z]!] = [![x]!] + [![y]!]$ 比较简单，各方直接将其对应的份额在本地相加即可，不需要交互：</p>\n<script type=\"math/tex; mode=display\">\nz_i = x_i + y_i</script><h2 id=\"乘法\"><a href=\"#乘法\" class=\"headerlink\" title=\"乘法\"></a>乘法</h2><p>计算两个数 $[![x]!], [![y]!]$ 的积 $[![z]!] = [![x]!] * [![y]!]$ 则复杂一点。在两方共享的情况下，需要借助额外的乘法三元组来计算，开销非常大。而三方下的复制共享这时候就起作用了，将 $xy$ 展开可以观察到有九项，每一项是两个份额的乘积，因此每一方只需要计算其可以计算的九项中的其中三项即可保持结果 $z$ 继续在三方中是加法共享的。计算完成后再把对应的结果发送给另一方，即可保持 $z$ 是重复共享的。</p>\n<p><img src=\"http://images.yingwai.top/picgo/aby3ppt3.png\" alt=\"\"></p>\n<p>可以看到乘法操作只包含了本地操作和各方各一次发送，开销比两方的情况下小很多。</p>\n<h1 id=\"本文的框架\"><a href=\"#本文的框架\" class=\"headerlink\" title=\"本文的框架\"></a>本文的框架</h1><h2 id=\"定点运算\"><a href=\"#定点运算\" class=\"headerlink\" title=\"定点运算\"></a>定点运算</h2><p>定点值定义为使用二进制补码表示的一个 $k$ 位整数，其中底部 $d$ 位表示小数，即对于正值，位 $i$ 表示 $2$ 的 $(i−d)$ 次方。由于预计结果将保持在 $2^k$ 以下，因此可以使用相应的整数运算来执行加法和减法。乘法也可以以相同的方式执行，但是十进制位的数量加倍，因此必须除以 $2^d$ 以保持 $d$ 个十进制位不变。</p>\n<p>在得到乘法结果后，各方可以直接把本地的份额后 $d$ 位截断，但这样会<strong>把原本份额相加的进位也截断了</strong>，导致截断后重构出来的 $\\tilde{x} \\neq x$。作者参考了<a href=\"https://yuyingwai.cn/2020/06/17/论文笔记-SecureML-A-System-for-Scalable-Privacy-Preserving-Machine-Learning/\" target=\"_blank\" rel=\"noopener\">SecureML</a>中的两方协议，给出了他们自己的在三方下的实现：</p>\n<p><img src=\"http://images.yingwai.top/picgo/aby3f1.png\" alt=\"\"></p>\n<p>一开始作者的想法是把 $x’$ 的截断 $x = x’/2^d$ 拆成 $[![x]!] := (x_1, x_2, x_3) = (x’_1/2^d, (x’_2 + x’_3)/2^d-r, r)$，其中 $r$ 是 $\\mathbb{Z}^k_2$ 中的随机数，但发现这样做有两轮通信的限制，于是进一步优化得到上面的协议。</p>\n<h2 id=\"矢量化乘法\"><a href=\"#矢量化乘法\" class=\"headerlink\" title=\"矢量化乘法\"></a>矢量化乘法</h2><p>两个向量作内积定义为 $\\vec{x} \\cdot \\vec{y} := \\sum^n_{i=1} x_i y_i$。在本文的背景下计算内积，朴素的做法是对两个向量的每一个元素都执行一次乘法+截断协议，但这样需要通信 $O(n)$ 次通信。</p>\n<p>于是作者进行了优化：各方只需要在本地将两个向量 $\\vec{x},\\vec{y}$ 的 $n$ 个分量计算相乘的份额，然后把这 $n$ 个积相加就得到了 $z’$ 的3/3共享，最后执行上一小节中的截断协议将 $[![z’]!]$ 截断为 $[![z]!]:= (z’+r’)/2^d - [![r]!]$。</p>\n<p>这样做不仅可以减少通信开销，而且误差也比执行 $n$ 次乘法+截断协议低（总共只进行了一次截断，相对于整体内积的误差为 $2^{-d}$）。</p>\n<h2 id=\"共享转换\"><a href=\"#共享转换\" class=\"headerlink\" title=\"共享转换\"></a>共享转换</h2><p>机器学习中有很多不同的函数，而不同的函数有适合其计算的不同共享方式：算术共享适合计算乘法和加法，而二进制共享适合计算非线性函数、最大池化以及平均值等。两方的情况可以参考<a href=\"https://yuyingwai.cn/2020/06/11/论文笔记-ABY-A-Framework-for-Efficient-Mixed-Protocol-Secure-Two-Party-Computation/\" target=\"_blank\" rel=\"noopener\">ABY</a>，本文给出了三方下的共享转换。</p>\n<p><img src=\"http://images.yingwai.top/picgo/aby3ppt6.png\" alt=\"\"></p>\n<h3 id=\"位分解\"><a href=\"#位分解\" class=\"headerlink\" title=\"位分解\"></a>位分解</h3><p>$[![x]!]^A \\rightarrow [![\\vec{x}]!]^B$</p>\n<p>最基础的想法是各方将其份额 $[![x]!]^A = (x_1, x_2, x_3)$ 输入到布尔电路中计算它们的和，但可以进行优化。观察到 $[![x]!]^A = (x_1, x_2, x_3)$ 可以转换为 $[![x_1]!]^B := (x_1,0,0), [![x_2]!]^B := (0,x_2,0), [![x_3]!]^B := (0,0,x_3)$ 而不需要交互。</p>\n<p>这里没太看懂，用到了各种加法器。作者首先观察到 $x_1 + x_2 + x_3$ 的计算可以减少成执行 $k$ 个相互独立的全加器计算 $2c+s$：$\\mathsf{FA}(x_1[i], x_2[i], x_3[i-1]) \\rightarrow (c[i], s[i])$，其中 $i \\in {0,…,k-1}$。然后再使用平行前缀加法器计算 $2[![c]!]^B + [![s]!]^B$。对于半诚实的情况，$P_2$ 可以提供 $(x_1 + x_2)$ 作为输入计算 $[![x]!]^B := [![x_1 + x_2]!]^B + [![x_3]!]^B$。</p>\n<h3 id=\"位提取\"><a href=\"#位提取\" class=\"headerlink\" title=\"位提取\"></a>位提取</h3><p>$[![x]!]^A \\rightarrow [![x[i]]!]^B$</p>\n<p>跟上面的情况类似，只是这次是提取比特串中的单一比特，把上一小节的电路中不必要的门去掉即可。</p>\n<h3 id=\"位组合\"><a href=\"#位组合\" class=\"headerlink\" title=\"位组合\"></a>位组合</h3><p>$[![x]!]^B \\rightarrow [![x]!]^A$</p>\n<p>用到的还是与上面类似的电路，只是操作顺序有点变化。首先 $P_1, P_2$ 输入一个随机共享 $[![-x_2]!]^B$，$P_2, P_3$ 同样输入一个随机共享 $[![-x_3]!]^B$，这两个将会是最终的转换结果的部分。这里可以利用两方间的密钥作为随机种子来生成随机数。</p>\n<p>然后三方计算 $\\mathsf{FA}([![x[i]]!]^B, [![-x_2[i]]!]^B, [![-x_3[i]]!]^B) \\rightarrow ([![c[i]]!]^B, [![s[i]]!]^B)$，其中 $i \\in {0,…,k-1}$。然后使用并行前缀加法器计算 $[![x_1]!]^B := 2[![c]!]^B + [![s]!]^B$。同样在半诚实下可以进一步优化，$P_2$ 提供 $(-x_2, -x_3)$ 作为输入计算 $[![x_1]!]^B := [![x]!]^B + [![-x_2 - x_3]!]^B$，$x_1$ 对 $P_1, P_3$ 开放，最后的共享定义为 $[![x]!]^A := (x_1, x_2, x_3)$。</p>\n<h3 id=\"位注入\"><a href=\"#位注入\" class=\"headerlink\" title=\"位注入\"></a>位注入</h3><p>$[![x]!]^B \\rightarrow [![x]!]^A$</p>\n<p>当需要将以二进制共享方式编码的单个位 $x$ 提升为算术共享 $[![x]!]^A$ 时，通常会出现另一种特殊情况，参考3.4。</p>\n<h3 id=\"联合姚输入\"><a href=\"#联合姚输入\" class=\"headerlink\" title=\"联合姚输入\"></a>联合姚输入</h3><p>在姚共享中，对于一个比特 $x$，$P<em>1$（评估者）拥有 $k^x</em>{\\mathsf{x}}$ 而另外两方拥有 $k^0<em>{\\mathsf{x}} \\in {0,1}^{\\kappa}$ 和一个全局随机串 $\\Delta \\in {0,1}^{\\kappa}$ 使得 $k^1</em>{\\mathsf{x}} := k^0<em>{\\mathsf{x}} \\oplus \\Delta$。转换到姚共享和从姚共享转换的一个有用的原语是双方提供双方都知道的输入的能力。比如说 $P_1, P_2$ 知道一个比特 $x$，想生成共享 $[![x]!]^Y$。在半诚实设置中比较简单，$P_2$ 可以本地生成并发送 $[![x]!]^Y$ 给 $P_1$。但是在恶意设置下 $P_1$ 需要在不知道 $\\Delta$ 的情况下验证 $[![x]!]^Y$ 正确地将 $x$ 编码。于是 $P_3$ 可以帮助 $P_1$ 进行验证：$P_2, P_3$ 同时发送 $k^0</em>{\\mathsf{x}}$ 和 $k^1_{\\mathsf{x}}$ 的承诺方案给 $P_1$ ，后者可以检查两个承诺是否一致以及是否能打开承诺。</p>\n<h3 id=\"姚共享到二进制共享\"><a href=\"#姚共享到二进制共享\" class=\"headerlink\" title=\"姚共享到二进制共享\"></a>姚共享到二进制共享</h3><p>$[![x]!]^Y \\rightarrow [![x]!]^B$</p>\n<p>在两方的情况下，密钥的最低有效位（置换位）形成 $x$ 的两方共享，即 $x \\oplus p<em>{\\mathsf{x}} = k^x</em>{\\mathsf{x}}[0]$，其中 $p<em>{\\mathsf{x}} = k^0</em>{\\mathsf{x}}[0]$。三方下 $P<em>3$ 也知道 $p</em>{\\mathsf{x}}$，首先 $P<em>1,P_2$ 本地生成随机比特 $r$ 然后 $P_1$ 将 $k^x</em>{\\mathsf{x}}[0] \\oplus r = x \\oplus p<em>{\\mathsf{x}} \\oplus r$ 发送给 $P_3$。于是就完成了共享的转换，原本的共享被转换为 $[![x]!]^B = (x \\oplus p</em>{\\mathsf{x}} \\oplus r, r, p_{\\mathsf{x}})$。</p>\n<p>在恶意的设置下，需要确认 $P<em>1$ 发送给 $P_3$ 的 $x \\oplus b \\oplus r$ 中的 $b = p</em>{\\mathsf{x}}$。首先 $P<em>1, P_2$ 选取 $k^r</em>{\\mathsf{r}} \\leftarrow {0,1}^{\\kappa}$，后者发送 $k^0<em>{\\mathsf{r}} := k^r</em>{\\mathsf{r}} \\oplus (r \\Delta)$ 给 $P<em>3$。然后 $P_2,P_3$ 发送承诺 $C_0 = \\mathsf{Comm}(k^{p</em>{\\mathsf{x}}}<em>{\\mathsf{y}}), C_1 = \\mathsf{Comm}(k^{\\overline{p</em>{\\mathsf{x}}}}<em>{\\mathsf{y}})$ 给 $P_1$，其中 $k^0</em>{\\mathsf{y}} := k^0<em>{\\mathsf{x}} \\oplus k^0</em>{\\mathsf{r}}$。$P<em>1$ 发送 $k^{x \\oplus r}</em>{\\mathsf{y}} := k^x<em>{\\mathsf{x} } \\oplus k^r</em>{\\mathsf{r}}$ 给 $P<em>3$，后者验证其是否在集合 ${k^0</em>{\\mathsf{y}}, k^1<em>{\\mathsf{y}}}$ 中。$P_1$ 同样验证承诺 $C</em>{p<em>{\\mathsf{x}} \\oplus x \\oplus r}$ 是否可以打开为 $k^{x \\oplus r}</em>{\\mathsf{y}}$ 以及 $C<em>0, C_1$ 是否一致。注意到 $x \\oplus p</em>{\\mathsf{x}} = k^x<em>{\\mathsf{x}}[0]$，于是三方就可以计算共享 $[![x]!]^B = (x \\oplus p</em>{\\mathsf{x}} \\oplus r, r, p<em>{\\mathsf{x}})$。观察到 $P_3$ 将 $x \\oplus p</em>{\\mathsf{x}} \\oplus r$ 计算为 $k^{x \\oplus r}<em>{\\mathsf{y}}[0] \\oplus p</em>{\\mathsf{r}}$。</p>\n<h3 id=\"二进制共享到姚共享\"><a href=\"#二进制共享到姚共享\" class=\"headerlink\" title=\"二进制共享到姚共享\"></a>二进制共享到姚共享</h3><p>$[![x]!]^B \\rightarrow [![x]!]^Y$</p>\n<p>设 $[![x]!]^B = (x_1, x_2, x_3)$。各方使用前面讨论的程序共同输入份额 $[![x_1]!]^Y,[![x_2]!]^Y,[![x_3]!]^Y$ 作为联合姚输入。然后可以使用乱码电路来计算最终份额，该电路计算三个值的异或 $[![x]!]^Y := [![x_1]!]^Y \\oplus [![x_2]!]^Y \\oplus [![x_3]!]^Y$ 。使用Free-XOR技术，这不需要三方之间的任何通信，并且可以由 $P_1$ 本地计算。在半诚实的设置中，可以基于 $P_2$ 知道 $x_2$ 和 $x_3$ 这一事实来进一步优化。因此，它们可以本地计算 $x_2 \\oplus x_3$，并将 $[![x_2 \\oplus x_3]!]^Y$ 发送给 $P_1$，后者本地计算 $[![x]!]^Y := [![x_1]!]^Y \\oplus [![x_2 \\oplus x_3]!]^Y$。</p>\n<h3 id=\"姚共享到算术共享\"><a href=\"#姚共享到算术共享\" class=\"headerlink\" title=\"姚共享到算术共享\"></a>姚共享到算术共享</h3><p>$[![x]!]^Y \\rightarrow [![x]!]^A$</p>\n<p>自然的想法是将姚共享先转换成二进制共享，再用位组合中的方法转换为算术共享。作者在这里也给出了优化方案，还是使用到了乱码电路，对这部分看得不是很懂。</p>\n<h3 id=\"算术共享到姚共享\"><a href=\"#算术共享到姚共享\" class=\"headerlink\" title=\"算术共享到姚共享\"></a>算术共享到姚共享</h3><p>$[![x]!]^A \\rightarrow [![x]!]^Y$</p>\n<p>各方联合输入 $[![x]!]^A = (x_1, x_2, x_3)$ 的共享 $[![x_1]!]^Y,[![x_2]!]^Y,[![x_3]!]^Y$。然后使用一个乱码电路生成 $[![x]!]^Y := [![x_1]!]^Y + [![x_2]!]^Y + [![x_3]!]^Y$。</p>\n<h2 id=\"计算-a-A-b-B-ab-A\"><a href=\"#计算-a-A-b-B-ab-A\" class=\"headerlink\" title=\"计算 $[![a]!]^A [![b]!]^B = [![ab]!]^A$\"></a>计算 $[![a]!]^A [![b]!]^B = [![ab]!]^A$</h2><p>虽然将共享转换后再计算上面的公式也可以，但作者在这里给出了更有效的特定协议。在训练Logistic回归和神经网络模型中通常用于逼近非线性激活函数的分段线性或多项式函数的计算需要重复该操作。</p>\n<h3 id=\"半诚实\"><a href=\"#半诚实\" class=\"headerlink\" title=\"半诚实\"></a>半诚实</h3><h4 id=\"三方OT\"><a href=\"#三方OT\" class=\"headerlink\" title=\"三方OT\"></a>三方OT</h4><p>作者首先给出了三方下的不经意传输协议，在两方的OT中有两个角色：sender和receiver。在这里作者添加了一个<em>helper</em>的角色，他不会收到输出且知道receiver的选择位。这个对于(sender, receiver, helper)的功能记为 $((m_0, m_1),c, c) \\mapsto (\\perp, m_c, \\perp)$。</p>\n<p>首先sender和helper选取随机串 $w_0, w_1 \\leftarrow {0,1}^k$。sender将消息盲化：$m_0 \\oplus w_0, m_1 \\oplus w_1$ 然后发送给receiver。helper知道receiver希望收到消息 $m_c$，这样helper可以发送 $w_c$ 给receiver来让后者重构 $m_c$。</p>\n<h4 id=\"计算-a-b-B-ab-A\"><a href=\"#计算-a-b-B-ab-A\" class=\"headerlink\" title=\"计算 $a[![b]!]^B = [![ab]!]^A$\"></a>计算 $a[![b]!]^B = [![ab]!]^A$</h4><p>最简单的一种情况是 $P<em>1$ 知道的一个公共值 $a \\in \\mathbb{Z}</em>{2^k}$ 和一个共享比特 $b \\in {0,1}$ 的乘法。首先 $P<em>3$ (sender)选取随机数 $r \\leftarrow \\mathbb{Z}</em>{2^k}$ 和定义两个消息 $m<em>i := (i \\oplus b_1 \\oplus b_3)a - r$，其中 $i \\in {0,1}$。$P_2$ (receiver)为了学习消息 $m</em>{b<em>2} = (b_2 \\oplus b_1 \\oplus b_3)a - r = ba - r$，定义他的输入为 $b_2$。注意到 $P_1$ (helper)也知道 $b_2$，因此这里可以使用前面提到的三方OT。然后三方本地生成重复0共享 $(s_1, s_2, s_3)$ 来计算 $[![c]!] = [![ab]!] = (s_1 + r, ab-r+s_3, s_3)$。但是为了令这个2/3秘密共享合法，$c_2 = ab - r + s_3$ 要发送给 $P_1$，导致需要总共两轮通信。或者可以(并行地)重复执行三方OT过程，$P_3$ 担任sender输入 $(i+b_2+b_3)a - r + s_3$，其中 $i \\in {0,1}$。于是 $P_1$ (receiver)输入 $b_2$，在第一轮中获知消息 $c_2$（非 $m</em>{b_2}$），总共 $6k$ 比特和 $1$ 轮通信。</p>\n<h4 id=\"计算-a-A-b-B-ab-A-1\"><a href=\"#计算-a-A-b-B-ab-A-1\" class=\"headerlink\" title=\"计算 $[![a]!]^A [![b]!]^B = [![ab]!]^A$\"></a>计算 $[![a]!]^A [![b]!]^B = [![ab]!]^A$</h4><p>在半诚实下，并行地执行两次 $a[![b]!]^B = [![ab]!]^A$ 过程就足够了。关键在于观察到上述计算中的 $a$ 不必是公开的。也就是说，$P_1$ 可以私下选择 $a$ 的值。利用这一点，可以观察到表达式可以写成 $[![a]!][![b]!]^B = a_1[![b]!]^B + (a_2 + a_3)[![b]!]^B$。$P_1$ 充当第一次的sender，$P_3$ 充当第二次的sender。每一方总共在 $1$ 轮上传送 $4k$ 比特。</p>\n<h3 id=\"恶意\"><a href=\"#恶意\" class=\"headerlink\" title=\"恶意\"></a>恶意</h3><h4 id=\"计算-a-b-B-ab-A-1\"><a href=\"#计算-a-b-B-ab-A-1\" class=\"headerlink\" title=\"计算 $a[![b]!]^B = [![ab]!]^A$\"></a>计算 $a[![b]!]^B = [![ab]!]^A$</h4><p>因为 $P_1$ 可以任意选择他输入到OT的值 $a$，所以半诚实方法在恶意设置下不适用。为了避开这一点，作者在这里先执行对 $b$ 的<em>位注入</em>。即计算 $[![b]!]^B \\rightarrow [![b]!]^A$ 然后 $a[![b]!]^A = [![ab]!]^A$。在3.3节中提到，各方可以在本地计算共享 $[![b_1]!]^A, [![b_2]!]^A, [![b_2]!]^A$，其中 $[![b]!]^B = (b_1, b_2, b_3)$。现在可以通过计算 $[![b_1 \\oplus b_2]!]^A = [![d]!]^A :=$ $[![b_1]!]^A + [![b_2]!]^A - 2[![b_1]!]^A[![b_2]!]^A$ 和 $[![b]!]^A := [![d \\oplus b_3]!]^A$ 在算术电路中模拟这些值的异或。然后可以将最终结果计算为 $[![ab]!]^A := a[![b]!]^A$，其中每一方用 $a$ 去乘以自己 $b$ 的份额。</p>\n<h4 id=\"计算-a-A-b-B-ab-A-2\"><a href=\"#计算-a-A-b-B-ab-A-2\" class=\"headerlink\" title=\"计算 $[![a]!]^A [![b]!]^B = [![ab]!]^A$\"></a>计算 $[![a]!]^A [![b]!]^B = [![ab]!]^A$</h4><p>同样，这里可以重复位注入过程，将 $[![b]!]^B$ 转换为 $[![b]!]^A$，然后使用乘法协议计算 $[![a]!]^A[![b]!]^A$。</p>\n<h2 id=\"多项式分段函数\"><a href=\"#多项式分段函数\" class=\"headerlink\" title=\"多项式分段函数\"></a>多项式分段函数</h2><p>设 $f<em>1,…,f_m$ 表示具有公共系数的多项式以及有 $-\\infty = c_0 &lt; c_1 &lt; … &lt; c</em>{m-1} &lt; c<em>m = \\infty$ 使得 $c</em>{i-1}&lt;x \\leq c<em>i$ 时 $f(x) = f_i(x)$。本文的方法是先计算向量 $b_1,…,b_m \\in {0,1}$ 的秘密共享值使得 $b_i = 1 \\Leftrightarrow c</em>{i-1} &lt; x \\leq c_i$，然后 $f$ 可以计算为 $f(x) = \\sum_i b_i f_i(x)$。</p>\n<p><img src=\"http://images.yingwai.top/picgo/aby3ppt5.png\" alt=\"\"></p>\n<p>比如说要比较 $[![x]!]$ 与 $c$ 的大小，可以看成提取 $[![x-c]!]$ 的最高有效位(MSB)（为1时 $x-c&lt;0$）。这里可以对 $[![x-c]!]$ 使用5.3中的位提取来获得二进制共享 $[![b]!]^B := [![\\mathsf{msb}(x-c)]!]^B$。</p>\n<p>每个 $f<em>i$ 函数被表示为多项式 $f_i([![x]!]) = a</em>{i,j}[![x]!]^j + … + a<em>{i,1}[![x]!] + a</em>{i,0}$，其中所有的 $a<em>{i,l}$ 都是公知的常数。当 $f_i$ 为0次多项式时，使用3.4中的技术可以将计算 $b_if_i([![x]!])$ 优化为 $a</em>{i,0}[![b]!]^B$。另外当 $f<em>i$ 的系数为整数时，给定 $[![x]!]^l$，$a</em>{i,l} [![x]!]^l$ 的计算可以在本地进行。但是当 $a_{i,j}$ 有非零小数时，将按照3.1的方法执行交互式截断。</p>\n<h1 id=\"应用到机器学习\"><a href=\"#应用到机器学习\" class=\"headerlink\" title=\"应用到机器学习\"></a>应用到机器学习</h1><p>作者还给出了本文框架分别在线性回归、逻辑回归以及神经网络中的应用。</p>\n<h2 id=\"线性回归\"><a href=\"#线性回归\" class=\"headerlink\" title=\"线性回归\"></a>线性回归</h2><p><img src=\"http://images.yingwai.top/picgo/aby3ppt7.png\" alt=\"\"></p>\n<p>线性回归是比较简单的一种模型，前向运算和更新权重都只包含了加法和乘法操作，因此只要利用前面提到的加法和乘法协议就可以完成一个线性回归模型的训练。</p>\n<h2 id=\"逻辑回归\"><a href=\"#逻辑回归\" class=\"headerlink\" title=\"逻辑回归\"></a>逻辑回归</h2><p><img src=\"http://images.yingwai.top/picgo/aby3ppt8.png\" alt=\"\"></p>\n<p>逻辑回归是在线性回归的基础上增加了一个Sigmoid函数，因为在秘密共享的情况下计算指数函数很困难，因此可以定义一个近似函数或用多项式去逼近。文中3.5节给出了计算此类函数的方法，这里近似函数可以使用<a href=\"https://yuyingwai.cn/2020/06/17/论文笔记-SecureML-A-System-for-Scalable-Privacy-Preserving-Machine-Learning/\" target=\"_blank\" rel=\"noopener\">SecureML</a>中定义的：</p>\n<script type=\"math/tex; mode=display\">\nf(x) = \\left\\{ \\begin{array}{lcl}0, & \\mbox{if} & x < - \\frac{1}{2} \\\\x + \\frac{1}{2}, & \\mbox{if} & - \\frac{1}{2} \\leq x \\leq \\frac{1}{2} \\\\1, & \\mbox{if} & x > \\frac{1}{2}\\end{array}\\right.</script><p><img src=\"http://images.yingwai.top/picgo/smlf5.png\" alt=\"\"></p>\n<h2 id=\"神经网络\"><a href=\"#神经网络\" class=\"headerlink\" title=\"神经网络\"></a>神经网络</h2><p><img src=\"http://images.yingwai.top/picgo/aby3ppt9.png\" alt=\"\"></p>\n<p>一个神经网络由很多个神经元组成，每一个神经元可以看成是与逻辑回归计算一致的单元，只是最后的非线性函数不一定是Sigmoid函数（替换成ReLU）。</p>\n","site":{"data":{}},"excerpt":"<p><em>Payman Mohassel, Peter Rindal</em></p>\n<p>CCS 2018</p>\n<p><a href=\"https://dl.acm.org/doi/10.1145/3243734.3243760\" target=\"_blank\" rel=\"noopener\">https://dl.acm.org/doi/10.1145/3243734.3243760</a></p>","more":"<p><img src=\"http://images.yingwai.top/picgo/ABY3.png\" alt=\"\"></p>\n<h1 id=\"本文贡献\"><a href=\"#本文贡献\" class=\"headerlink\" title=\"本文贡献\"></a>本文贡献</h1><ul>\n<li>新的共享十进制数近似定点乘法协议；</li>\n<li>提出了三方的ABY框架，其中许多转换都是基于新技术，并在本文中首次进行了设计和优化；</li>\n<li>提高了矩阵乘法的效率；</li>\n<li>有效的分段多项式函数评估。</li>\n</ul>\n<h1 id=\"计算模型\"><a href=\"#计算模型\" class=\"headerlink\" title=\"计算模型\"></a>计算模型</h1><p>本文采用三方的重复共享，即把一个数 $x$ 拆成三份，各方都拥有三份中的两份，下面是ABY三种共享形式：</p>\n<p><img src=\"http://images.yingwai.top/picgo/aby3ppt4.png\" alt=\"\"></p>\n<p>在这种设置下，三方交互式地计算函数 $f(x)$，本篇文章主要针对机器学习中的算法。</p>\n<p><img src=\"http://images.yingwai.top/picgo/aby3ppt2.png\" alt=\"\"></p>\n<h2 id=\"加法\"><a href=\"#加法\" class=\"headerlink\" title=\"加法\"></a>加法</h2><p>在秘密共享的情况下，计算两个数 $[![x]!], [![y]!]$ 的和 $[![z]!] = [![x]!] + [![y]!]$ 比较简单，各方直接将其对应的份额在本地相加即可，不需要交互：</p>\n<script type=\"math/tex; mode=display\">\nz_i = x_i + y_i</script><h2 id=\"乘法\"><a href=\"#乘法\" class=\"headerlink\" title=\"乘法\"></a>乘法</h2><p>计算两个数 $[![x]!], [![y]!]$ 的积 $[![z]!] = [![x]!] * [![y]!]$ 则复杂一点。在两方共享的情况下，需要借助额外的乘法三元组来计算，开销非常大。而三方下的复制共享这时候就起作用了，将 $xy$ 展开可以观察到有九项，每一项是两个份额的乘积，因此每一方只需要计算其可以计算的九项中的其中三项即可保持结果 $z$ 继续在三方中是加法共享的。计算完成后再把对应的结果发送给另一方，即可保持 $z$ 是重复共享的。</p>\n<p><img src=\"http://images.yingwai.top/picgo/aby3ppt3.png\" alt=\"\"></p>\n<p>可以看到乘法操作只包含了本地操作和各方各一次发送，开销比两方的情况下小很多。</p>\n<h1 id=\"本文的框架\"><a href=\"#本文的框架\" class=\"headerlink\" title=\"本文的框架\"></a>本文的框架</h1><h2 id=\"定点运算\"><a href=\"#定点运算\" class=\"headerlink\" title=\"定点运算\"></a>定点运算</h2><p>定点值定义为使用二进制补码表示的一个 $k$ 位整数，其中底部 $d$ 位表示小数，即对于正值，位 $i$ 表示 $2$ 的 $(i−d)$ 次方。由于预计结果将保持在 $2^k$ 以下，因此可以使用相应的整数运算来执行加法和减法。乘法也可以以相同的方式执行，但是十进制位的数量加倍，因此必须除以 $2^d$ 以保持 $d$ 个十进制位不变。</p>\n<p>在得到乘法结果后，各方可以直接把本地的份额后 $d$ 位截断，但这样会<strong>把原本份额相加的进位也截断了</strong>，导致截断后重构出来的 $\\tilde{x} \\neq x$。作者参考了<a href=\"https://yuyingwai.cn/2020/06/17/论文笔记-SecureML-A-System-for-Scalable-Privacy-Preserving-Machine-Learning/\" target=\"_blank\" rel=\"noopener\">SecureML</a>中的两方协议，给出了他们自己的在三方下的实现：</p>\n<p><img src=\"http://images.yingwai.top/picgo/aby3f1.png\" alt=\"\"></p>\n<p>一开始作者的想法是把 $x’$ 的截断 $x = x’/2^d$ 拆成 $[![x]!] := (x_1, x_2, x_3) = (x’_1/2^d, (x’_2 + x’_3)/2^d-r, r)$，其中 $r$ 是 $\\mathbb{Z}^k_2$ 中的随机数，但发现这样做有两轮通信的限制，于是进一步优化得到上面的协议。</p>\n<h2 id=\"矢量化乘法\"><a href=\"#矢量化乘法\" class=\"headerlink\" title=\"矢量化乘法\"></a>矢量化乘法</h2><p>两个向量作内积定义为 $\\vec{x} \\cdot \\vec{y} := \\sum^n_{i=1} x_i y_i$。在本文的背景下计算内积，朴素的做法是对两个向量的每一个元素都执行一次乘法+截断协议，但这样需要通信 $O(n)$ 次通信。</p>\n<p>于是作者进行了优化：各方只需要在本地将两个向量 $\\vec{x},\\vec{y}$ 的 $n$ 个分量计算相乘的份额，然后把这 $n$ 个积相加就得到了 $z’$ 的3/3共享，最后执行上一小节中的截断协议将 $[![z’]!]$ 截断为 $[![z]!]:= (z’+r’)/2^d - [![r]!]$。</p>\n<p>这样做不仅可以减少通信开销，而且误差也比执行 $n$ 次乘法+截断协议低（总共只进行了一次截断，相对于整体内积的误差为 $2^{-d}$）。</p>\n<h2 id=\"共享转换\"><a href=\"#共享转换\" class=\"headerlink\" title=\"共享转换\"></a>共享转换</h2><p>机器学习中有很多不同的函数，而不同的函数有适合其计算的不同共享方式：算术共享适合计算乘法和加法，而二进制共享适合计算非线性函数、最大池化以及平均值等。两方的情况可以参考<a href=\"https://yuyingwai.cn/2020/06/11/论文笔记-ABY-A-Framework-for-Efficient-Mixed-Protocol-Secure-Two-Party-Computation/\" target=\"_blank\" rel=\"noopener\">ABY</a>，本文给出了三方下的共享转换。</p>\n<p><img src=\"http://images.yingwai.top/picgo/aby3ppt6.png\" alt=\"\"></p>\n<h3 id=\"位分解\"><a href=\"#位分解\" class=\"headerlink\" title=\"位分解\"></a>位分解</h3><p>$[![x]!]^A \\rightarrow [![\\vec{x}]!]^B$</p>\n<p>最基础的想法是各方将其份额 $[![x]!]^A = (x_1, x_2, x_3)$ 输入到布尔电路中计算它们的和，但可以进行优化。观察到 $[![x]!]^A = (x_1, x_2, x_3)$ 可以转换为 $[![x_1]!]^B := (x_1,0,0), [![x_2]!]^B := (0,x_2,0), [![x_3]!]^B := (0,0,x_3)$ 而不需要交互。</p>\n<p>这里没太看懂，用到了各种加法器。作者首先观察到 $x_1 + x_2 + x_3$ 的计算可以减少成执行 $k$ 个相互独立的全加器计算 $2c+s$：$\\mathsf{FA}(x_1[i], x_2[i], x_3[i-1]) \\rightarrow (c[i], s[i])$，其中 $i \\in {0,…,k-1}$。然后再使用平行前缀加法器计算 $2[![c]!]^B + [![s]!]^B$。对于半诚实的情况，$P_2$ 可以提供 $(x_1 + x_2)$ 作为输入计算 $[![x]!]^B := [![x_1 + x_2]!]^B + [![x_3]!]^B$。</p>\n<h3 id=\"位提取\"><a href=\"#位提取\" class=\"headerlink\" title=\"位提取\"></a>位提取</h3><p>$[![x]!]^A \\rightarrow [![x[i]]!]^B$</p>\n<p>跟上面的情况类似，只是这次是提取比特串中的单一比特，把上一小节的电路中不必要的门去掉即可。</p>\n<h3 id=\"位组合\"><a href=\"#位组合\" class=\"headerlink\" title=\"位组合\"></a>位组合</h3><p>$[![x]!]^B \\rightarrow [![x]!]^A$</p>\n<p>用到的还是与上面类似的电路，只是操作顺序有点变化。首先 $P_1, P_2$ 输入一个随机共享 $[![-x_2]!]^B$，$P_2, P_3$ 同样输入一个随机共享 $[![-x_3]!]^B$，这两个将会是最终的转换结果的部分。这里可以利用两方间的密钥作为随机种子来生成随机数。</p>\n<p>然后三方计算 $\\mathsf{FA}([![x[i]]!]^B, [![-x_2[i]]!]^B, [![-x_3[i]]!]^B) \\rightarrow ([![c[i]]!]^B, [![s[i]]!]^B)$，其中 $i \\in {0,…,k-1}$。然后使用并行前缀加法器计算 $[![x_1]!]^B := 2[![c]!]^B + [![s]!]^B$。同样在半诚实下可以进一步优化，$P_2$ 提供 $(-x_2, -x_3)$ 作为输入计算 $[![x_1]!]^B := [![x]!]^B + [![-x_2 - x_3]!]^B$，$x_1$ 对 $P_1, P_3$ 开放，最后的共享定义为 $[![x]!]^A := (x_1, x_2, x_3)$。</p>\n<h3 id=\"位注入\"><a href=\"#位注入\" class=\"headerlink\" title=\"位注入\"></a>位注入</h3><p>$[![x]!]^B \\rightarrow [![x]!]^A$</p>\n<p>当需要将以二进制共享方式编码的单个位 $x$ 提升为算术共享 $[![x]!]^A$ 时，通常会出现另一种特殊情况，参考3.4。</p>\n<h3 id=\"联合姚输入\"><a href=\"#联合姚输入\" class=\"headerlink\" title=\"联合姚输入\"></a>联合姚输入</h3><p>在姚共享中，对于一个比特 $x$，$P<em>1$（评估者）拥有 $k^x</em>{\\mathsf{x}}$ 而另外两方拥有 $k^0<em>{\\mathsf{x}} \\in {0,1}^{\\kappa}$ 和一个全局随机串 $\\Delta \\in {0,1}^{\\kappa}$ 使得 $k^1</em>{\\mathsf{x}} := k^0<em>{\\mathsf{x}} \\oplus \\Delta$。转换到姚共享和从姚共享转换的一个有用的原语是双方提供双方都知道的输入的能力。比如说 $P_1, P_2$ 知道一个比特 $x$，想生成共享 $[![x]!]^Y$。在半诚实设置中比较简单，$P_2$ 可以本地生成并发送 $[![x]!]^Y$ 给 $P_1$。但是在恶意设置下 $P_1$ 需要在不知道 $\\Delta$ 的情况下验证 $[![x]!]^Y$ 正确地将 $x$ 编码。于是 $P_3$ 可以帮助 $P_1$ 进行验证：$P_2, P_3$ 同时发送 $k^0</em>{\\mathsf{x}}$ 和 $k^1_{\\mathsf{x}}$ 的承诺方案给 $P_1$ ，后者可以检查两个承诺是否一致以及是否能打开承诺。</p>\n<h3 id=\"姚共享到二进制共享\"><a href=\"#姚共享到二进制共享\" class=\"headerlink\" title=\"姚共享到二进制共享\"></a>姚共享到二进制共享</h3><p>$[![x]!]^Y \\rightarrow [![x]!]^B$</p>\n<p>在两方的情况下，密钥的最低有效位（置换位）形成 $x$ 的两方共享，即 $x \\oplus p<em>{\\mathsf{x}} = k^x</em>{\\mathsf{x}}[0]$，其中 $p<em>{\\mathsf{x}} = k^0</em>{\\mathsf{x}}[0]$。三方下 $P<em>3$ 也知道 $p</em>{\\mathsf{x}}$，首先 $P<em>1,P_2$ 本地生成随机比特 $r$ 然后 $P_1$ 将 $k^x</em>{\\mathsf{x}}[0] \\oplus r = x \\oplus p<em>{\\mathsf{x}} \\oplus r$ 发送给 $P_3$。于是就完成了共享的转换，原本的共享被转换为 $[![x]!]^B = (x \\oplus p</em>{\\mathsf{x}} \\oplus r, r, p_{\\mathsf{x}})$。</p>\n<p>在恶意的设置下，需要确认 $P<em>1$ 发送给 $P_3$ 的 $x \\oplus b \\oplus r$ 中的 $b = p</em>{\\mathsf{x}}$。首先 $P<em>1, P_2$ 选取 $k^r</em>{\\mathsf{r}} \\leftarrow {0,1}^{\\kappa}$，后者发送 $k^0<em>{\\mathsf{r}} := k^r</em>{\\mathsf{r}} \\oplus (r \\Delta)$ 给 $P<em>3$。然后 $P_2,P_3$ 发送承诺 $C_0 = \\mathsf{Comm}(k^{p</em>{\\mathsf{x}}}<em>{\\mathsf{y}}), C_1 = \\mathsf{Comm}(k^{\\overline{p</em>{\\mathsf{x}}}}<em>{\\mathsf{y}})$ 给 $P_1$，其中 $k^0</em>{\\mathsf{y}} := k^0<em>{\\mathsf{x}} \\oplus k^0</em>{\\mathsf{r}}$。$P<em>1$ 发送 $k^{x \\oplus r}</em>{\\mathsf{y}} := k^x<em>{\\mathsf{x} } \\oplus k^r</em>{\\mathsf{r}}$ 给 $P<em>3$，后者验证其是否在集合 ${k^0</em>{\\mathsf{y}}, k^1<em>{\\mathsf{y}}}$ 中。$P_1$ 同样验证承诺 $C</em>{p<em>{\\mathsf{x}} \\oplus x \\oplus r}$ 是否可以打开为 $k^{x \\oplus r}</em>{\\mathsf{y}}$ 以及 $C<em>0, C_1$ 是否一致。注意到 $x \\oplus p</em>{\\mathsf{x}} = k^x<em>{\\mathsf{x}}[0]$，于是三方就可以计算共享 $[![x]!]^B = (x \\oplus p</em>{\\mathsf{x}} \\oplus r, r, p<em>{\\mathsf{x}})$。观察到 $P_3$ 将 $x \\oplus p</em>{\\mathsf{x}} \\oplus r$ 计算为 $k^{x \\oplus r}<em>{\\mathsf{y}}[0] \\oplus p</em>{\\mathsf{r}}$。</p>\n<h3 id=\"二进制共享到姚共享\"><a href=\"#二进制共享到姚共享\" class=\"headerlink\" title=\"二进制共享到姚共享\"></a>二进制共享到姚共享</h3><p>$[![x]!]^B \\rightarrow [![x]!]^Y$</p>\n<p>设 $[![x]!]^B = (x_1, x_2, x_3)$。各方使用前面讨论的程序共同输入份额 $[![x_1]!]^Y,[![x_2]!]^Y,[![x_3]!]^Y$ 作为联合姚输入。然后可以使用乱码电路来计算最终份额，该电路计算三个值的异或 $[![x]!]^Y := [![x_1]!]^Y \\oplus [![x_2]!]^Y \\oplus [![x_3]!]^Y$ 。使用Free-XOR技术，这不需要三方之间的任何通信，并且可以由 $P_1$ 本地计算。在半诚实的设置中，可以基于 $P_2$ 知道 $x_2$ 和 $x_3$ 这一事实来进一步优化。因此，它们可以本地计算 $x_2 \\oplus x_3$，并将 $[![x_2 \\oplus x_3]!]^Y$ 发送给 $P_1$，后者本地计算 $[![x]!]^Y := [![x_1]!]^Y \\oplus [![x_2 \\oplus x_3]!]^Y$。</p>\n<h3 id=\"姚共享到算术共享\"><a href=\"#姚共享到算术共享\" class=\"headerlink\" title=\"姚共享到算术共享\"></a>姚共享到算术共享</h3><p>$[![x]!]^Y \\rightarrow [![x]!]^A$</p>\n<p>自然的想法是将姚共享先转换成二进制共享，再用位组合中的方法转换为算术共享。作者在这里也给出了优化方案，还是使用到了乱码电路，对这部分看得不是很懂。</p>\n<h3 id=\"算术共享到姚共享\"><a href=\"#算术共享到姚共享\" class=\"headerlink\" title=\"算术共享到姚共享\"></a>算术共享到姚共享</h3><p>$[![x]!]^A \\rightarrow [![x]!]^Y$</p>\n<p>各方联合输入 $[![x]!]^A = (x_1, x_2, x_3)$ 的共享 $[![x_1]!]^Y,[![x_2]!]^Y,[![x_3]!]^Y$。然后使用一个乱码电路生成 $[![x]!]^Y := [![x_1]!]^Y + [![x_2]!]^Y + [![x_3]!]^Y$。</p>\n<h2 id=\"计算-a-A-b-B-ab-A\"><a href=\"#计算-a-A-b-B-ab-A\" class=\"headerlink\" title=\"计算 $[![a]!]^A [![b]!]^B = [![ab]!]^A$\"></a>计算 $[![a]!]^A [![b]!]^B = [![ab]!]^A$</h2><p>虽然将共享转换后再计算上面的公式也可以，但作者在这里给出了更有效的特定协议。在训练Logistic回归和神经网络模型中通常用于逼近非线性激活函数的分段线性或多项式函数的计算需要重复该操作。</p>\n<h3 id=\"半诚实\"><a href=\"#半诚实\" class=\"headerlink\" title=\"半诚实\"></a>半诚实</h3><h4 id=\"三方OT\"><a href=\"#三方OT\" class=\"headerlink\" title=\"三方OT\"></a>三方OT</h4><p>作者首先给出了三方下的不经意传输协议，在两方的OT中有两个角色：sender和receiver。在这里作者添加了一个<em>helper</em>的角色，他不会收到输出且知道receiver的选择位。这个对于(sender, receiver, helper)的功能记为 $((m_0, m_1),c, c) \\mapsto (\\perp, m_c, \\perp)$。</p>\n<p>首先sender和helper选取随机串 $w_0, w_1 \\leftarrow {0,1}^k$。sender将消息盲化：$m_0 \\oplus w_0, m_1 \\oplus w_1$ 然后发送给receiver。helper知道receiver希望收到消息 $m_c$，这样helper可以发送 $w_c$ 给receiver来让后者重构 $m_c$。</p>\n<h4 id=\"计算-a-b-B-ab-A\"><a href=\"#计算-a-b-B-ab-A\" class=\"headerlink\" title=\"计算 $a[![b]!]^B = [![ab]!]^A$\"></a>计算 $a[![b]!]^B = [![ab]!]^A$</h4><p>最简单的一种情况是 $P<em>1$ 知道的一个公共值 $a \\in \\mathbb{Z}</em>{2^k}$ 和一个共享比特 $b \\in {0,1}$ 的乘法。首先 $P<em>3$ (sender)选取随机数 $r \\leftarrow \\mathbb{Z}</em>{2^k}$ 和定义两个消息 $m<em>i := (i \\oplus b_1 \\oplus b_3)a - r$，其中 $i \\in {0,1}$。$P_2$ (receiver)为了学习消息 $m</em>{b<em>2} = (b_2 \\oplus b_1 \\oplus b_3)a - r = ba - r$，定义他的输入为 $b_2$。注意到 $P_1$ (helper)也知道 $b_2$，因此这里可以使用前面提到的三方OT。然后三方本地生成重复0共享 $(s_1, s_2, s_3)$ 来计算 $[![c]!] = [![ab]!] = (s_1 + r, ab-r+s_3, s_3)$。但是为了令这个2/3秘密共享合法，$c_2 = ab - r + s_3$ 要发送给 $P_1$，导致需要总共两轮通信。或者可以(并行地)重复执行三方OT过程，$P_3$ 担任sender输入 $(i+b_2+b_3)a - r + s_3$，其中 $i \\in {0,1}$。于是 $P_1$ (receiver)输入 $b_2$，在第一轮中获知消息 $c_2$（非 $m</em>{b_2}$），总共 $6k$ 比特和 $1$ 轮通信。</p>\n<h4 id=\"计算-a-A-b-B-ab-A-1\"><a href=\"#计算-a-A-b-B-ab-A-1\" class=\"headerlink\" title=\"计算 $[![a]!]^A [![b]!]^B = [![ab]!]^A$\"></a>计算 $[![a]!]^A [![b]!]^B = [![ab]!]^A$</h4><p>在半诚实下，并行地执行两次 $a[![b]!]^B = [![ab]!]^A$ 过程就足够了。关键在于观察到上述计算中的 $a$ 不必是公开的。也就是说，$P_1$ 可以私下选择 $a$ 的值。利用这一点，可以观察到表达式可以写成 $[![a]!][![b]!]^B = a_1[![b]!]^B + (a_2 + a_3)[![b]!]^B$。$P_1$ 充当第一次的sender，$P_3$ 充当第二次的sender。每一方总共在 $1$ 轮上传送 $4k$ 比特。</p>\n<h3 id=\"恶意\"><a href=\"#恶意\" class=\"headerlink\" title=\"恶意\"></a>恶意</h3><h4 id=\"计算-a-b-B-ab-A-1\"><a href=\"#计算-a-b-B-ab-A-1\" class=\"headerlink\" title=\"计算 $a[![b]!]^B = [![ab]!]^A$\"></a>计算 $a[![b]!]^B = [![ab]!]^A$</h4><p>因为 $P_1$ 可以任意选择他输入到OT的值 $a$，所以半诚实方法在恶意设置下不适用。为了避开这一点，作者在这里先执行对 $b$ 的<em>位注入</em>。即计算 $[![b]!]^B \\rightarrow [![b]!]^A$ 然后 $a[![b]!]^A = [![ab]!]^A$。在3.3节中提到，各方可以在本地计算共享 $[![b_1]!]^A, [![b_2]!]^A, [![b_2]!]^A$，其中 $[![b]!]^B = (b_1, b_2, b_3)$。现在可以通过计算 $[![b_1 \\oplus b_2]!]^A = [![d]!]^A :=$ $[![b_1]!]^A + [![b_2]!]^A - 2[![b_1]!]^A[![b_2]!]^A$ 和 $[![b]!]^A := [![d \\oplus b_3]!]^A$ 在算术电路中模拟这些值的异或。然后可以将最终结果计算为 $[![ab]!]^A := a[![b]!]^A$，其中每一方用 $a$ 去乘以自己 $b$ 的份额。</p>\n<h4 id=\"计算-a-A-b-B-ab-A-2\"><a href=\"#计算-a-A-b-B-ab-A-2\" class=\"headerlink\" title=\"计算 $[![a]!]^A [![b]!]^B = [![ab]!]^A$\"></a>计算 $[![a]!]^A [![b]!]^B = [![ab]!]^A$</h4><p>同样，这里可以重复位注入过程，将 $[![b]!]^B$ 转换为 $[![b]!]^A$，然后使用乘法协议计算 $[![a]!]^A[![b]!]^A$。</p>\n<h2 id=\"多项式分段函数\"><a href=\"#多项式分段函数\" class=\"headerlink\" title=\"多项式分段函数\"></a>多项式分段函数</h2><p>设 $f<em>1,…,f_m$ 表示具有公共系数的多项式以及有 $-\\infty = c_0 &lt; c_1 &lt; … &lt; c</em>{m-1} &lt; c<em>m = \\infty$ 使得 $c</em>{i-1}&lt;x \\leq c<em>i$ 时 $f(x) = f_i(x)$。本文的方法是先计算向量 $b_1,…,b_m \\in {0,1}$ 的秘密共享值使得 $b_i = 1 \\Leftrightarrow c</em>{i-1} &lt; x \\leq c_i$，然后 $f$ 可以计算为 $f(x) = \\sum_i b_i f_i(x)$。</p>\n<p><img src=\"http://images.yingwai.top/picgo/aby3ppt5.png\" alt=\"\"></p>\n<p>比如说要比较 $[![x]!]$ 与 $c$ 的大小，可以看成提取 $[![x-c]!]$ 的最高有效位(MSB)（为1时 $x-c&lt;0$）。这里可以对 $[![x-c]!]$ 使用5.3中的位提取来获得二进制共享 $[![b]!]^B := [![\\mathsf{msb}(x-c)]!]^B$。</p>\n<p>每个 $f<em>i$ 函数被表示为多项式 $f_i([![x]!]) = a</em>{i,j}[![x]!]^j + … + a<em>{i,1}[![x]!] + a</em>{i,0}$，其中所有的 $a<em>{i,l}$ 都是公知的常数。当 $f_i$ 为0次多项式时，使用3.4中的技术可以将计算 $b_if_i([![x]!])$ 优化为 $a</em>{i,0}[![b]!]^B$。另外当 $f<em>i$ 的系数为整数时，给定 $[![x]!]^l$，$a</em>{i,l} [![x]!]^l$ 的计算可以在本地进行。但是当 $a_{i,j}$ 有非零小数时，将按照3.1的方法执行交互式截断。</p>\n<h1 id=\"应用到机器学习\"><a href=\"#应用到机器学习\" class=\"headerlink\" title=\"应用到机器学习\"></a>应用到机器学习</h1><p>作者还给出了本文框架分别在线性回归、逻辑回归以及神经网络中的应用。</p>\n<h2 id=\"线性回归\"><a href=\"#线性回归\" class=\"headerlink\" title=\"线性回归\"></a>线性回归</h2><p><img src=\"http://images.yingwai.top/picgo/aby3ppt7.png\" alt=\"\"></p>\n<p>线性回归是比较简单的一种模型，前向运算和更新权重都只包含了加法和乘法操作，因此只要利用前面提到的加法和乘法协议就可以完成一个线性回归模型的训练。</p>\n<h2 id=\"逻辑回归\"><a href=\"#逻辑回归\" class=\"headerlink\" title=\"逻辑回归\"></a>逻辑回归</h2><p><img src=\"http://images.yingwai.top/picgo/aby3ppt8.png\" alt=\"\"></p>\n<p>逻辑回归是在线性回归的基础上增加了一个Sigmoid函数，因为在秘密共享的情况下计算指数函数很困难，因此可以定义一个近似函数或用多项式去逼近。文中3.5节给出了计算此类函数的方法，这里近似函数可以使用<a href=\"https://yuyingwai.cn/2020/06/17/论文笔记-SecureML-A-System-for-Scalable-Privacy-Preserving-Machine-Learning/\" target=\"_blank\" rel=\"noopener\">SecureML</a>中定义的：</p>\n<script type=\"math/tex; mode=display\">\nf(x) = \\left\\{ \\begin{array}{lcl}0, & \\mbox{if} & x < - \\frac{1}{2} \\\\x + \\frac{1}{2}, & \\mbox{if} & - \\frac{1}{2} \\leq x \\leq \\frac{1}{2} \\\\1, & \\mbox{if} & x > \\frac{1}{2}\\end{array}\\right.</script><p><img src=\"http://images.yingwai.top/picgo/smlf5.png\" alt=\"\"></p>\n<h2 id=\"神经网络\"><a href=\"#神经网络\" class=\"headerlink\" title=\"神经网络\"></a>神经网络</h2><p><img src=\"http://images.yingwai.top/picgo/aby3ppt9.png\" alt=\"\"></p>\n<p>一个神经网络由很多个神经元组成，每一个神经元可以看成是与逻辑回归计算一致的单元，只是最后的非线性函数不一定是Sigmoid函数（替换成ReLU）。</p>"},{"title":"论文笔记 Automatic Unit Test Generation and Execution for JavaScript Program through Symbolic Execution","date":"2020-04-16T07:29:36.000Z","_content":"\n[Hideo Tanida](https://www.semanticscholar.org/author/Hideo-Tanida/2725857), [Guodong Li](https://www.semanticscholar.org/author/Guodong-Li/1720073), [Indradeep Ghosh](https://www.semanticscholar.org/author/Indradeep-Ghosh/3291522), [Tadahiro Uehara](https://www.semanticscholar.org/author/Tadahiro-Uehara/3081128)\n\nPublished in ICSEA 2014\n\nhttps://scholar.google.com/scholar?hl=zh-CN&as_sdt=0%2C5&q=Automatic+Unit+Test+Generation+and+Execution+for+JavaScript+Program+through+Symbolic+Execution&btnG=\n\n<!-- more -->\n\n\n## 摘要及介绍\n\n### 摘要\n\n​\t\t考虑到对更具交互性的Web/移动应用程序的需求，JavaScript有望成为一种使用更广泛的编程语言。虽然JavaScript代码的可靠性将更加重要，但与其他语言相比，该语言的测试技术仍然不足。本文提出了一种为JavaScript代码自动生成高覆盖率单元测试的技术。该技术使用JavaScript代码的符号执行引擎，以及自动为不感兴趣的代码生成存根的存根/驱动程序生成引擎。本文的方法允许全自动生成用于高覆盖率的JavaScript代码单元测试的输入数据，从而以较少的工作量确保目标代码的质量。\n\n\n\n### 主要贡献\n\n* 本文提出了一种在工具**SymJS**上通过符号执行为JavaScript代码生成测试输入的技术；\n* 对比现有工具，本文的约束求解器**PASS**[10]允许为具有各种复杂字符串操作的程序生成测试；\n* 并且不需要对目标代码进行任何修改，而现有的符号执行器需要修改和多次运行，因此适用于现实中的开发；\n* 本文的自动生成存根/驱动程序代码允许完全自动生成测试数据。\n\n\n\n### 现有的工具\n\n​\t\t现有的JavaScript代码测试工具包括**Kudzu**[8]和**Jalangi**[9]。kudzu自动生成程序函数的输入数据，目的是自动发现目标中的安全漏洞。Jalangi允许在正常的具体执行下修改路径约束，以便获得与以前运行不同的结果。然而，由于字符串约束处理方面的限制，以及需要手动创建用于测试的驱动程序/存根，这些工具不能应用于现实中JavaScript代码的单元测试。\n\n\n\n## 背景及基础知识\n\n### 符号执行\n\n​\t\t符号执行（Symbolic Execution）是一种程序分析技术，可以通过分析程序源代码来得到测试输入。通俗来讲，比如说游戏中一个角色在佩戴各种装备之后的面板数值为：攻击力xxx、防御力xxx...；此时通过佩戴装备到获得属性的过程就好比一个程序，佩戴装备的品质就是这个程序的输入，而最后获得的属性就是这个程序的输出；符号执行的过程则是进行分析，从某组给定的属性逆向推导，最后得到某组质量的装备，佩戴这组装备可以获得一开始给定的属性。\n\n#### 符号执行的基本原理\n\n​\t\t符号执行的关键思想是把输入变为符号值，那么程序的输出值就是一个符号输入值的函数。在程序执行期间，获得每个执行路径中的变量的值要满足的约束。在获得程序内所有路径的约束之后，通过将约束提供给诸如可满足性模理论（SMT）[7]求解器之类的求解器，可以获得执行每条路径的输入变量的具体值。\n\n参考：https://zhuanlan.zhihu.com/p/26927127\n\n#### 通过符号执行生成测试输入\n\n​\t\t在程序的符号执行期间，执行每个路径所需要满足的约束是以迭代的方式计算的。在访问程序内每条可能的路径之后，获得所有路径的约束。使用**SMT**等求解器可以获得满足约束条件的变量的具体值。得到的值是与约束条件相对应的，可以用来进行测试。\n\n\n\n### SymJS\n\nSymJS是一个用于自动测试JavaScript Web应用程序客户端的框架，该工具包括一个用于JavaScript的符号执行引擎和一个Web页面的自动的事件资源管理器。而其中符号引擎包括一个符号虚拟机、一个字符串+数字解算器和一个符号可执行DOM模型。\n\n​\t\tSymJS解释从目标程序源代码编译的字节码。现有的符号执行器（如**Klee**[2]和**Symbol Pathfinder**[3]）都采用这种方法。处理字节码而不是源代码允许实现符号执行器，而无需处理语言的复杂语法。SymJS被实现为Rhino字节码的解释器，它在执行每条字节码指令时更新程序状态(堆/栈内容和路径条件)。在命中分支指令时，它复制程序状态并继续执行两个分支。\n\n|    Tool     | Target Lang. | Sym.VM | Dep./Cache Solving | String Solving |\n| :---------: | :----------: | :----: | :----------------: | :------------: |\n|    SymJS    |  JavaScript  |  Yes   |        Yes         |      Yes       |\n|  KLEE [2]   |      C       |  Yes   |        Yes         |       No       |\n|  SAGE [6]   |  x86 binary  |   No   |        Yes         |       No       |\n| Sym JPF [3] |     Java     |  Yes   |         No         |       No       |\n|  Kudzu [8]  |  JavaScript  |   No   |         No         |      Yes       |\n| Jalangi [9] |  JavaScript  |   No   |         No         |    Limited     |\n\n<center>\n    <i>表I 符号执行器的比较</i>\n</center>\n\n\n​\t\t为了实现目标程序的符号执行，本文修改了原始Rhino对表II中所示指令的解释。堆栈操作、异常处理和变量范围管理的指令处理保持不变。\n\n\n\n|              操作              |                             指令                             |\n| :----------------------------: | :----------------------------------------------------------: |\n| Arithemetic/Logical Operations | ADD, SUB, MUL, DIV, MOD, NEG, POS, BITNOT, BITAND, BITOR, BITXOR, LSH, RSH,URSH *etc.* |\n|          Comparisons           |        EQ, NE, GE, GT, LE, LT, NOT, SHEQ, SHNE *etc.*        |\n|            Branches            |                 IFEQ, IFNE, IFEQ_POP *etc.*                  |\n|         Function Calls         |                RETURN, CALL, TAIL_CALL *etc.*                |\n|      Object Manipulations      | NEW, REF, IN, INSTANCEOF, TYPEOF, GETNAME, SETNAME, NAME *etc.* |\n|        Object Accesses         | GETPROP, SETPROP, DELPROP, GETELEM, SETELEM, GETREF, SETREF *etc.* |\n\n<center>\n    <i>表II 修改后的指令解释</i>\n</center>\n例如，指令 `ADD op1 op2` 解释如下：\n\n(1)从堆栈中弹出操作数 `op1` 和 `op2` 。操作数可以使用抽象的值，也可以使用具体的值。\n\n(2)检查操作数的类型。如果两个操作数都是字符串，则计算结果是操作数的拼接。如果它们是数值，则结果是操作数的总和。否则，将**根据ECMAScript语言标准转换值**，结果是将获得的值拼接或相加。\n\n#### 分支指令\n\n​\t\t比较指令之后是Rhino字节码中的分支指令。SymJS处理比较和分支指令对，如下所示：\n\n​\t\t首先，在进行必要的类型转换后，生成与比较结果相对应的布尔公式。假设所创建的公式由符号 $c$ 表示，我们检查 $c$ 及其否定 $\\neg c$ 是否与路径条件 $pc$ 一起满足。换句话说，我们检查 $pc \\land c$ 和 $pc \\land \\neg c$ 的可满足性。如果两者都是可满足的，我们建立对应于 $pc \\land c$ 和 $pc \\land \\neg c$ 的状态 $s_1, s_2$，并从状态 $s_1$ 和 $s_2$ 继续执行。如果其中一个是可满足的，则选择与可满足的状态相对应的状态，并从该点继续执行。\n\n​\t\tSymJS支持两种方式来管理在命中分支等情况下创建的状态。第一种方法是**存储程序状态变量，包括堆/栈的内容**，如[2] [3]中所做的那样。第二种方法是**只记住在分支上走哪一侧。此方法需要在回溯时从初始状态重新执行目标程序。**但是，它得益于其简单的实现和较小的内存占用。这种方法被称为“模糊”，类似于[4] [6]中介绍的技术。但是，本文的技术是在符号执行器上实现的，不需要修改现有JavaScript工具[8] [9]所需的目标代码。\n\n​\t\t在通过模糊化执行程序的符号过程中，状态仅由分支上的哪一方表示和存储。该信息可用于从程序的初始状态重新执行该程序，并探索目标可能采取的状态空间。在模糊化期间，用与表I中的测试1-6相对应的路径条件符号执行图1中的目标程序之后的状态如表IV所示。符号L、R表示在分支指令上走左/右分支。\n\n```javascript\nfunction func0 (s, a) {\n    if(””.equals(s)) { // block 0\n\t\ts = null;\n\t} else {\n\t\tif (s.length <= 5) { // block 1\n\t\t\ta = a + status;\n\t\t} else {\n\t\t\tif(””.equals(s)) { // block 2\n\t\t\t\tLib.m0(); // Unreachable\n\t\t\t} else { // block 3\n\t\t\t\tLib.m1();\n\t\t\t}\n\t\t}\n\t}\n\tif (a <= Lib.m2()) { // block A\n\ta = 0;\n\t} else { // block B\n\ta = a + s.length; // Error with null s\n\t}\n}\n```\n\n<center>\n    <i>图1 一个代码框架：\n    s, a, Lib.m2()可以取任意值</i>\n</center>\n\n\n\n![](http://images.yingwai.top/picgo/SymJSf2.png)\n\n<center>\n    <i>图2 代码执行路径</i>\n</center>\n\n\n\n| Test No. | Blocks Executed | State Representation |\n| :------: | :-------------- | -------------------- |\n|    1     | 0, A            | L;L                  |\n|    2     | 0, B            | L;R                  |\n|    3     | 1, A            | R;L;L                |\n|    4     | 1, B            | R;L;R                |\n|    5     | 3, A            | R;R;R;L              |\n|    6     | 3, B            | R;R;R;R              |\n\n<center>\n    <i>表IV 执行图1代码后的模糊表示</i>\n</center>\n\n\n\n#### PASS\n\n​\t\t对于表IV中的每个状态表示，可以获得相应的路径条件。如果有可能获得满足约束条件的解，则可以将其用作测试期间的输入。关于数值的约束可以通过SMT求解器来解决，但**SMT不能处理对于字符串的约束**。因此本文使用约束求解器PASS。\n\n​\t\t**PASS可以处理对整数、位向量、浮点数和字符串的约束。**虽然以前的支持字符串约束的约束解算器使用位向量或自动机，但通过参数化数组传递引入的建模可以实现更高效的求解。因此，它可以解决ECMAScript标准中与字符串操作相对应的大部分约束。\n\n\n\n#### 符号存根及驱动程序\n\n​\t\t符号变量是通过符号执行生成测试输入的对象。**SymJS允许通过函数调用定义符号变量。**下面的代码片段展示了定义符号字符串变量的例子：\n\n`var s = symjs_mk_symbol_string();`\n\n​\t\t以上的例子定义了字符串类型的符号变量，也可以通过`symjs_mk_symbolic_int()`、`symjs_mk_symbolic_bool()`和`symjs_mk_symbolic_real()`分别定义整型、布尔型以及浮点型的符号变量。虽然SymJS只允许字符串、整数、布尔值和浮点数是符号的，但它们的约束作为更复杂的对象的组成部分保留在赋值/引用上，从而允许生成对象组成部分的值不断变化的测试。\n\n​\t\t为了确定图1中函数`func0()`的测试输入，需要额外的代码段。首先需要一个如下所示的符号驱动程序：\n\n```javascript\nvar s = symjs_mk_symbolic_string();\nvar a = symjs_mk_symbolic_float();\nfunc0(s, a);\n```\n\n<center>\n    <i>图3 用于执行图1中代码的符号驱动程序</i>\n</center>\n\n驱动程序声明符号变量并将它们作为参数传递给函数。注入依赖项的存根也是必需的。如下所示的符号存根包括符号变量声明。通过存根，包含对`Lib.m2()`的函数调用的返回值，以测试SymJS获得的输入。\n\n```javascript\nLib.m2 = function() {\n    return symjs_mk_symbolic_float();\n};\n```\n\n<center>\n    <i>图4 提供图1中代码使用的Lib.m2()的符号存根</i>\n</center>\n\n函数`symjs_mk_symbolic_*()`是用于在测试生成期间定义新符号变量的表达式。**SymJS允许使用生成的测试输入进行正常的具体执行。**在具体执行期间，函数返回测试输入中包含的具体值。SymJS可以将测试输入导出为JavaScript Object Notation (JSON) 格式的外部文件。文件可以由测试回放库读取，该库在`symjs_mk_symbolic_*()`函数调用中返回相应的测试输入数据。加载到典型Web浏览器中的测试库可以在没有自定义JavaScript解释器的情况下执行生成的测试。\n\n\n\n## 符号存根及驱动程序的自动生成\n\n​\t\t如第2部分所述，符号存根和驱动程序需要对目标函数进行符号执行并获得测试输入。返回符号变量的符号存根用于生成从被测函数调用的函数的返回值。需要符号驱动程序来改变传递给测试函数的参数。\n\n### 生成符号存根和驱动程序的策略\n\n​\t\t本文的符号存根生成技术为指定的函数和类生成存根。本文的驱动程序生成技术发出调用指定函数的代码。\n\n​\t\t对于存根生成，生成函数根据调用者期望的返回值类型，创建和返回对象。以下是预期类型与返回对象之间的映射关系：\n\n* 字符串、整数、布尔值和浮点数这些可以被SymJS作为符号处理的类型（后面称为SymJS基础类型）：\n\n  新定义的相应类型的符号变量。\n\n* 其他类：\n\n  预期类型的新实例化对象。如果该类的目标是生成存根，则返回**新实例化的存根对象**。\n\n* Void：不返回任何内容。\n\n​\t\t为了创建类的存根，还需要生成构造函数的存根。在这里，本文生成空构造函数，这将导致所有无状态对象。我们的方法假设没有对存根类的字段的直接访问，并且不为字段生成存根。\n\n​\t\t注意：即使返回值类型不是SymJS的基本类型，也可能得到多个测试输入。如果在返回的对象中定义的函数返回符号变量，会出现这种情况。如果**非SymJS基本类型的对象包含返回SymJS基本类型的对象的函数，并且非SymJS基本类型生成了存根**，就会发生这种情况。因此可以通过调用返回非SymJS基本类型的函数来获得多组测试输入。\n\n​\t\t使用本文的技术生成的符号驱动程序具有以下功能：\n\n* 如果待测函数不是静态的、需要一个实例去执行，则实例化对应类的对象并调用该函数\n* 如果待测函数是静态的，就直接调用函数\n\n对于传递给函数的参数，驱动程序根据预期类型提供以下对象：\n\n* SymJS基本类型：\n\n  新定义的相应类型的符号变量。\n\n* 其他类：\n\n  预期类型的新实例化对象。如果该类的目标是存根生成，则传递新实例化的存根对象。\n\n​\t\t选择参数的方式类似于解决在符号存根中返回什么的方式。\n\n### 从注释生成符号存根和驱动程序\n\n​\t\t上一部分提出的符号存根/驱动程序生成策略需要知道来自目标代码的类型信息，生成存根需要调用方期望的返回值类型，需要传递给被测函数的参数类型才能生成驱动程序。\n\n​\t\t但是JavaScript是一种动态类型语言，在真正运行前很难确定返回值和参数的类型。很多JavaScript程序对返回值和参数的类型有一个期望，通常是在应用程序编程接口（API）等中给出的。此外，有一种方法可以**用机器可读的方式表示JavaScript代码的类型信息**，就是JSDoc风格的注释。本文从JSDoc3[13]约定的风格的注释中获取类型信息，生成符号存根和驱动程序。\n\n​\t\tJSDoc3主要允许通过`@return`注释声明返回值类型。为了为图1的代码片段中使用的函数`Lib.m2()`生成符号存根，需要如下所示的注释：\n\n```javascript\n/** @return {Number} m2 value */\nLib.m2 = function() { ... };\n```\n\n如果将此类注释附加到函数的原始源代码，则可以确定返回值的类型。根据获得的返回值类型，可以以全自动的方式生成图4中的符号存根。该示例演示了为返回SymJS原语的函数生成符号存根。下面展示了为返回非SymJS基本类型的函数生成符号存根的示例：\n\n```javascript\n/** @return {tx.Data} data */\ntx.Ui.getValue = function(){ ... };\n```\n\n<center>\n    ↓\n</center>\n\n```javascript\ntx.Ui.getValue = function(){\n    return new tx.Data();\n};\n```\n\n​\t\t符号驱动程序的生成也是一样的。\n\n​\t\t传递给函数的参数类型通常使用JSDoc3的`@param`注释给出。函数`func0()`的符号驱动程序可以从该函数中的注释生成：\n\n```javascript\n/** @param {String} s\n  * @param {Number} a */\nfunction func0(s, a) { ... }\n```\n\n注释给出了函数的参数类型，允许生成图3中的符号驱动程序。\n\n​\t\t提出的自动生成符号存根和驱动程序的技术是作为JSDoc3的插件实现的。也可以使用其他来源的类型信息，例如API规范文档。\n\n\n\n## Evaluation\n\n​\t\t本文使用一个工业JavaScript程序进行了实验。该程序对应于在本文的自定义Web应用程序实现框架上实现的Web应用程序的客户端部分。该程序调用未在我们的框架中包装的ECMAScript标准中定义的API，并且它只包含对标准API或本文的框架的调用。表V显示了目标程序的统计数据：\n\n| #Line | #Function | #File |\n| :---: | :-------: | :---: |\n|  431  |    23     |   1   |\n\n<center>\n    <i>表V 目标程序的统计数据</i>\n</center>\n\n### 符号存根和驱动程序的生成\n\n​\t\t使用本文的方法成功地为框架中定义的所有类和函数生成存根。表VI列出了生成的存根的统计数据：\n\n| #Line(Orig.) | #Line(Stub) | #Function | #File |\n| :----------: | :---------: | :-------: | :---: |\n|     2843     |    1304     |    154    |  13   |\n\n<center>\n    <i>表VI 用于生成存根的框架源代码和生成的存根的统计数据</i>\n</center>\n\n### 生成测试输入和执行测试\n\n​\t\t所有函数的符号执行在1秒内完成，并生成测试输入。测试输入的数量（将具体值赋给符号变量）在目标函数之间是不同的。对于没有分支的函数，只生成1个测试输入，而对于更复杂的函数，获得的测试数量变化到27个。\n\n​\t\t利用获得的测试输入来具体执行目标函数。运行在网络浏览器上的测试回放库用于重放测试。使用JSCover[14]测量测试期间的代码覆盖率，获得92%的行覆盖率。结果表明，该技术能够自动生成单元测试输入，实现高代码覆盖率。\n\n### 实验中未覆盖的代码\n\n​\t\t实验结果表明，该方法可以生成代码覆盖率较高的测试输入，但没有达到100%的覆盖率，这意味着目标程序的某些部分没有被执行。以下是使用我们的方法未执行到的代码类。\n\n​\t\t**意外类型的代码处理对象没有被覆盖到。**由于JavaScript是一种动态类型语言，函数可能会返回意外类型的对象。为了处理这种情况，目标程序包含类型检查和后续错误处理代码。但是，通过本文的技术生成的符号存根总是返回源代码批注中描述的类型的对象。这样的存根不能利用处理不同于注释类型的对象的代码部分。\n\n​\t\t**没有对象类型前提的代码也没有被覆盖到。**目标程序包含在运行时确定对象类型并相应地处理它们的代码片段。然而，本文的技术不能涵盖这样的程序。从返回值类型未知的函数中，我们生成返回默认JavaScript “Object” 的存根。因此，与自定义类的对象交互的代码没有被覆盖。\n\n\n\n## Conclusions\n\n​\t\t本文提出了一种为JavaScript代码自动生成单元测试输入数据的技术。该技术使用符号执行引擎，以便在测试期间实现高代码覆盖率。该技术分为两个阶段，由以下全自动步骤组成：\n\n* 基于从注释获得的类型信息生成符号存根/驱动程序\n* 通过目标代码的符号执行生成测试输入\n\n​\t\t实验结果显示，该技术可以生成92%的行覆盖率的测试，表明本文的技术可以自动生成和执行JavaScript代码的单元测试。\n\n### Future Work\n\n​\t\t未来的方向包括更多的验证试验和各种目标程序。虽然作者已经用相对较小的程序进行了实验，但也需要在较大的目标上进行实验。\n\n​\t\t根据实验结果，需要改进符号存根。可以使用引发异常的符号存根触发代码处理异常。除了更复杂的自动存根生成策略外，手动修改自动生成的存根被认为是增加覆盖率的有效方法。\n\n\n\n## 参考文献\n\n[1] C. Cadar, V . Ganesh, P . M. Pawlowski, D. L. Dill, and D. R. Engler, *“EXE: Automatically Generating Inputs of Death,”* in Proceedings of the 13th ACM Conference on Computer and Communications Security, 2006, pp. 322–335.\n\n[2] C. Cadar, D. Dunbar, and D. Engler, *“KLEE: Unassisted and Automatic Generation of High-coverage Tests for Complex Systems Programs,”* in Proceedings of the 8th USENIX Conference on Operating Systems Design and Implementation, 2008, pp. 209–224.\n\n[3] C. S. Pǎsǎreanu and N. Rungta, *“Symbolic PathFinder: Symbolic Execution of Java Bytecode,”* in Proceedings of the IEEE/ACM International Conference on Automated Software Engineering, 2010, pp. 179–180.\n\n[4] K. Sen, D. Marinov, and G. Agha, *“CUTE: A Concolic Unit Testing Engine for C,”* in Proceedings of the 10th European Software Engineering Conference, 2005, pp. 263–272.\n\n[5] N. Tillmann and J. De Halleux, *“Pex: White Box Test Generation for .NET,”* in Proceedings of the 2nd International Conference on Tests and Proofs, ser. TAP’08, 2008, pp. 134–153.\n\n[6] P . Godefroid, M. Y . Levin, and D. Molnar, *“SAGE: Whitebox Fuzzing for Security Testing,”* Queue, 2012, pp. 20:20–20:27.\n\n[7] L. De Moura and N. Bjørner, *“Satisfiability Modulo Theories: Introduction and Applications,”* Commun. ACM, vol. 54, no. 9, 2011, pp. 69–77.\n\n[8] P. Saxena, D. Akhawe, S. Hanna, F. Mao, S. McCamant, and D. Song, *“A Symbolic Execution Framework for JavaScript,”* in Proceedings of the 2010 IEEE Symposium on Security and Privacy, 2010, pp. 513–528.\n\n[9] K. Sen, S. Kalasapur, T. Brutch, and S. Gibbs, *“Jalangi: A selective record-replay and dynamic analysis framework for javascript,”* in Proceedings of the 2013 9th Joint Meeting on Foundations of Software Engineering, 2013, pp. 488–498.\n\n[10] G. Li and I. Ghosh, *“PASS: String Solving with Parameterized Array and Interval Automaton,”* in Proceedings of Haifa Verification Conference, 2013, pp. 15–31.\n\n[11] ECMA International, Standard ECMA-262 - ECMAScript Language Specification, 5th ed., June 2011. [Online]. Available: http://www.ecma-international.org/publications/standards/Ecma-262.htm\n\n[12] *“Rhino,”* https://developer.mozilla.org/en-US/docs/Rhino, [Online; accessed 2014.08.15].\n\n[13] *“Use JSDoc,”* http://usejsdoc.org/index.html, [Online; accessed 2014.08.15].\n\n[14] *“JSCover - JavaScript code coverage,”* http://tntim96.github.io/JSCover/ http://usejsdoc.org/index.html, [Online; accessed 2014.08.15].","source":"_posts/论文笔记-Automatic-Unit-Test-Generation-and-Execution-for-JavaScript-Program-through-Symbolic-Execution.md","raw":"---\ntitle: >-\n  论文笔记 Automatic Unit Test Generation and Execution for JavaScript Program\n  through Symbolic Execution\ndate: 2020-04-16 15:29:36\ncategories: Papers\ntags: [JavaScript, 测试]\n---\n\n[Hideo Tanida](https://www.semanticscholar.org/author/Hideo-Tanida/2725857), [Guodong Li](https://www.semanticscholar.org/author/Guodong-Li/1720073), [Indradeep Ghosh](https://www.semanticscholar.org/author/Indradeep-Ghosh/3291522), [Tadahiro Uehara](https://www.semanticscholar.org/author/Tadahiro-Uehara/3081128)\n\nPublished in ICSEA 2014\n\nhttps://scholar.google.com/scholar?hl=zh-CN&as_sdt=0%2C5&q=Automatic+Unit+Test+Generation+and+Execution+for+JavaScript+Program+through+Symbolic+Execution&btnG=\n\n<!-- more -->\n\n\n## 摘要及介绍\n\n### 摘要\n\n​\t\t考虑到对更具交互性的Web/移动应用程序的需求，JavaScript有望成为一种使用更广泛的编程语言。虽然JavaScript代码的可靠性将更加重要，但与其他语言相比，该语言的测试技术仍然不足。本文提出了一种为JavaScript代码自动生成高覆盖率单元测试的技术。该技术使用JavaScript代码的符号执行引擎，以及自动为不感兴趣的代码生成存根的存根/驱动程序生成引擎。本文的方法允许全自动生成用于高覆盖率的JavaScript代码单元测试的输入数据，从而以较少的工作量确保目标代码的质量。\n\n\n\n### 主要贡献\n\n* 本文提出了一种在工具**SymJS**上通过符号执行为JavaScript代码生成测试输入的技术；\n* 对比现有工具，本文的约束求解器**PASS**[10]允许为具有各种复杂字符串操作的程序生成测试；\n* 并且不需要对目标代码进行任何修改，而现有的符号执行器需要修改和多次运行，因此适用于现实中的开发；\n* 本文的自动生成存根/驱动程序代码允许完全自动生成测试数据。\n\n\n\n### 现有的工具\n\n​\t\t现有的JavaScript代码测试工具包括**Kudzu**[8]和**Jalangi**[9]。kudzu自动生成程序函数的输入数据，目的是自动发现目标中的安全漏洞。Jalangi允许在正常的具体执行下修改路径约束，以便获得与以前运行不同的结果。然而，由于字符串约束处理方面的限制，以及需要手动创建用于测试的驱动程序/存根，这些工具不能应用于现实中JavaScript代码的单元测试。\n\n\n\n## 背景及基础知识\n\n### 符号执行\n\n​\t\t符号执行（Symbolic Execution）是一种程序分析技术，可以通过分析程序源代码来得到测试输入。通俗来讲，比如说游戏中一个角色在佩戴各种装备之后的面板数值为：攻击力xxx、防御力xxx...；此时通过佩戴装备到获得属性的过程就好比一个程序，佩戴装备的品质就是这个程序的输入，而最后获得的属性就是这个程序的输出；符号执行的过程则是进行分析，从某组给定的属性逆向推导，最后得到某组质量的装备，佩戴这组装备可以获得一开始给定的属性。\n\n#### 符号执行的基本原理\n\n​\t\t符号执行的关键思想是把输入变为符号值，那么程序的输出值就是一个符号输入值的函数。在程序执行期间，获得每个执行路径中的变量的值要满足的约束。在获得程序内所有路径的约束之后，通过将约束提供给诸如可满足性模理论（SMT）[7]求解器之类的求解器，可以获得执行每条路径的输入变量的具体值。\n\n参考：https://zhuanlan.zhihu.com/p/26927127\n\n#### 通过符号执行生成测试输入\n\n​\t\t在程序的符号执行期间，执行每个路径所需要满足的约束是以迭代的方式计算的。在访问程序内每条可能的路径之后，获得所有路径的约束。使用**SMT**等求解器可以获得满足约束条件的变量的具体值。得到的值是与约束条件相对应的，可以用来进行测试。\n\n\n\n### SymJS\n\nSymJS是一个用于自动测试JavaScript Web应用程序客户端的框架，该工具包括一个用于JavaScript的符号执行引擎和一个Web页面的自动的事件资源管理器。而其中符号引擎包括一个符号虚拟机、一个字符串+数字解算器和一个符号可执行DOM模型。\n\n​\t\tSymJS解释从目标程序源代码编译的字节码。现有的符号执行器（如**Klee**[2]和**Symbol Pathfinder**[3]）都采用这种方法。处理字节码而不是源代码允许实现符号执行器，而无需处理语言的复杂语法。SymJS被实现为Rhino字节码的解释器，它在执行每条字节码指令时更新程序状态(堆/栈内容和路径条件)。在命中分支指令时，它复制程序状态并继续执行两个分支。\n\n|    Tool     | Target Lang. | Sym.VM | Dep./Cache Solving | String Solving |\n| :---------: | :----------: | :----: | :----------------: | :------------: |\n|    SymJS    |  JavaScript  |  Yes   |        Yes         |      Yes       |\n|  KLEE [2]   |      C       |  Yes   |        Yes         |       No       |\n|  SAGE [6]   |  x86 binary  |   No   |        Yes         |       No       |\n| Sym JPF [3] |     Java     |  Yes   |         No         |       No       |\n|  Kudzu [8]  |  JavaScript  |   No   |         No         |      Yes       |\n| Jalangi [9] |  JavaScript  |   No   |         No         |    Limited     |\n\n<center>\n    <i>表I 符号执行器的比较</i>\n</center>\n\n\n​\t\t为了实现目标程序的符号执行，本文修改了原始Rhino对表II中所示指令的解释。堆栈操作、异常处理和变量范围管理的指令处理保持不变。\n\n\n\n|              操作              |                             指令                             |\n| :----------------------------: | :----------------------------------------------------------: |\n| Arithemetic/Logical Operations | ADD, SUB, MUL, DIV, MOD, NEG, POS, BITNOT, BITAND, BITOR, BITXOR, LSH, RSH,URSH *etc.* |\n|          Comparisons           |        EQ, NE, GE, GT, LE, LT, NOT, SHEQ, SHNE *etc.*        |\n|            Branches            |                 IFEQ, IFNE, IFEQ_POP *etc.*                  |\n|         Function Calls         |                RETURN, CALL, TAIL_CALL *etc.*                |\n|      Object Manipulations      | NEW, REF, IN, INSTANCEOF, TYPEOF, GETNAME, SETNAME, NAME *etc.* |\n|        Object Accesses         | GETPROP, SETPROP, DELPROP, GETELEM, SETELEM, GETREF, SETREF *etc.* |\n\n<center>\n    <i>表II 修改后的指令解释</i>\n</center>\n例如，指令 `ADD op1 op2` 解释如下：\n\n(1)从堆栈中弹出操作数 `op1` 和 `op2` 。操作数可以使用抽象的值，也可以使用具体的值。\n\n(2)检查操作数的类型。如果两个操作数都是字符串，则计算结果是操作数的拼接。如果它们是数值，则结果是操作数的总和。否则，将**根据ECMAScript语言标准转换值**，结果是将获得的值拼接或相加。\n\n#### 分支指令\n\n​\t\t比较指令之后是Rhino字节码中的分支指令。SymJS处理比较和分支指令对，如下所示：\n\n​\t\t首先，在进行必要的类型转换后，生成与比较结果相对应的布尔公式。假设所创建的公式由符号 $c$ 表示，我们检查 $c$ 及其否定 $\\neg c$ 是否与路径条件 $pc$ 一起满足。换句话说，我们检查 $pc \\land c$ 和 $pc \\land \\neg c$ 的可满足性。如果两者都是可满足的，我们建立对应于 $pc \\land c$ 和 $pc \\land \\neg c$ 的状态 $s_1, s_2$，并从状态 $s_1$ 和 $s_2$ 继续执行。如果其中一个是可满足的，则选择与可满足的状态相对应的状态，并从该点继续执行。\n\n​\t\tSymJS支持两种方式来管理在命中分支等情况下创建的状态。第一种方法是**存储程序状态变量，包括堆/栈的内容**，如[2] [3]中所做的那样。第二种方法是**只记住在分支上走哪一侧。此方法需要在回溯时从初始状态重新执行目标程序。**但是，它得益于其简单的实现和较小的内存占用。这种方法被称为“模糊”，类似于[4] [6]中介绍的技术。但是，本文的技术是在符号执行器上实现的，不需要修改现有JavaScript工具[8] [9]所需的目标代码。\n\n​\t\t在通过模糊化执行程序的符号过程中，状态仅由分支上的哪一方表示和存储。该信息可用于从程序的初始状态重新执行该程序，并探索目标可能采取的状态空间。在模糊化期间，用与表I中的测试1-6相对应的路径条件符号执行图1中的目标程序之后的状态如表IV所示。符号L、R表示在分支指令上走左/右分支。\n\n```javascript\nfunction func0 (s, a) {\n    if(””.equals(s)) { // block 0\n\t\ts = null;\n\t} else {\n\t\tif (s.length <= 5) { // block 1\n\t\t\ta = a + status;\n\t\t} else {\n\t\t\tif(””.equals(s)) { // block 2\n\t\t\t\tLib.m0(); // Unreachable\n\t\t\t} else { // block 3\n\t\t\t\tLib.m1();\n\t\t\t}\n\t\t}\n\t}\n\tif (a <= Lib.m2()) { // block A\n\ta = 0;\n\t} else { // block B\n\ta = a + s.length; // Error with null s\n\t}\n}\n```\n\n<center>\n    <i>图1 一个代码框架：\n    s, a, Lib.m2()可以取任意值</i>\n</center>\n\n\n\n![](http://images.yingwai.top/picgo/SymJSf2.png)\n\n<center>\n    <i>图2 代码执行路径</i>\n</center>\n\n\n\n| Test No. | Blocks Executed | State Representation |\n| :------: | :-------------- | -------------------- |\n|    1     | 0, A            | L;L                  |\n|    2     | 0, B            | L;R                  |\n|    3     | 1, A            | R;L;L                |\n|    4     | 1, B            | R;L;R                |\n|    5     | 3, A            | R;R;R;L              |\n|    6     | 3, B            | R;R;R;R              |\n\n<center>\n    <i>表IV 执行图1代码后的模糊表示</i>\n</center>\n\n\n\n#### PASS\n\n​\t\t对于表IV中的每个状态表示，可以获得相应的路径条件。如果有可能获得满足约束条件的解，则可以将其用作测试期间的输入。关于数值的约束可以通过SMT求解器来解决，但**SMT不能处理对于字符串的约束**。因此本文使用约束求解器PASS。\n\n​\t\t**PASS可以处理对整数、位向量、浮点数和字符串的约束。**虽然以前的支持字符串约束的约束解算器使用位向量或自动机，但通过参数化数组传递引入的建模可以实现更高效的求解。因此，它可以解决ECMAScript标准中与字符串操作相对应的大部分约束。\n\n\n\n#### 符号存根及驱动程序\n\n​\t\t符号变量是通过符号执行生成测试输入的对象。**SymJS允许通过函数调用定义符号变量。**下面的代码片段展示了定义符号字符串变量的例子：\n\n`var s = symjs_mk_symbol_string();`\n\n​\t\t以上的例子定义了字符串类型的符号变量，也可以通过`symjs_mk_symbolic_int()`、`symjs_mk_symbolic_bool()`和`symjs_mk_symbolic_real()`分别定义整型、布尔型以及浮点型的符号变量。虽然SymJS只允许字符串、整数、布尔值和浮点数是符号的，但它们的约束作为更复杂的对象的组成部分保留在赋值/引用上，从而允许生成对象组成部分的值不断变化的测试。\n\n​\t\t为了确定图1中函数`func0()`的测试输入，需要额外的代码段。首先需要一个如下所示的符号驱动程序：\n\n```javascript\nvar s = symjs_mk_symbolic_string();\nvar a = symjs_mk_symbolic_float();\nfunc0(s, a);\n```\n\n<center>\n    <i>图3 用于执行图1中代码的符号驱动程序</i>\n</center>\n\n驱动程序声明符号变量并将它们作为参数传递给函数。注入依赖项的存根也是必需的。如下所示的符号存根包括符号变量声明。通过存根，包含对`Lib.m2()`的函数调用的返回值，以测试SymJS获得的输入。\n\n```javascript\nLib.m2 = function() {\n    return symjs_mk_symbolic_float();\n};\n```\n\n<center>\n    <i>图4 提供图1中代码使用的Lib.m2()的符号存根</i>\n</center>\n\n函数`symjs_mk_symbolic_*()`是用于在测试生成期间定义新符号变量的表达式。**SymJS允许使用生成的测试输入进行正常的具体执行。**在具体执行期间，函数返回测试输入中包含的具体值。SymJS可以将测试输入导出为JavaScript Object Notation (JSON) 格式的外部文件。文件可以由测试回放库读取，该库在`symjs_mk_symbolic_*()`函数调用中返回相应的测试输入数据。加载到典型Web浏览器中的测试库可以在没有自定义JavaScript解释器的情况下执行生成的测试。\n\n\n\n## 符号存根及驱动程序的自动生成\n\n​\t\t如第2部分所述，符号存根和驱动程序需要对目标函数进行符号执行并获得测试输入。返回符号变量的符号存根用于生成从被测函数调用的函数的返回值。需要符号驱动程序来改变传递给测试函数的参数。\n\n### 生成符号存根和驱动程序的策略\n\n​\t\t本文的符号存根生成技术为指定的函数和类生成存根。本文的驱动程序生成技术发出调用指定函数的代码。\n\n​\t\t对于存根生成，生成函数根据调用者期望的返回值类型，创建和返回对象。以下是预期类型与返回对象之间的映射关系：\n\n* 字符串、整数、布尔值和浮点数这些可以被SymJS作为符号处理的类型（后面称为SymJS基础类型）：\n\n  新定义的相应类型的符号变量。\n\n* 其他类：\n\n  预期类型的新实例化对象。如果该类的目标是生成存根，则返回**新实例化的存根对象**。\n\n* Void：不返回任何内容。\n\n​\t\t为了创建类的存根，还需要生成构造函数的存根。在这里，本文生成空构造函数，这将导致所有无状态对象。我们的方法假设没有对存根类的字段的直接访问，并且不为字段生成存根。\n\n​\t\t注意：即使返回值类型不是SymJS的基本类型，也可能得到多个测试输入。如果在返回的对象中定义的函数返回符号变量，会出现这种情况。如果**非SymJS基本类型的对象包含返回SymJS基本类型的对象的函数，并且非SymJS基本类型生成了存根**，就会发生这种情况。因此可以通过调用返回非SymJS基本类型的函数来获得多组测试输入。\n\n​\t\t使用本文的技术生成的符号驱动程序具有以下功能：\n\n* 如果待测函数不是静态的、需要一个实例去执行，则实例化对应类的对象并调用该函数\n* 如果待测函数是静态的，就直接调用函数\n\n对于传递给函数的参数，驱动程序根据预期类型提供以下对象：\n\n* SymJS基本类型：\n\n  新定义的相应类型的符号变量。\n\n* 其他类：\n\n  预期类型的新实例化对象。如果该类的目标是存根生成，则传递新实例化的存根对象。\n\n​\t\t选择参数的方式类似于解决在符号存根中返回什么的方式。\n\n### 从注释生成符号存根和驱动程序\n\n​\t\t上一部分提出的符号存根/驱动程序生成策略需要知道来自目标代码的类型信息，生成存根需要调用方期望的返回值类型，需要传递给被测函数的参数类型才能生成驱动程序。\n\n​\t\t但是JavaScript是一种动态类型语言，在真正运行前很难确定返回值和参数的类型。很多JavaScript程序对返回值和参数的类型有一个期望，通常是在应用程序编程接口（API）等中给出的。此外，有一种方法可以**用机器可读的方式表示JavaScript代码的类型信息**，就是JSDoc风格的注释。本文从JSDoc3[13]约定的风格的注释中获取类型信息，生成符号存根和驱动程序。\n\n​\t\tJSDoc3主要允许通过`@return`注释声明返回值类型。为了为图1的代码片段中使用的函数`Lib.m2()`生成符号存根，需要如下所示的注释：\n\n```javascript\n/** @return {Number} m2 value */\nLib.m2 = function() { ... };\n```\n\n如果将此类注释附加到函数的原始源代码，则可以确定返回值的类型。根据获得的返回值类型，可以以全自动的方式生成图4中的符号存根。该示例演示了为返回SymJS原语的函数生成符号存根。下面展示了为返回非SymJS基本类型的函数生成符号存根的示例：\n\n```javascript\n/** @return {tx.Data} data */\ntx.Ui.getValue = function(){ ... };\n```\n\n<center>\n    ↓\n</center>\n\n```javascript\ntx.Ui.getValue = function(){\n    return new tx.Data();\n};\n```\n\n​\t\t符号驱动程序的生成也是一样的。\n\n​\t\t传递给函数的参数类型通常使用JSDoc3的`@param`注释给出。函数`func0()`的符号驱动程序可以从该函数中的注释生成：\n\n```javascript\n/** @param {String} s\n  * @param {Number} a */\nfunction func0(s, a) { ... }\n```\n\n注释给出了函数的参数类型，允许生成图3中的符号驱动程序。\n\n​\t\t提出的自动生成符号存根和驱动程序的技术是作为JSDoc3的插件实现的。也可以使用其他来源的类型信息，例如API规范文档。\n\n\n\n## Evaluation\n\n​\t\t本文使用一个工业JavaScript程序进行了实验。该程序对应于在本文的自定义Web应用程序实现框架上实现的Web应用程序的客户端部分。该程序调用未在我们的框架中包装的ECMAScript标准中定义的API，并且它只包含对标准API或本文的框架的调用。表V显示了目标程序的统计数据：\n\n| #Line | #Function | #File |\n| :---: | :-------: | :---: |\n|  431  |    23     |   1   |\n\n<center>\n    <i>表V 目标程序的统计数据</i>\n</center>\n\n### 符号存根和驱动程序的生成\n\n​\t\t使用本文的方法成功地为框架中定义的所有类和函数生成存根。表VI列出了生成的存根的统计数据：\n\n| #Line(Orig.) | #Line(Stub) | #Function | #File |\n| :----------: | :---------: | :-------: | :---: |\n|     2843     |    1304     |    154    |  13   |\n\n<center>\n    <i>表VI 用于生成存根的框架源代码和生成的存根的统计数据</i>\n</center>\n\n### 生成测试输入和执行测试\n\n​\t\t所有函数的符号执行在1秒内完成，并生成测试输入。测试输入的数量（将具体值赋给符号变量）在目标函数之间是不同的。对于没有分支的函数，只生成1个测试输入，而对于更复杂的函数，获得的测试数量变化到27个。\n\n​\t\t利用获得的测试输入来具体执行目标函数。运行在网络浏览器上的测试回放库用于重放测试。使用JSCover[14]测量测试期间的代码覆盖率，获得92%的行覆盖率。结果表明，该技术能够自动生成单元测试输入，实现高代码覆盖率。\n\n### 实验中未覆盖的代码\n\n​\t\t实验结果表明，该方法可以生成代码覆盖率较高的测试输入，但没有达到100%的覆盖率，这意味着目标程序的某些部分没有被执行。以下是使用我们的方法未执行到的代码类。\n\n​\t\t**意外类型的代码处理对象没有被覆盖到。**由于JavaScript是一种动态类型语言，函数可能会返回意外类型的对象。为了处理这种情况，目标程序包含类型检查和后续错误处理代码。但是，通过本文的技术生成的符号存根总是返回源代码批注中描述的类型的对象。这样的存根不能利用处理不同于注释类型的对象的代码部分。\n\n​\t\t**没有对象类型前提的代码也没有被覆盖到。**目标程序包含在运行时确定对象类型并相应地处理它们的代码片段。然而，本文的技术不能涵盖这样的程序。从返回值类型未知的函数中，我们生成返回默认JavaScript “Object” 的存根。因此，与自定义类的对象交互的代码没有被覆盖。\n\n\n\n## Conclusions\n\n​\t\t本文提出了一种为JavaScript代码自动生成单元测试输入数据的技术。该技术使用符号执行引擎，以便在测试期间实现高代码覆盖率。该技术分为两个阶段，由以下全自动步骤组成：\n\n* 基于从注释获得的类型信息生成符号存根/驱动程序\n* 通过目标代码的符号执行生成测试输入\n\n​\t\t实验结果显示，该技术可以生成92%的行覆盖率的测试，表明本文的技术可以自动生成和执行JavaScript代码的单元测试。\n\n### Future Work\n\n​\t\t未来的方向包括更多的验证试验和各种目标程序。虽然作者已经用相对较小的程序进行了实验，但也需要在较大的目标上进行实验。\n\n​\t\t根据实验结果，需要改进符号存根。可以使用引发异常的符号存根触发代码处理异常。除了更复杂的自动存根生成策略外，手动修改自动生成的存根被认为是增加覆盖率的有效方法。\n\n\n\n## 参考文献\n\n[1] C. Cadar, V . Ganesh, P . M. Pawlowski, D. L. Dill, and D. R. Engler, *“EXE: Automatically Generating Inputs of Death,”* in Proceedings of the 13th ACM Conference on Computer and Communications Security, 2006, pp. 322–335.\n\n[2] C. Cadar, D. Dunbar, and D. Engler, *“KLEE: Unassisted and Automatic Generation of High-coverage Tests for Complex Systems Programs,”* in Proceedings of the 8th USENIX Conference on Operating Systems Design and Implementation, 2008, pp. 209–224.\n\n[3] C. S. Pǎsǎreanu and N. Rungta, *“Symbolic PathFinder: Symbolic Execution of Java Bytecode,”* in Proceedings of the IEEE/ACM International Conference on Automated Software Engineering, 2010, pp. 179–180.\n\n[4] K. Sen, D. Marinov, and G. Agha, *“CUTE: A Concolic Unit Testing Engine for C,”* in Proceedings of the 10th European Software Engineering Conference, 2005, pp. 263–272.\n\n[5] N. Tillmann and J. De Halleux, *“Pex: White Box Test Generation for .NET,”* in Proceedings of the 2nd International Conference on Tests and Proofs, ser. TAP’08, 2008, pp. 134–153.\n\n[6] P . Godefroid, M. Y . Levin, and D. Molnar, *“SAGE: Whitebox Fuzzing for Security Testing,”* Queue, 2012, pp. 20:20–20:27.\n\n[7] L. De Moura and N. Bjørner, *“Satisfiability Modulo Theories: Introduction and Applications,”* Commun. ACM, vol. 54, no. 9, 2011, pp. 69–77.\n\n[8] P. Saxena, D. Akhawe, S. Hanna, F. Mao, S. McCamant, and D. Song, *“A Symbolic Execution Framework for JavaScript,”* in Proceedings of the 2010 IEEE Symposium on Security and Privacy, 2010, pp. 513–528.\n\n[9] K. Sen, S. Kalasapur, T. Brutch, and S. Gibbs, *“Jalangi: A selective record-replay and dynamic analysis framework for javascript,”* in Proceedings of the 2013 9th Joint Meeting on Foundations of Software Engineering, 2013, pp. 488–498.\n\n[10] G. Li and I. Ghosh, *“PASS: String Solving with Parameterized Array and Interval Automaton,”* in Proceedings of Haifa Verification Conference, 2013, pp. 15–31.\n\n[11] ECMA International, Standard ECMA-262 - ECMAScript Language Specification, 5th ed., June 2011. [Online]. Available: http://www.ecma-international.org/publications/standards/Ecma-262.htm\n\n[12] *“Rhino,”* https://developer.mozilla.org/en-US/docs/Rhino, [Online; accessed 2014.08.15].\n\n[13] *“Use JSDoc,”* http://usejsdoc.org/index.html, [Online; accessed 2014.08.15].\n\n[14] *“JSCover - JavaScript code coverage,”* http://tntim96.github.io/JSCover/ http://usejsdoc.org/index.html, [Online; accessed 2014.08.15].","slug":"论文笔记-Automatic-Unit-Test-Generation-and-Execution-for-JavaScript-Program-through-Symbolic-Execution","published":1,"updated":"2020-08-23T14:33:37.434Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cke79q4ti004488psg4d2b3pm","content":"<p><a href=\"https://www.semanticscholar.org/author/Hideo-Tanida/2725857\" target=\"_blank\" rel=\"noopener\">Hideo Tanida</a>, <a href=\"https://www.semanticscholar.org/author/Guodong-Li/1720073\" target=\"_blank\" rel=\"noopener\">Guodong Li</a>, <a href=\"https://www.semanticscholar.org/author/Indradeep-Ghosh/3291522\" target=\"_blank\" rel=\"noopener\">Indradeep Ghosh</a>, <a href=\"https://www.semanticscholar.org/author/Tadahiro-Uehara/3081128\" target=\"_blank\" rel=\"noopener\">Tadahiro Uehara</a></p>\n<p>Published in ICSEA 2014</p>\n<p><a href=\"https://scholar.google.com/scholar?hl=zh-CN&amp;as_sdt=0%2C5&amp;q=Automatic+Unit+Test+Generation+and+Execution+for+JavaScript+Program+through+Symbolic+Execution&amp;btnG=\" target=\"_blank\" rel=\"noopener\">https://scholar.google.com/scholar?hl=zh-CN&amp;as_sdt=0%2C5&amp;q=Automatic+Unit+Test+Generation+and+Execution+for+JavaScript+Program+through+Symbolic+Execution&amp;btnG=</a></p>\n<a id=\"more\"></a>\n<h2 id=\"摘要及介绍\"><a href=\"#摘要及介绍\" class=\"headerlink\" title=\"摘要及介绍\"></a>摘要及介绍</h2><h3 id=\"摘要\"><a href=\"#摘要\" class=\"headerlink\" title=\"摘要\"></a>摘要</h3><p>​        考虑到对更具交互性的Web/移动应用程序的需求，JavaScript有望成为一种使用更广泛的编程语言。虽然JavaScript代码的可靠性将更加重要，但与其他语言相比，该语言的测试技术仍然不足。本文提出了一种为JavaScript代码自动生成高覆盖率单元测试的技术。该技术使用JavaScript代码的符号执行引擎，以及自动为不感兴趣的代码生成存根的存根/驱动程序生成引擎。本文的方法允许全自动生成用于高覆盖率的JavaScript代码单元测试的输入数据，从而以较少的工作量确保目标代码的质量。</p>\n<h3 id=\"主要贡献\"><a href=\"#主要贡献\" class=\"headerlink\" title=\"主要贡献\"></a>主要贡献</h3><ul>\n<li>本文提出了一种在工具<strong>SymJS</strong>上通过符号执行为JavaScript代码生成测试输入的技术；</li>\n<li>对比现有工具，本文的约束求解器<strong>PASS</strong>[10]允许为具有各种复杂字符串操作的程序生成测试；</li>\n<li>并且不需要对目标代码进行任何修改，而现有的符号执行器需要修改和多次运行，因此适用于现实中的开发；</li>\n<li>本文的自动生成存根/驱动程序代码允许完全自动生成测试数据。</li>\n</ul>\n<h3 id=\"现有的工具\"><a href=\"#现有的工具\" class=\"headerlink\" title=\"现有的工具\"></a>现有的工具</h3><p>​        现有的JavaScript代码测试工具包括<strong>Kudzu</strong>[8]和<strong>Jalangi</strong>[9]。kudzu自动生成程序函数的输入数据，目的是自动发现目标中的安全漏洞。Jalangi允许在正常的具体执行下修改路径约束，以便获得与以前运行不同的结果。然而，由于字符串约束处理方面的限制，以及需要手动创建用于测试的驱动程序/存根，这些工具不能应用于现实中JavaScript代码的单元测试。</p>\n<h2 id=\"背景及基础知识\"><a href=\"#背景及基础知识\" class=\"headerlink\" title=\"背景及基础知识\"></a>背景及基础知识</h2><h3 id=\"符号执行\"><a href=\"#符号执行\" class=\"headerlink\" title=\"符号执行\"></a>符号执行</h3><p>​        符号执行（Symbolic Execution）是一种程序分析技术，可以通过分析程序源代码来得到测试输入。通俗来讲，比如说游戏中一个角色在佩戴各种装备之后的面板数值为：攻击力xxx、防御力xxx…；此时通过佩戴装备到获得属性的过程就好比一个程序，佩戴装备的品质就是这个程序的输入，而最后获得的属性就是这个程序的输出；符号执行的过程则是进行分析，从某组给定的属性逆向推导，最后得到某组质量的装备，佩戴这组装备可以获得一开始给定的属性。</p>\n<h4 id=\"符号执行的基本原理\"><a href=\"#符号执行的基本原理\" class=\"headerlink\" title=\"符号执行的基本原理\"></a>符号执行的基本原理</h4><p>​        符号执行的关键思想是把输入变为符号值，那么程序的输出值就是一个符号输入值的函数。在程序执行期间，获得每个执行路径中的变量的值要满足的约束。在获得程序内所有路径的约束之后，通过将约束提供给诸如可满足性模理论（SMT）[7]求解器之类的求解器，可以获得执行每条路径的输入变量的具体值。</p>\n<p>参考：<a href=\"https://zhuanlan.zhihu.com/p/26927127\" target=\"_blank\" rel=\"noopener\">https://zhuanlan.zhihu.com/p/26927127</a></p>\n<h4 id=\"通过符号执行生成测试输入\"><a href=\"#通过符号执行生成测试输入\" class=\"headerlink\" title=\"通过符号执行生成测试输入\"></a>通过符号执行生成测试输入</h4><p>​        在程序的符号执行期间，执行每个路径所需要满足的约束是以迭代的方式计算的。在访问程序内每条可能的路径之后，获得所有路径的约束。使用<strong>SMT</strong>等求解器可以获得满足约束条件的变量的具体值。得到的值是与约束条件相对应的，可以用来进行测试。</p>\n<h3 id=\"SymJS\"><a href=\"#SymJS\" class=\"headerlink\" title=\"SymJS\"></a>SymJS</h3><p>SymJS是一个用于自动测试JavaScript Web应用程序客户端的框架，该工具包括一个用于JavaScript的符号执行引擎和一个Web页面的自动的事件资源管理器。而其中符号引擎包括一个符号虚拟机、一个字符串+数字解算器和一个符号可执行DOM模型。</p>\n<p>​        SymJS解释从目标程序源代码编译的字节码。现有的符号执行器（如<strong>Klee</strong>[2]和<strong>Symbol Pathfinder</strong>[3]）都采用这种方法。处理字节码而不是源代码允许实现符号执行器，而无需处理语言的复杂语法。SymJS被实现为Rhino字节码的解释器，它在执行每条字节码指令时更新程序状态(堆/栈内容和路径条件)。在命中分支指令时，它复制程序状态并继续执行两个分支。</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">Tool</th>\n<th style=\"text-align:center\">Target Lang.</th>\n<th style=\"text-align:center\">Sym.VM</th>\n<th style=\"text-align:center\">Dep./Cache Solving</th>\n<th style=\"text-align:center\">String Solving</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">SymJS</td>\n<td style=\"text-align:center\">JavaScript</td>\n<td style=\"text-align:center\">Yes</td>\n<td style=\"text-align:center\">Yes</td>\n<td style=\"text-align:center\">Yes</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">KLEE [2]</td>\n<td style=\"text-align:center\">C</td>\n<td style=\"text-align:center\">Yes</td>\n<td style=\"text-align:center\">Yes</td>\n<td style=\"text-align:center\">No</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">SAGE [6]</td>\n<td style=\"text-align:center\">x86 binary</td>\n<td style=\"text-align:center\">No</td>\n<td style=\"text-align:center\">Yes</td>\n<td style=\"text-align:center\">No</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Sym JPF [3]</td>\n<td style=\"text-align:center\">Java</td>\n<td style=\"text-align:center\">Yes</td>\n<td style=\"text-align:center\">No</td>\n<td style=\"text-align:center\">No</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Kudzu [8]</td>\n<td style=\"text-align:center\">JavaScript</td>\n<td style=\"text-align:center\">No</td>\n<td style=\"text-align:center\">No</td>\n<td style=\"text-align:center\">Yes</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Jalangi [9]</td>\n<td style=\"text-align:center\">JavaScript</td>\n<td style=\"text-align:center\">No</td>\n<td style=\"text-align:center\">No</td>\n<td style=\"text-align:center\">Limited</td>\n</tr>\n</tbody>\n</table>\n</div>\n<center>\n    <i>表I 符号执行器的比较</i>\n</center>\n\n\n<p>​        为了实现目标程序的符号执行，本文修改了原始Rhino对表II中所示指令的解释。堆栈操作、异常处理和变量范围管理的指令处理保持不变。</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">操作</th>\n<th style=\"text-align:center\">指令</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">Arithemetic/Logical Operations</td>\n<td style=\"text-align:center\">ADD, SUB, MUL, DIV, MOD, NEG, POS, BITNOT, BITAND, BITOR, BITXOR, LSH, RSH,URSH <em>etc.</em></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Comparisons</td>\n<td style=\"text-align:center\">EQ, NE, GE, GT, LE, LT, NOT, SHEQ, SHNE <em>etc.</em></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Branches</td>\n<td style=\"text-align:center\">IFEQ, IFNE, IFEQ_POP <em>etc.</em></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Function Calls</td>\n<td style=\"text-align:center\">RETURN, CALL, TAIL_CALL <em>etc.</em></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Object Manipulations</td>\n<td style=\"text-align:center\">NEW, REF, IN, INSTANCEOF, TYPEOF, GETNAME, SETNAME, NAME <em>etc.</em></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Object Accesses</td>\n<td style=\"text-align:center\">GETPROP, SETPROP, DELPROP, GETELEM, SETELEM, GETREF, SETREF <em>etc.</em></td>\n</tr>\n</tbody>\n</table>\n</div>\n<center>\n    <i>表II 修改后的指令解释</i>\n</center>\n例如，指令 `ADD op1 op2` 解释如下：\n\n(1)从堆栈中弹出操作数 `op1` 和 `op2` 。操作数可以使用抽象的值，也可以使用具体的值。\n\n(2)检查操作数的类型。如果两个操作数都是字符串，则计算结果是操作数的拼接。如果它们是数值，则结果是操作数的总和。否则，将**根据ECMAScript语言标准转换值**，结果是将获得的值拼接或相加。\n\n#### 分支指令\n\n​        比较指令之后是Rhino字节码中的分支指令。SymJS处理比较和分支指令对，如下所示：\n\n​        首先，在进行必要的类型转换后，生成与比较结果相对应的布尔公式。假设所创建的公式由符号 $c$ 表示，我们检查 $c$ 及其否定 $\\neg c$ 是否与路径条件 $pc$ 一起满足。换句话说，我们检查 $pc \\land c$ 和 $pc \\land \\neg c$ 的可满足性。如果两者都是可满足的，我们建立对应于 $pc \\land c$ 和 $pc \\land \\neg c$ 的状态 $s_1, s_2$，并从状态 $s_1$ 和 $s_2$ 继续执行。如果其中一个是可满足的，则选择与可满足的状态相对应的状态，并从该点继续执行。\n\n​        SymJS支持两种方式来管理在命中分支等情况下创建的状态。第一种方法是**存储程序状态变量，包括堆/栈的内容**，如[2] [3]中所做的那样。第二种方法是**只记住在分支上走哪一侧。此方法需要在回溯时从初始状态重新执行目标程序。**但是，它得益于其简单的实现和较小的内存占用。这种方法被称为“模糊”，类似于[4] [6]中介绍的技术。但是，本文的技术是在符号执行器上实现的，不需要修改现有JavaScript工具[8] [9]所需的目标代码。\n\n​        在通过模糊化执行程序的符号过程中，状态仅由分支上的哪一方表示和存储。该信息可用于从程序的初始状态重新执行该程序，并探索目标可能采取的状态空间。在模糊化期间，用与表I中的测试1-6相对应的路径条件符号执行图1中的目标程序之后的状态如表IV所示。符号L、R表示在分支指令上走左/右分支。\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">func0</span> (<span class=\"params\">s, a</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(””.equals(s)) &#123; <span class=\"comment\">// block 0</span></span><br><span class=\"line\">\t\ts = <span class=\"literal\">null</span>;</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (s.length &lt;= <span class=\"number\">5</span>) &#123; <span class=\"comment\">// block 1</span></span><br><span class=\"line\">\t\t\ta = a + status;</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(””.equals(s)) &#123; <span class=\"comment\">// block 2</span></span><br><span class=\"line\">\t\t\t\tLib.m0(); <span class=\"comment\">// Unreachable</span></span><br><span class=\"line\">\t\t\t&#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// block 3</span></span><br><span class=\"line\">\t\t\t\tLib.m1();</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (a &lt;= Lib.m2()) &#123; <span class=\"comment\">// block A</span></span><br><span class=\"line\">\ta = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// block B</span></span><br><span class=\"line\">\ta = a + s.length; <span class=\"comment\">// Error with null s</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<center>\n    <i>图1 一个代码框架：\n    s, a, Lib.m2()可以取任意值</i>\n</center>\n\n\n\n<p><img src=\"http://images.yingwai.top/picgo/SymJSf2.png\" alt=\"\"></p>\n<center>\n    <i>图2 代码执行路径</i>\n</center>\n\n\n\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">Test No.</th>\n<th style=\"text-align:left\">Blocks Executed</th>\n<th>State Representation</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:left\">0, A</td>\n<td>L;L</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">2</td>\n<td style=\"text-align:left\">0, B</td>\n<td>L;R</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">3</td>\n<td style=\"text-align:left\">1, A</td>\n<td>R;L;L</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">4</td>\n<td style=\"text-align:left\">1, B</td>\n<td>R;L;R</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">5</td>\n<td style=\"text-align:left\">3, A</td>\n<td>R;R;R;L</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">6</td>\n<td style=\"text-align:left\">3, B</td>\n<td>R;R;R;R</td>\n</tr>\n</tbody>\n</table>\n</div>\n<center>\n    <i>表IV 执行图1代码后的模糊表示</i>\n</center>\n\n\n\n<h4 id=\"PASS\"><a href=\"#PASS\" class=\"headerlink\" title=\"PASS\"></a>PASS</h4><p>​        对于表IV中的每个状态表示，可以获得相应的路径条件。如果有可能获得满足约束条件的解，则可以将其用作测试期间的输入。关于数值的约束可以通过SMT求解器来解决，但<strong>SMT不能处理对于字符串的约束</strong>。因此本文使用约束求解器PASS。</p>\n<p>​        <strong>PASS可以处理对整数、位向量、浮点数和字符串的约束。</strong>虽然以前的支持字符串约束的约束解算器使用位向量或自动机，但通过参数化数组传递引入的建模可以实现更高效的求解。因此，它可以解决ECMAScript标准中与字符串操作相对应的大部分约束。</p>\n<h4 id=\"符号存根及驱动程序\"><a href=\"#符号存根及驱动程序\" class=\"headerlink\" title=\"符号存根及驱动程序\"></a>符号存根及驱动程序</h4><p>​        符号变量是通过符号执行生成测试输入的对象。<strong>SymJS允许通过函数调用定义符号变量。</strong>下面的代码片段展示了定义符号字符串变量的例子：</p>\n<p><code>var s = symjs_mk_symbol_string();</code></p>\n<p>​        以上的例子定义了字符串类型的符号变量，也可以通过<code>symjs_mk_symbolic_int()</code>、<code>symjs_mk_symbolic_bool()</code>和<code>symjs_mk_symbolic_real()</code>分别定义整型、布尔型以及浮点型的符号变量。虽然SymJS只允许字符串、整数、布尔值和浮点数是符号的，但它们的约束作为更复杂的对象的组成部分保留在赋值/引用上，从而允许生成对象组成部分的值不断变化的测试。</p>\n<p>​        为了确定图1中函数<code>func0()</code>的测试输入，需要额外的代码段。首先需要一个如下所示的符号驱动程序：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> s = symjs_mk_symbolic_string();</span><br><span class=\"line\"><span class=\"keyword\">var</span> a = symjs_mk_symbolic_float();</span><br><span class=\"line\">func0(s, a);</span><br></pre></td></tr></table></figure>\n<center>\n    <i>图3 用于执行图1中代码的符号驱动程序</i>\n</center>\n\n<p>驱动程序声明符号变量并将它们作为参数传递给函数。注入依赖项的存根也是必需的。如下所示的符号存根包括符号变量声明。通过存根，包含对<code>Lib.m2()</code>的函数调用的返回值，以测试SymJS获得的输入。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Lib.m2 = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> symjs_mk_symbolic_float();</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<center>\n    <i>图4 提供图1中代码使用的Lib.m2()的符号存根</i>\n</center>\n\n<p>函数<code>symjs_mk_symbolic_*()</code>是用于在测试生成期间定义新符号变量的表达式。<strong>SymJS允许使用生成的测试输入进行正常的具体执行。</strong>在具体执行期间，函数返回测试输入中包含的具体值。SymJS可以将测试输入导出为JavaScript Object Notation (JSON) 格式的外部文件。文件可以由测试回放库读取，该库在<code>symjs_mk_symbolic_*()</code>函数调用中返回相应的测试输入数据。加载到典型Web浏览器中的测试库可以在没有自定义JavaScript解释器的情况下执行生成的测试。</p>\n<h2 id=\"符号存根及驱动程序的自动生成\"><a href=\"#符号存根及驱动程序的自动生成\" class=\"headerlink\" title=\"符号存根及驱动程序的自动生成\"></a>符号存根及驱动程序的自动生成</h2><p>​        如第2部分所述，符号存根和驱动程序需要对目标函数进行符号执行并获得测试输入。返回符号变量的符号存根用于生成从被测函数调用的函数的返回值。需要符号驱动程序来改变传递给测试函数的参数。</p>\n<h3 id=\"生成符号存根和驱动程序的策略\"><a href=\"#生成符号存根和驱动程序的策略\" class=\"headerlink\" title=\"生成符号存根和驱动程序的策略\"></a>生成符号存根和驱动程序的策略</h3><p>​        本文的符号存根生成技术为指定的函数和类生成存根。本文的驱动程序生成技术发出调用指定函数的代码。</p>\n<p>​        对于存根生成，生成函数根据调用者期望的返回值类型，创建和返回对象。以下是预期类型与返回对象之间的映射关系：</p>\n<ul>\n<li><p>字符串、整数、布尔值和浮点数这些可以被SymJS作为符号处理的类型（后面称为SymJS基础类型）：</p>\n<p>新定义的相应类型的符号变量。</p>\n</li>\n<li><p>其他类：</p>\n<p>预期类型的新实例化对象。如果该类的目标是生成存根，则返回<strong>新实例化的存根对象</strong>。</p>\n</li>\n<li><p>Void：不返回任何内容。</p>\n</li>\n</ul>\n<p>​        为了创建类的存根，还需要生成构造函数的存根。在这里，本文生成空构造函数，这将导致所有无状态对象。我们的方法假设没有对存根类的字段的直接访问，并且不为字段生成存根。</p>\n<p>​        注意：即使返回值类型不是SymJS的基本类型，也可能得到多个测试输入。如果在返回的对象中定义的函数返回符号变量，会出现这种情况。如果<strong>非SymJS基本类型的对象包含返回SymJS基本类型的对象的函数，并且非SymJS基本类型生成了存根</strong>，就会发生这种情况。因此可以通过调用返回非SymJS基本类型的函数来获得多组测试输入。</p>\n<p>​        使用本文的技术生成的符号驱动程序具有以下功能：</p>\n<ul>\n<li>如果待测函数不是静态的、需要一个实例去执行，则实例化对应类的对象并调用该函数</li>\n<li>如果待测函数是静态的，就直接调用函数</li>\n</ul>\n<p>对于传递给函数的参数，驱动程序根据预期类型提供以下对象：</p>\n<ul>\n<li><p>SymJS基本类型：</p>\n<p>新定义的相应类型的符号变量。</p>\n</li>\n<li><p>其他类：</p>\n<p>预期类型的新实例化对象。如果该类的目标是存根生成，则传递新实例化的存根对象。</p>\n</li>\n</ul>\n<p>​        选择参数的方式类似于解决在符号存根中返回什么的方式。</p>\n<h3 id=\"从注释生成符号存根和驱动程序\"><a href=\"#从注释生成符号存根和驱动程序\" class=\"headerlink\" title=\"从注释生成符号存根和驱动程序\"></a>从注释生成符号存根和驱动程序</h3><p>​        上一部分提出的符号存根/驱动程序生成策略需要知道来自目标代码的类型信息，生成存根需要调用方期望的返回值类型，需要传递给被测函数的参数类型才能生成驱动程序。</p>\n<p>​        但是JavaScript是一种动态类型语言，在真正运行前很难确定返回值和参数的类型。很多JavaScript程序对返回值和参数的类型有一个期望，通常是在应用程序编程接口（API）等中给出的。此外，有一种方法可以<strong>用机器可读的方式表示JavaScript代码的类型信息</strong>，就是JSDoc风格的注释。本文从JSDoc3[13]约定的风格的注释中获取类型信息，生成符号存根和驱动程序。</p>\n<p>​        JSDoc3主要允许通过<code>@return</code>注释声明返回值类型。为了为图1的代码片段中使用的函数<code>Lib.m2()</code>生成符号存根，需要如下所示的注释：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** <span class=\"doctag\">@return <span class=\"type\">&#123;Number&#125;</span> </span>m2 value */</span></span><br><span class=\"line\">Lib.m2 = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; ... &#125;;</span><br></pre></td></tr></table></figure>\n<p>如果将此类注释附加到函数的原始源代码，则可以确定返回值的类型。根据获得的返回值类型，可以以全自动的方式生成图4中的符号存根。该示例演示了为返回SymJS原语的函数生成符号存根。下面展示了为返回非SymJS基本类型的函数生成符号存根的示例：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** <span class=\"doctag\">@return <span class=\"type\">&#123;tx.Data&#125;</span> </span>data */</span></span><br><span class=\"line\">tx.Ui.getValue = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123; ... &#125;;</span><br></pre></td></tr></table></figure>\n<center>\n    ↓\n</center>\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tx.Ui.getValue = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> tx.Data();</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>​        符号驱动程序的生成也是一样的。</p>\n<p>​        传递给函数的参数类型通常使用JSDoc3的<code>@param</code>注释给出。函数<code>func0()</code>的符号驱动程序可以从该函数中的注释生成：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** <span class=\"doctag\">@param <span class=\"type\">&#123;String&#125;</span> <span class=\"variable\">s</span></span></span></span><br><span class=\"line\"><span class=\"comment\">  * <span class=\"doctag\">@param <span class=\"type\">&#123;Number&#125;</span> </span>a */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">func0</span>(<span class=\"params\">s, a</span>) </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>\n<p>注释给出了函数的参数类型，允许生成图3中的符号驱动程序。</p>\n<p>​        提出的自动生成符号存根和驱动程序的技术是作为JSDoc3的插件实现的。也可以使用其他来源的类型信息，例如API规范文档。</p>\n<h2 id=\"Evaluation\"><a href=\"#Evaluation\" class=\"headerlink\" title=\"Evaluation\"></a>Evaluation</h2><p>​        本文使用一个工业JavaScript程序进行了实验。该程序对应于在本文的自定义Web应用程序实现框架上实现的Web应用程序的客户端部分。该程序调用未在我们的框架中包装的ECMAScript标准中定义的API，并且它只包含对标准API或本文的框架的调用。表V显示了目标程序的统计数据：</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">#Line</th>\n<th style=\"text-align:center\">#Function</th>\n<th style=\"text-align:center\">#File</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">431</td>\n<td style=\"text-align:center\">23</td>\n<td style=\"text-align:center\">1</td>\n</tr>\n</tbody>\n</table>\n</div>\n<center>\n    <i>表V 目标程序的统计数据</i>\n</center>\n\n<h3 id=\"符号存根和驱动程序的生成\"><a href=\"#符号存根和驱动程序的生成\" class=\"headerlink\" title=\"符号存根和驱动程序的生成\"></a>符号存根和驱动程序的生成</h3><p>​        使用本文的方法成功地为框架中定义的所有类和函数生成存根。表VI列出了生成的存根的统计数据：</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">#Line(Orig.)</th>\n<th style=\"text-align:center\">#Line(Stub)</th>\n<th style=\"text-align:center\">#Function</th>\n<th style=\"text-align:center\">#File</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">2843</td>\n<td style=\"text-align:center\">1304</td>\n<td style=\"text-align:center\">154</td>\n<td style=\"text-align:center\">13</td>\n</tr>\n</tbody>\n</table>\n</div>\n<center>\n    <i>表VI 用于生成存根的框架源代码和生成的存根的统计数据</i>\n</center>\n\n<h3 id=\"生成测试输入和执行测试\"><a href=\"#生成测试输入和执行测试\" class=\"headerlink\" title=\"生成测试输入和执行测试\"></a>生成测试输入和执行测试</h3><p>​        所有函数的符号执行在1秒内完成，并生成测试输入。测试输入的数量（将具体值赋给符号变量）在目标函数之间是不同的。对于没有分支的函数，只生成1个测试输入，而对于更复杂的函数，获得的测试数量变化到27个。</p>\n<p>​        利用获得的测试输入来具体执行目标函数。运行在网络浏览器上的测试回放库用于重放测试。使用JSCover[14]测量测试期间的代码覆盖率，获得92%的行覆盖率。结果表明，该技术能够自动生成单元测试输入，实现高代码覆盖率。</p>\n<h3 id=\"实验中未覆盖的代码\"><a href=\"#实验中未覆盖的代码\" class=\"headerlink\" title=\"实验中未覆盖的代码\"></a>实验中未覆盖的代码</h3><p>​        实验结果表明，该方法可以生成代码覆盖率较高的测试输入，但没有达到100%的覆盖率，这意味着目标程序的某些部分没有被执行。以下是使用我们的方法未执行到的代码类。</p>\n<p>​        <strong>意外类型的代码处理对象没有被覆盖到。</strong>由于JavaScript是一种动态类型语言，函数可能会返回意外类型的对象。为了处理这种情况，目标程序包含类型检查和后续错误处理代码。但是，通过本文的技术生成的符号存根总是返回源代码批注中描述的类型的对象。这样的存根不能利用处理不同于注释类型的对象的代码部分。</p>\n<p>​        <strong>没有对象类型前提的代码也没有被覆盖到。</strong>目标程序包含在运行时确定对象类型并相应地处理它们的代码片段。然而，本文的技术不能涵盖这样的程序。从返回值类型未知的函数中，我们生成返回默认JavaScript “Object” 的存根。因此，与自定义类的对象交互的代码没有被覆盖。</p>\n<h2 id=\"Conclusions\"><a href=\"#Conclusions\" class=\"headerlink\" title=\"Conclusions\"></a>Conclusions</h2><p>​        本文提出了一种为JavaScript代码自动生成单元测试输入数据的技术。该技术使用符号执行引擎，以便在测试期间实现高代码覆盖率。该技术分为两个阶段，由以下全自动步骤组成：</p>\n<ul>\n<li>基于从注释获得的类型信息生成符号存根/驱动程序</li>\n<li>通过目标代码的符号执行生成测试输入</li>\n</ul>\n<p>​        实验结果显示，该技术可以生成92%的行覆盖率的测试，表明本文的技术可以自动生成和执行JavaScript代码的单元测试。</p>\n<h3 id=\"Future-Work\"><a href=\"#Future-Work\" class=\"headerlink\" title=\"Future Work\"></a>Future Work</h3><p>​        未来的方向包括更多的验证试验和各种目标程序。虽然作者已经用相对较小的程序进行了实验，但也需要在较大的目标上进行实验。</p>\n<p>​        根据实验结果，需要改进符号存根。可以使用引发异常的符号存根触发代码处理异常。除了更复杂的自动存根生成策略外，手动修改自动生成的存根被认为是增加覆盖率的有效方法。</p>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><p>[1] C. Cadar, V . Ganesh, P . M. Pawlowski, D. L. Dill, and D. R. Engler, <em>“EXE: Automatically Generating Inputs of Death,”</em> in Proceedings of the 13th ACM Conference on Computer and Communications Security, 2006, pp. 322–335.</p>\n<p>[2] C. Cadar, D. Dunbar, and D. Engler, <em>“KLEE: Unassisted and Automatic Generation of High-coverage Tests for Complex Systems Programs,”</em> in Proceedings of the 8th USENIX Conference on Operating Systems Design and Implementation, 2008, pp. 209–224.</p>\n<p>[3] C. S. Pǎsǎreanu and N. Rungta, <em>“Symbolic PathFinder: Symbolic Execution of Java Bytecode,”</em> in Proceedings of the IEEE/ACM International Conference on Automated Software Engineering, 2010, pp. 179–180.</p>\n<p>[4] K. Sen, D. Marinov, and G. Agha, <em>“CUTE: A Concolic Unit Testing Engine for C,”</em> in Proceedings of the 10th European Software Engineering Conference, 2005, pp. 263–272.</p>\n<p>[5] N. Tillmann and J. De Halleux, <em>“Pex: White Box Test Generation for .NET,”</em> in Proceedings of the 2nd International Conference on Tests and Proofs, ser. TAP’08, 2008, pp. 134–153.</p>\n<p>[6] P . Godefroid, M. Y . Levin, and D. Molnar, <em>“SAGE: Whitebox Fuzzing for Security Testing,”</em> Queue, 2012, pp. 20:20–20:27.</p>\n<p>[7] L. De Moura and N. Bjørner, <em>“Satisfiability Modulo Theories: Introduction and Applications,”</em> Commun. ACM, vol. 54, no. 9, 2011, pp. 69–77.</p>\n<p>[8] P. Saxena, D. Akhawe, S. Hanna, F. Mao, S. McCamant, and D. Song, <em>“A Symbolic Execution Framework for JavaScript,”</em> in Proceedings of the 2010 IEEE Symposium on Security and Privacy, 2010, pp. 513–528.</p>\n<p>[9] K. Sen, S. Kalasapur, T. Brutch, and S. Gibbs, <em>“Jalangi: A selective record-replay and dynamic analysis framework for javascript,”</em> in Proceedings of the 2013 9th Joint Meeting on Foundations of Software Engineering, 2013, pp. 488–498.</p>\n<p>[10] G. Li and I. Ghosh, <em>“PASS: String Solving with Parameterized Array and Interval Automaton,”</em> in Proceedings of Haifa Verification Conference, 2013, pp. 15–31.</p>\n<p>[11] ECMA International, Standard ECMA-262 - ECMAScript Language Specification, 5th ed., June 2011. [Online]. Available: <a href=\"http://www.ecma-international.org/publications/standards/Ecma-262.htm\" target=\"_blank\" rel=\"noopener\">http://www.ecma-international.org/publications/standards/Ecma-262.htm</a></p>\n<p>[12] <em>“Rhino,”</em> <a href=\"https://developer.mozilla.org/en-US/docs/Rhino\" target=\"_blank\" rel=\"noopener\">https://developer.mozilla.org/en-US/docs/Rhino</a>, [Online; accessed 2014.08.15].</p>\n<p>[13] <em>“Use JSDoc,”</em> <a href=\"http://usejsdoc.org/index.html\" target=\"_blank\" rel=\"noopener\">http://usejsdoc.org/index.html</a>, [Online; accessed 2014.08.15].</p>\n<p>[14] <em>“JSCover - JavaScript code coverage,”</em> <a href=\"http://tntim96.github.io/JSCover/\" target=\"_blank\" rel=\"noopener\">http://tntim96.github.io/JSCover/</a> <a href=\"http://usejsdoc.org/index.html\" target=\"_blank\" rel=\"noopener\">http://usejsdoc.org/index.html</a>, [Online; accessed 2014.08.15].</p>\n","site":{"data":{}},"excerpt":"<p><a href=\"https://www.semanticscholar.org/author/Hideo-Tanida/2725857\" target=\"_blank\" rel=\"noopener\">Hideo Tanida</a>, <a href=\"https://www.semanticscholar.org/author/Guodong-Li/1720073\" target=\"_blank\" rel=\"noopener\">Guodong Li</a>, <a href=\"https://www.semanticscholar.org/author/Indradeep-Ghosh/3291522\" target=\"_blank\" rel=\"noopener\">Indradeep Ghosh</a>, <a href=\"https://www.semanticscholar.org/author/Tadahiro-Uehara/3081128\" target=\"_blank\" rel=\"noopener\">Tadahiro Uehara</a></p>\n<p>Published in ICSEA 2014</p>\n<p><a href=\"https://scholar.google.com/scholar?hl=zh-CN&amp;as_sdt=0%2C5&amp;q=Automatic+Unit+Test+Generation+and+Execution+for+JavaScript+Program+through+Symbolic+Execution&amp;btnG=\" target=\"_blank\" rel=\"noopener\">https://scholar.google.com/scholar?hl=zh-CN&amp;as_sdt=0%2C5&amp;q=Automatic+Unit+Test+Generation+and+Execution+for+JavaScript+Program+through+Symbolic+Execution&amp;btnG=</a></p>","more":"<h2 id=\"摘要及介绍\"><a href=\"#摘要及介绍\" class=\"headerlink\" title=\"摘要及介绍\"></a>摘要及介绍</h2><h3 id=\"摘要\"><a href=\"#摘要\" class=\"headerlink\" title=\"摘要\"></a>摘要</h3><p>​        考虑到对更具交互性的Web/移动应用程序的需求，JavaScript有望成为一种使用更广泛的编程语言。虽然JavaScript代码的可靠性将更加重要，但与其他语言相比，该语言的测试技术仍然不足。本文提出了一种为JavaScript代码自动生成高覆盖率单元测试的技术。该技术使用JavaScript代码的符号执行引擎，以及自动为不感兴趣的代码生成存根的存根/驱动程序生成引擎。本文的方法允许全自动生成用于高覆盖率的JavaScript代码单元测试的输入数据，从而以较少的工作量确保目标代码的质量。</p>\n<h3 id=\"主要贡献\"><a href=\"#主要贡献\" class=\"headerlink\" title=\"主要贡献\"></a>主要贡献</h3><ul>\n<li>本文提出了一种在工具<strong>SymJS</strong>上通过符号执行为JavaScript代码生成测试输入的技术；</li>\n<li>对比现有工具，本文的约束求解器<strong>PASS</strong>[10]允许为具有各种复杂字符串操作的程序生成测试；</li>\n<li>并且不需要对目标代码进行任何修改，而现有的符号执行器需要修改和多次运行，因此适用于现实中的开发；</li>\n<li>本文的自动生成存根/驱动程序代码允许完全自动生成测试数据。</li>\n</ul>\n<h3 id=\"现有的工具\"><a href=\"#现有的工具\" class=\"headerlink\" title=\"现有的工具\"></a>现有的工具</h3><p>​        现有的JavaScript代码测试工具包括<strong>Kudzu</strong>[8]和<strong>Jalangi</strong>[9]。kudzu自动生成程序函数的输入数据，目的是自动发现目标中的安全漏洞。Jalangi允许在正常的具体执行下修改路径约束，以便获得与以前运行不同的结果。然而，由于字符串约束处理方面的限制，以及需要手动创建用于测试的驱动程序/存根，这些工具不能应用于现实中JavaScript代码的单元测试。</p>\n<h2 id=\"背景及基础知识\"><a href=\"#背景及基础知识\" class=\"headerlink\" title=\"背景及基础知识\"></a>背景及基础知识</h2><h3 id=\"符号执行\"><a href=\"#符号执行\" class=\"headerlink\" title=\"符号执行\"></a>符号执行</h3><p>​        符号执行（Symbolic Execution）是一种程序分析技术，可以通过分析程序源代码来得到测试输入。通俗来讲，比如说游戏中一个角色在佩戴各种装备之后的面板数值为：攻击力xxx、防御力xxx…；此时通过佩戴装备到获得属性的过程就好比一个程序，佩戴装备的品质就是这个程序的输入，而最后获得的属性就是这个程序的输出；符号执行的过程则是进行分析，从某组给定的属性逆向推导，最后得到某组质量的装备，佩戴这组装备可以获得一开始给定的属性。</p>\n<h4 id=\"符号执行的基本原理\"><a href=\"#符号执行的基本原理\" class=\"headerlink\" title=\"符号执行的基本原理\"></a>符号执行的基本原理</h4><p>​        符号执行的关键思想是把输入变为符号值，那么程序的输出值就是一个符号输入值的函数。在程序执行期间，获得每个执行路径中的变量的值要满足的约束。在获得程序内所有路径的约束之后，通过将约束提供给诸如可满足性模理论（SMT）[7]求解器之类的求解器，可以获得执行每条路径的输入变量的具体值。</p>\n<p>参考：<a href=\"https://zhuanlan.zhihu.com/p/26927127\" target=\"_blank\" rel=\"noopener\">https://zhuanlan.zhihu.com/p/26927127</a></p>\n<h4 id=\"通过符号执行生成测试输入\"><a href=\"#通过符号执行生成测试输入\" class=\"headerlink\" title=\"通过符号执行生成测试输入\"></a>通过符号执行生成测试输入</h4><p>​        在程序的符号执行期间，执行每个路径所需要满足的约束是以迭代的方式计算的。在访问程序内每条可能的路径之后，获得所有路径的约束。使用<strong>SMT</strong>等求解器可以获得满足约束条件的变量的具体值。得到的值是与约束条件相对应的，可以用来进行测试。</p>\n<h3 id=\"SymJS\"><a href=\"#SymJS\" class=\"headerlink\" title=\"SymJS\"></a>SymJS</h3><p>SymJS是一个用于自动测试JavaScript Web应用程序客户端的框架，该工具包括一个用于JavaScript的符号执行引擎和一个Web页面的自动的事件资源管理器。而其中符号引擎包括一个符号虚拟机、一个字符串+数字解算器和一个符号可执行DOM模型。</p>\n<p>​        SymJS解释从目标程序源代码编译的字节码。现有的符号执行器（如<strong>Klee</strong>[2]和<strong>Symbol Pathfinder</strong>[3]）都采用这种方法。处理字节码而不是源代码允许实现符号执行器，而无需处理语言的复杂语法。SymJS被实现为Rhino字节码的解释器，它在执行每条字节码指令时更新程序状态(堆/栈内容和路径条件)。在命中分支指令时，它复制程序状态并继续执行两个分支。</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">Tool</th>\n<th style=\"text-align:center\">Target Lang.</th>\n<th style=\"text-align:center\">Sym.VM</th>\n<th style=\"text-align:center\">Dep./Cache Solving</th>\n<th style=\"text-align:center\">String Solving</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">SymJS</td>\n<td style=\"text-align:center\">JavaScript</td>\n<td style=\"text-align:center\">Yes</td>\n<td style=\"text-align:center\">Yes</td>\n<td style=\"text-align:center\">Yes</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">KLEE [2]</td>\n<td style=\"text-align:center\">C</td>\n<td style=\"text-align:center\">Yes</td>\n<td style=\"text-align:center\">Yes</td>\n<td style=\"text-align:center\">No</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">SAGE [6]</td>\n<td style=\"text-align:center\">x86 binary</td>\n<td style=\"text-align:center\">No</td>\n<td style=\"text-align:center\">Yes</td>\n<td style=\"text-align:center\">No</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Sym JPF [3]</td>\n<td style=\"text-align:center\">Java</td>\n<td style=\"text-align:center\">Yes</td>\n<td style=\"text-align:center\">No</td>\n<td style=\"text-align:center\">No</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Kudzu [8]</td>\n<td style=\"text-align:center\">JavaScript</td>\n<td style=\"text-align:center\">No</td>\n<td style=\"text-align:center\">No</td>\n<td style=\"text-align:center\">Yes</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Jalangi [9]</td>\n<td style=\"text-align:center\">JavaScript</td>\n<td style=\"text-align:center\">No</td>\n<td style=\"text-align:center\">No</td>\n<td style=\"text-align:center\">Limited</td>\n</tr>\n</tbody>\n</table>\n</div>\n<center>\n    <i>表I 符号执行器的比较</i>\n</center>\n\n\n<p>​        为了实现目标程序的符号执行，本文修改了原始Rhino对表II中所示指令的解释。堆栈操作、异常处理和变量范围管理的指令处理保持不变。</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">操作</th>\n<th style=\"text-align:center\">指令</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">Arithemetic/Logical Operations</td>\n<td style=\"text-align:center\">ADD, SUB, MUL, DIV, MOD, NEG, POS, BITNOT, BITAND, BITOR, BITXOR, LSH, RSH,URSH <em>etc.</em></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Comparisons</td>\n<td style=\"text-align:center\">EQ, NE, GE, GT, LE, LT, NOT, SHEQ, SHNE <em>etc.</em></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Branches</td>\n<td style=\"text-align:center\">IFEQ, IFNE, IFEQ_POP <em>etc.</em></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Function Calls</td>\n<td style=\"text-align:center\">RETURN, CALL, TAIL_CALL <em>etc.</em></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Object Manipulations</td>\n<td style=\"text-align:center\">NEW, REF, IN, INSTANCEOF, TYPEOF, GETNAME, SETNAME, NAME <em>etc.</em></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Object Accesses</td>\n<td style=\"text-align:center\">GETPROP, SETPROP, DELPROP, GETELEM, SETELEM, GETREF, SETREF <em>etc.</em></td>\n</tr>\n</tbody>\n</table>\n</div>\n<center>\n    <i>表II 修改后的指令解释</i>\n</center>\n例如，指令 `ADD op1 op2` 解释如下：\n\n(1)从堆栈中弹出操作数 `op1` 和 `op2` 。操作数可以使用抽象的值，也可以使用具体的值。\n\n(2)检查操作数的类型。如果两个操作数都是字符串，则计算结果是操作数的拼接。如果它们是数值，则结果是操作数的总和。否则，将**根据ECMAScript语言标准转换值**，结果是将获得的值拼接或相加。\n\n#### 分支指令\n\n​        比较指令之后是Rhino字节码中的分支指令。SymJS处理比较和分支指令对，如下所示：\n\n​        首先，在进行必要的类型转换后，生成与比较结果相对应的布尔公式。假设所创建的公式由符号 $c$ 表示，我们检查 $c$ 及其否定 $\\neg c$ 是否与路径条件 $pc$ 一起满足。换句话说，我们检查 $pc \\land c$ 和 $pc \\land \\neg c$ 的可满足性。如果两者都是可满足的，我们建立对应于 $pc \\land c$ 和 $pc \\land \\neg c$ 的状态 $s_1, s_2$，并从状态 $s_1$ 和 $s_2$ 继续执行。如果其中一个是可满足的，则选择与可满足的状态相对应的状态，并从该点继续执行。\n\n​        SymJS支持两种方式来管理在命中分支等情况下创建的状态。第一种方法是**存储程序状态变量，包括堆/栈的内容**，如[2] [3]中所做的那样。第二种方法是**只记住在分支上走哪一侧。此方法需要在回溯时从初始状态重新执行目标程序。**但是，它得益于其简单的实现和较小的内存占用。这种方法被称为“模糊”，类似于[4] [6]中介绍的技术。但是，本文的技术是在符号执行器上实现的，不需要修改现有JavaScript工具[8] [9]所需的目标代码。\n\n​        在通过模糊化执行程序的符号过程中，状态仅由分支上的哪一方表示和存储。该信息可用于从程序的初始状态重新执行该程序，并探索目标可能采取的状态空间。在模糊化期间，用与表I中的测试1-6相对应的路径条件符号执行图1中的目标程序之后的状态如表IV所示。符号L、R表示在分支指令上走左/右分支。\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">func0</span> (<span class=\"params\">s, a</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(””.equals(s)) &#123; <span class=\"comment\">// block 0</span></span><br><span class=\"line\">\t\ts = <span class=\"literal\">null</span>;</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (s.length &lt;= <span class=\"number\">5</span>) &#123; <span class=\"comment\">// block 1</span></span><br><span class=\"line\">\t\t\ta = a + status;</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(””.equals(s)) &#123; <span class=\"comment\">// block 2</span></span><br><span class=\"line\">\t\t\t\tLib.m0(); <span class=\"comment\">// Unreachable</span></span><br><span class=\"line\">\t\t\t&#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// block 3</span></span><br><span class=\"line\">\t\t\t\tLib.m1();</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (a &lt;= Lib.m2()) &#123; <span class=\"comment\">// block A</span></span><br><span class=\"line\">\ta = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// block B</span></span><br><span class=\"line\">\ta = a + s.length; <span class=\"comment\">// Error with null s</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<center>\n    <i>图1 一个代码框架：\n    s, a, Lib.m2()可以取任意值</i>\n</center>\n\n\n\n<p><img src=\"http://images.yingwai.top/picgo/SymJSf2.png\" alt=\"\"></p>\n<center>\n    <i>图2 代码执行路径</i>\n</center>\n\n\n\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">Test No.</th>\n<th style=\"text-align:left\">Blocks Executed</th>\n<th>State Representation</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:left\">0, A</td>\n<td>L;L</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">2</td>\n<td style=\"text-align:left\">0, B</td>\n<td>L;R</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">3</td>\n<td style=\"text-align:left\">1, A</td>\n<td>R;L;L</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">4</td>\n<td style=\"text-align:left\">1, B</td>\n<td>R;L;R</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">5</td>\n<td style=\"text-align:left\">3, A</td>\n<td>R;R;R;L</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">6</td>\n<td style=\"text-align:left\">3, B</td>\n<td>R;R;R;R</td>\n</tr>\n</tbody>\n</table>\n</div>\n<center>\n    <i>表IV 执行图1代码后的模糊表示</i>\n</center>\n\n\n\n<h4 id=\"PASS\"><a href=\"#PASS\" class=\"headerlink\" title=\"PASS\"></a>PASS</h4><p>​        对于表IV中的每个状态表示，可以获得相应的路径条件。如果有可能获得满足约束条件的解，则可以将其用作测试期间的输入。关于数值的约束可以通过SMT求解器来解决，但<strong>SMT不能处理对于字符串的约束</strong>。因此本文使用约束求解器PASS。</p>\n<p>​        <strong>PASS可以处理对整数、位向量、浮点数和字符串的约束。</strong>虽然以前的支持字符串约束的约束解算器使用位向量或自动机，但通过参数化数组传递引入的建模可以实现更高效的求解。因此，它可以解决ECMAScript标准中与字符串操作相对应的大部分约束。</p>\n<h4 id=\"符号存根及驱动程序\"><a href=\"#符号存根及驱动程序\" class=\"headerlink\" title=\"符号存根及驱动程序\"></a>符号存根及驱动程序</h4><p>​        符号变量是通过符号执行生成测试输入的对象。<strong>SymJS允许通过函数调用定义符号变量。</strong>下面的代码片段展示了定义符号字符串变量的例子：</p>\n<p><code>var s = symjs_mk_symbol_string();</code></p>\n<p>​        以上的例子定义了字符串类型的符号变量，也可以通过<code>symjs_mk_symbolic_int()</code>、<code>symjs_mk_symbolic_bool()</code>和<code>symjs_mk_symbolic_real()</code>分别定义整型、布尔型以及浮点型的符号变量。虽然SymJS只允许字符串、整数、布尔值和浮点数是符号的，但它们的约束作为更复杂的对象的组成部分保留在赋值/引用上，从而允许生成对象组成部分的值不断变化的测试。</p>\n<p>​        为了确定图1中函数<code>func0()</code>的测试输入，需要额外的代码段。首先需要一个如下所示的符号驱动程序：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> s = symjs_mk_symbolic_string();</span><br><span class=\"line\"><span class=\"keyword\">var</span> a = symjs_mk_symbolic_float();</span><br><span class=\"line\">func0(s, a);</span><br></pre></td></tr></table></figure>\n<center>\n    <i>图3 用于执行图1中代码的符号驱动程序</i>\n</center>\n\n<p>驱动程序声明符号变量并将它们作为参数传递给函数。注入依赖项的存根也是必需的。如下所示的符号存根包括符号变量声明。通过存根，包含对<code>Lib.m2()</code>的函数调用的返回值，以测试SymJS获得的输入。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Lib.m2 = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> symjs_mk_symbolic_float();</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<center>\n    <i>图4 提供图1中代码使用的Lib.m2()的符号存根</i>\n</center>\n\n<p>函数<code>symjs_mk_symbolic_*()</code>是用于在测试生成期间定义新符号变量的表达式。<strong>SymJS允许使用生成的测试输入进行正常的具体执行。</strong>在具体执行期间，函数返回测试输入中包含的具体值。SymJS可以将测试输入导出为JavaScript Object Notation (JSON) 格式的外部文件。文件可以由测试回放库读取，该库在<code>symjs_mk_symbolic_*()</code>函数调用中返回相应的测试输入数据。加载到典型Web浏览器中的测试库可以在没有自定义JavaScript解释器的情况下执行生成的测试。</p>\n<h2 id=\"符号存根及驱动程序的自动生成\"><a href=\"#符号存根及驱动程序的自动生成\" class=\"headerlink\" title=\"符号存根及驱动程序的自动生成\"></a>符号存根及驱动程序的自动生成</h2><p>​        如第2部分所述，符号存根和驱动程序需要对目标函数进行符号执行并获得测试输入。返回符号变量的符号存根用于生成从被测函数调用的函数的返回值。需要符号驱动程序来改变传递给测试函数的参数。</p>\n<h3 id=\"生成符号存根和驱动程序的策略\"><a href=\"#生成符号存根和驱动程序的策略\" class=\"headerlink\" title=\"生成符号存根和驱动程序的策略\"></a>生成符号存根和驱动程序的策略</h3><p>​        本文的符号存根生成技术为指定的函数和类生成存根。本文的驱动程序生成技术发出调用指定函数的代码。</p>\n<p>​        对于存根生成，生成函数根据调用者期望的返回值类型，创建和返回对象。以下是预期类型与返回对象之间的映射关系：</p>\n<ul>\n<li><p>字符串、整数、布尔值和浮点数这些可以被SymJS作为符号处理的类型（后面称为SymJS基础类型）：</p>\n<p>新定义的相应类型的符号变量。</p>\n</li>\n<li><p>其他类：</p>\n<p>预期类型的新实例化对象。如果该类的目标是生成存根，则返回<strong>新实例化的存根对象</strong>。</p>\n</li>\n<li><p>Void：不返回任何内容。</p>\n</li>\n</ul>\n<p>​        为了创建类的存根，还需要生成构造函数的存根。在这里，本文生成空构造函数，这将导致所有无状态对象。我们的方法假设没有对存根类的字段的直接访问，并且不为字段生成存根。</p>\n<p>​        注意：即使返回值类型不是SymJS的基本类型，也可能得到多个测试输入。如果在返回的对象中定义的函数返回符号变量，会出现这种情况。如果<strong>非SymJS基本类型的对象包含返回SymJS基本类型的对象的函数，并且非SymJS基本类型生成了存根</strong>，就会发生这种情况。因此可以通过调用返回非SymJS基本类型的函数来获得多组测试输入。</p>\n<p>​        使用本文的技术生成的符号驱动程序具有以下功能：</p>\n<ul>\n<li>如果待测函数不是静态的、需要一个实例去执行，则实例化对应类的对象并调用该函数</li>\n<li>如果待测函数是静态的，就直接调用函数</li>\n</ul>\n<p>对于传递给函数的参数，驱动程序根据预期类型提供以下对象：</p>\n<ul>\n<li><p>SymJS基本类型：</p>\n<p>新定义的相应类型的符号变量。</p>\n</li>\n<li><p>其他类：</p>\n<p>预期类型的新实例化对象。如果该类的目标是存根生成，则传递新实例化的存根对象。</p>\n</li>\n</ul>\n<p>​        选择参数的方式类似于解决在符号存根中返回什么的方式。</p>\n<h3 id=\"从注释生成符号存根和驱动程序\"><a href=\"#从注释生成符号存根和驱动程序\" class=\"headerlink\" title=\"从注释生成符号存根和驱动程序\"></a>从注释生成符号存根和驱动程序</h3><p>​        上一部分提出的符号存根/驱动程序生成策略需要知道来自目标代码的类型信息，生成存根需要调用方期望的返回值类型，需要传递给被测函数的参数类型才能生成驱动程序。</p>\n<p>​        但是JavaScript是一种动态类型语言，在真正运行前很难确定返回值和参数的类型。很多JavaScript程序对返回值和参数的类型有一个期望，通常是在应用程序编程接口（API）等中给出的。此外，有一种方法可以<strong>用机器可读的方式表示JavaScript代码的类型信息</strong>，就是JSDoc风格的注释。本文从JSDoc3[13]约定的风格的注释中获取类型信息，生成符号存根和驱动程序。</p>\n<p>​        JSDoc3主要允许通过<code>@return</code>注释声明返回值类型。为了为图1的代码片段中使用的函数<code>Lib.m2()</code>生成符号存根，需要如下所示的注释：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** <span class=\"doctag\">@return <span class=\"type\">&#123;Number&#125;</span> </span>m2 value */</span></span><br><span class=\"line\">Lib.m2 = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; ... &#125;;</span><br></pre></td></tr></table></figure>\n<p>如果将此类注释附加到函数的原始源代码，则可以确定返回值的类型。根据获得的返回值类型，可以以全自动的方式生成图4中的符号存根。该示例演示了为返回SymJS原语的函数生成符号存根。下面展示了为返回非SymJS基本类型的函数生成符号存根的示例：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** <span class=\"doctag\">@return <span class=\"type\">&#123;tx.Data&#125;</span> </span>data */</span></span><br><span class=\"line\">tx.Ui.getValue = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123; ... &#125;;</span><br></pre></td></tr></table></figure>\n<center>\n    ↓\n</center>\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tx.Ui.getValue = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> tx.Data();</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>​        符号驱动程序的生成也是一样的。</p>\n<p>​        传递给函数的参数类型通常使用JSDoc3的<code>@param</code>注释给出。函数<code>func0()</code>的符号驱动程序可以从该函数中的注释生成：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** <span class=\"doctag\">@param <span class=\"type\">&#123;String&#125;</span> <span class=\"variable\">s</span></span></span></span><br><span class=\"line\"><span class=\"comment\">  * <span class=\"doctag\">@param <span class=\"type\">&#123;Number&#125;</span> </span>a */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">func0</span>(<span class=\"params\">s, a</span>) </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>\n<p>注释给出了函数的参数类型，允许生成图3中的符号驱动程序。</p>\n<p>​        提出的自动生成符号存根和驱动程序的技术是作为JSDoc3的插件实现的。也可以使用其他来源的类型信息，例如API规范文档。</p>\n<h2 id=\"Evaluation\"><a href=\"#Evaluation\" class=\"headerlink\" title=\"Evaluation\"></a>Evaluation</h2><p>​        本文使用一个工业JavaScript程序进行了实验。该程序对应于在本文的自定义Web应用程序实现框架上实现的Web应用程序的客户端部分。该程序调用未在我们的框架中包装的ECMAScript标准中定义的API，并且它只包含对标准API或本文的框架的调用。表V显示了目标程序的统计数据：</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">#Line</th>\n<th style=\"text-align:center\">#Function</th>\n<th style=\"text-align:center\">#File</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">431</td>\n<td style=\"text-align:center\">23</td>\n<td style=\"text-align:center\">1</td>\n</tr>\n</tbody>\n</table>\n</div>\n<center>\n    <i>表V 目标程序的统计数据</i>\n</center>\n\n<h3 id=\"符号存根和驱动程序的生成\"><a href=\"#符号存根和驱动程序的生成\" class=\"headerlink\" title=\"符号存根和驱动程序的生成\"></a>符号存根和驱动程序的生成</h3><p>​        使用本文的方法成功地为框架中定义的所有类和函数生成存根。表VI列出了生成的存根的统计数据：</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">#Line(Orig.)</th>\n<th style=\"text-align:center\">#Line(Stub)</th>\n<th style=\"text-align:center\">#Function</th>\n<th style=\"text-align:center\">#File</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">2843</td>\n<td style=\"text-align:center\">1304</td>\n<td style=\"text-align:center\">154</td>\n<td style=\"text-align:center\">13</td>\n</tr>\n</tbody>\n</table>\n</div>\n<center>\n    <i>表VI 用于生成存根的框架源代码和生成的存根的统计数据</i>\n</center>\n\n<h3 id=\"生成测试输入和执行测试\"><a href=\"#生成测试输入和执行测试\" class=\"headerlink\" title=\"生成测试输入和执行测试\"></a>生成测试输入和执行测试</h3><p>​        所有函数的符号执行在1秒内完成，并生成测试输入。测试输入的数量（将具体值赋给符号变量）在目标函数之间是不同的。对于没有分支的函数，只生成1个测试输入，而对于更复杂的函数，获得的测试数量变化到27个。</p>\n<p>​        利用获得的测试输入来具体执行目标函数。运行在网络浏览器上的测试回放库用于重放测试。使用JSCover[14]测量测试期间的代码覆盖率，获得92%的行覆盖率。结果表明，该技术能够自动生成单元测试输入，实现高代码覆盖率。</p>\n<h3 id=\"实验中未覆盖的代码\"><a href=\"#实验中未覆盖的代码\" class=\"headerlink\" title=\"实验中未覆盖的代码\"></a>实验中未覆盖的代码</h3><p>​        实验结果表明，该方法可以生成代码覆盖率较高的测试输入，但没有达到100%的覆盖率，这意味着目标程序的某些部分没有被执行。以下是使用我们的方法未执行到的代码类。</p>\n<p>​        <strong>意外类型的代码处理对象没有被覆盖到。</strong>由于JavaScript是一种动态类型语言，函数可能会返回意外类型的对象。为了处理这种情况，目标程序包含类型检查和后续错误处理代码。但是，通过本文的技术生成的符号存根总是返回源代码批注中描述的类型的对象。这样的存根不能利用处理不同于注释类型的对象的代码部分。</p>\n<p>​        <strong>没有对象类型前提的代码也没有被覆盖到。</strong>目标程序包含在运行时确定对象类型并相应地处理它们的代码片段。然而，本文的技术不能涵盖这样的程序。从返回值类型未知的函数中，我们生成返回默认JavaScript “Object” 的存根。因此，与自定义类的对象交互的代码没有被覆盖。</p>\n<h2 id=\"Conclusions\"><a href=\"#Conclusions\" class=\"headerlink\" title=\"Conclusions\"></a>Conclusions</h2><p>​        本文提出了一种为JavaScript代码自动生成单元测试输入数据的技术。该技术使用符号执行引擎，以便在测试期间实现高代码覆盖率。该技术分为两个阶段，由以下全自动步骤组成：</p>\n<ul>\n<li>基于从注释获得的类型信息生成符号存根/驱动程序</li>\n<li>通过目标代码的符号执行生成测试输入</li>\n</ul>\n<p>​        实验结果显示，该技术可以生成92%的行覆盖率的测试，表明本文的技术可以自动生成和执行JavaScript代码的单元测试。</p>\n<h3 id=\"Future-Work\"><a href=\"#Future-Work\" class=\"headerlink\" title=\"Future Work\"></a>Future Work</h3><p>​        未来的方向包括更多的验证试验和各种目标程序。虽然作者已经用相对较小的程序进行了实验，但也需要在较大的目标上进行实验。</p>\n<p>​        根据实验结果，需要改进符号存根。可以使用引发异常的符号存根触发代码处理异常。除了更复杂的自动存根生成策略外，手动修改自动生成的存根被认为是增加覆盖率的有效方法。</p>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><p>[1] C. Cadar, V . Ganesh, P . M. Pawlowski, D. L. Dill, and D. R. Engler, <em>“EXE: Automatically Generating Inputs of Death,”</em> in Proceedings of the 13th ACM Conference on Computer and Communications Security, 2006, pp. 322–335.</p>\n<p>[2] C. Cadar, D. Dunbar, and D. Engler, <em>“KLEE: Unassisted and Automatic Generation of High-coverage Tests for Complex Systems Programs,”</em> in Proceedings of the 8th USENIX Conference on Operating Systems Design and Implementation, 2008, pp. 209–224.</p>\n<p>[3] C. S. Pǎsǎreanu and N. Rungta, <em>“Symbolic PathFinder: Symbolic Execution of Java Bytecode,”</em> in Proceedings of the IEEE/ACM International Conference on Automated Software Engineering, 2010, pp. 179–180.</p>\n<p>[4] K. Sen, D. Marinov, and G. Agha, <em>“CUTE: A Concolic Unit Testing Engine for C,”</em> in Proceedings of the 10th European Software Engineering Conference, 2005, pp. 263–272.</p>\n<p>[5] N. Tillmann and J. De Halleux, <em>“Pex: White Box Test Generation for .NET,”</em> in Proceedings of the 2nd International Conference on Tests and Proofs, ser. TAP’08, 2008, pp. 134–153.</p>\n<p>[6] P . Godefroid, M. Y . Levin, and D. Molnar, <em>“SAGE: Whitebox Fuzzing for Security Testing,”</em> Queue, 2012, pp. 20:20–20:27.</p>\n<p>[7] L. De Moura and N. Bjørner, <em>“Satisfiability Modulo Theories: Introduction and Applications,”</em> Commun. ACM, vol. 54, no. 9, 2011, pp. 69–77.</p>\n<p>[8] P. Saxena, D. Akhawe, S. Hanna, F. Mao, S. McCamant, and D. Song, <em>“A Symbolic Execution Framework for JavaScript,”</em> in Proceedings of the 2010 IEEE Symposium on Security and Privacy, 2010, pp. 513–528.</p>\n<p>[9] K. Sen, S. Kalasapur, T. Brutch, and S. Gibbs, <em>“Jalangi: A selective record-replay and dynamic analysis framework for javascript,”</em> in Proceedings of the 2013 9th Joint Meeting on Foundations of Software Engineering, 2013, pp. 488–498.</p>\n<p>[10] G. Li and I. Ghosh, <em>“PASS: String Solving with Parameterized Array and Interval Automaton,”</em> in Proceedings of Haifa Verification Conference, 2013, pp. 15–31.</p>\n<p>[11] ECMA International, Standard ECMA-262 - ECMAScript Language Specification, 5th ed., June 2011. [Online]. Available: <a href=\"http://www.ecma-international.org/publications/standards/Ecma-262.htm\" target=\"_blank\" rel=\"noopener\">http://www.ecma-international.org/publications/standards/Ecma-262.htm</a></p>\n<p>[12] <em>“Rhino,”</em> <a href=\"https://developer.mozilla.org/en-US/docs/Rhino\" target=\"_blank\" rel=\"noopener\">https://developer.mozilla.org/en-US/docs/Rhino</a>, [Online; accessed 2014.08.15].</p>\n<p>[13] <em>“Use JSDoc,”</em> <a href=\"http://usejsdoc.org/index.html\" target=\"_blank\" rel=\"noopener\">http://usejsdoc.org/index.html</a>, [Online; accessed 2014.08.15].</p>\n<p>[14] <em>“JSCover - JavaScript code coverage,”</em> <a href=\"http://tntim96.github.io/JSCover/\" target=\"_blank\" rel=\"noopener\">http://tntim96.github.io/JSCover/</a> <a href=\"http://usejsdoc.org/index.html\" target=\"_blank\" rel=\"noopener\">http://usejsdoc.org/index.html</a>, [Online; accessed 2014.08.15].</p>"},{"title":"论文笔记 High-Throughput Semi-Honest Secure Three-Party Computation with an Honest Majority","date":"2020-06-10T12:07:19.000Z","_content":"\n*Toshinori Araki, Jun Furukawa, Yehuda Lindell, Ariel Nof, Kazuma Ohara*\n\nCCS 2016\n\nhttps://dl.acm.org/doi/10.1145/2976749.2978331\n\n<!--more-->\n\n# 摘要\n\n在这篇文章中，作者描述了一个新的信息论协议(和一个计算安全的变体)，用于诚实多数的安全三方计算。该协议的计算量和通信量非常小；对于布尔电路，每一方只为每个与门发送一位(对于异或门则不发送任何内容)。本文的协议在半诚实的攻击者面前是(基于模拟的)安全的，在恶意攻击者面前实现了客户机/服务器模型下的隐私。\n\n在具有10Gbps连接的三个20核服务器的集群上，本文的协议的实现每秒执行超过130万次AES计算，涉及每秒处理超过70亿个门。此外，作者还开发了一个Kerberos扩展，它使用服务器之间共享的密钥/密码，用本文的协议取代了MIT-Kerberos中密钥分发中心(KDC)上的票证授予-票证加密。这样可以在保护密码的同时使用Kerberos。本文的实现能够支持每秒超过35,000个登录的登录风暴，即使对于非常大的组织也足够了。本文的工作证明了在标准硬件上实现高通量安全计算是可能的。\n\n\n\n# THE NEW PROTOCOL\n\n## Securely Computing Boolean Circuits\n\n为了简化说明，首先描述具有与和异或门的布尔电路的特殊情况的协议。假设各方 $P_1,P_2,P_3$ 能够获得随机的 $x_1, x_2, x_3 \\in \\{0,1 \\}$，使得 $x_1 \\oplus x_2 \\oplus x_3 = 0$。\n\n**秘密共享。**作者定义了一个3取2的秘密共享方案，记为$\\left( \\begin{array}{c} 3\\\\2 \\end{array} \\right)$-共享，如下所示。为了共享比特 $v$，分发者在 $x_1 \\oplus x_2 \\oplus x_3 = 0$ 的约束下选择三个随机比特 $x_1, x_2, x_3 \\in \\{0,1 \\}$。然后：\n\n* $P_1$ 的份额为 $(x_1, a_1)$，其中 $a_1 = x_3 \\oplus v$；\n* $P_2$ 的份额为 $(x_2, a_2)$，其中 $a_2 = x_1 \\oplus v$；\n* $P_3$ 的份额为 $(x_3, a_3)$，其中 $a_3 = x_2 \\oplus v$。\n\n很明显，任何一方的份额都不能揭示关于v的任何信息。此外，任何两个份额都足以获得 $v$；例如，给定 $x_1,x_2,a_1,a_2$，我们可以计算 $v = a_2 \\oplus x_1$。\n\n**异或(加法)门。**设 $(x_1,a_1),(x_2,a_2),(x_3,a_3)$ 是 $v_1$ 的秘密共享，$(y_1,b_1),(y_2,b_2),(y_3,b_3)$ 是 $v_2$ 的秘密共享。然后，为了计算 $v_1$ 和 $v_2$ 的秘密共享，每个 $P_i$ 在本地计算 $z_i = x_i \\oplus y_i$ 和 $c_i = a_i \\oplus b_i$ 得到 $(z_i, c_i)$ (不需要通信)。为了查看结果是否构成 $v_1 \\oplus v_2$ 的有效$\\left( \\begin{array}{c} 3\\\\2 \\end{array} \\right)$-共享，首先注意到 $z_1 \\oplus z_2 \\oplus z_3 = 0$ (因为 $x_1 \\oplus x_2 \\oplus x_3 = 0$ 和 $y_1 \\oplus y_2 \\oplus y_3 = 0$)。接下来，观察到对于每个 $i \\in \\{1,2,3\\}$，它持有 $c_i = z_{i−1} \\oplus (v_1 \\oplus v_2)$，其中 $i=1$ 时 $i−1=3$；例如，我们有 $c_1=a_1 \\oplus b_1$ $=x_3 \\oplus v_1 \\oplus y_3 \\oplus v_2$ $=(x_3 \\oplus y_3)\\oplus (v_1 \\oplus v_2)$ $=z_3\\oplus (v_1 \\oplus v_2)$。因此，这构成具有随机性 $z_1,z_2,z_3$ 的 $v_1 \\oplus v_2$ 的共享。\n\n**与(乘法)门。**现在展示各方如何计算与(乘法)门；此子协议要求每一方只发送单个比特。该协议分两个阶段工作：第一阶段双方计算输入位的与的简单$\\left( \\begin{array}{c} 3\\\\3 \\end{array} \\right)$异或-共享，第二阶段将$\\left( \\begin{array}{c} 3\\\\3 \\end{array} \\right)$-共享转换为上述定义的$\\left( \\begin{array}{c} 3\\\\2 \\end{array} \\right)$-共享。\n\n设 $(x_1,a_1),(x_2,a_2),(x_3,a_3)$ 是 $v_1$ 的秘密共享，$(y_1,b_1),(y_2,b_2),(y_3,b_3)$ 是 $v_2$ 的秘密共享。假设各方 $P_1,P_2,P_3$ 分别具有相关随机性 $\\alpha, \\beta, \\gamma$，其中 $\\alpha \\oplus \\beta \\oplus \\gamma = 0$。双方计算 $v_1 \\cdot v_2 = v_1 \\wedge v_2$ 的$\\left( \\begin{array}{c} 3\\\\2 \\end{array} \\right)$-份额如下(从这里开始，将简单地将 $a$ 和 $b$ 的积表示为 $ab$)：\n\n1. 第一步——计算$\\left( \\begin{array}{c} 3\\\\3 \\end{array} \\right)$-共享：\n\n   * $P_1$ 计算 $r_1 = x_1 y_1 \\oplus a_1 b_1 \\oplus \\alpha$，然后发送 $r_1$ 给 $P_2$；\n   * $P_2$ 计算 $r_2 = x_2 y_2 \\oplus a_2 b_2 \\oplus \\beta$，然后发送 $r_2$ 给 $P_3$；\n   * $P_3$ 计算 $r_3 = x_3 y_3 \\oplus a_3 b_3 \\oplus \\gamma$，然后发送 $r_3$ 给 $P_1$。\n\n   这些消息是并行地计算和发送的。\n\n2. 第二步——计算$\\left( \\begin{array}{c} 3\\\\2 \\end{array} \\right)$-共享：在此步骤中，各方根据其给定的$\\left( \\begin{array}{c} 3\\\\3 \\end{array} \\right)$-共享和上一步中发送的消息构建$\\left( \\begin{array}{c} 3\\\\2 \\end{array} \\right)$-共享，只需要本地计算。\n\n   *  $P_1$ 存储 $(z_1, c_1)$，其中 $z_1 = r_1 \\oplus r_3$，以及 $c_1 = r_1$；\n   *  $P_2$ 存储 $(z_2, c_2)$，其中 $z_2 = r_2 \\oplus r_1$，以及 $c_2 = r_2$；\n   *  $P_3$ 存储 $(z_3, c_3)$，其中 $z_3 = r_3 \\oplus r_2$，以及 $c_3 = r_3$；\n\n**对第一步的解释：**证明第一步中，$r_1 \\oplus r_2 \\oplus r_3 = v_1 \\wedge v_2$。首先注意到：\n$$\na_1 b_1 = (x_3 \\oplus v_1) (y_3 \\oplus v_2) = x_3 y_3 \\oplus x_3 v_2 \\oplus y_3 v_1 \\oplus v_1 v_2 \\tag{1}\n$$\n类似地有 $a_2 b_2 = x_1 y_1 \\oplus x_1 v_2 \\oplus y_1 v_1 \\oplus v_1 v_2$ 和 $a_3 b_3 = x_2 y_2 \\oplus x_2 v_2 \\oplus y_2 v_1 \\oplus v_1 v_2$。因此，\n$$\n\\begin{align}\nr_1 &\\oplus r_2 \\oplus r_3 \\\\\n &= (x_1 y_1 \\oplus a_1 b_1 \\oplus \\alpha) \\oplus (x_2 y_2 \\oplus a_2 b_2 \\oplus \\beta) \\oplus (x_3 y_3 \\oplus a_3 b_3 \\oplus \\gamma) \\\\\n &= x_1 y_1 \\oplus x_2 y_2 \\oplus x_3 y_3 \\oplus b_1 a_1 \\oplus a_2 b_2 \\oplus a_3 b_3 \\\\\n &= x_1 y_1 \\oplus x_2 y_2 \\oplus x_3  y_3 \\oplus (x_3 y_3 \\oplus x_3 v_2 \\oplus y_3 v_1 \\oplus v_1 v_2) \\\\\n & \\qquad \\qquad \\qquad \\qquad \\quad  \\oplus (x_1 y_1 \\oplus x_1 v_2 \\oplus y_1 v_1 \\oplus v_1 v_2) \\\\\n & \\qquad \\qquad \\qquad \\qquad \\quad  \\oplus (x_2 y_2 \\oplus x_2 v_2 \\oplus y_2 v_1 \\oplus v_1 v_2) \\\\\n &= (x_1 \\oplus x_2 \\oplus x_3) v_2 \\oplus (y_1 \\oplus y_2 \\oplus y_3) v_1 \\oplus v_1 v_2 = v_1 v_2\n\\end{align}\n$$\n第二个等号成立是因为 $\\alpha \\oplus \\beta \\oplus \\gamma = 0$，第三个等号成立是因为公式 $(1)$，第四个等号成立就是简单的删除重复元素，最后一个等号成立是因为 $x_1 \\oplus x_2 \\oplus x_3 = y_1 \\oplus y_2 \\oplus y_3 = 0$。\n\n**对第二步的解释：**根据定义，为了证明结果是有效的 $v_1v_2$ 的$\\left( \\begin{array}{c} 3\\\\2 \\end{array} \\right)$-共享，我们需要证明 $z_1,z_2,z_3$ 使得 $z_1 \\oplus z_2 \\oplus z_3 = 0$，并且 $c_1,c_2,c_3$ 是所定义的形式。\n\n首先，$z_1 \\oplus z_2 \\oplus z_3 = (r_1 \\oplus r_3) \\oplus (r_2 \\oplus r_1) \\oplus (r_3 \\oplus r_2) = 0$。其次，注意到$c_1 \\oplus c_2 \\oplus c_3 = r_1 \\oplus r_2 \\oplus r_3 = v_1 v_2$，移项得 $c_1 = r_1 = v_1 v_2 \\oplus r_2 \\oplus r_3$。又因为 $r_2 \\oplus r_3 = z_3$，于是 $c_1 = v_1 v_2 \\oplus z_3$，得证。对于 $c_2, c_3$ 也可以同样证明。\n\n**协议。**完整的三方协议以自然的方式工作。各方首先使用秘密共享方法共享其输入。然后，它们根据电路的预定拓扑顺序计算电路中的每个XOR与AND门。最后，各方在输出线上重建其输出。(在客户端/服务器模型中，外部客户端将其输入的共享发送给三方，然后三方根据收到的共享以相同的方式计算电路。)\n\n请注意，每一方只与另一方进行通信。这一性质也适用于Sharemind的协议。然而，本文的秘密共享方案和乘法协议是完全不同的。\n\n\n\n## Generating Correlated Randomness\n\n这里将说明如何高效地为每个与门生成随机比特 $\\alpha, \\beta, \\gamma \\in \\{0, 1\\}$ ，满足 $\\alpha \\oplus \\beta \\oplus \\gamma = 0$。\n\n**信息论相关随机性。**通过使每一方 $P_i$ 简单地选择随机 $\\rho_i \\in \\{0,1\\}$ 并将其发送到 $P_{i+1}$ (其中 $P_3$ 发送到 $P_1$)，可以安全地生成具有完美安全性的相关随机性。然后，每一方将其随机比特作为其选择的比特与其接收的比特的异或：$P_1$ 计算 $\\alpha = \\rho_3 \\oplus \\rho_1$，$P_2$ 计算 $\\beta = \\rho_1 \\oplus \\rho_2$ 以及 $P_3$ 计算 $\\gamma = \\rho_2 \\oplus \\rho_3$。观察到 $\\alpha + \\beta + \\gamma = 0$ 满足要求。此外，如果 $P_1$ 损坏，则它除了知道 $\\beta \\oplus \\gamma = \\alpha$ 之外，对 $\\beta$ 和 $\\gamma$ 一无所知。这是因为 $\\beta$ 和 $\\gamma$ 在他们的计算中都包含了 $\\rho_2$，而这对于 $P_1$ 是未知的。类似的论点也适用于损坏的 $P_2$ 或 $P_3$。尽管此解决方案既优雅又简单，但作者使用了不同的方法。这是因为这将使每个与门的通信增加一倍；确实，这仍然是非常少的通信。但是，考虑到通信是瓶颈，这将使吞吐量减半。\n\n**计算相关随机性。**接下来作者展示了如何通过计算安全地计算相关随机性，而不需要除短初始设置之外的任何交互。这使我们能够维持各方只需要在每个与门传输单个比特的当前情况。设 $\\kappa$ 为安全参数，$F: \\{0,1\\}^{\\kappa} \\times \\{0,1\\}^{\\kappa} \\rightarrow \\{0,1\\}$ 为输出单比特的伪随机函数。\n\n1. **Init：**\n\n   * 每个 $P_i$ 选择一个随机的 $k_i \\in \\{0,1\\}^{\\kappa}$；\n   * $P_1$ 发送 $k_1$ 给 $P_3$，$P_2$ 发送 $k_2$ 给 $P_1$，$P_3$ 发送 $k_3$ 给 $P_2$。\n\n   $P_1$ 持有 $k_1, k_2$，$P_2$ 持有 $k_2, k_3$，$P_3$ 持有 $k_3, k_1$。\n\n2. **GetNextBit：**给定唯一标识符 $id \\in \\{0,1\\}^{\\kappa}$，\n\n   * $P_1$ 计算 $\\alpha = F_{k_1}(id) \\oplus F_{k_2}(id)$；\n   * $P_2$ 计算 $\\beta = F_{k_2}(id) \\oplus F_{k_3}(id)$；\n   * $P_3$ 计算 $\\gamma = F_{k_3}(id) \\oplus F_{k_1}(id)$。\n\n注意到 $\\alpha \\oplus \\beta \\oplus \\gamma = 0$。此外，$P_1$ 不知道用于生成 $\\beta$ 和 $\\gamma$ 的 $k_3$。因此，在 $\\beta$ 和 $\\gamma$ 的约束下，$\\beta \\oplus \\gamma = \\alpha$ 对 $P_1$ 是伪随机的。实际上，$id$ 可以是所有各方在每次调用 **GetNextBit** 时本地递增的计数器。\n\n\n\n## The Ring Modulo $2^n$ and Fields\n\n上一节讲到的是布尔电路下的协议，接下来将其推广到模 $2^n$ 的环和大于 $2$ 的任意域的一般情况。当取 $n=1$ 时，加法(和减法)与异或相同，乘法与与相同。在这种情况下，这里的协议与第2.1节中描述的协议完全相同。\n\n$\\left( \\begin{array}{c} 3\\\\2 \\end{array} \\right)$**-共享。**为了共享一个元素 $v \\bmod 2^n$，分发者选择三个满足约束 $x_1 + x_2 + x_3 = 0$ 的随机元素 $x_1, x_2, x_3 \\in \\mathbb{Z}_{2^n}$。然后 $P_1$ 的份额为 $(x_1, a_1)$，其中 $a_1 = x_3 - v$；$P_2$ 的份额为 $(x_2, a_2)$，其中 $a_2 = x_1 - v$；$P_3$ 的份额为 $(x_3, a_3)$，其中 $a_3 = x_2 - v$。跟布尔电路的情况一样，每一方的份额都没有暴露关于 $v$ 的信息，而且任意两方可以重构 $v$。\n\n**加法门。**与布尔电路的情况一样，各方在本地将对应的份额进行相加模 $2^n$ 即可。\n\n**乘法门。**设 $(x_1,a_1),(x_2,a_2),(x_3,a_3)$ 是 $v_1$ 的秘密共享，$(y_1,b_1),(y_2,b_2),(y_3,b_3)$ 是 $v_2$ 的秘密共享。假设各方 $P_1,P_2,P_3$ 分别有 $\\alpha, \\beta, \\gamma \\in \\mathbb{Z}_{2^n}$，其中 $\\alpha + \\beta + \\gamma = 0$。为了计算两个值的积的$\\left( \\begin{array}{c} 3\\\\2 \\end{array} \\right)$-份额，各方计算：\n\n1. $P_1$ 计算 $r_1 = \\frac{a_1 b_1 - x_1 y_1 + \\alpha}{3}$，然后发送 $r_1$ 给 $P_2$；\n2. $P_2$ 计算 $r_2 = \\frac{a_2 b_2 - x_2 y_2 + \\beta}{3}$，然后发送 $r_2$ 给 $P_3$；\n3. $P_3$ 计算 $r_3 = \\frac{a_3 b_3 - x_3 y_3 + \\gamma}{3}$，然后发送 $r_3$ 给 $P_1$；\n4. $P_1$ 将它的份额定义为 $z_1 = r_3 - r_1$ 和 $c_1 = -2r_3 - r_1$；\n5. $P_2$ 将它的份额定义为 $z_2 = r_1 - r_2$ 和 $c_2 = -2r_1 - r_2$；\n6. $P_3$ 将它的份额定义为 $z_3 = r_2 - r_3$ 和 $c_3 = -2r_2 - r_3$。\n\n上面的计算是合法的，因为 $3$ 与 $2^n$ 是互质的；因此，$3$ 是可逆的。此外，上述结果在3个以上元素的有限域上都成立。\n\n为了验证 $r_1 + r_2 + r_3 = v_1 v_2$，首先观察到\n$$\na_1 b_1  = (x_3 - v_1)(y_3 - v_2) = x_3 y_3 - x_3 v_2 - y_3 v_1 + v_1 v_2 \\tag{2}\n$$\n类似地，$a_2 b_2 = x_1 y_1 - x_1 v_2 - y_1 v_1 + v_1 v_2$，$a_3 b_3 = x_2 y_2 - x_2 v_2 - y_2 v_1 + v_1 v_2$。然后\n$$\n\\begin{align}\n3(&r_1 + r_2 + r_3) \\\\\n&= a_1 b_1 - x_1 y_1 + \\alpha + a_2 b_2 - x_2 y_2 + \\beta + a_3 b_3 - x_3 y_3 + \\gamma \\\\\n&= a_1 b_1 + a_2 b_2 + a_3 b_3 - x_1 y_1 - x_2 y_2 - x_3 y_3 \\\\\n&= 3v_1 v_2 - v_1(y_1 + y_2 + y_3) - v_2(x_1 + x_2 + x_3) = 3v_1 v_2\n\\end{align}\n$$\n接下来证明各方的$\\left( \\begin{array}{c} 3\\\\2 \\end{array} \\right)$-份额是有效的：根据定义，各方的份额为 $(z_1, z_3 - v_1 v_2), (z_2, z_1 - v_1 v_2)$ 和 $(z_3, z_2 - v_1 v_2)$，其中 $z_1 + z_2 + z_3 = 0 \\bmod 2^n$。首先后者很容易看出来是成立的，根据 $z_1, z_2, z_3$ 的定义。其次，$P_1$ 持有 $c_1$ $= -2 r_3 - r_1$ $= -r_3 - r_3 - r_1 - r_2 + r_2$ $=(r_2 - r_3)-(r_1 + r_2 + r_3)$ $=z_3 - v_1 v_2$，满足要求。对于 $P_2$ 和 $P_3$ 的情况同样成立。\n\n**生成相关随机性。**各方使用与第2.2节所述相同的(计算)方法，但有以下不同之处。首先，我们假设 $F_k$ 是将字符串映射到 $\\mathbb{Z}_{2^n}$ (或等价于 $\\{0,1\\}^n$)的伪随机函数。其次，$P_1$计算 $\\alpha = F_{k_1}(id) - F_{k_2}(id)$，$P_2$计算 $\\beta = F_{k_2}(id) - F_{k_3}(id)$，$P_3$计算 $\\gamma = F_{k_3}(id) - F_{k_1}(id)$。","source":"_posts/论文笔记-High-Throughput-Semi-Honest-Secure-Three-Party-Computation-with-an-Honest-Majority.md","raw":"---\ntitle: >-\n  论文笔记 High-Throughput Semi-Honest Secure Three-Party Computation with an Honest\n  Majority\ndate: 2020-06-10 20:07:19\ncategories: Papers\ntags: [MPC, 密码学, Secret Sharing]\n---\n\n*Toshinori Araki, Jun Furukawa, Yehuda Lindell, Ariel Nof, Kazuma Ohara*\n\nCCS 2016\n\nhttps://dl.acm.org/doi/10.1145/2976749.2978331\n\n<!--more-->\n\n# 摘要\n\n在这篇文章中，作者描述了一个新的信息论协议(和一个计算安全的变体)，用于诚实多数的安全三方计算。该协议的计算量和通信量非常小；对于布尔电路，每一方只为每个与门发送一位(对于异或门则不发送任何内容)。本文的协议在半诚实的攻击者面前是(基于模拟的)安全的，在恶意攻击者面前实现了客户机/服务器模型下的隐私。\n\n在具有10Gbps连接的三个20核服务器的集群上，本文的协议的实现每秒执行超过130万次AES计算，涉及每秒处理超过70亿个门。此外，作者还开发了一个Kerberos扩展，它使用服务器之间共享的密钥/密码，用本文的协议取代了MIT-Kerberos中密钥分发中心(KDC)上的票证授予-票证加密。这样可以在保护密码的同时使用Kerberos。本文的实现能够支持每秒超过35,000个登录的登录风暴，即使对于非常大的组织也足够了。本文的工作证明了在标准硬件上实现高通量安全计算是可能的。\n\n\n\n# THE NEW PROTOCOL\n\n## Securely Computing Boolean Circuits\n\n为了简化说明，首先描述具有与和异或门的布尔电路的特殊情况的协议。假设各方 $P_1,P_2,P_3$ 能够获得随机的 $x_1, x_2, x_3 \\in \\{0,1 \\}$，使得 $x_1 \\oplus x_2 \\oplus x_3 = 0$。\n\n**秘密共享。**作者定义了一个3取2的秘密共享方案，记为$\\left( \\begin{array}{c} 3\\\\2 \\end{array} \\right)$-共享，如下所示。为了共享比特 $v$，分发者在 $x_1 \\oplus x_2 \\oplus x_3 = 0$ 的约束下选择三个随机比特 $x_1, x_2, x_3 \\in \\{0,1 \\}$。然后：\n\n* $P_1$ 的份额为 $(x_1, a_1)$，其中 $a_1 = x_3 \\oplus v$；\n* $P_2$ 的份额为 $(x_2, a_2)$，其中 $a_2 = x_1 \\oplus v$；\n* $P_3$ 的份额为 $(x_3, a_3)$，其中 $a_3 = x_2 \\oplus v$。\n\n很明显，任何一方的份额都不能揭示关于v的任何信息。此外，任何两个份额都足以获得 $v$；例如，给定 $x_1,x_2,a_1,a_2$，我们可以计算 $v = a_2 \\oplus x_1$。\n\n**异或(加法)门。**设 $(x_1,a_1),(x_2,a_2),(x_3,a_3)$ 是 $v_1$ 的秘密共享，$(y_1,b_1),(y_2,b_2),(y_3,b_3)$ 是 $v_2$ 的秘密共享。然后，为了计算 $v_1$ 和 $v_2$ 的秘密共享，每个 $P_i$ 在本地计算 $z_i = x_i \\oplus y_i$ 和 $c_i = a_i \\oplus b_i$ 得到 $(z_i, c_i)$ (不需要通信)。为了查看结果是否构成 $v_1 \\oplus v_2$ 的有效$\\left( \\begin{array}{c} 3\\\\2 \\end{array} \\right)$-共享，首先注意到 $z_1 \\oplus z_2 \\oplus z_3 = 0$ (因为 $x_1 \\oplus x_2 \\oplus x_3 = 0$ 和 $y_1 \\oplus y_2 \\oplus y_3 = 0$)。接下来，观察到对于每个 $i \\in \\{1,2,3\\}$，它持有 $c_i = z_{i−1} \\oplus (v_1 \\oplus v_2)$，其中 $i=1$ 时 $i−1=3$；例如，我们有 $c_1=a_1 \\oplus b_1$ $=x_3 \\oplus v_1 \\oplus y_3 \\oplus v_2$ $=(x_3 \\oplus y_3)\\oplus (v_1 \\oplus v_2)$ $=z_3\\oplus (v_1 \\oplus v_2)$。因此，这构成具有随机性 $z_1,z_2,z_3$ 的 $v_1 \\oplus v_2$ 的共享。\n\n**与(乘法)门。**现在展示各方如何计算与(乘法)门；此子协议要求每一方只发送单个比特。该协议分两个阶段工作：第一阶段双方计算输入位的与的简单$\\left( \\begin{array}{c} 3\\\\3 \\end{array} \\right)$异或-共享，第二阶段将$\\left( \\begin{array}{c} 3\\\\3 \\end{array} \\right)$-共享转换为上述定义的$\\left( \\begin{array}{c} 3\\\\2 \\end{array} \\right)$-共享。\n\n设 $(x_1,a_1),(x_2,a_2),(x_3,a_3)$ 是 $v_1$ 的秘密共享，$(y_1,b_1),(y_2,b_2),(y_3,b_3)$ 是 $v_2$ 的秘密共享。假设各方 $P_1,P_2,P_3$ 分别具有相关随机性 $\\alpha, \\beta, \\gamma$，其中 $\\alpha \\oplus \\beta \\oplus \\gamma = 0$。双方计算 $v_1 \\cdot v_2 = v_1 \\wedge v_2$ 的$\\left( \\begin{array}{c} 3\\\\2 \\end{array} \\right)$-份额如下(从这里开始，将简单地将 $a$ 和 $b$ 的积表示为 $ab$)：\n\n1. 第一步——计算$\\left( \\begin{array}{c} 3\\\\3 \\end{array} \\right)$-共享：\n\n   * $P_1$ 计算 $r_1 = x_1 y_1 \\oplus a_1 b_1 \\oplus \\alpha$，然后发送 $r_1$ 给 $P_2$；\n   * $P_2$ 计算 $r_2 = x_2 y_2 \\oplus a_2 b_2 \\oplus \\beta$，然后发送 $r_2$ 给 $P_3$；\n   * $P_3$ 计算 $r_3 = x_3 y_3 \\oplus a_3 b_3 \\oplus \\gamma$，然后发送 $r_3$ 给 $P_1$。\n\n   这些消息是并行地计算和发送的。\n\n2. 第二步——计算$\\left( \\begin{array}{c} 3\\\\2 \\end{array} \\right)$-共享：在此步骤中，各方根据其给定的$\\left( \\begin{array}{c} 3\\\\3 \\end{array} \\right)$-共享和上一步中发送的消息构建$\\left( \\begin{array}{c} 3\\\\2 \\end{array} \\right)$-共享，只需要本地计算。\n\n   *  $P_1$ 存储 $(z_1, c_1)$，其中 $z_1 = r_1 \\oplus r_3$，以及 $c_1 = r_1$；\n   *  $P_2$ 存储 $(z_2, c_2)$，其中 $z_2 = r_2 \\oplus r_1$，以及 $c_2 = r_2$；\n   *  $P_3$ 存储 $(z_3, c_3)$，其中 $z_3 = r_3 \\oplus r_2$，以及 $c_3 = r_3$；\n\n**对第一步的解释：**证明第一步中，$r_1 \\oplus r_2 \\oplus r_3 = v_1 \\wedge v_2$。首先注意到：\n$$\na_1 b_1 = (x_3 \\oplus v_1) (y_3 \\oplus v_2) = x_3 y_3 \\oplus x_3 v_2 \\oplus y_3 v_1 \\oplus v_1 v_2 \\tag{1}\n$$\n类似地有 $a_2 b_2 = x_1 y_1 \\oplus x_1 v_2 \\oplus y_1 v_1 \\oplus v_1 v_2$ 和 $a_3 b_3 = x_2 y_2 \\oplus x_2 v_2 \\oplus y_2 v_1 \\oplus v_1 v_2$。因此，\n$$\n\\begin{align}\nr_1 &\\oplus r_2 \\oplus r_3 \\\\\n &= (x_1 y_1 \\oplus a_1 b_1 \\oplus \\alpha) \\oplus (x_2 y_2 \\oplus a_2 b_2 \\oplus \\beta) \\oplus (x_3 y_3 \\oplus a_3 b_3 \\oplus \\gamma) \\\\\n &= x_1 y_1 \\oplus x_2 y_2 \\oplus x_3 y_3 \\oplus b_1 a_1 \\oplus a_2 b_2 \\oplus a_3 b_3 \\\\\n &= x_1 y_1 \\oplus x_2 y_2 \\oplus x_3  y_3 \\oplus (x_3 y_3 \\oplus x_3 v_2 \\oplus y_3 v_1 \\oplus v_1 v_2) \\\\\n & \\qquad \\qquad \\qquad \\qquad \\quad  \\oplus (x_1 y_1 \\oplus x_1 v_2 \\oplus y_1 v_1 \\oplus v_1 v_2) \\\\\n & \\qquad \\qquad \\qquad \\qquad \\quad  \\oplus (x_2 y_2 \\oplus x_2 v_2 \\oplus y_2 v_1 \\oplus v_1 v_2) \\\\\n &= (x_1 \\oplus x_2 \\oplus x_3) v_2 \\oplus (y_1 \\oplus y_2 \\oplus y_3) v_1 \\oplus v_1 v_2 = v_1 v_2\n\\end{align}\n$$\n第二个等号成立是因为 $\\alpha \\oplus \\beta \\oplus \\gamma = 0$，第三个等号成立是因为公式 $(1)$，第四个等号成立就是简单的删除重复元素，最后一个等号成立是因为 $x_1 \\oplus x_2 \\oplus x_3 = y_1 \\oplus y_2 \\oplus y_3 = 0$。\n\n**对第二步的解释：**根据定义，为了证明结果是有效的 $v_1v_2$ 的$\\left( \\begin{array}{c} 3\\\\2 \\end{array} \\right)$-共享，我们需要证明 $z_1,z_2,z_3$ 使得 $z_1 \\oplus z_2 \\oplus z_3 = 0$，并且 $c_1,c_2,c_3$ 是所定义的形式。\n\n首先，$z_1 \\oplus z_2 \\oplus z_3 = (r_1 \\oplus r_3) \\oplus (r_2 \\oplus r_1) \\oplus (r_3 \\oplus r_2) = 0$。其次，注意到$c_1 \\oplus c_2 \\oplus c_3 = r_1 \\oplus r_2 \\oplus r_3 = v_1 v_2$，移项得 $c_1 = r_1 = v_1 v_2 \\oplus r_2 \\oplus r_3$。又因为 $r_2 \\oplus r_3 = z_3$，于是 $c_1 = v_1 v_2 \\oplus z_3$，得证。对于 $c_2, c_3$ 也可以同样证明。\n\n**协议。**完整的三方协议以自然的方式工作。各方首先使用秘密共享方法共享其输入。然后，它们根据电路的预定拓扑顺序计算电路中的每个XOR与AND门。最后，各方在输出线上重建其输出。(在客户端/服务器模型中，外部客户端将其输入的共享发送给三方，然后三方根据收到的共享以相同的方式计算电路。)\n\n请注意，每一方只与另一方进行通信。这一性质也适用于Sharemind的协议。然而，本文的秘密共享方案和乘法协议是完全不同的。\n\n\n\n## Generating Correlated Randomness\n\n这里将说明如何高效地为每个与门生成随机比特 $\\alpha, \\beta, \\gamma \\in \\{0, 1\\}$ ，满足 $\\alpha \\oplus \\beta \\oplus \\gamma = 0$。\n\n**信息论相关随机性。**通过使每一方 $P_i$ 简单地选择随机 $\\rho_i \\in \\{0,1\\}$ 并将其发送到 $P_{i+1}$ (其中 $P_3$ 发送到 $P_1$)，可以安全地生成具有完美安全性的相关随机性。然后，每一方将其随机比特作为其选择的比特与其接收的比特的异或：$P_1$ 计算 $\\alpha = \\rho_3 \\oplus \\rho_1$，$P_2$ 计算 $\\beta = \\rho_1 \\oplus \\rho_2$ 以及 $P_3$ 计算 $\\gamma = \\rho_2 \\oplus \\rho_3$。观察到 $\\alpha + \\beta + \\gamma = 0$ 满足要求。此外，如果 $P_1$ 损坏，则它除了知道 $\\beta \\oplus \\gamma = \\alpha$ 之外，对 $\\beta$ 和 $\\gamma$ 一无所知。这是因为 $\\beta$ 和 $\\gamma$ 在他们的计算中都包含了 $\\rho_2$，而这对于 $P_1$ 是未知的。类似的论点也适用于损坏的 $P_2$ 或 $P_3$。尽管此解决方案既优雅又简单，但作者使用了不同的方法。这是因为这将使每个与门的通信增加一倍；确实，这仍然是非常少的通信。但是，考虑到通信是瓶颈，这将使吞吐量减半。\n\n**计算相关随机性。**接下来作者展示了如何通过计算安全地计算相关随机性，而不需要除短初始设置之外的任何交互。这使我们能够维持各方只需要在每个与门传输单个比特的当前情况。设 $\\kappa$ 为安全参数，$F: \\{0,1\\}^{\\kappa} \\times \\{0,1\\}^{\\kappa} \\rightarrow \\{0,1\\}$ 为输出单比特的伪随机函数。\n\n1. **Init：**\n\n   * 每个 $P_i$ 选择一个随机的 $k_i \\in \\{0,1\\}^{\\kappa}$；\n   * $P_1$ 发送 $k_1$ 给 $P_3$，$P_2$ 发送 $k_2$ 给 $P_1$，$P_3$ 发送 $k_3$ 给 $P_2$。\n\n   $P_1$ 持有 $k_1, k_2$，$P_2$ 持有 $k_2, k_3$，$P_3$ 持有 $k_3, k_1$。\n\n2. **GetNextBit：**给定唯一标识符 $id \\in \\{0,1\\}^{\\kappa}$，\n\n   * $P_1$ 计算 $\\alpha = F_{k_1}(id) \\oplus F_{k_2}(id)$；\n   * $P_2$ 计算 $\\beta = F_{k_2}(id) \\oplus F_{k_3}(id)$；\n   * $P_3$ 计算 $\\gamma = F_{k_3}(id) \\oplus F_{k_1}(id)$。\n\n注意到 $\\alpha \\oplus \\beta \\oplus \\gamma = 0$。此外，$P_1$ 不知道用于生成 $\\beta$ 和 $\\gamma$ 的 $k_3$。因此，在 $\\beta$ 和 $\\gamma$ 的约束下，$\\beta \\oplus \\gamma = \\alpha$ 对 $P_1$ 是伪随机的。实际上，$id$ 可以是所有各方在每次调用 **GetNextBit** 时本地递增的计数器。\n\n\n\n## The Ring Modulo $2^n$ and Fields\n\n上一节讲到的是布尔电路下的协议，接下来将其推广到模 $2^n$ 的环和大于 $2$ 的任意域的一般情况。当取 $n=1$ 时，加法(和减法)与异或相同，乘法与与相同。在这种情况下，这里的协议与第2.1节中描述的协议完全相同。\n\n$\\left( \\begin{array}{c} 3\\\\2 \\end{array} \\right)$**-共享。**为了共享一个元素 $v \\bmod 2^n$，分发者选择三个满足约束 $x_1 + x_2 + x_3 = 0$ 的随机元素 $x_1, x_2, x_3 \\in \\mathbb{Z}_{2^n}$。然后 $P_1$ 的份额为 $(x_1, a_1)$，其中 $a_1 = x_3 - v$；$P_2$ 的份额为 $(x_2, a_2)$，其中 $a_2 = x_1 - v$；$P_3$ 的份额为 $(x_3, a_3)$，其中 $a_3 = x_2 - v$。跟布尔电路的情况一样，每一方的份额都没有暴露关于 $v$ 的信息，而且任意两方可以重构 $v$。\n\n**加法门。**与布尔电路的情况一样，各方在本地将对应的份额进行相加模 $2^n$ 即可。\n\n**乘法门。**设 $(x_1,a_1),(x_2,a_2),(x_3,a_3)$ 是 $v_1$ 的秘密共享，$(y_1,b_1),(y_2,b_2),(y_3,b_3)$ 是 $v_2$ 的秘密共享。假设各方 $P_1,P_2,P_3$ 分别有 $\\alpha, \\beta, \\gamma \\in \\mathbb{Z}_{2^n}$，其中 $\\alpha + \\beta + \\gamma = 0$。为了计算两个值的积的$\\left( \\begin{array}{c} 3\\\\2 \\end{array} \\right)$-份额，各方计算：\n\n1. $P_1$ 计算 $r_1 = \\frac{a_1 b_1 - x_1 y_1 + \\alpha}{3}$，然后发送 $r_1$ 给 $P_2$；\n2. $P_2$ 计算 $r_2 = \\frac{a_2 b_2 - x_2 y_2 + \\beta}{3}$，然后发送 $r_2$ 给 $P_3$；\n3. $P_3$ 计算 $r_3 = \\frac{a_3 b_3 - x_3 y_3 + \\gamma}{3}$，然后发送 $r_3$ 给 $P_1$；\n4. $P_1$ 将它的份额定义为 $z_1 = r_3 - r_1$ 和 $c_1 = -2r_3 - r_1$；\n5. $P_2$ 将它的份额定义为 $z_2 = r_1 - r_2$ 和 $c_2 = -2r_1 - r_2$；\n6. $P_3$ 将它的份额定义为 $z_3 = r_2 - r_3$ 和 $c_3 = -2r_2 - r_3$。\n\n上面的计算是合法的，因为 $3$ 与 $2^n$ 是互质的；因此，$3$ 是可逆的。此外，上述结果在3个以上元素的有限域上都成立。\n\n为了验证 $r_1 + r_2 + r_3 = v_1 v_2$，首先观察到\n$$\na_1 b_1  = (x_3 - v_1)(y_3 - v_2) = x_3 y_3 - x_3 v_2 - y_3 v_1 + v_1 v_2 \\tag{2}\n$$\n类似地，$a_2 b_2 = x_1 y_1 - x_1 v_2 - y_1 v_1 + v_1 v_2$，$a_3 b_3 = x_2 y_2 - x_2 v_2 - y_2 v_1 + v_1 v_2$。然后\n$$\n\\begin{align}\n3(&r_1 + r_2 + r_3) \\\\\n&= a_1 b_1 - x_1 y_1 + \\alpha + a_2 b_2 - x_2 y_2 + \\beta + a_3 b_3 - x_3 y_3 + \\gamma \\\\\n&= a_1 b_1 + a_2 b_2 + a_3 b_3 - x_1 y_1 - x_2 y_2 - x_3 y_3 \\\\\n&= 3v_1 v_2 - v_1(y_1 + y_2 + y_3) - v_2(x_1 + x_2 + x_3) = 3v_1 v_2\n\\end{align}\n$$\n接下来证明各方的$\\left( \\begin{array}{c} 3\\\\2 \\end{array} \\right)$-份额是有效的：根据定义，各方的份额为 $(z_1, z_3 - v_1 v_2), (z_2, z_1 - v_1 v_2)$ 和 $(z_3, z_2 - v_1 v_2)$，其中 $z_1 + z_2 + z_3 = 0 \\bmod 2^n$。首先后者很容易看出来是成立的，根据 $z_1, z_2, z_3$ 的定义。其次，$P_1$ 持有 $c_1$ $= -2 r_3 - r_1$ $= -r_3 - r_3 - r_1 - r_2 + r_2$ $=(r_2 - r_3)-(r_1 + r_2 + r_3)$ $=z_3 - v_1 v_2$，满足要求。对于 $P_2$ 和 $P_3$ 的情况同样成立。\n\n**生成相关随机性。**各方使用与第2.2节所述相同的(计算)方法，但有以下不同之处。首先，我们假设 $F_k$ 是将字符串映射到 $\\mathbb{Z}_{2^n}$ (或等价于 $\\{0,1\\}^n$)的伪随机函数。其次，$P_1$计算 $\\alpha = F_{k_1}(id) - F_{k_2}(id)$，$P_2$计算 $\\beta = F_{k_2}(id) - F_{k_3}(id)$，$P_3$计算 $\\gamma = F_{k_3}(id) - F_{k_1}(id)$。","slug":"论文笔记-High-Throughput-Semi-Honest-Secure-Three-Party-Computation-with-an-Honest-Majority","published":1,"updated":"2020-08-23T14:33:37.435Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cke79q4tj004688psal20d540","content":"<p><em>Toshinori Araki, Jun Furukawa, Yehuda Lindell, Ariel Nof, Kazuma Ohara</em></p>\n<p>CCS 2016</p>\n<p><a href=\"https://dl.acm.org/doi/10.1145/2976749.2978331\" target=\"_blank\" rel=\"noopener\">https://dl.acm.org/doi/10.1145/2976749.2978331</a></p>\n<a id=\"more\"></a>\n<h1 id=\"摘要\"><a href=\"#摘要\" class=\"headerlink\" title=\"摘要\"></a>摘要</h1><p>在这篇文章中，作者描述了一个新的信息论协议(和一个计算安全的变体)，用于诚实多数的安全三方计算。该协议的计算量和通信量非常小；对于布尔电路，每一方只为每个与门发送一位(对于异或门则不发送任何内容)。本文的协议在半诚实的攻击者面前是(基于模拟的)安全的，在恶意攻击者面前实现了客户机/服务器模型下的隐私。</p>\n<p>在具有10Gbps连接的三个20核服务器的集群上，本文的协议的实现每秒执行超过130万次AES计算，涉及每秒处理超过70亿个门。此外，作者还开发了一个Kerberos扩展，它使用服务器之间共享的密钥/密码，用本文的协议取代了MIT-Kerberos中密钥分发中心(KDC)上的票证授予-票证加密。这样可以在保护密码的同时使用Kerberos。本文的实现能够支持每秒超过35,000个登录的登录风暴，即使对于非常大的组织也足够了。本文的工作证明了在标准硬件上实现高通量安全计算是可能的。</p>\n<h1 id=\"THE-NEW-PROTOCOL\"><a href=\"#THE-NEW-PROTOCOL\" class=\"headerlink\" title=\"THE NEW PROTOCOL\"></a>THE NEW PROTOCOL</h1><h2 id=\"Securely-Computing-Boolean-Circuits\"><a href=\"#Securely-Computing-Boolean-Circuits\" class=\"headerlink\" title=\"Securely Computing Boolean Circuits\"></a>Securely Computing Boolean Circuits</h2><p>为了简化说明，首先描述具有与和异或门的布尔电路的特殊情况的协议。假设各方 $P_1,P_2,P_3$ 能够获得随机的 $x_1, x_2, x_3 \\in {0,1 }$，使得 $x_1 \\oplus x_2 \\oplus x_3 = 0$。</p>\n<p><strong>秘密共享。</strong>作者定义了一个3取2的秘密共享方案，记为$\\left( \\begin{array}{c} 3\\2 \\end{array} \\right)$-共享，如下所示。为了共享比特 $v$，分发者在 $x_1 \\oplus x_2 \\oplus x_3 = 0$ 的约束下选择三个随机比特 $x_1, x_2, x_3 \\in {0,1 }$。然后：</p>\n<ul>\n<li>$P_1$ 的份额为 $(x_1, a_1)$，其中 $a_1 = x_3 \\oplus v$；</li>\n<li>$P_2$ 的份额为 $(x_2, a_2)$，其中 $a_2 = x_1 \\oplus v$；</li>\n<li>$P_3$ 的份额为 $(x_3, a_3)$，其中 $a_3 = x_2 \\oplus v$。</li>\n</ul>\n<p>很明显，任何一方的份额都不能揭示关于v的任何信息。此外，任何两个份额都足以获得 $v$；例如，给定 $x_1,x_2,a_1,a_2$，我们可以计算 $v = a_2 \\oplus x_1$。</p>\n<p><strong>异或(加法)门。</strong>设 $(x<em>1,a_1),(x_2,a_2),(x_3,a_3)$ 是 $v_1$ 的秘密共享，$(y_1,b_1),(y_2,b_2),(y_3,b_3)$ 是 $v_2$ 的秘密共享。然后，为了计算 $v_1$ 和 $v_2$ 的秘密共享，每个 $P_i$ 在本地计算 $z_i = x_i \\oplus y_i$ 和 $c_i = a_i \\oplus b_i$ 得到 $(z_i, c_i)$ (不需要通信)。为了查看结果是否构成 $v_1 \\oplus v_2$ 的有效$\\left( \\begin{array}{c} 3\\2 \\end{array} \\right)$-共享，首先注意到 $z_1 \\oplus z_2 \\oplus z_3 = 0$ (因为 $x_1 \\oplus x_2 \\oplus x_3 = 0$ 和 $y_1 \\oplus y_2 \\oplus y_3 = 0$)。接下来，观察到对于每个 $i \\in {1,2,3}$，它持有 $c_i = z</em>{i−1} \\oplus (v_1 \\oplus v_2)$，其中 $i=1$ 时 $i−1=3$；例如，我们有 $c_1=a_1 \\oplus b_1$ $=x_3 \\oplus v_1 \\oplus y_3 \\oplus v_2$ $=(x_3 \\oplus y_3)\\oplus (v_1 \\oplus v_2)$ $=z_3\\oplus (v_1 \\oplus v_2)$。因此，这构成具有随机性 $z_1,z_2,z_3$ 的 $v_1 \\oplus v_2$ 的共享。</p>\n<p><strong>与(乘法)门。</strong>现在展示各方如何计算与(乘法)门；此子协议要求每一方只发送单个比特。该协议分两个阶段工作：第一阶段双方计算输入位的与的简单$\\left( \\begin{array}{c} 3\\3 \\end{array} \\right)$异或-共享，第二阶段将$\\left( \\begin{array}{c} 3\\3 \\end{array} \\right)$-共享转换为上述定义的$\\left( \\begin{array}{c} 3\\2 \\end{array} \\right)$-共享。</p>\n<p>设 $(x_1,a_1),(x_2,a_2),(x_3,a_3)$ 是 $v_1$ 的秘密共享，$(y_1,b_1),(y_2,b_2),(y_3,b_3)$ 是 $v_2$ 的秘密共享。假设各方 $P_1,P_2,P_3$ 分别具有相关随机性 $\\alpha, \\beta, \\gamma$，其中 $\\alpha \\oplus \\beta \\oplus \\gamma = 0$。双方计算 $v_1 \\cdot v_2 = v_1 \\wedge v_2$ 的$\\left( \\begin{array}{c} 3\\2 \\end{array} \\right)$-份额如下(从这里开始，将简单地将 $a$ 和 $b$ 的积表示为 $ab$)：</p>\n<ol>\n<li><p>第一步——计算$\\left( \\begin{array}{c} 3\\3 \\end{array} \\right)$-共享：</p>\n<ul>\n<li>$P_1$ 计算 $r_1 = x_1 y_1 \\oplus a_1 b_1 \\oplus \\alpha$，然后发送 $r_1$ 给 $P_2$；</li>\n<li>$P_2$ 计算 $r_2 = x_2 y_2 \\oplus a_2 b_2 \\oplus \\beta$，然后发送 $r_2$ 给 $P_3$；</li>\n<li>$P_3$ 计算 $r_3 = x_3 y_3 \\oplus a_3 b_3 \\oplus \\gamma$，然后发送 $r_3$ 给 $P_1$。</li>\n</ul>\n<p>这些消息是并行地计算和发送的。</p>\n</li>\n<li><p>第二步——计算$\\left( \\begin{array}{c} 3\\2 \\end{array} \\right)$-共享：在此步骤中，各方根据其给定的$\\left( \\begin{array}{c} 3\\3 \\end{array} \\right)$-共享和上一步中发送的消息构建$\\left( \\begin{array}{c} 3\\2 \\end{array} \\right)$-共享，只需要本地计算。</p>\n<ul>\n<li>$P_1$ 存储 $(z_1, c_1)$，其中 $z_1 = r_1 \\oplus r_3$，以及 $c_1 = r_1$；</li>\n<li>$P_2$ 存储 $(z_2, c_2)$，其中 $z_2 = r_2 \\oplus r_1$，以及 $c_2 = r_2$；</li>\n<li>$P_3$ 存储 $(z_3, c_3)$，其中 $z_3 = r_3 \\oplus r_2$，以及 $c_3 = r_3$；</li>\n</ul>\n</li>\n</ol>\n<p><strong>对第一步的解释：</strong>证明第一步中，$r_1 \\oplus r_2 \\oplus r_3 = v_1 \\wedge v_2$。首先注意到：</p>\n<script type=\"math/tex; mode=display\">\na_1 b_1 = (x_3 \\oplus v_1) (y_3 \\oplus v_2) = x_3 y_3 \\oplus x_3 v_2 \\oplus y_3 v_1 \\oplus v_1 v_2 \\tag{1}</script><p>类似地有 $a_2 b_2 = x_1 y_1 \\oplus x_1 v_2 \\oplus y_1 v_1 \\oplus v_1 v_2$ 和 $a_3 b_3 = x_2 y_2 \\oplus x_2 v_2 \\oplus y_2 v_1 \\oplus v_1 v_2$。因此，</p>\n<script type=\"math/tex; mode=display\">\n\\begin{align}\nr_1 &\\oplus r_2 \\oplus r_3 \\\\\n &= (x_1 y_1 \\oplus a_1 b_1 \\oplus \\alpha) \\oplus (x_2 y_2 \\oplus a_2 b_2 \\oplus \\beta) \\oplus (x_3 y_3 \\oplus a_3 b_3 \\oplus \\gamma) \\\\\n &= x_1 y_1 \\oplus x_2 y_2 \\oplus x_3 y_3 \\oplus b_1 a_1 \\oplus a_2 b_2 \\oplus a_3 b_3 \\\\\n &= x_1 y_1 \\oplus x_2 y_2 \\oplus x_3  y_3 \\oplus (x_3 y_3 \\oplus x_3 v_2 \\oplus y_3 v_1 \\oplus v_1 v_2) \\\\\n & \\qquad \\qquad \\qquad \\qquad \\quad  \\oplus (x_1 y_1 \\oplus x_1 v_2 \\oplus y_1 v_1 \\oplus v_1 v_2) \\\\\n & \\qquad \\qquad \\qquad \\qquad \\quad  \\oplus (x_2 y_2 \\oplus x_2 v_2 \\oplus y_2 v_1 \\oplus v_1 v_2) \\\\\n &= (x_1 \\oplus x_2 \\oplus x_3) v_2 \\oplus (y_1 \\oplus y_2 \\oplus y_3) v_1 \\oplus v_1 v_2 = v_1 v_2\n\\end{align}</script><p>第二个等号成立是因为 $\\alpha \\oplus \\beta \\oplus \\gamma = 0$，第三个等号成立是因为公式 $(1)$，第四个等号成立就是简单的删除重复元素，最后一个等号成立是因为 $x_1 \\oplus x_2 \\oplus x_3 = y_1 \\oplus y_2 \\oplus y_3 = 0$。</p>\n<p><strong>对第二步的解释：</strong>根据定义，为了证明结果是有效的 $v_1v_2$ 的$\\left( \\begin{array}{c} 3\\2 \\end{array} \\right)$-共享，我们需要证明 $z_1,z_2,z_3$ 使得 $z_1 \\oplus z_2 \\oplus z_3 = 0$，并且 $c_1,c_2,c_3$ 是所定义的形式。</p>\n<p>首先，$z_1 \\oplus z_2 \\oplus z_3 = (r_1 \\oplus r_3) \\oplus (r_2 \\oplus r_1) \\oplus (r_3 \\oplus r_2) = 0$。其次，注意到$c_1 \\oplus c_2 \\oplus c_3 = r_1 \\oplus r_2 \\oplus r_3 = v_1 v_2$，移项得 $c_1 = r_1 = v_1 v_2 \\oplus r_2 \\oplus r_3$。又因为 $r_2 \\oplus r_3 = z_3$，于是 $c_1 = v_1 v_2 \\oplus z_3$，得证。对于 $c_2, c_3$ 也可以同样证明。</p>\n<p><strong>协议。</strong>完整的三方协议以自然的方式工作。各方首先使用秘密共享方法共享其输入。然后，它们根据电路的预定拓扑顺序计算电路中的每个XOR与AND门。最后，各方在输出线上重建其输出。(在客户端/服务器模型中，外部客户端将其输入的共享发送给三方，然后三方根据收到的共享以相同的方式计算电路。)</p>\n<p>请注意，每一方只与另一方进行通信。这一性质也适用于Sharemind的协议。然而，本文的秘密共享方案和乘法协议是完全不同的。</p>\n<h2 id=\"Generating-Correlated-Randomness\"><a href=\"#Generating-Correlated-Randomness\" class=\"headerlink\" title=\"Generating Correlated Randomness\"></a>Generating Correlated Randomness</h2><p>这里将说明如何高效地为每个与门生成随机比特 $\\alpha, \\beta, \\gamma \\in {0, 1}$ ，满足 $\\alpha \\oplus \\beta \\oplus \\gamma = 0$。</p>\n<p><strong>信息论相关随机性。</strong>通过使每一方 $P<em>i$ 简单地选择随机 $\\rho_i \\in {0,1}$ 并将其发送到 $P</em>{i+1}$ (其中 $P_3$ 发送到 $P_1$)，可以安全地生成具有完美安全性的相关随机性。然后，每一方将其随机比特作为其选择的比特与其接收的比特的异或：$P_1$ 计算 $\\alpha = \\rho_3 \\oplus \\rho_1$，$P_2$ 计算 $\\beta = \\rho_1 \\oplus \\rho_2$ 以及 $P_3$ 计算 $\\gamma = \\rho_2 \\oplus \\rho_3$。观察到 $\\alpha + \\beta + \\gamma = 0$ 满足要求。此外，如果 $P_1$ 损坏，则它除了知道 $\\beta \\oplus \\gamma = \\alpha$ 之外，对 $\\beta$ 和 $\\gamma$ 一无所知。这是因为 $\\beta$ 和 $\\gamma$ 在他们的计算中都包含了 $\\rho_2$，而这对于 $P_1$ 是未知的。类似的论点也适用于损坏的 $P_2$ 或 $P_3$。尽管此解决方案既优雅又简单，但作者使用了不同的方法。这是因为这将使每个与门的通信增加一倍；确实，这仍然是非常少的通信。但是，考虑到通信是瓶颈，这将使吞吐量减半。</p>\n<p><strong>计算相关随机性。</strong>接下来作者展示了如何通过计算安全地计算相关随机性，而不需要除短初始设置之外的任何交互。这使我们能够维持各方只需要在每个与门传输单个比特的当前情况。设 $\\kappa$ 为安全参数，$F: {0,1}^{\\kappa} \\times {0,1}^{\\kappa} \\rightarrow {0,1}$ 为输出单比特的伪随机函数。</p>\n<ol>\n<li><p><strong>Init：</strong></p>\n<ul>\n<li>每个 $P_i$ 选择一个随机的 $k_i \\in {0,1}^{\\kappa}$；</li>\n<li>$P_1$ 发送 $k_1$ 给 $P_3$，$P_2$ 发送 $k_2$ 给 $P_1$，$P_3$ 发送 $k_3$ 给 $P_2$。</li>\n</ul>\n<p>$P_1$ 持有 $k_1, k_2$，$P_2$ 持有 $k_2, k_3$，$P_3$ 持有 $k_3, k_1$。</p>\n</li>\n<li><p><strong>GetNextBit：</strong>给定唯一标识符 $id \\in {0,1}^{\\kappa}$，</p>\n<ul>\n<li>$P<em>1$ 计算 $\\alpha = F</em>{k<em>1}(id) \\oplus F</em>{k_2}(id)$；</li>\n<li>$P<em>2$ 计算 $\\beta = F</em>{k<em>2}(id) \\oplus F</em>{k_3}(id)$；</li>\n<li>$P<em>3$ 计算 $\\gamma = F</em>{k<em>3}(id) \\oplus F</em>{k_1}(id)$。</li>\n</ul>\n</li>\n</ol>\n<p>注意到 $\\alpha \\oplus \\beta \\oplus \\gamma = 0$。此外，$P_1$ 不知道用于生成 $\\beta$ 和 $\\gamma$ 的 $k_3$。因此，在 $\\beta$ 和 $\\gamma$ 的约束下，$\\beta \\oplus \\gamma = \\alpha$ 对 $P_1$ 是伪随机的。实际上，$id$ 可以是所有各方在每次调用 <strong>GetNextBit</strong> 时本地递增的计数器。</p>\n<h2 id=\"The-Ring-Modulo-2-n-and-Fields\"><a href=\"#The-Ring-Modulo-2-n-and-Fields\" class=\"headerlink\" title=\"The Ring Modulo $2^n$ and Fields\"></a>The Ring Modulo $2^n$ and Fields</h2><p>上一节讲到的是布尔电路下的协议，接下来将其推广到模 $2^n$ 的环和大于 $2$ 的任意域的一般情况。当取 $n=1$ 时，加法(和减法)与异或相同，乘法与与相同。在这种情况下，这里的协议与第2.1节中描述的协议完全相同。</p>\n<p>$\\left( \\begin{array}{c} 3\\2 \\end{array} \\right)$<strong>-共享。</strong>为了共享一个元素 $v \\bmod 2^n$，分发者选择三个满足约束 $x<em>1 + x_2 + x_3 = 0$ 的随机元素 $x_1, x_2, x_3 \\in \\mathbb{Z}</em>{2^n}$。然后 $P_1$ 的份额为 $(x_1, a_1)$，其中 $a_1 = x_3 - v$；$P_2$ 的份额为 $(x_2, a_2)$，其中 $a_2 = x_1 - v$；$P_3$ 的份额为 $(x_3, a_3)$，其中 $a_3 = x_2 - v$。跟布尔电路的情况一样，每一方的份额都没有暴露关于 $v$ 的信息，而且任意两方可以重构 $v$。</p>\n<p><strong>加法门。</strong>与布尔电路的情况一样，各方在本地将对应的份额进行相加模 $2^n$ 即可。</p>\n<p><strong>乘法门。</strong>设 $(x<em>1,a_1),(x_2,a_2),(x_3,a_3)$ 是 $v_1$ 的秘密共享，$(y_1,b_1),(y_2,b_2),(y_3,b_3)$ 是 $v_2$ 的秘密共享。假设各方 $P_1,P_2,P_3$ 分别有 $\\alpha, \\beta, \\gamma \\in \\mathbb{Z}</em>{2^n}$，其中 $\\alpha + \\beta + \\gamma = 0$。为了计算两个值的积的$\\left( \\begin{array}{c} 3\\2 \\end{array} \\right)$-份额，各方计算：</p>\n<ol>\n<li>$P_1$ 计算 $r_1 = \\frac{a_1 b_1 - x_1 y_1 + \\alpha}{3}$，然后发送 $r_1$ 给 $P_2$；</li>\n<li>$P_2$ 计算 $r_2 = \\frac{a_2 b_2 - x_2 y_2 + \\beta}{3}$，然后发送 $r_2$ 给 $P_3$；</li>\n<li>$P_3$ 计算 $r_3 = \\frac{a_3 b_3 - x_3 y_3 + \\gamma}{3}$，然后发送 $r_3$ 给 $P_1$；</li>\n<li>$P_1$ 将它的份额定义为 $z_1 = r_3 - r_1$ 和 $c_1 = -2r_3 - r_1$；</li>\n<li>$P_2$ 将它的份额定义为 $z_2 = r_1 - r_2$ 和 $c_2 = -2r_1 - r_2$；</li>\n<li>$P_3$ 将它的份额定义为 $z_3 = r_2 - r_3$ 和 $c_3 = -2r_2 - r_3$。</li>\n</ol>\n<p>上面的计算是合法的，因为 $3$ 与 $2^n$ 是互质的；因此，$3$ 是可逆的。此外，上述结果在3个以上元素的有限域上都成立。</p>\n<p>为了验证 $r_1 + r_2 + r_3 = v_1 v_2$，首先观察到</p>\n<script type=\"math/tex; mode=display\">\na_1 b_1  = (x_3 - v_1)(y_3 - v_2) = x_3 y_3 - x_3 v_2 - y_3 v_1 + v_1 v_2 \\tag{2}</script><p>类似地，$a_2 b_2 = x_1 y_1 - x_1 v_2 - y_1 v_1 + v_1 v_2$，$a_3 b_3 = x_2 y_2 - x_2 v_2 - y_2 v_1 + v_1 v_2$。然后</p>\n<script type=\"math/tex; mode=display\">\n\\begin{align}\n3(&r_1 + r_2 + r_3) \\\\\n&= a_1 b_1 - x_1 y_1 + \\alpha + a_2 b_2 - x_2 y_2 + \\beta + a_3 b_3 - x_3 y_3 + \\gamma \\\\\n&= a_1 b_1 + a_2 b_2 + a_3 b_3 - x_1 y_1 - x_2 y_2 - x_3 y_3 \\\\\n&= 3v_1 v_2 - v_1(y_1 + y_2 + y_3) - v_2(x_1 + x_2 + x_3) = 3v_1 v_2\n\\end{align}</script><p>接下来证明各方的$\\left( \\begin{array}{c} 3\\2 \\end{array} \\right)$-份额是有效的：根据定义，各方的份额为 $(z_1, z_3 - v_1 v_2), (z_2, z_1 - v_1 v_2)$ 和 $(z_3, z_2 - v_1 v_2)$，其中 $z_1 + z_2 + z_3 = 0 \\bmod 2^n$。首先后者很容易看出来是成立的，根据 $z_1, z_2, z_3$ 的定义。其次，$P_1$ 持有 $c_1$ $= -2 r_3 - r_1$ $= -r_3 - r_3 - r_1 - r_2 + r_2$ $=(r_2 - r_3)-(r_1 + r_2 + r_3)$ $=z_3 - v_1 v_2$，满足要求。对于 $P_2$ 和 $P_3$ 的情况同样成立。</p>\n<p><strong>生成相关随机性。</strong>各方使用与第2.2节所述相同的(计算)方法，但有以下不同之处。首先，我们假设 $F<em>k$ 是将字符串映射到 $\\mathbb{Z}</em>{2^n}$ (或等价于 ${0,1}^n$)的伪随机函数。其次，$P<em>1$计算 $\\alpha = F</em>{k<em>1}(id) - F</em>{k<em>2}(id)$，$P_2$计算 $\\beta = F</em>{k<em>2}(id) - F</em>{k<em>3}(id)$，$P_3$计算 $\\gamma = F</em>{k<em>3}(id) - F</em>{k_1}(id)$。</p>\n","site":{"data":{}},"excerpt":"<p><em>Toshinori Araki, Jun Furukawa, Yehuda Lindell, Ariel Nof, Kazuma Ohara</em></p>\n<p>CCS 2016</p>\n<p><a href=\"https://dl.acm.org/doi/10.1145/2976749.2978331\" target=\"_blank\" rel=\"noopener\">https://dl.acm.org/doi/10.1145/2976749.2978331</a></p>","more":"<h1 id=\"摘要\"><a href=\"#摘要\" class=\"headerlink\" title=\"摘要\"></a>摘要</h1><p>在这篇文章中，作者描述了一个新的信息论协议(和一个计算安全的变体)，用于诚实多数的安全三方计算。该协议的计算量和通信量非常小；对于布尔电路，每一方只为每个与门发送一位(对于异或门则不发送任何内容)。本文的协议在半诚实的攻击者面前是(基于模拟的)安全的，在恶意攻击者面前实现了客户机/服务器模型下的隐私。</p>\n<p>在具有10Gbps连接的三个20核服务器的集群上，本文的协议的实现每秒执行超过130万次AES计算，涉及每秒处理超过70亿个门。此外，作者还开发了一个Kerberos扩展，它使用服务器之间共享的密钥/密码，用本文的协议取代了MIT-Kerberos中密钥分发中心(KDC)上的票证授予-票证加密。这样可以在保护密码的同时使用Kerberos。本文的实现能够支持每秒超过35,000个登录的登录风暴，即使对于非常大的组织也足够了。本文的工作证明了在标准硬件上实现高通量安全计算是可能的。</p>\n<h1 id=\"THE-NEW-PROTOCOL\"><a href=\"#THE-NEW-PROTOCOL\" class=\"headerlink\" title=\"THE NEW PROTOCOL\"></a>THE NEW PROTOCOL</h1><h2 id=\"Securely-Computing-Boolean-Circuits\"><a href=\"#Securely-Computing-Boolean-Circuits\" class=\"headerlink\" title=\"Securely Computing Boolean Circuits\"></a>Securely Computing Boolean Circuits</h2><p>为了简化说明，首先描述具有与和异或门的布尔电路的特殊情况的协议。假设各方 $P_1,P_2,P_3$ 能够获得随机的 $x_1, x_2, x_3 \\in {0,1 }$，使得 $x_1 \\oplus x_2 \\oplus x_3 = 0$。</p>\n<p><strong>秘密共享。</strong>作者定义了一个3取2的秘密共享方案，记为$\\left( \\begin{array}{c} 3\\2 \\end{array} \\right)$-共享，如下所示。为了共享比特 $v$，分发者在 $x_1 \\oplus x_2 \\oplus x_3 = 0$ 的约束下选择三个随机比特 $x_1, x_2, x_3 \\in {0,1 }$。然后：</p>\n<ul>\n<li>$P_1$ 的份额为 $(x_1, a_1)$，其中 $a_1 = x_3 \\oplus v$；</li>\n<li>$P_2$ 的份额为 $(x_2, a_2)$，其中 $a_2 = x_1 \\oplus v$；</li>\n<li>$P_3$ 的份额为 $(x_3, a_3)$，其中 $a_3 = x_2 \\oplus v$。</li>\n</ul>\n<p>很明显，任何一方的份额都不能揭示关于v的任何信息。此外，任何两个份额都足以获得 $v$；例如，给定 $x_1,x_2,a_1,a_2$，我们可以计算 $v = a_2 \\oplus x_1$。</p>\n<p><strong>异或(加法)门。</strong>设 $(x<em>1,a_1),(x_2,a_2),(x_3,a_3)$ 是 $v_1$ 的秘密共享，$(y_1,b_1),(y_2,b_2),(y_3,b_3)$ 是 $v_2$ 的秘密共享。然后，为了计算 $v_1$ 和 $v_2$ 的秘密共享，每个 $P_i$ 在本地计算 $z_i = x_i \\oplus y_i$ 和 $c_i = a_i \\oplus b_i$ 得到 $(z_i, c_i)$ (不需要通信)。为了查看结果是否构成 $v_1 \\oplus v_2$ 的有效$\\left( \\begin{array}{c} 3\\2 \\end{array} \\right)$-共享，首先注意到 $z_1 \\oplus z_2 \\oplus z_3 = 0$ (因为 $x_1 \\oplus x_2 \\oplus x_3 = 0$ 和 $y_1 \\oplus y_2 \\oplus y_3 = 0$)。接下来，观察到对于每个 $i \\in {1,2,3}$，它持有 $c_i = z</em>{i−1} \\oplus (v_1 \\oplus v_2)$，其中 $i=1$ 时 $i−1=3$；例如，我们有 $c_1=a_1 \\oplus b_1$ $=x_3 \\oplus v_1 \\oplus y_3 \\oplus v_2$ $=(x_3 \\oplus y_3)\\oplus (v_1 \\oplus v_2)$ $=z_3\\oplus (v_1 \\oplus v_2)$。因此，这构成具有随机性 $z_1,z_2,z_3$ 的 $v_1 \\oplus v_2$ 的共享。</p>\n<p><strong>与(乘法)门。</strong>现在展示各方如何计算与(乘法)门；此子协议要求每一方只发送单个比特。该协议分两个阶段工作：第一阶段双方计算输入位的与的简单$\\left( \\begin{array}{c} 3\\3 \\end{array} \\right)$异或-共享，第二阶段将$\\left( \\begin{array}{c} 3\\3 \\end{array} \\right)$-共享转换为上述定义的$\\left( \\begin{array}{c} 3\\2 \\end{array} \\right)$-共享。</p>\n<p>设 $(x_1,a_1),(x_2,a_2),(x_3,a_3)$ 是 $v_1$ 的秘密共享，$(y_1,b_1),(y_2,b_2),(y_3,b_3)$ 是 $v_2$ 的秘密共享。假设各方 $P_1,P_2,P_3$ 分别具有相关随机性 $\\alpha, \\beta, \\gamma$，其中 $\\alpha \\oplus \\beta \\oplus \\gamma = 0$。双方计算 $v_1 \\cdot v_2 = v_1 \\wedge v_2$ 的$\\left( \\begin{array}{c} 3\\2 \\end{array} \\right)$-份额如下(从这里开始，将简单地将 $a$ 和 $b$ 的积表示为 $ab$)：</p>\n<ol>\n<li><p>第一步——计算$\\left( \\begin{array}{c} 3\\3 \\end{array} \\right)$-共享：</p>\n<ul>\n<li>$P_1$ 计算 $r_1 = x_1 y_1 \\oplus a_1 b_1 \\oplus \\alpha$，然后发送 $r_1$ 给 $P_2$；</li>\n<li>$P_2$ 计算 $r_2 = x_2 y_2 \\oplus a_2 b_2 \\oplus \\beta$，然后发送 $r_2$ 给 $P_3$；</li>\n<li>$P_3$ 计算 $r_3 = x_3 y_3 \\oplus a_3 b_3 \\oplus \\gamma$，然后发送 $r_3$ 给 $P_1$。</li>\n</ul>\n<p>这些消息是并行地计算和发送的。</p>\n</li>\n<li><p>第二步——计算$\\left( \\begin{array}{c} 3\\2 \\end{array} \\right)$-共享：在此步骤中，各方根据其给定的$\\left( \\begin{array}{c} 3\\3 \\end{array} \\right)$-共享和上一步中发送的消息构建$\\left( \\begin{array}{c} 3\\2 \\end{array} \\right)$-共享，只需要本地计算。</p>\n<ul>\n<li>$P_1$ 存储 $(z_1, c_1)$，其中 $z_1 = r_1 \\oplus r_3$，以及 $c_1 = r_1$；</li>\n<li>$P_2$ 存储 $(z_2, c_2)$，其中 $z_2 = r_2 \\oplus r_1$，以及 $c_2 = r_2$；</li>\n<li>$P_3$ 存储 $(z_3, c_3)$，其中 $z_3 = r_3 \\oplus r_2$，以及 $c_3 = r_3$；</li>\n</ul>\n</li>\n</ol>\n<p><strong>对第一步的解释：</strong>证明第一步中，$r_1 \\oplus r_2 \\oplus r_3 = v_1 \\wedge v_2$。首先注意到：</p>\n<script type=\"math/tex; mode=display\">\na_1 b_1 = (x_3 \\oplus v_1) (y_3 \\oplus v_2) = x_3 y_3 \\oplus x_3 v_2 \\oplus y_3 v_1 \\oplus v_1 v_2 \\tag{1}</script><p>类似地有 $a_2 b_2 = x_1 y_1 \\oplus x_1 v_2 \\oplus y_1 v_1 \\oplus v_1 v_2$ 和 $a_3 b_3 = x_2 y_2 \\oplus x_2 v_2 \\oplus y_2 v_1 \\oplus v_1 v_2$。因此，</p>\n<script type=\"math/tex; mode=display\">\n\\begin{align}\nr_1 &\\oplus r_2 \\oplus r_3 \\\\\n &= (x_1 y_1 \\oplus a_1 b_1 \\oplus \\alpha) \\oplus (x_2 y_2 \\oplus a_2 b_2 \\oplus \\beta) \\oplus (x_3 y_3 \\oplus a_3 b_3 \\oplus \\gamma) \\\\\n &= x_1 y_1 \\oplus x_2 y_2 \\oplus x_3 y_3 \\oplus b_1 a_1 \\oplus a_2 b_2 \\oplus a_3 b_3 \\\\\n &= x_1 y_1 \\oplus x_2 y_2 \\oplus x_3  y_3 \\oplus (x_3 y_3 \\oplus x_3 v_2 \\oplus y_3 v_1 \\oplus v_1 v_2) \\\\\n & \\qquad \\qquad \\qquad \\qquad \\quad  \\oplus (x_1 y_1 \\oplus x_1 v_2 \\oplus y_1 v_1 \\oplus v_1 v_2) \\\\\n & \\qquad \\qquad \\qquad \\qquad \\quad  \\oplus (x_2 y_2 \\oplus x_2 v_2 \\oplus y_2 v_1 \\oplus v_1 v_2) \\\\\n &= (x_1 \\oplus x_2 \\oplus x_3) v_2 \\oplus (y_1 \\oplus y_2 \\oplus y_3) v_1 \\oplus v_1 v_2 = v_1 v_2\n\\end{align}</script><p>第二个等号成立是因为 $\\alpha \\oplus \\beta \\oplus \\gamma = 0$，第三个等号成立是因为公式 $(1)$，第四个等号成立就是简单的删除重复元素，最后一个等号成立是因为 $x_1 \\oplus x_2 \\oplus x_3 = y_1 \\oplus y_2 \\oplus y_3 = 0$。</p>\n<p><strong>对第二步的解释：</strong>根据定义，为了证明结果是有效的 $v_1v_2$ 的$\\left( \\begin{array}{c} 3\\2 \\end{array} \\right)$-共享，我们需要证明 $z_1,z_2,z_3$ 使得 $z_1 \\oplus z_2 \\oplus z_3 = 0$，并且 $c_1,c_2,c_3$ 是所定义的形式。</p>\n<p>首先，$z_1 \\oplus z_2 \\oplus z_3 = (r_1 \\oplus r_3) \\oplus (r_2 \\oplus r_1) \\oplus (r_3 \\oplus r_2) = 0$。其次，注意到$c_1 \\oplus c_2 \\oplus c_3 = r_1 \\oplus r_2 \\oplus r_3 = v_1 v_2$，移项得 $c_1 = r_1 = v_1 v_2 \\oplus r_2 \\oplus r_3$。又因为 $r_2 \\oplus r_3 = z_3$，于是 $c_1 = v_1 v_2 \\oplus z_3$，得证。对于 $c_2, c_3$ 也可以同样证明。</p>\n<p><strong>协议。</strong>完整的三方协议以自然的方式工作。各方首先使用秘密共享方法共享其输入。然后，它们根据电路的预定拓扑顺序计算电路中的每个XOR与AND门。最后，各方在输出线上重建其输出。(在客户端/服务器模型中，外部客户端将其输入的共享发送给三方，然后三方根据收到的共享以相同的方式计算电路。)</p>\n<p>请注意，每一方只与另一方进行通信。这一性质也适用于Sharemind的协议。然而，本文的秘密共享方案和乘法协议是完全不同的。</p>\n<h2 id=\"Generating-Correlated-Randomness\"><a href=\"#Generating-Correlated-Randomness\" class=\"headerlink\" title=\"Generating Correlated Randomness\"></a>Generating Correlated Randomness</h2><p>这里将说明如何高效地为每个与门生成随机比特 $\\alpha, \\beta, \\gamma \\in {0, 1}$ ，满足 $\\alpha \\oplus \\beta \\oplus \\gamma = 0$。</p>\n<p><strong>信息论相关随机性。</strong>通过使每一方 $P<em>i$ 简单地选择随机 $\\rho_i \\in {0,1}$ 并将其发送到 $P</em>{i+1}$ (其中 $P_3$ 发送到 $P_1$)，可以安全地生成具有完美安全性的相关随机性。然后，每一方将其随机比特作为其选择的比特与其接收的比特的异或：$P_1$ 计算 $\\alpha = \\rho_3 \\oplus \\rho_1$，$P_2$ 计算 $\\beta = \\rho_1 \\oplus \\rho_2$ 以及 $P_3$ 计算 $\\gamma = \\rho_2 \\oplus \\rho_3$。观察到 $\\alpha + \\beta + \\gamma = 0$ 满足要求。此外，如果 $P_1$ 损坏，则它除了知道 $\\beta \\oplus \\gamma = \\alpha$ 之外，对 $\\beta$ 和 $\\gamma$ 一无所知。这是因为 $\\beta$ 和 $\\gamma$ 在他们的计算中都包含了 $\\rho_2$，而这对于 $P_1$ 是未知的。类似的论点也适用于损坏的 $P_2$ 或 $P_3$。尽管此解决方案既优雅又简单，但作者使用了不同的方法。这是因为这将使每个与门的通信增加一倍；确实，这仍然是非常少的通信。但是，考虑到通信是瓶颈，这将使吞吐量减半。</p>\n<p><strong>计算相关随机性。</strong>接下来作者展示了如何通过计算安全地计算相关随机性，而不需要除短初始设置之外的任何交互。这使我们能够维持各方只需要在每个与门传输单个比特的当前情况。设 $\\kappa$ 为安全参数，$F: {0,1}^{\\kappa} \\times {0,1}^{\\kappa} \\rightarrow {0,1}$ 为输出单比特的伪随机函数。</p>\n<ol>\n<li><p><strong>Init：</strong></p>\n<ul>\n<li>每个 $P_i$ 选择一个随机的 $k_i \\in {0,1}^{\\kappa}$；</li>\n<li>$P_1$ 发送 $k_1$ 给 $P_3$，$P_2$ 发送 $k_2$ 给 $P_1$，$P_3$ 发送 $k_3$ 给 $P_2$。</li>\n</ul>\n<p>$P_1$ 持有 $k_1, k_2$，$P_2$ 持有 $k_2, k_3$，$P_3$ 持有 $k_3, k_1$。</p>\n</li>\n<li><p><strong>GetNextBit：</strong>给定唯一标识符 $id \\in {0,1}^{\\kappa}$，</p>\n<ul>\n<li>$P<em>1$ 计算 $\\alpha = F</em>{k<em>1}(id) \\oplus F</em>{k_2}(id)$；</li>\n<li>$P<em>2$ 计算 $\\beta = F</em>{k<em>2}(id) \\oplus F</em>{k_3}(id)$；</li>\n<li>$P<em>3$ 计算 $\\gamma = F</em>{k<em>3}(id) \\oplus F</em>{k_1}(id)$。</li>\n</ul>\n</li>\n</ol>\n<p>注意到 $\\alpha \\oplus \\beta \\oplus \\gamma = 0$。此外，$P_1$ 不知道用于生成 $\\beta$ 和 $\\gamma$ 的 $k_3$。因此，在 $\\beta$ 和 $\\gamma$ 的约束下，$\\beta \\oplus \\gamma = \\alpha$ 对 $P_1$ 是伪随机的。实际上，$id$ 可以是所有各方在每次调用 <strong>GetNextBit</strong> 时本地递增的计数器。</p>\n<h2 id=\"The-Ring-Modulo-2-n-and-Fields\"><a href=\"#The-Ring-Modulo-2-n-and-Fields\" class=\"headerlink\" title=\"The Ring Modulo $2^n$ and Fields\"></a>The Ring Modulo $2^n$ and Fields</h2><p>上一节讲到的是布尔电路下的协议，接下来将其推广到模 $2^n$ 的环和大于 $2$ 的任意域的一般情况。当取 $n=1$ 时，加法(和减法)与异或相同，乘法与与相同。在这种情况下，这里的协议与第2.1节中描述的协议完全相同。</p>\n<p>$\\left( \\begin{array}{c} 3\\2 \\end{array} \\right)$<strong>-共享。</strong>为了共享一个元素 $v \\bmod 2^n$，分发者选择三个满足约束 $x<em>1 + x_2 + x_3 = 0$ 的随机元素 $x_1, x_2, x_3 \\in \\mathbb{Z}</em>{2^n}$。然后 $P_1$ 的份额为 $(x_1, a_1)$，其中 $a_1 = x_3 - v$；$P_2$ 的份额为 $(x_2, a_2)$，其中 $a_2 = x_1 - v$；$P_3$ 的份额为 $(x_3, a_3)$，其中 $a_3 = x_2 - v$。跟布尔电路的情况一样，每一方的份额都没有暴露关于 $v$ 的信息，而且任意两方可以重构 $v$。</p>\n<p><strong>加法门。</strong>与布尔电路的情况一样，各方在本地将对应的份额进行相加模 $2^n$ 即可。</p>\n<p><strong>乘法门。</strong>设 $(x<em>1,a_1),(x_2,a_2),(x_3,a_3)$ 是 $v_1$ 的秘密共享，$(y_1,b_1),(y_2,b_2),(y_3,b_3)$ 是 $v_2$ 的秘密共享。假设各方 $P_1,P_2,P_3$ 分别有 $\\alpha, \\beta, \\gamma \\in \\mathbb{Z}</em>{2^n}$，其中 $\\alpha + \\beta + \\gamma = 0$。为了计算两个值的积的$\\left( \\begin{array}{c} 3\\2 \\end{array} \\right)$-份额，各方计算：</p>\n<ol>\n<li>$P_1$ 计算 $r_1 = \\frac{a_1 b_1 - x_1 y_1 + \\alpha}{3}$，然后发送 $r_1$ 给 $P_2$；</li>\n<li>$P_2$ 计算 $r_2 = \\frac{a_2 b_2 - x_2 y_2 + \\beta}{3}$，然后发送 $r_2$ 给 $P_3$；</li>\n<li>$P_3$ 计算 $r_3 = \\frac{a_3 b_3 - x_3 y_3 + \\gamma}{3}$，然后发送 $r_3$ 给 $P_1$；</li>\n<li>$P_1$ 将它的份额定义为 $z_1 = r_3 - r_1$ 和 $c_1 = -2r_3 - r_1$；</li>\n<li>$P_2$ 将它的份额定义为 $z_2 = r_1 - r_2$ 和 $c_2 = -2r_1 - r_2$；</li>\n<li>$P_3$ 将它的份额定义为 $z_3 = r_2 - r_3$ 和 $c_3 = -2r_2 - r_3$。</li>\n</ol>\n<p>上面的计算是合法的，因为 $3$ 与 $2^n$ 是互质的；因此，$3$ 是可逆的。此外，上述结果在3个以上元素的有限域上都成立。</p>\n<p>为了验证 $r_1 + r_2 + r_3 = v_1 v_2$，首先观察到</p>\n<script type=\"math/tex; mode=display\">\na_1 b_1  = (x_3 - v_1)(y_3 - v_2) = x_3 y_3 - x_3 v_2 - y_3 v_1 + v_1 v_2 \\tag{2}</script><p>类似地，$a_2 b_2 = x_1 y_1 - x_1 v_2 - y_1 v_1 + v_1 v_2$，$a_3 b_3 = x_2 y_2 - x_2 v_2 - y_2 v_1 + v_1 v_2$。然后</p>\n<script type=\"math/tex; mode=display\">\n\\begin{align}\n3(&r_1 + r_2 + r_3) \\\\\n&= a_1 b_1 - x_1 y_1 + \\alpha + a_2 b_2 - x_2 y_2 + \\beta + a_3 b_3 - x_3 y_3 + \\gamma \\\\\n&= a_1 b_1 + a_2 b_2 + a_3 b_3 - x_1 y_1 - x_2 y_2 - x_3 y_3 \\\\\n&= 3v_1 v_2 - v_1(y_1 + y_2 + y_3) - v_2(x_1 + x_2 + x_3) = 3v_1 v_2\n\\end{align}</script><p>接下来证明各方的$\\left( \\begin{array}{c} 3\\2 \\end{array} \\right)$-份额是有效的：根据定义，各方的份额为 $(z_1, z_3 - v_1 v_2), (z_2, z_1 - v_1 v_2)$ 和 $(z_3, z_2 - v_1 v_2)$，其中 $z_1 + z_2 + z_3 = 0 \\bmod 2^n$。首先后者很容易看出来是成立的，根据 $z_1, z_2, z_3$ 的定义。其次，$P_1$ 持有 $c_1$ $= -2 r_3 - r_1$ $= -r_3 - r_3 - r_1 - r_2 + r_2$ $=(r_2 - r_3)-(r_1 + r_2 + r_3)$ $=z_3 - v_1 v_2$，满足要求。对于 $P_2$ 和 $P_3$ 的情况同样成立。</p>\n<p><strong>生成相关随机性。</strong>各方使用与第2.2节所述相同的(计算)方法，但有以下不同之处。首先，我们假设 $F<em>k$ 是将字符串映射到 $\\mathbb{Z}</em>{2^n}$ (或等价于 ${0,1}^n$)的伪随机函数。其次，$P<em>1$计算 $\\alpha = F</em>{k<em>1}(id) - F</em>{k<em>2}(id)$，$P_2$计算 $\\beta = F</em>{k<em>2}(id) - F</em>{k<em>3}(id)$，$P_3$计算 $\\gamma = F</em>{k<em>3}(id) - F</em>{k_1}(id)$。</p>"},{"title":"论文笔记 Efficient Multi-Key Homomorphic Encryption with Packed Ciphertexts with Application to Oblivious Neural Network Inference","date":"2020-07-09T06:56:51.000Z","_content":"\n*Hao Chen, Wei Dai, Miran Kim, Yongsoo Song*\n\nCCS 2019\n\nhttps://dl.acm.org/doi/10.1145/3319535.3363207\n\n<!--more-->\n\n# 本文的贡献\n\n本文设计了BFV[6，22]和CKKS[16]方案的多密钥变体。本文提出了一种新的生成重线性化密钥的方法，与文献[13]中的以前技术相比，该方法更简单、更快。此外，本文将这些方案[9，12，14]的最新自举算法应用于多密钥场景，以构建具有压缩密文的多密钥完全同态加密。最后，作者使用Microsoft SEAL[47]给出了本文的多密钥方案的概念验证实现，并给出了实验结果。据作者所知，这是支持打包密文的MKHE方案的第一个实际实现。\n\n本文还提出了MKHE的第一个可行的应用，它安全地评估了预先训练的卷积神经网络(CNN)模型。本文构建了一个高效的协议，云服务器使用模型提供者提供的分类器为数据所有者提供在线预测服务，同时使用MKHE保护数据和模型的隐私。如图1所示，本文的方案支持多密钥操作，使得以较低的端到端延迟和接近最佳的数据和模型提供者成本来实现这一点。服务器可以存储以不同密钥加密的大量密文，但是特定任务的计算成本仅取决于与电路相关的各方的数量。作者注意到，本文的解决方案比单密钥HE更有优势，因为ML模型提供者不需要将未加密的模型发送到服务器。\n\n![](http://images.yingwai.top/picgo/emkhef1.png)\n\n\n\n# BACKGROUND\n\n## 记号法\n\n除非另有说明，否则所有对数都以 $2$ 为底。我们用粗体表示向量，例如$\\mathbf{a}$，用大写粗体表示矩阵，例如 $\\mathbf{A}$。本文用 $\\langle \\mathbf{u}, \\mathbf{v} \\rangle$ 表示两个向量 $\\mathbf{u}, \\mathbf{v}$ 的通常点积。对于实数 $r$，$\\lfloor r \\rceil$ 表示最表示最接近 $r$ 的整数，在平局的情况下向上舍入。本文用 $x \\leftarrow D$ 表示按分布 $D$ 抽样的 $x$。对于有限集 $S$，$U(S)$ 表示 $S$ 上的均匀分布。本文用 $\\lambda$ 表示安全参数：所有已知的对作用域内的密码方案的有效攻击都应该采用 $\\Omega(2^\\lambda)$ 位运算。\n\n\n\n## 多密钥同态加密\n\n多密钥同态加密是一种密码系统，它允许我们对可能在不同密钥下加密的密文评估算术电路。\n\n设 $\\mathcal{M}$ 是具有算术结构的消息空间。MKHE方案MKHE由五个PPT算法($\\mathsf{Setup}, \\mathsf{KeyGen}, \\mathsf{Enc}, \\mathsf{Dec}, \\mathsf{Eval}$)组成。本文假设每个参与方都有对其公钥和私钥的引用(索引)。多密钥密文隐式包含*有序*集合 $T = \\{id_1, ..., id_k\\}$ 相关联的引用。例如，新的密文 $\\mathsf{ct} \\leftarrow \\mathsf{MKHE.Enc}(\\mu; \\mathsf{pk}_{id})$ 对应于单个元素集合 $T = \\{id\\}$，但是随着来自不同方的密文之间的计算的进行，参考集合的大小变得更大。\n\n* **初始化**：$pp \\leftarrow \\mathsf{MKHE.Setup}(1^\\lambda)$。将安全参数作为输入并返回公共参数化。本文假设所有其他算法都隐含地将 $pp$ 作为输入。\n\n* **密钥生成**：$(\\mathsf{sk}, \\mathsf{pk}) \\leftarrow \\mathsf{MKHE.KeyGen}(pp)$。输出一对私钥和公钥。\n\n* **加密**：$\\mathsf{ct} \\leftarrow \\mathsf{MKHE.Enc}(\\mu; \\mathsf{pk})$。加密明文 $\\mu \\in \\mathcal{M}$ 并输出密文 $\\mathsf{ct} \\in \\{0,1 \\}^*$。\n\n* **解密**：$\\mu \\leftarrow \\mathsf{MKHE.Dec}(\\overline{\\mathsf{ct}}; \\{\\mathsf{sk}_{id}\\}_{id \\in T})$。给定具有对应密钥序列的密文 $\\overline{\\mathsf{ct}}$，输出明文 $\\mu$。\n\n* **同态评估**：\n  $$\n  \\overline{\\mathsf{ct}} \\leftarrow \\mathsf{MKHE.Eval}(\\mathcal{C}, (\\overline{\\mathsf{ct}}_1,...,\\overline{\\mathsf{ct}}_l),\\{\\mathsf{pk}_{id}\\}_{id \\in T})\n  $$\n  给定电路 $\\mathcal{C}$，多密钥密文的元组 $(\\overline{\\mathsf{ct}}_1,...,\\overline{\\mathsf{ct}}_l)$ 和对应的一组公钥 $\\{\\mathsf{pk}_{id}\\}_{id \\in T}$，输出密文 $\\overline{\\mathsf{ct}}$。它的参考集是输入密文 $\\overline{\\mathsf{ct}}_j, 1 \\leq j \\leq l$ 的联合 $T = T_1 \\cup \\cdots \\cup T_l$。\n\n**语义安全。**对于任意两条消息 $\\mu_0, \\mu_1 \\in \\mathcal{M}, \\ \\ i = 0, 1$ 的分布 $\\{\\mathsf{MKHE.Enc}(\\mu_i; \\mathsf{pk}) \\}$ 在 $pp \\leftarrow \\mathsf{MKHE.Setup}(1^\\lambda)$ 和 $(\\mathsf{sk}, \\mathsf{pk}) \\leftarrow \\mathsf{MKHE.KeyGen}(pp)$ 的计算上应该是不可区分的。\n\n**正确性和紧凑性。**如果与 $k$ 方相关的密文的大小受固定多项式 ${\\rm poly}(\\cdot, \\cdot)$ 的 ${\\rm poly}(\\lambda, k)$ 的限制，则MKHE方案是紧致的。\n\n对于 $1 \\leq j \\leq l$，设 $\\overline{\\mathsf{ct}}_j$ 为密文(参考集合 $T_j$)，使得 $\\mathsf{MKHE.Dec}(\\overline{\\mathsf{ct}}_j; \\{\\mathsf{sk}_{id}\\}_{id \\in T} = \\mu_j$。设 $\\mathcal{C} : \\mathcal{M}^l \\rightarrow \\mathcal{M}$ 为电路，$\\overline{\\mathsf{ct}} \\leftarrow \\mathsf{MKHE.Eval}(\\mathcal{C}, (\\overline{\\mathsf{ct}}_1,...,\\overline{\\mathsf{ct}}_l),\\{\\mathsf{pk}_{id}\\}_{id \\in T})$，其中 $T = T_1 \\cup \\cdots \\cup T_l$。然后，\n$$\n\\mathsf{MKHE.Dec}(\\overline{\\mathsf{ct}}; \\{\\mathsf{sk}_{id}\\}_{id \\in T} = \\mathcal{C}(\\mu_1,...,\\mu_l) \\tag{1}\n$$\n以压倒性的可能性。对于近似算术[16]，可以用类似于CKKS格式的近似相等来代替(1)的相等。\n\n\n\n## 环上容错学习\n\n在整篇文章中，作者假设 $n$ 是2的幂整数，并且 $R=\\mathbb{Z}[X]/(X^n+1)$。对于 $R$ 的模为整数 $q$ 的剩余环，本文记作 $R_q=R/(q·R)$。带参数 $(n,q,\\chi,\\psi)$ 的环学习假设是给定任意多项式数目的形式的样本 $(a_i,b_i=s \\cdot a_i+e_i) \\in R^2_q$，其中 $a_i$ 在 $R_q$ 中是一致随机的，$s$ 选自 $R_q$ 上的密钥分布 $\\chi$，$e_i$ 取自 $R$ 上的误差分布 $\\psi$，$b_i$ 是 $R_q$ 中的均匀随机元素、在计算上是不可区分的。\n\n\n\n## 小工具分解\n\n设 $\\mathbf{g}=(g_i) \\in \\mathbb{Z}^d$ 为小工具向量，$q$ 为整数。小工具分解，由 $\\mathbf{g}^{-1}$ 表示，是从 $R_q$ 到 $R^d$ 的函数，它将元素 $a \\in R_q$ 转换成*小*多项式向量 $u=(u_0,...,u_{d−1})\\in R^d$ ，使得 $a = \\sum^{d-1}_{i=0} g_i \\cdot u_i \\pmod{q}$。\n\n小工具分解技术被广泛应用于HE方案的构建中。例如，非线性电路的同态评估是基于密钥切换技术的，并且大多数HE方案利用各种小工具分解方法来控制噪声增长。文献中已经提出了各种分解方法，如位分解[6，7]、基分解[17，21]和基于RNS的分解[4，30]。本文的实现利用了RNS友好的分解来提高效率。\n\n\n\n# 本文的构造\n\n## 基本方案\n\n* $\\mathsf{Setup}(1^\\lambda)$：对于给定的安全参数 $\\lambda$，设置RLWE维数 $n$、密文模数 $q$、密钥分布 $\\chi$ 和R上的误差分布 $\\psi$。生成随机向量 $\\mathbf{a} \\leftarrow U(R^d_q)$。返回公共参数 $pp=(n, q, \\chi, \\psi, \\mathbf{a})$。\n* $\\mathsf{KeyGen}(pp)$：选取密钥 $s \\leftarrow \\chi$。选取误差向量 $e \\leftarrow \\psi^d$，并将公钥在 $R^d_q$ 中设置为 $\\mathbf{b} = -s \\cdot \\mathbf{a} + \\mathbf{e} \\pmod{q}$。\n* $\\mathsf{UniEnc}(\\mu;s)$：对于输入明文 $\\mu \\in R$，生成密文 $\\mathbf{D} = [\\mathbf{d}_0 | \\mathbf{d}_1 | \\mathbf{d}_2] \\in R^{d \\times 3}_q$，如下所示：\n  1. 选取 $r \\leftarrow \\chi$；\n  2. 选取 $\\mathbf{d}_1 \\leftarrow U(R^d_q)$ 和 $\\mathbf{e}_1 \\leftarrow \\psi^d$，然后设 $\\mathbf{d}_0 = -s \\cdot \\mathbf{d}_1 + \\mathbf{e}_1 + r \\cdot \\mathbf{g} \\pmod{q}$；\n  3. 选取 $\\mathbf{e}_2 \\leftarrow \\psi^d$ 然后设 $\\mathbf{d}_2 = r \\cdot \\mathbf{a} + \\mathbf{e}_2 + \\mu \\cdot \\mathbf{g} \\pmod{q}$。\n\n公共参数 $pp$ 包含一个随机生成的向量 $\\mathbf{a} \\in R^d_q$，因此本文假设使用公共引用字符串模型。各方应将相同的公共参数作为密钥生成算法的输入，以支持多密钥同态运算。在以前关于MKHE的所有工作中都做出了同样的假设。\n\n单一加密算法是对称加密，它可以加密单个环形元件。一次加密的密文 $\\mathbf{D} = [\\mathbf{d}_0 | \\mathbf{d}_1 | \\mathbf{d}_2] \\leftarrow \\mathsf{UniEnc}(\\mu;s)$ 由 $R^d_q$ 中的三个矢量组成，其大小是 $R^{2d \\times 2}_q$ 中普通RGSW密文的(3/4)倍。对于一次加密密文 $\\mathbf{D}$，前两列 $[\\mathbf{d}_0 | \\mathbf{d}_1]$ 可以被视为秘密 $s$ 下的 $r$ 的加密，而 $[\\mathbf{d}_2 | -\\mathbf{a}]$ 形成秘密 $r$ 下的 $\\mu$ 的加密。\n\n\n\n## 再线性化\n\n在级联秘密 $\\overline{\\mathsf{sk}} = (1, s_1, ..., s_k)$ 下加密的两个多密钥密文 $\\overline{\\mathsf{ct}}_i \\in R^{k+1}_q$ 的张量积 $\\overline{\\mathsf{ct}} = \\overline{\\mathsf{ct}}_1 \\otimes \\overline{\\mathsf{ct}}_2$ 可以看作是对应于张量平方密钥 $\\overline{\\mathsf{sk}} \\otimes \\overline{\\mathsf{sk}}$ 的密文。$\\overline{\\mathsf{sk}} \\otimes \\overline{\\mathsf{sk}}$ 包含一些与两个不同方相关的非线性项 $s_i \\cdot s_j$。因此，计算服务器应该能够通过非线性项 $s_i \\cdot s_j$ 的线性化来将扩展密文 $\\overline{\\mathsf{ct}} \\in R^{(k+1) \\times (k+1)}_q$ 转换为规范密文。\n\n本文的重新线性化方法需要由单个各方生成的相同公共材料(评估密钥)，如下所示：\n\n* $\\mathsf{EvkGen}(s)$：给定秘密 $s \\in R$，返回 $\\mathbf{D} \\leftarrow \\mathsf{UniEnc}(s;s)$。\n\n准确地说，每一方 $i$ 通过运行算法(si，bi)←KeyGen(Pp)和Di←EvkGen(Si)来生成其自己的秘密密钥、公共密钥和评估密钥，然后发布该对(bi，Di)。在本节的其余部分，我们将介绍两种重新线性化算法，并说明它们的优缺点。","source":"_posts/论文笔记-Efficient-Multi-Key-Homomorphic-Encryption-with-Packed-Ciphertexts-with-Application-to-Oblivious-Neural-Network-Inference.md","raw":"---\ntitle: >-\n  论文笔记 Efficient Multi-Key Homomorphic Encryption with Packed Ciphertexts with\n  Application to Oblivious Neural Network Inference\ndate: 2020-07-09 14:56:51\ncategories: Papers\ntags: [HE, PPML, Neural Network]\n---\n\n*Hao Chen, Wei Dai, Miran Kim, Yongsoo Song*\n\nCCS 2019\n\nhttps://dl.acm.org/doi/10.1145/3319535.3363207\n\n<!--more-->\n\n# 本文的贡献\n\n本文设计了BFV[6，22]和CKKS[16]方案的多密钥变体。本文提出了一种新的生成重线性化密钥的方法，与文献[13]中的以前技术相比，该方法更简单、更快。此外，本文将这些方案[9，12，14]的最新自举算法应用于多密钥场景，以构建具有压缩密文的多密钥完全同态加密。最后，作者使用Microsoft SEAL[47]给出了本文的多密钥方案的概念验证实现，并给出了实验结果。据作者所知，这是支持打包密文的MKHE方案的第一个实际实现。\n\n本文还提出了MKHE的第一个可行的应用，它安全地评估了预先训练的卷积神经网络(CNN)模型。本文构建了一个高效的协议，云服务器使用模型提供者提供的分类器为数据所有者提供在线预测服务，同时使用MKHE保护数据和模型的隐私。如图1所示，本文的方案支持多密钥操作，使得以较低的端到端延迟和接近最佳的数据和模型提供者成本来实现这一点。服务器可以存储以不同密钥加密的大量密文，但是特定任务的计算成本仅取决于与电路相关的各方的数量。作者注意到，本文的解决方案比单密钥HE更有优势，因为ML模型提供者不需要将未加密的模型发送到服务器。\n\n![](http://images.yingwai.top/picgo/emkhef1.png)\n\n\n\n# BACKGROUND\n\n## 记号法\n\n除非另有说明，否则所有对数都以 $2$ 为底。我们用粗体表示向量，例如$\\mathbf{a}$，用大写粗体表示矩阵，例如 $\\mathbf{A}$。本文用 $\\langle \\mathbf{u}, \\mathbf{v} \\rangle$ 表示两个向量 $\\mathbf{u}, \\mathbf{v}$ 的通常点积。对于实数 $r$，$\\lfloor r \\rceil$ 表示最表示最接近 $r$ 的整数，在平局的情况下向上舍入。本文用 $x \\leftarrow D$ 表示按分布 $D$ 抽样的 $x$。对于有限集 $S$，$U(S)$ 表示 $S$ 上的均匀分布。本文用 $\\lambda$ 表示安全参数：所有已知的对作用域内的密码方案的有效攻击都应该采用 $\\Omega(2^\\lambda)$ 位运算。\n\n\n\n## 多密钥同态加密\n\n多密钥同态加密是一种密码系统，它允许我们对可能在不同密钥下加密的密文评估算术电路。\n\n设 $\\mathcal{M}$ 是具有算术结构的消息空间。MKHE方案MKHE由五个PPT算法($\\mathsf{Setup}, \\mathsf{KeyGen}, \\mathsf{Enc}, \\mathsf{Dec}, \\mathsf{Eval}$)组成。本文假设每个参与方都有对其公钥和私钥的引用(索引)。多密钥密文隐式包含*有序*集合 $T = \\{id_1, ..., id_k\\}$ 相关联的引用。例如，新的密文 $\\mathsf{ct} \\leftarrow \\mathsf{MKHE.Enc}(\\mu; \\mathsf{pk}_{id})$ 对应于单个元素集合 $T = \\{id\\}$，但是随着来自不同方的密文之间的计算的进行，参考集合的大小变得更大。\n\n* **初始化**：$pp \\leftarrow \\mathsf{MKHE.Setup}(1^\\lambda)$。将安全参数作为输入并返回公共参数化。本文假设所有其他算法都隐含地将 $pp$ 作为输入。\n\n* **密钥生成**：$(\\mathsf{sk}, \\mathsf{pk}) \\leftarrow \\mathsf{MKHE.KeyGen}(pp)$。输出一对私钥和公钥。\n\n* **加密**：$\\mathsf{ct} \\leftarrow \\mathsf{MKHE.Enc}(\\mu; \\mathsf{pk})$。加密明文 $\\mu \\in \\mathcal{M}$ 并输出密文 $\\mathsf{ct} \\in \\{0,1 \\}^*$。\n\n* **解密**：$\\mu \\leftarrow \\mathsf{MKHE.Dec}(\\overline{\\mathsf{ct}}; \\{\\mathsf{sk}_{id}\\}_{id \\in T})$。给定具有对应密钥序列的密文 $\\overline{\\mathsf{ct}}$，输出明文 $\\mu$。\n\n* **同态评估**：\n  $$\n  \\overline{\\mathsf{ct}} \\leftarrow \\mathsf{MKHE.Eval}(\\mathcal{C}, (\\overline{\\mathsf{ct}}_1,...,\\overline{\\mathsf{ct}}_l),\\{\\mathsf{pk}_{id}\\}_{id \\in T})\n  $$\n  给定电路 $\\mathcal{C}$，多密钥密文的元组 $(\\overline{\\mathsf{ct}}_1,...,\\overline{\\mathsf{ct}}_l)$ 和对应的一组公钥 $\\{\\mathsf{pk}_{id}\\}_{id \\in T}$，输出密文 $\\overline{\\mathsf{ct}}$。它的参考集是输入密文 $\\overline{\\mathsf{ct}}_j, 1 \\leq j \\leq l$ 的联合 $T = T_1 \\cup \\cdots \\cup T_l$。\n\n**语义安全。**对于任意两条消息 $\\mu_0, \\mu_1 \\in \\mathcal{M}, \\ \\ i = 0, 1$ 的分布 $\\{\\mathsf{MKHE.Enc}(\\mu_i; \\mathsf{pk}) \\}$ 在 $pp \\leftarrow \\mathsf{MKHE.Setup}(1^\\lambda)$ 和 $(\\mathsf{sk}, \\mathsf{pk}) \\leftarrow \\mathsf{MKHE.KeyGen}(pp)$ 的计算上应该是不可区分的。\n\n**正确性和紧凑性。**如果与 $k$ 方相关的密文的大小受固定多项式 ${\\rm poly}(\\cdot, \\cdot)$ 的 ${\\rm poly}(\\lambda, k)$ 的限制，则MKHE方案是紧致的。\n\n对于 $1 \\leq j \\leq l$，设 $\\overline{\\mathsf{ct}}_j$ 为密文(参考集合 $T_j$)，使得 $\\mathsf{MKHE.Dec}(\\overline{\\mathsf{ct}}_j; \\{\\mathsf{sk}_{id}\\}_{id \\in T} = \\mu_j$。设 $\\mathcal{C} : \\mathcal{M}^l \\rightarrow \\mathcal{M}$ 为电路，$\\overline{\\mathsf{ct}} \\leftarrow \\mathsf{MKHE.Eval}(\\mathcal{C}, (\\overline{\\mathsf{ct}}_1,...,\\overline{\\mathsf{ct}}_l),\\{\\mathsf{pk}_{id}\\}_{id \\in T})$，其中 $T = T_1 \\cup \\cdots \\cup T_l$。然后，\n$$\n\\mathsf{MKHE.Dec}(\\overline{\\mathsf{ct}}; \\{\\mathsf{sk}_{id}\\}_{id \\in T} = \\mathcal{C}(\\mu_1,...,\\mu_l) \\tag{1}\n$$\n以压倒性的可能性。对于近似算术[16]，可以用类似于CKKS格式的近似相等来代替(1)的相等。\n\n\n\n## 环上容错学习\n\n在整篇文章中，作者假设 $n$ 是2的幂整数，并且 $R=\\mathbb{Z}[X]/(X^n+1)$。对于 $R$ 的模为整数 $q$ 的剩余环，本文记作 $R_q=R/(q·R)$。带参数 $(n,q,\\chi,\\psi)$ 的环学习假设是给定任意多项式数目的形式的样本 $(a_i,b_i=s \\cdot a_i+e_i) \\in R^2_q$，其中 $a_i$ 在 $R_q$ 中是一致随机的，$s$ 选自 $R_q$ 上的密钥分布 $\\chi$，$e_i$ 取自 $R$ 上的误差分布 $\\psi$，$b_i$ 是 $R_q$ 中的均匀随机元素、在计算上是不可区分的。\n\n\n\n## 小工具分解\n\n设 $\\mathbf{g}=(g_i) \\in \\mathbb{Z}^d$ 为小工具向量，$q$ 为整数。小工具分解，由 $\\mathbf{g}^{-1}$ 表示，是从 $R_q$ 到 $R^d$ 的函数，它将元素 $a \\in R_q$ 转换成*小*多项式向量 $u=(u_0,...,u_{d−1})\\in R^d$ ，使得 $a = \\sum^{d-1}_{i=0} g_i \\cdot u_i \\pmod{q}$。\n\n小工具分解技术被广泛应用于HE方案的构建中。例如，非线性电路的同态评估是基于密钥切换技术的，并且大多数HE方案利用各种小工具分解方法来控制噪声增长。文献中已经提出了各种分解方法，如位分解[6，7]、基分解[17，21]和基于RNS的分解[4，30]。本文的实现利用了RNS友好的分解来提高效率。\n\n\n\n# 本文的构造\n\n## 基本方案\n\n* $\\mathsf{Setup}(1^\\lambda)$：对于给定的安全参数 $\\lambda$，设置RLWE维数 $n$、密文模数 $q$、密钥分布 $\\chi$ 和R上的误差分布 $\\psi$。生成随机向量 $\\mathbf{a} \\leftarrow U(R^d_q)$。返回公共参数 $pp=(n, q, \\chi, \\psi, \\mathbf{a})$。\n* $\\mathsf{KeyGen}(pp)$：选取密钥 $s \\leftarrow \\chi$。选取误差向量 $e \\leftarrow \\psi^d$，并将公钥在 $R^d_q$ 中设置为 $\\mathbf{b} = -s \\cdot \\mathbf{a} + \\mathbf{e} \\pmod{q}$。\n* $\\mathsf{UniEnc}(\\mu;s)$：对于输入明文 $\\mu \\in R$，生成密文 $\\mathbf{D} = [\\mathbf{d}_0 | \\mathbf{d}_1 | \\mathbf{d}_2] \\in R^{d \\times 3}_q$，如下所示：\n  1. 选取 $r \\leftarrow \\chi$；\n  2. 选取 $\\mathbf{d}_1 \\leftarrow U(R^d_q)$ 和 $\\mathbf{e}_1 \\leftarrow \\psi^d$，然后设 $\\mathbf{d}_0 = -s \\cdot \\mathbf{d}_1 + \\mathbf{e}_1 + r \\cdot \\mathbf{g} \\pmod{q}$；\n  3. 选取 $\\mathbf{e}_2 \\leftarrow \\psi^d$ 然后设 $\\mathbf{d}_2 = r \\cdot \\mathbf{a} + \\mathbf{e}_2 + \\mu \\cdot \\mathbf{g} \\pmod{q}$。\n\n公共参数 $pp$ 包含一个随机生成的向量 $\\mathbf{a} \\in R^d_q$，因此本文假设使用公共引用字符串模型。各方应将相同的公共参数作为密钥生成算法的输入，以支持多密钥同态运算。在以前关于MKHE的所有工作中都做出了同样的假设。\n\n单一加密算法是对称加密，它可以加密单个环形元件。一次加密的密文 $\\mathbf{D} = [\\mathbf{d}_0 | \\mathbf{d}_1 | \\mathbf{d}_2] \\leftarrow \\mathsf{UniEnc}(\\mu;s)$ 由 $R^d_q$ 中的三个矢量组成，其大小是 $R^{2d \\times 2}_q$ 中普通RGSW密文的(3/4)倍。对于一次加密密文 $\\mathbf{D}$，前两列 $[\\mathbf{d}_0 | \\mathbf{d}_1]$ 可以被视为秘密 $s$ 下的 $r$ 的加密，而 $[\\mathbf{d}_2 | -\\mathbf{a}]$ 形成秘密 $r$ 下的 $\\mu$ 的加密。\n\n\n\n## 再线性化\n\n在级联秘密 $\\overline{\\mathsf{sk}} = (1, s_1, ..., s_k)$ 下加密的两个多密钥密文 $\\overline{\\mathsf{ct}}_i \\in R^{k+1}_q$ 的张量积 $\\overline{\\mathsf{ct}} = \\overline{\\mathsf{ct}}_1 \\otimes \\overline{\\mathsf{ct}}_2$ 可以看作是对应于张量平方密钥 $\\overline{\\mathsf{sk}} \\otimes \\overline{\\mathsf{sk}}$ 的密文。$\\overline{\\mathsf{sk}} \\otimes \\overline{\\mathsf{sk}}$ 包含一些与两个不同方相关的非线性项 $s_i \\cdot s_j$。因此，计算服务器应该能够通过非线性项 $s_i \\cdot s_j$ 的线性化来将扩展密文 $\\overline{\\mathsf{ct}} \\in R^{(k+1) \\times (k+1)}_q$ 转换为规范密文。\n\n本文的重新线性化方法需要由单个各方生成的相同公共材料(评估密钥)，如下所示：\n\n* $\\mathsf{EvkGen}(s)$：给定秘密 $s \\in R$，返回 $\\mathbf{D} \\leftarrow \\mathsf{UniEnc}(s;s)$。\n\n准确地说，每一方 $i$ 通过运行算法(si，bi)←KeyGen(Pp)和Di←EvkGen(Si)来生成其自己的秘密密钥、公共密钥和评估密钥，然后发布该对(bi，Di)。在本节的其余部分，我们将介绍两种重新线性化算法，并说明它们的优缺点。","slug":"论文笔记-Efficient-Multi-Key-Homomorphic-Encryption-with-Packed-Ciphertexts-with-Application-to-Oblivious-Neural-Network-Inference","published":1,"updated":"2020-08-23T14:33:37.435Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cke79q4tl004988ps1wz4dep5","content":"<p><em>Hao Chen, Wei Dai, Miran Kim, Yongsoo Song</em></p>\n<p>CCS 2019</p>\n<p><a href=\"https://dl.acm.org/doi/10.1145/3319535.3363207\" target=\"_blank\" rel=\"noopener\">https://dl.acm.org/doi/10.1145/3319535.3363207</a></p>\n<a id=\"more\"></a>\n<h1 id=\"本文的贡献\"><a href=\"#本文的贡献\" class=\"headerlink\" title=\"本文的贡献\"></a>本文的贡献</h1><p>本文设计了BFV[6，22]和CKKS[16]方案的多密钥变体。本文提出了一种新的生成重线性化密钥的方法，与文献[13]中的以前技术相比，该方法更简单、更快。此外，本文将这些方案[9，12，14]的最新自举算法应用于多密钥场景，以构建具有压缩密文的多密钥完全同态加密。最后，作者使用Microsoft SEAL[47]给出了本文的多密钥方案的概念验证实现，并给出了实验结果。据作者所知，这是支持打包密文的MKHE方案的第一个实际实现。</p>\n<p>本文还提出了MKHE的第一个可行的应用，它安全地评估了预先训练的卷积神经网络(CNN)模型。本文构建了一个高效的协议，云服务器使用模型提供者提供的分类器为数据所有者提供在线预测服务，同时使用MKHE保护数据和模型的隐私。如图1所示，本文的方案支持多密钥操作，使得以较低的端到端延迟和接近最佳的数据和模型提供者成本来实现这一点。服务器可以存储以不同密钥加密的大量密文，但是特定任务的计算成本仅取决于与电路相关的各方的数量。作者注意到，本文的解决方案比单密钥HE更有优势，因为ML模型提供者不需要将未加密的模型发送到服务器。</p>\n<p><img src=\"http://images.yingwai.top/picgo/emkhef1.png\" alt=\"\"></p>\n<h1 id=\"BACKGROUND\"><a href=\"#BACKGROUND\" class=\"headerlink\" title=\"BACKGROUND\"></a>BACKGROUND</h1><h2 id=\"记号法\"><a href=\"#记号法\" class=\"headerlink\" title=\"记号法\"></a>记号法</h2><p>除非另有说明，否则所有对数都以 $2$ 为底。我们用粗体表示向量，例如$\\mathbf{a}$，用大写粗体表示矩阵，例如 $\\mathbf{A}$。本文用 $\\langle \\mathbf{u}, \\mathbf{v} \\rangle$ 表示两个向量 $\\mathbf{u}, \\mathbf{v}$ 的通常点积。对于实数 $r$，$\\lfloor r \\rceil$ 表示最表示最接近 $r$ 的整数，在平局的情况下向上舍入。本文用 $x \\leftarrow D$ 表示按分布 $D$ 抽样的 $x$。对于有限集 $S$，$U(S)$ 表示 $S$ 上的均匀分布。本文用 $\\lambda$ 表示安全参数：所有已知的对作用域内的密码方案的有效攻击都应该采用 $\\Omega(2^\\lambda)$ 位运算。</p>\n<h2 id=\"多密钥同态加密\"><a href=\"#多密钥同态加密\" class=\"headerlink\" title=\"多密钥同态加密\"></a>多密钥同态加密</h2><p>多密钥同态加密是一种密码系统，它允许我们对可能在不同密钥下加密的密文评估算术电路。</p>\n<p>设 $\\mathcal{M}$ 是具有算术结构的消息空间。MKHE方案MKHE由五个PPT算法($\\mathsf{Setup}, \\mathsf{KeyGen}, \\mathsf{Enc}, \\mathsf{Dec}, \\mathsf{Eval}$)组成。本文假设每个参与方都有对其公钥和私钥的引用(索引)。多密钥密文隐式包含<em>有序</em>集合 $T = {id<em>1, …, id_k}$ 相关联的引用。例如，新的密文 $\\mathsf{ct} \\leftarrow \\mathsf{MKHE.Enc}(\\mu; \\mathsf{pk}</em>{id})$ 对应于单个元素集合 $T = {id}$，但是随着来自不同方的密文之间的计算的进行，参考集合的大小变得更大。</p>\n<ul>\n<li><p><strong>初始化</strong>：$pp \\leftarrow \\mathsf{MKHE.Setup}(1^\\lambda)$。将安全参数作为输入并返回公共参数化。本文假设所有其他算法都隐含地将 $pp$ 作为输入。</p>\n</li>\n<li><p><strong>密钥生成</strong>：$(\\mathsf{sk}, \\mathsf{pk}) \\leftarrow \\mathsf{MKHE.KeyGen}(pp)$。输出一对私钥和公钥。</p>\n</li>\n<li><p><strong>加密</strong>：$\\mathsf{ct} \\leftarrow \\mathsf{MKHE.Enc}(\\mu; \\mathsf{pk})$。加密明文 $\\mu \\in \\mathcal{M}$ 并输出密文 $\\mathsf{ct} \\in {0,1 }^*$。</p>\n</li>\n<li><p><strong>解密</strong>：$\\mu \\leftarrow \\mathsf{MKHE.Dec}(\\overline{\\mathsf{ct}}; {\\mathsf{sk}<em>{id}}</em>{id \\in T})$。给定具有对应密钥序列的密文 $\\overline{\\mathsf{ct}}$，输出明文 $\\mu$。</p>\n</li>\n<li><p><strong>同态评估</strong>：</p>\n<script type=\"math/tex; mode=display\">\n\\overline{\\mathsf{ct}} \\leftarrow \\mathsf{MKHE.Eval}(\\mathcal{C}, (\\overline{\\mathsf{ct}}_1,...,\\overline{\\mathsf{ct}}_l),\\{\\mathsf{pk}_{id}\\}_{id \\in T})</script><p>给定电路 $\\mathcal{C}$，多密钥密文的元组 $(\\overline{\\mathsf{ct}}<em>1,…,\\overline{\\mathsf{ct}}_l)$ 和对应的一组公钥 ${\\mathsf{pk}</em>{id}}_{id \\in T}$，输出密文 $\\overline{\\mathsf{ct}}$。它的参考集是输入密文 $\\overline{\\mathsf{ct}}_j, 1 \\leq j \\leq l$ 的联合 $T = T_1 \\cup \\cdots \\cup T_l$。</p>\n</li>\n</ul>\n<p><strong>语义安全。</strong>对于任意两条消息 $\\mu_0, \\mu_1 \\in \\mathcal{M}, \\ \\ i = 0, 1$ 的分布 ${\\mathsf{MKHE.Enc}(\\mu_i; \\mathsf{pk}) }$ 在 $pp \\leftarrow \\mathsf{MKHE.Setup}(1^\\lambda)$ 和 $(\\mathsf{sk}, \\mathsf{pk}) \\leftarrow \\mathsf{MKHE.KeyGen}(pp)$ 的计算上应该是不可区分的。</p>\n<p><strong>正确性和紧凑性。</strong>如果与 $k$ 方相关的密文的大小受固定多项式 ${\\rm poly}(\\cdot, \\cdot)$ 的 ${\\rm poly}(\\lambda, k)$ 的限制，则MKHE方案是紧致的。</p>\n<p>对于 $1 \\leq j \\leq l$，设 $\\overline{\\mathsf{ct}}<em>j$ 为密文(参考集合 $T_j$)，使得 $\\mathsf{MKHE.Dec}(\\overline{\\mathsf{ct}}_j; {\\mathsf{sk}</em>{id}}<em>{id \\in T} = \\mu_j$。设 $\\mathcal{C} : \\mathcal{M}^l \\rightarrow \\mathcal{M}$ 为电路，$\\overline{\\mathsf{ct}} \\leftarrow \\mathsf{MKHE.Eval}(\\mathcal{C}, (\\overline{\\mathsf{ct}}_1,…,\\overline{\\mathsf{ct}}_l),{\\mathsf{pk}</em>{id}}_{id \\in T})$，其中 $T = T_1 \\cup \\cdots \\cup T_l$。然后，</p>\n<script type=\"math/tex; mode=display\">\n\\mathsf{MKHE.Dec}(\\overline{\\mathsf{ct}}; \\{\\mathsf{sk}_{id}\\}_{id \\in T} = \\mathcal{C}(\\mu_1,...,\\mu_l) \\tag{1}</script><p>以压倒性的可能性。对于近似算术[16]，可以用类似于CKKS格式的近似相等来代替(1)的相等。</p>\n<h2 id=\"环上容错学习\"><a href=\"#环上容错学习\" class=\"headerlink\" title=\"环上容错学习\"></a>环上容错学习</h2><p>在整篇文章中，作者假设 $n$ 是2的幂整数，并且 $R=\\mathbb{Z}[X]/(X^n+1)$。对于 $R$ 的模为整数 $q$ 的剩余环，本文记作 $R_q=R/(q·R)$。带参数 $(n,q,\\chi,\\psi)$ 的环学习假设是给定任意多项式数目的形式的样本 $(a_i,b_i=s \\cdot a_i+e_i) \\in R^2_q$，其中 $a_i$ 在 $R_q$ 中是一致随机的，$s$ 选自 $R_q$ 上的密钥分布 $\\chi$，$e_i$ 取自 $R$ 上的误差分布 $\\psi$，$b_i$ 是 $R_q$ 中的均匀随机元素、在计算上是不可区分的。</p>\n<h2 id=\"小工具分解\"><a href=\"#小工具分解\" class=\"headerlink\" title=\"小工具分解\"></a>小工具分解</h2><p>设 $\\mathbf{g}=(g<em>i) \\in \\mathbb{Z}^d$ 为小工具向量，$q$ 为整数。小工具分解，由 $\\mathbf{g}^{-1}$ 表示，是从 $R_q$ 到 $R^d$ 的函数，它将元素 $a \\in R_q$ 转换成<em>小</em>多项式向量 $u=(u_0,…,u</em>{d−1})\\in R^d$ ，使得 $a = \\sum^{d-1}_{i=0} g_i \\cdot u_i \\pmod{q}$。</p>\n<p>小工具分解技术被广泛应用于HE方案的构建中。例如，非线性电路的同态评估是基于密钥切换技术的，并且大多数HE方案利用各种小工具分解方法来控制噪声增长。文献中已经提出了各种分解方法，如位分解[6，7]、基分解[17，21]和基于RNS的分解[4，30]。本文的实现利用了RNS友好的分解来提高效率。</p>\n<h1 id=\"本文的构造\"><a href=\"#本文的构造\" class=\"headerlink\" title=\"本文的构造\"></a>本文的构造</h1><h2 id=\"基本方案\"><a href=\"#基本方案\" class=\"headerlink\" title=\"基本方案\"></a>基本方案</h2><ul>\n<li>$\\mathsf{Setup}(1^\\lambda)$：对于给定的安全参数 $\\lambda$，设置RLWE维数 $n$、密文模数 $q$、密钥分布 $\\chi$ 和R上的误差分布 $\\psi$。生成随机向量 $\\mathbf{a} \\leftarrow U(R^d_q)$。返回公共参数 $pp=(n, q, \\chi, \\psi, \\mathbf{a})$。</li>\n<li>$\\mathsf{KeyGen}(pp)$：选取密钥 $s \\leftarrow \\chi$。选取误差向量 $e \\leftarrow \\psi^d$，并将公钥在 $R^d_q$ 中设置为 $\\mathbf{b} = -s \\cdot \\mathbf{a} + \\mathbf{e} \\pmod{q}$。</li>\n<li>$\\mathsf{UniEnc}(\\mu;s)$：对于输入明文 $\\mu \\in R$，生成密文 $\\mathbf{D} = [\\mathbf{d}_0 | \\mathbf{d}_1 | \\mathbf{d}_2] \\in R^{d \\times 3}_q$，如下所示：<ol>\n<li>选取 $r \\leftarrow \\chi$；</li>\n<li>选取 $\\mathbf{d}_1 \\leftarrow U(R^d_q)$ 和 $\\mathbf{e}_1 \\leftarrow \\psi^d$，然后设 $\\mathbf{d}_0 = -s \\cdot \\mathbf{d}_1 + \\mathbf{e}_1 + r \\cdot \\mathbf{g} \\pmod{q}$；</li>\n<li>选取 $\\mathbf{e}_2 \\leftarrow \\psi^d$ 然后设 $\\mathbf{d}_2 = r \\cdot \\mathbf{a} + \\mathbf{e}_2 + \\mu \\cdot \\mathbf{g} \\pmod{q}$。</li>\n</ol>\n</li>\n</ul>\n<p>公共参数 $pp$ 包含一个随机生成的向量 $\\mathbf{a} \\in R^d_q$，因此本文假设使用公共引用字符串模型。各方应将相同的公共参数作为密钥生成算法的输入，以支持多密钥同态运算。在以前关于MKHE的所有工作中都做出了同样的假设。</p>\n<p>单一加密算法是对称加密，它可以加密单个环形元件。一次加密的密文 $\\mathbf{D} = [\\mathbf{d}_0 | \\mathbf{d}_1 | \\mathbf{d}_2] \\leftarrow \\mathsf{UniEnc}(\\mu;s)$ 由 $R^d_q$ 中的三个矢量组成，其大小是 $R^{2d \\times 2}_q$ 中普通RGSW密文的(3/4)倍。对于一次加密密文 $\\mathbf{D}$，前两列 $[\\mathbf{d}_0 | \\mathbf{d}_1]$ 可以被视为秘密 $s$ 下的 $r$ 的加密，而 $[\\mathbf{d}_2 | -\\mathbf{a}]$ 形成秘密 $r$ 下的 $\\mu$ 的加密。</p>\n<h2 id=\"再线性化\"><a href=\"#再线性化\" class=\"headerlink\" title=\"再线性化\"></a>再线性化</h2><p>在级联秘密 $\\overline{\\mathsf{sk}} = (1, s_1, …, s_k)$ 下加密的两个多密钥密文 $\\overline{\\mathsf{ct}}_i \\in R^{k+1}_q$ 的张量积 $\\overline{\\mathsf{ct}} = \\overline{\\mathsf{ct}}_1 \\otimes \\overline{\\mathsf{ct}}_2$ 可以看作是对应于张量平方密钥 $\\overline{\\mathsf{sk}} \\otimes \\overline{\\mathsf{sk}}$ 的密文。$\\overline{\\mathsf{sk}} \\otimes \\overline{\\mathsf{sk}}$ 包含一些与两个不同方相关的非线性项 $s_i \\cdot s_j$。因此，计算服务器应该能够通过非线性项 $s_i \\cdot s_j$ 的线性化来将扩展密文 $\\overline{\\mathsf{ct}} \\in R^{(k+1) \\times (k+1)}_q$ 转换为规范密文。</p>\n<p>本文的重新线性化方法需要由单个各方生成的相同公共材料(评估密钥)，如下所示：</p>\n<ul>\n<li>$\\mathsf{EvkGen}(s)$：给定秘密 $s \\in R$，返回 $\\mathbf{D} \\leftarrow \\mathsf{UniEnc}(s;s)$。</li>\n</ul>\n<p>准确地说，每一方 $i$ 通过运行算法(si，bi)←KeyGen(Pp)和Di←EvkGen(Si)来生成其自己的秘密密钥、公共密钥和评估密钥，然后发布该对(bi，Di)。在本节的其余部分，我们将介绍两种重新线性化算法，并说明它们的优缺点。</p>\n","site":{"data":{}},"excerpt":"<p><em>Hao Chen, Wei Dai, Miran Kim, Yongsoo Song</em></p>\n<p>CCS 2019</p>\n<p><a href=\"https://dl.acm.org/doi/10.1145/3319535.3363207\" target=\"_blank\" rel=\"noopener\">https://dl.acm.org/doi/10.1145/3319535.3363207</a></p>","more":"<h1 id=\"本文的贡献\"><a href=\"#本文的贡献\" class=\"headerlink\" title=\"本文的贡献\"></a>本文的贡献</h1><p>本文设计了BFV[6，22]和CKKS[16]方案的多密钥变体。本文提出了一种新的生成重线性化密钥的方法，与文献[13]中的以前技术相比，该方法更简单、更快。此外，本文将这些方案[9，12，14]的最新自举算法应用于多密钥场景，以构建具有压缩密文的多密钥完全同态加密。最后，作者使用Microsoft SEAL[47]给出了本文的多密钥方案的概念验证实现，并给出了实验结果。据作者所知，这是支持打包密文的MKHE方案的第一个实际实现。</p>\n<p>本文还提出了MKHE的第一个可行的应用，它安全地评估了预先训练的卷积神经网络(CNN)模型。本文构建了一个高效的协议，云服务器使用模型提供者提供的分类器为数据所有者提供在线预测服务，同时使用MKHE保护数据和模型的隐私。如图1所示，本文的方案支持多密钥操作，使得以较低的端到端延迟和接近最佳的数据和模型提供者成本来实现这一点。服务器可以存储以不同密钥加密的大量密文，但是特定任务的计算成本仅取决于与电路相关的各方的数量。作者注意到，本文的解决方案比单密钥HE更有优势，因为ML模型提供者不需要将未加密的模型发送到服务器。</p>\n<p><img src=\"http://images.yingwai.top/picgo/emkhef1.png\" alt=\"\"></p>\n<h1 id=\"BACKGROUND\"><a href=\"#BACKGROUND\" class=\"headerlink\" title=\"BACKGROUND\"></a>BACKGROUND</h1><h2 id=\"记号法\"><a href=\"#记号法\" class=\"headerlink\" title=\"记号法\"></a>记号法</h2><p>除非另有说明，否则所有对数都以 $2$ 为底。我们用粗体表示向量，例如$\\mathbf{a}$，用大写粗体表示矩阵，例如 $\\mathbf{A}$。本文用 $\\langle \\mathbf{u}, \\mathbf{v} \\rangle$ 表示两个向量 $\\mathbf{u}, \\mathbf{v}$ 的通常点积。对于实数 $r$，$\\lfloor r \\rceil$ 表示最表示最接近 $r$ 的整数，在平局的情况下向上舍入。本文用 $x \\leftarrow D$ 表示按分布 $D$ 抽样的 $x$。对于有限集 $S$，$U(S)$ 表示 $S$ 上的均匀分布。本文用 $\\lambda$ 表示安全参数：所有已知的对作用域内的密码方案的有效攻击都应该采用 $\\Omega(2^\\lambda)$ 位运算。</p>\n<h2 id=\"多密钥同态加密\"><a href=\"#多密钥同态加密\" class=\"headerlink\" title=\"多密钥同态加密\"></a>多密钥同态加密</h2><p>多密钥同态加密是一种密码系统，它允许我们对可能在不同密钥下加密的密文评估算术电路。</p>\n<p>设 $\\mathcal{M}$ 是具有算术结构的消息空间。MKHE方案MKHE由五个PPT算法($\\mathsf{Setup}, \\mathsf{KeyGen}, \\mathsf{Enc}, \\mathsf{Dec}, \\mathsf{Eval}$)组成。本文假设每个参与方都有对其公钥和私钥的引用(索引)。多密钥密文隐式包含<em>有序</em>集合 $T = {id<em>1, …, id_k}$ 相关联的引用。例如，新的密文 $\\mathsf{ct} \\leftarrow \\mathsf{MKHE.Enc}(\\mu; \\mathsf{pk}</em>{id})$ 对应于单个元素集合 $T = {id}$，但是随着来自不同方的密文之间的计算的进行，参考集合的大小变得更大。</p>\n<ul>\n<li><p><strong>初始化</strong>：$pp \\leftarrow \\mathsf{MKHE.Setup}(1^\\lambda)$。将安全参数作为输入并返回公共参数化。本文假设所有其他算法都隐含地将 $pp$ 作为输入。</p>\n</li>\n<li><p><strong>密钥生成</strong>：$(\\mathsf{sk}, \\mathsf{pk}) \\leftarrow \\mathsf{MKHE.KeyGen}(pp)$。输出一对私钥和公钥。</p>\n</li>\n<li><p><strong>加密</strong>：$\\mathsf{ct} \\leftarrow \\mathsf{MKHE.Enc}(\\mu; \\mathsf{pk})$。加密明文 $\\mu \\in \\mathcal{M}$ 并输出密文 $\\mathsf{ct} \\in {0,1 }^*$。</p>\n</li>\n<li><p><strong>解密</strong>：$\\mu \\leftarrow \\mathsf{MKHE.Dec}(\\overline{\\mathsf{ct}}; {\\mathsf{sk}<em>{id}}</em>{id \\in T})$。给定具有对应密钥序列的密文 $\\overline{\\mathsf{ct}}$，输出明文 $\\mu$。</p>\n</li>\n<li><p><strong>同态评估</strong>：</p>\n<script type=\"math/tex; mode=display\">\n\\overline{\\mathsf{ct}} \\leftarrow \\mathsf{MKHE.Eval}(\\mathcal{C}, (\\overline{\\mathsf{ct}}_1,...,\\overline{\\mathsf{ct}}_l),\\{\\mathsf{pk}_{id}\\}_{id \\in T})</script><p>给定电路 $\\mathcal{C}$，多密钥密文的元组 $(\\overline{\\mathsf{ct}}<em>1,…,\\overline{\\mathsf{ct}}_l)$ 和对应的一组公钥 ${\\mathsf{pk}</em>{id}}_{id \\in T}$，输出密文 $\\overline{\\mathsf{ct}}$。它的参考集是输入密文 $\\overline{\\mathsf{ct}}_j, 1 \\leq j \\leq l$ 的联合 $T = T_1 \\cup \\cdots \\cup T_l$。</p>\n</li>\n</ul>\n<p><strong>语义安全。</strong>对于任意两条消息 $\\mu_0, \\mu_1 \\in \\mathcal{M}, \\ \\ i = 0, 1$ 的分布 ${\\mathsf{MKHE.Enc}(\\mu_i; \\mathsf{pk}) }$ 在 $pp \\leftarrow \\mathsf{MKHE.Setup}(1^\\lambda)$ 和 $(\\mathsf{sk}, \\mathsf{pk}) \\leftarrow \\mathsf{MKHE.KeyGen}(pp)$ 的计算上应该是不可区分的。</p>\n<p><strong>正确性和紧凑性。</strong>如果与 $k$ 方相关的密文的大小受固定多项式 ${\\rm poly}(\\cdot, \\cdot)$ 的 ${\\rm poly}(\\lambda, k)$ 的限制，则MKHE方案是紧致的。</p>\n<p>对于 $1 \\leq j \\leq l$，设 $\\overline{\\mathsf{ct}}<em>j$ 为密文(参考集合 $T_j$)，使得 $\\mathsf{MKHE.Dec}(\\overline{\\mathsf{ct}}_j; {\\mathsf{sk}</em>{id}}<em>{id \\in T} = \\mu_j$。设 $\\mathcal{C} : \\mathcal{M}^l \\rightarrow \\mathcal{M}$ 为电路，$\\overline{\\mathsf{ct}} \\leftarrow \\mathsf{MKHE.Eval}(\\mathcal{C}, (\\overline{\\mathsf{ct}}_1,…,\\overline{\\mathsf{ct}}_l),{\\mathsf{pk}</em>{id}}_{id \\in T})$，其中 $T = T_1 \\cup \\cdots \\cup T_l$。然后，</p>\n<script type=\"math/tex; mode=display\">\n\\mathsf{MKHE.Dec}(\\overline{\\mathsf{ct}}; \\{\\mathsf{sk}_{id}\\}_{id \\in T} = \\mathcal{C}(\\mu_1,...,\\mu_l) \\tag{1}</script><p>以压倒性的可能性。对于近似算术[16]，可以用类似于CKKS格式的近似相等来代替(1)的相等。</p>\n<h2 id=\"环上容错学习\"><a href=\"#环上容错学习\" class=\"headerlink\" title=\"环上容错学习\"></a>环上容错学习</h2><p>在整篇文章中，作者假设 $n$ 是2的幂整数，并且 $R=\\mathbb{Z}[X]/(X^n+1)$。对于 $R$ 的模为整数 $q$ 的剩余环，本文记作 $R_q=R/(q·R)$。带参数 $(n,q,\\chi,\\psi)$ 的环学习假设是给定任意多项式数目的形式的样本 $(a_i,b_i=s \\cdot a_i+e_i) \\in R^2_q$，其中 $a_i$ 在 $R_q$ 中是一致随机的，$s$ 选自 $R_q$ 上的密钥分布 $\\chi$，$e_i$ 取自 $R$ 上的误差分布 $\\psi$，$b_i$ 是 $R_q$ 中的均匀随机元素、在计算上是不可区分的。</p>\n<h2 id=\"小工具分解\"><a href=\"#小工具分解\" class=\"headerlink\" title=\"小工具分解\"></a>小工具分解</h2><p>设 $\\mathbf{g}=(g<em>i) \\in \\mathbb{Z}^d$ 为小工具向量，$q$ 为整数。小工具分解，由 $\\mathbf{g}^{-1}$ 表示，是从 $R_q$ 到 $R^d$ 的函数，它将元素 $a \\in R_q$ 转换成<em>小</em>多项式向量 $u=(u_0,…,u</em>{d−1})\\in R^d$ ，使得 $a = \\sum^{d-1}_{i=0} g_i \\cdot u_i \\pmod{q}$。</p>\n<p>小工具分解技术被广泛应用于HE方案的构建中。例如，非线性电路的同态评估是基于密钥切换技术的，并且大多数HE方案利用各种小工具分解方法来控制噪声增长。文献中已经提出了各种分解方法，如位分解[6，7]、基分解[17，21]和基于RNS的分解[4，30]。本文的实现利用了RNS友好的分解来提高效率。</p>\n<h1 id=\"本文的构造\"><a href=\"#本文的构造\" class=\"headerlink\" title=\"本文的构造\"></a>本文的构造</h1><h2 id=\"基本方案\"><a href=\"#基本方案\" class=\"headerlink\" title=\"基本方案\"></a>基本方案</h2><ul>\n<li>$\\mathsf{Setup}(1^\\lambda)$：对于给定的安全参数 $\\lambda$，设置RLWE维数 $n$、密文模数 $q$、密钥分布 $\\chi$ 和R上的误差分布 $\\psi$。生成随机向量 $\\mathbf{a} \\leftarrow U(R^d_q)$。返回公共参数 $pp=(n, q, \\chi, \\psi, \\mathbf{a})$。</li>\n<li>$\\mathsf{KeyGen}(pp)$：选取密钥 $s \\leftarrow \\chi$。选取误差向量 $e \\leftarrow \\psi^d$，并将公钥在 $R^d_q$ 中设置为 $\\mathbf{b} = -s \\cdot \\mathbf{a} + \\mathbf{e} \\pmod{q}$。</li>\n<li>$\\mathsf{UniEnc}(\\mu;s)$：对于输入明文 $\\mu \\in R$，生成密文 $\\mathbf{D} = [\\mathbf{d}_0 | \\mathbf{d}_1 | \\mathbf{d}_2] \\in R^{d \\times 3}_q$，如下所示：<ol>\n<li>选取 $r \\leftarrow \\chi$；</li>\n<li>选取 $\\mathbf{d}_1 \\leftarrow U(R^d_q)$ 和 $\\mathbf{e}_1 \\leftarrow \\psi^d$，然后设 $\\mathbf{d}_0 = -s \\cdot \\mathbf{d}_1 + \\mathbf{e}_1 + r \\cdot \\mathbf{g} \\pmod{q}$；</li>\n<li>选取 $\\mathbf{e}_2 \\leftarrow \\psi^d$ 然后设 $\\mathbf{d}_2 = r \\cdot \\mathbf{a} + \\mathbf{e}_2 + \\mu \\cdot \\mathbf{g} \\pmod{q}$。</li>\n</ol>\n</li>\n</ul>\n<p>公共参数 $pp$ 包含一个随机生成的向量 $\\mathbf{a} \\in R^d_q$，因此本文假设使用公共引用字符串模型。各方应将相同的公共参数作为密钥生成算法的输入，以支持多密钥同态运算。在以前关于MKHE的所有工作中都做出了同样的假设。</p>\n<p>单一加密算法是对称加密，它可以加密单个环形元件。一次加密的密文 $\\mathbf{D} = [\\mathbf{d}_0 | \\mathbf{d}_1 | \\mathbf{d}_2] \\leftarrow \\mathsf{UniEnc}(\\mu;s)$ 由 $R^d_q$ 中的三个矢量组成，其大小是 $R^{2d \\times 2}_q$ 中普通RGSW密文的(3/4)倍。对于一次加密密文 $\\mathbf{D}$，前两列 $[\\mathbf{d}_0 | \\mathbf{d}_1]$ 可以被视为秘密 $s$ 下的 $r$ 的加密，而 $[\\mathbf{d}_2 | -\\mathbf{a}]$ 形成秘密 $r$ 下的 $\\mu$ 的加密。</p>\n<h2 id=\"再线性化\"><a href=\"#再线性化\" class=\"headerlink\" title=\"再线性化\"></a>再线性化</h2><p>在级联秘密 $\\overline{\\mathsf{sk}} = (1, s_1, …, s_k)$ 下加密的两个多密钥密文 $\\overline{\\mathsf{ct}}_i \\in R^{k+1}_q$ 的张量积 $\\overline{\\mathsf{ct}} = \\overline{\\mathsf{ct}}_1 \\otimes \\overline{\\mathsf{ct}}_2$ 可以看作是对应于张量平方密钥 $\\overline{\\mathsf{sk}} \\otimes \\overline{\\mathsf{sk}}$ 的密文。$\\overline{\\mathsf{sk}} \\otimes \\overline{\\mathsf{sk}}$ 包含一些与两个不同方相关的非线性项 $s_i \\cdot s_j$。因此，计算服务器应该能够通过非线性项 $s_i \\cdot s_j$ 的线性化来将扩展密文 $\\overline{\\mathsf{ct}} \\in R^{(k+1) \\times (k+1)}_q$ 转换为规范密文。</p>\n<p>本文的重新线性化方法需要由单个各方生成的相同公共材料(评估密钥)，如下所示：</p>\n<ul>\n<li>$\\mathsf{EvkGen}(s)$：给定秘密 $s \\in R$，返回 $\\mathbf{D} \\leftarrow \\mathsf{UniEnc}(s;s)$。</li>\n</ul>\n<p>准确地说，每一方 $i$ 通过运行算法(si，bi)←KeyGen(Pp)和Di←EvkGen(Si)来生成其自己的秘密密钥、公共密钥和评估密钥，然后发布该对(bi，Di)。在本节的其余部分，我们将介绍两种重新线性化算法，并说明它们的优缺点。</p>"},{"title":"论文笔记 Improved Garbled Circuit: Free XOR Gates and Applications","date":"2020-06-16T03:07:59.000Z","_content":"\n*Vladimir Kolesnikov, Thomas Schneider*\n\n [ICALP (2) 2008](https://dblp.uni-trier.de/db/conf/icalp/icalp2008-2.html#KolesnikovS08)\n\nhttps://dl.acm.org/doi/10.1007/978-3-540-70583-3_40\n\n<!--more-->\n\n# 摘要\n\n本文提出了一种新的用于两方安全函数评估(SFE)的乱码电路结构。在本文的单轮协议中，XOR门的评估是“免费的”，这导致了对最佳乱码电路实现的相应改进(例如Fairplay)。\n\n本文几乎完全使用XOR门来构建置换网络和通用电路(UC)；这使得它们的SFE(在计算和通信方面)提高了多达4倍。本文还改进了整数加法和等价性测试，最高可达2倍。\n\n本文依赖随机预言(RO)假设。本文的构造在半诚实模型中被证明是安全的。\n\n\n\n## 本文的贡献\n\n* 在半诚实模型下，本文提出了一种新的用于两方安全函数评估(SFE)的乱码电路结构。\n* 在本文的一轮协议中，XOR门的计算是“免费的”(也就是说，不使用相关的乱码表和相应的散列或对称密钥操作)。在处理其他门时，本文的构造与最好的乱码电路实现(例如Fairplay)一样有效。\n\n\n\n\n\n# Setting and Preliminaries\n\n两方通用安全函数评估(SFE)允许双方评估其各自输入 $x$ 和 $y$ 上的任何函数，同时保持 $x$ 和 $y$ 的隐私。\n\n本文考虑具有 $k$ 个门和任意扇出的非循环布尔电路。也就是说，每个门的(单个)输出可以用作任意数量的门的输入。本文假设电路的门 $G_1,...,G_k$ 按拓扑排序。该顺序(不一定是唯一的)确保第 $i$ 个门 $G_i$ 不具有作为连续门 $G_j,\\ j>i$ 的输出的输入。总是可以通过 $O(k)$ 计算在非循环电路上获得拓扑顺序。\n\n本文专注于半诚实的模式，在这种模式下，参与者遵循协议，但试图从执行记录中学习信息。\n\n本文使用以下标准符号：$\\in_R$ 表示均匀随机采样，$\\|$ 表示位串的连接。$\\langle a, b \\rangle$ 是一个包括了 $a,b$ 两个元素的向量，且其比特串表示为 $a \\| b$。$W_c = g(W_a, W_b)$ 表示2输入门 $G$，其用输入线 $W_a,W_b$ 和输出线 $W_c$ 计算函数 $g: \\{0,1\\}^2 \\rightarrow \\{0,1 \\}$。\n\n设 $N$ 为安全参数。设 $S$ 是无限集，设 $X=\\{X_s\\}_{s \\in S}$ 和 $Y=\\{Y_s\\}_{s \\in S}$ 为分布全体。我们说 $X$ 和 $Y$ 在计算上是不可区分的，记为 $X \\overset{c}{\\equiv} Y$，如果对每个非均匀多项式时间微分器 $D$ 和所有足够大的 $s \\in S, \\ |Pr[D(X_s)=1]−Pr[D(Y_s)=1]|<1/p(|s|) $ 对每个多项式 $p$。\n\n**随机预言。**RO模型是一个有用的抽象。RO只是一个随机选择的函数 $\\{0,1\\}^* \\mapsto \\{0,1\\}^N$ -一个不能被多项式参与者完全存储或遍历的大对象。RO模型为所有参与者提供了Oracle访问此类功能的权限。实际上，RO由散列函数(如SHA)建模。\n\n**不经意传输(OT)。**2选1OT是两方协议。*发送方* $P_1$ 具有两个秘密 $m_0,m_1$，*接收方* $P_2$ 具有选择位 $i \\in \\{0,1\\}$。在协议的最后，$P_2$ 得到 $m_i$，但没有获得关于 $m_{i-1}$ 的任何信息，$P_1$ 没有获得关于 $i$ 的任何信息。\n\n**姚氏乱码电路(GC)。**参与者 $P_1$ 首先扰乱电路 $C$：对于每条线 $W_i$ 的值 $j$，他随机选择两个秘密 $w^0_i$ 和 $w^1_i$，其中 $w^j_i$ 是一个乱值，或者说是乱码。(注：$w^j_i$ 不透露 $j$。)。此外对于每个门 $G_i$，$P_1$ 创建具有以下属性的乱码表 $T_i$ 并将其发送到 $P_2$：给定一组 $G_i$ 的输入乱码，$T_i$ 允许恢复相应 $G_i$ 的输出的乱码，而不透露其他信息。然后参与方输入的乱码被(不经意地)传输到 $P_2$。现在 $P_2$ 可以使用表格 $T_i$ 通过逐个门地评估乱码电路来简单地获得乱码输出。如果在给定输入上对 $C$ 求值时，$W_i$ 取值 $j$，则称 $W_i$ 的乱码 $w^j_i$ *有效*。观察到，对于每根导线，$P_2$ 只能获得其有效乱码。电路的输出线没有乱码(或其乱码被公布)，因此 $P_2$ (仅)获知电路的输出，而不学习内部线路值。$P_1$ 从(半诚实的) $P_2$ 学习输出。(这一步在半诚实模型中是微不足道的，通常不会在分析中考虑。)。GC的正确性源于表 $T_i$ 的构建方法。任何一方都不会从协议执行中获知任何附加信息。\n\n\n\n# 本文的协议\n\n首先，本文展示了XOR门 $G$ 的SFE实现，它源自[14]中的一个。设 $G$ 有两根输入线 $W_a, W_b$，输出线 $W_c$。按如下方式对导线值进行乱码处理：随机选择 $w^0_a, w^0_b, R \\in_R \\{0,1\\}^N$。设 $w^0_c = w^0_a \\oplus w^0_b$ 和 $\\forall i \\in \\{a,b,c\\}: w^1_i = w^0_i \\oplus R$。很容易看出，乱码门输出只需对乱码门输入进行异或运算即可获得：\n$$\n\\begin{align}\nw^0_c &= w^0_a \\oplus w^0_b = (w^0_a \\oplus R) \\oplus (w^0_b \\oplus R) = w^1_a \\oplus w^1_b \\\\\nw^1_c &= w^0_c \\oplus R = w^0_a \\oplus (w^0_b \\oplus R) = w^0_a \\oplus w^1_b = (w^0_a \\oplus R) \\oplus w^0_b = w^1_a \\oplus w^0_b\n\\end{align}\n$$\n且乱码 $w^j_i$ 不会透露它们对应的线路值。\n\n上述异或结构对乱码值施加的限制：电路中每根导线的两个值的乱码必须相差相同的值，即对于某个全局 $R$，$\\forall i: w^1_i = w^0_i \\oplus R$。相比之下，在以前的GC结构中，所有乱码 $w^j_i$ 是独立随机选择的，并且安全性证明依赖于该性质。\n\n\n\n## 本文的乱码电路构造\n\n设 $C$ 是一个电路。首先注意到，NOT门可以通过简单地消除它们并颠倒导线的值和乱码的对应关系来“免费”实现。\n\n在下面的Alg.1中，每个乱码 $w= \\langle k, p \\rangle$ 由密钥 $k \\in \\{0,1\\}^N$ 和排列位 $p \\in \\{0,1\\}$ 组成。密钥用于表条目的解密，$p$ 用于选择要解密的条目。每条导线的两个乱码 $w^0_i, w^1_i$ 按照异或构造的要求相关：对于选定的 $R\\in_R \\{0,1\\}^N$，$\\forall i: w^1_i = \\langle k^1_i, p^1_i \\rangle = \\langle k^0_i \\oplus R, p^0_i \\oplus 1 \\rangle$，其中 $w^0_i = \\langle k^0_i, p^0_i \\rangle$。$H: \\{0,1\\}^* \\mapsto \\{0,1\\}^{N+1}$ 是一个RO。\n\n现在我们将上述想法形式化，并给出GC结构(Alg.1)和评估(Alg.2)。在SFE中，Alg.1由 $P_1$ 执行，Alg.2由 $P_2$ 执行。\n\n![](http://images.yingwai.top/picgo/freeXORa1.png)\n\n注意，本文的表项加密(步骤3(C)iii)类似于Fairplay。Fairplay使用 $e_{v_a,v_b} = H(k^{v_a}_a \\| i \\| p^{v_a}_a \\| p^{v_b}_b) \\oplus$ $H(k^{v_b}_b \\| i \\| p^{v_a}_a \\| p^{v_b}_b) \\oplus$ $w^{g_i(v_a, v_b)}_c$。这是一个不重要的区别；我们可以使用Fairplay的加密。\n\n**安全方面的直觉。**Alg.1使用RO $H$ 的输出作为一次性垫来加密乱码表中的乱码输出值(步骤3(C)III)和乱码输出表(步骤4a)。注意，在本文的整个构造过程中，$H$ 的输入(密钥和门索引)的任何特定组合都用于加密至多一个表项。(本文假设 $H$ 中的串联和字符串表示是“正确的”。)。此外，由于被篡改电路的评估者每条线路只知道一个被篡改的值，所以他可以精确地解密 $G_i$ 的乱码表中的一个条目。所有其他条目都使用多次赋值器无法猜到的至少一个密钥进行加密。因此，在他看来，每根电线的两个乱值中的一个看起来是随机的。\n\n现在给出相应的GC评估算法，由 $P_2$ 运行。回想一下，$P_2$ 会从 $P_1$ 获取所有乱码表格和 $P_1$ 输入值的乱码。由 $P_2$ 保存的输入值的乱码通过OT发送。\n\n![](http://images.yingwai.top/picgo/freeXORa2.png)\n\nGC构造和评估算法可以直接用于以标准方式获得基于GC的SFE协议。为完整起见，本文包含了对此协议的描述。\n\n----\n\n**Protocol 1.** *(Two-party SFE protocol):*\n\n- **Inputs:**  $P_1$ has private input $x = \\langle x_1,..,x_{u_1} \\rangle \\in \\{0,1\\}^{u_1}$and $P_2$ has private input $y = \\langle y_1,..,y_{u_2} \\rangle \\in \\{0,1\\}^{u_2}$.\n\n- **Auxiliary input:**  A boolean acyclic circuit $C$ such that $\\forall x \\in \\{0,1\\}^{u_1}, y \\in \\{0,1\\}^{u_2}$, it holds that $C(x,y) = f(x,y)$, where $f: \\{0,1\\}^{u_1} \\times \\{0,1\\}^{u_2} \\rightarrow \\{0,1\\}^v$. We require that $C$ is such that if a circuit-output wire leaves some gate $G$, then gate $G$ has no other wires leading from it into other gates (i.e., no circuit-output wire is also a gate-input wire). Likewise, a circuit-input wire that is also a circuit-output wire enters no gates. We also require that $C$ is modified to contain no NOT-gates and all n-input XOR-gates with $n > 2$ replaced by 2-input XOR-gates as described in Section 3.1.\n\n- **The protocol:**\n\n  1. $P_1$ constructs the garbled circuit using Algorithm 1 and sends it (i.e. the garbled tables) to $P_2$.\n\n  2. Let $W_1,.., W_{u_1}$ be the circuit input wires corresponding to $x$, and let $W_{u_1+1},..,W_{u_1+u_2}$ be the circuit input wires corresponding to $y$. Then, \n\n     ​\t(a) $P_1$ sends $P_2$ the garbled values $w^{x_1}_1,..,w^{x_{u_1}}_{u_1}$.\n\n     ​\t(b) For every $i \\in \\{1, .., u_2\\}$, $P_1$ and $P_2$ execute a 1-out-of-2 oblivious transfer protocol, where $P_1$’s input is $(k^0_{u_1+i}, k^1_{u_1+i})$, and $P_2$’s input is $y_i$. All $u_2$ OT instances can be run in parallel.\n\n  3. $P_2$ now has the garbled tables and the garblings of circuit’s input wires. $P_2$ evaluates the garbled circuit, as described in Alg. 2, and outputs $f(x, y)$.\n\n----\n\n","source":"_posts/论文笔记-Improved-Garbled-Circuit-Free-XOR-Gates-and-Applications.md","raw":"---\ntitle: '论文笔记 Improved Garbled Circuit: Free XOR Gates and Applications'\ndate: 2020-06-16 11:07:59\ncategories: Papers\ntags: [MPC, 密码学, Garbled Circuit]\n---\n\n*Vladimir Kolesnikov, Thomas Schneider*\n\n [ICALP (2) 2008](https://dblp.uni-trier.de/db/conf/icalp/icalp2008-2.html#KolesnikovS08)\n\nhttps://dl.acm.org/doi/10.1007/978-3-540-70583-3_40\n\n<!--more-->\n\n# 摘要\n\n本文提出了一种新的用于两方安全函数评估(SFE)的乱码电路结构。在本文的单轮协议中，XOR门的评估是“免费的”，这导致了对最佳乱码电路实现的相应改进(例如Fairplay)。\n\n本文几乎完全使用XOR门来构建置换网络和通用电路(UC)；这使得它们的SFE(在计算和通信方面)提高了多达4倍。本文还改进了整数加法和等价性测试，最高可达2倍。\n\n本文依赖随机预言(RO)假设。本文的构造在半诚实模型中被证明是安全的。\n\n\n\n## 本文的贡献\n\n* 在半诚实模型下，本文提出了一种新的用于两方安全函数评估(SFE)的乱码电路结构。\n* 在本文的一轮协议中，XOR门的计算是“免费的”(也就是说，不使用相关的乱码表和相应的散列或对称密钥操作)。在处理其他门时，本文的构造与最好的乱码电路实现(例如Fairplay)一样有效。\n\n\n\n\n\n# Setting and Preliminaries\n\n两方通用安全函数评估(SFE)允许双方评估其各自输入 $x$ 和 $y$ 上的任何函数，同时保持 $x$ 和 $y$ 的隐私。\n\n本文考虑具有 $k$ 个门和任意扇出的非循环布尔电路。也就是说，每个门的(单个)输出可以用作任意数量的门的输入。本文假设电路的门 $G_1,...,G_k$ 按拓扑排序。该顺序(不一定是唯一的)确保第 $i$ 个门 $G_i$ 不具有作为连续门 $G_j,\\ j>i$ 的输出的输入。总是可以通过 $O(k)$ 计算在非循环电路上获得拓扑顺序。\n\n本文专注于半诚实的模式，在这种模式下，参与者遵循协议，但试图从执行记录中学习信息。\n\n本文使用以下标准符号：$\\in_R$ 表示均匀随机采样，$\\|$ 表示位串的连接。$\\langle a, b \\rangle$ 是一个包括了 $a,b$ 两个元素的向量，且其比特串表示为 $a \\| b$。$W_c = g(W_a, W_b)$ 表示2输入门 $G$，其用输入线 $W_a,W_b$ 和输出线 $W_c$ 计算函数 $g: \\{0,1\\}^2 \\rightarrow \\{0,1 \\}$。\n\n设 $N$ 为安全参数。设 $S$ 是无限集，设 $X=\\{X_s\\}_{s \\in S}$ 和 $Y=\\{Y_s\\}_{s \\in S}$ 为分布全体。我们说 $X$ 和 $Y$ 在计算上是不可区分的，记为 $X \\overset{c}{\\equiv} Y$，如果对每个非均匀多项式时间微分器 $D$ 和所有足够大的 $s \\in S, \\ |Pr[D(X_s)=1]−Pr[D(Y_s)=1]|<1/p(|s|) $ 对每个多项式 $p$。\n\n**随机预言。**RO模型是一个有用的抽象。RO只是一个随机选择的函数 $\\{0,1\\}^* \\mapsto \\{0,1\\}^N$ -一个不能被多项式参与者完全存储或遍历的大对象。RO模型为所有参与者提供了Oracle访问此类功能的权限。实际上，RO由散列函数(如SHA)建模。\n\n**不经意传输(OT)。**2选1OT是两方协议。*发送方* $P_1$ 具有两个秘密 $m_0,m_1$，*接收方* $P_2$ 具有选择位 $i \\in \\{0,1\\}$。在协议的最后，$P_2$ 得到 $m_i$，但没有获得关于 $m_{i-1}$ 的任何信息，$P_1$ 没有获得关于 $i$ 的任何信息。\n\n**姚氏乱码电路(GC)。**参与者 $P_1$ 首先扰乱电路 $C$：对于每条线 $W_i$ 的值 $j$，他随机选择两个秘密 $w^0_i$ 和 $w^1_i$，其中 $w^j_i$ 是一个乱值，或者说是乱码。(注：$w^j_i$ 不透露 $j$。)。此外对于每个门 $G_i$，$P_1$ 创建具有以下属性的乱码表 $T_i$ 并将其发送到 $P_2$：给定一组 $G_i$ 的输入乱码，$T_i$ 允许恢复相应 $G_i$ 的输出的乱码，而不透露其他信息。然后参与方输入的乱码被(不经意地)传输到 $P_2$。现在 $P_2$ 可以使用表格 $T_i$ 通过逐个门地评估乱码电路来简单地获得乱码输出。如果在给定输入上对 $C$ 求值时，$W_i$ 取值 $j$，则称 $W_i$ 的乱码 $w^j_i$ *有效*。观察到，对于每根导线，$P_2$ 只能获得其有效乱码。电路的输出线没有乱码(或其乱码被公布)，因此 $P_2$ (仅)获知电路的输出，而不学习内部线路值。$P_1$ 从(半诚实的) $P_2$ 学习输出。(这一步在半诚实模型中是微不足道的，通常不会在分析中考虑。)。GC的正确性源于表 $T_i$ 的构建方法。任何一方都不会从协议执行中获知任何附加信息。\n\n\n\n# 本文的协议\n\n首先，本文展示了XOR门 $G$ 的SFE实现，它源自[14]中的一个。设 $G$ 有两根输入线 $W_a, W_b$，输出线 $W_c$。按如下方式对导线值进行乱码处理：随机选择 $w^0_a, w^0_b, R \\in_R \\{0,1\\}^N$。设 $w^0_c = w^0_a \\oplus w^0_b$ 和 $\\forall i \\in \\{a,b,c\\}: w^1_i = w^0_i \\oplus R$。很容易看出，乱码门输出只需对乱码门输入进行异或运算即可获得：\n$$\n\\begin{align}\nw^0_c &= w^0_a \\oplus w^0_b = (w^0_a \\oplus R) \\oplus (w^0_b \\oplus R) = w^1_a \\oplus w^1_b \\\\\nw^1_c &= w^0_c \\oplus R = w^0_a \\oplus (w^0_b \\oplus R) = w^0_a \\oplus w^1_b = (w^0_a \\oplus R) \\oplus w^0_b = w^1_a \\oplus w^0_b\n\\end{align}\n$$\n且乱码 $w^j_i$ 不会透露它们对应的线路值。\n\n上述异或结构对乱码值施加的限制：电路中每根导线的两个值的乱码必须相差相同的值，即对于某个全局 $R$，$\\forall i: w^1_i = w^0_i \\oplus R$。相比之下，在以前的GC结构中，所有乱码 $w^j_i$ 是独立随机选择的，并且安全性证明依赖于该性质。\n\n\n\n## 本文的乱码电路构造\n\n设 $C$ 是一个电路。首先注意到，NOT门可以通过简单地消除它们并颠倒导线的值和乱码的对应关系来“免费”实现。\n\n在下面的Alg.1中，每个乱码 $w= \\langle k, p \\rangle$ 由密钥 $k \\in \\{0,1\\}^N$ 和排列位 $p \\in \\{0,1\\}$ 组成。密钥用于表条目的解密，$p$ 用于选择要解密的条目。每条导线的两个乱码 $w^0_i, w^1_i$ 按照异或构造的要求相关：对于选定的 $R\\in_R \\{0,1\\}^N$，$\\forall i: w^1_i = \\langle k^1_i, p^1_i \\rangle = \\langle k^0_i \\oplus R, p^0_i \\oplus 1 \\rangle$，其中 $w^0_i = \\langle k^0_i, p^0_i \\rangle$。$H: \\{0,1\\}^* \\mapsto \\{0,1\\}^{N+1}$ 是一个RO。\n\n现在我们将上述想法形式化，并给出GC结构(Alg.1)和评估(Alg.2)。在SFE中，Alg.1由 $P_1$ 执行，Alg.2由 $P_2$ 执行。\n\n![](http://images.yingwai.top/picgo/freeXORa1.png)\n\n注意，本文的表项加密(步骤3(C)iii)类似于Fairplay。Fairplay使用 $e_{v_a,v_b} = H(k^{v_a}_a \\| i \\| p^{v_a}_a \\| p^{v_b}_b) \\oplus$ $H(k^{v_b}_b \\| i \\| p^{v_a}_a \\| p^{v_b}_b) \\oplus$ $w^{g_i(v_a, v_b)}_c$。这是一个不重要的区别；我们可以使用Fairplay的加密。\n\n**安全方面的直觉。**Alg.1使用RO $H$ 的输出作为一次性垫来加密乱码表中的乱码输出值(步骤3(C)III)和乱码输出表(步骤4a)。注意，在本文的整个构造过程中，$H$ 的输入(密钥和门索引)的任何特定组合都用于加密至多一个表项。(本文假设 $H$ 中的串联和字符串表示是“正确的”。)。此外，由于被篡改电路的评估者每条线路只知道一个被篡改的值，所以他可以精确地解密 $G_i$ 的乱码表中的一个条目。所有其他条目都使用多次赋值器无法猜到的至少一个密钥进行加密。因此，在他看来，每根电线的两个乱值中的一个看起来是随机的。\n\n现在给出相应的GC评估算法，由 $P_2$ 运行。回想一下，$P_2$ 会从 $P_1$ 获取所有乱码表格和 $P_1$ 输入值的乱码。由 $P_2$ 保存的输入值的乱码通过OT发送。\n\n![](http://images.yingwai.top/picgo/freeXORa2.png)\n\nGC构造和评估算法可以直接用于以标准方式获得基于GC的SFE协议。为完整起见，本文包含了对此协议的描述。\n\n----\n\n**Protocol 1.** *(Two-party SFE protocol):*\n\n- **Inputs:**  $P_1$ has private input $x = \\langle x_1,..,x_{u_1} \\rangle \\in \\{0,1\\}^{u_1}$and $P_2$ has private input $y = \\langle y_1,..,y_{u_2} \\rangle \\in \\{0,1\\}^{u_2}$.\n\n- **Auxiliary input:**  A boolean acyclic circuit $C$ such that $\\forall x \\in \\{0,1\\}^{u_1}, y \\in \\{0,1\\}^{u_2}$, it holds that $C(x,y) = f(x,y)$, where $f: \\{0,1\\}^{u_1} \\times \\{0,1\\}^{u_2} \\rightarrow \\{0,1\\}^v$. We require that $C$ is such that if a circuit-output wire leaves some gate $G$, then gate $G$ has no other wires leading from it into other gates (i.e., no circuit-output wire is also a gate-input wire). Likewise, a circuit-input wire that is also a circuit-output wire enters no gates. We also require that $C$ is modified to contain no NOT-gates and all n-input XOR-gates with $n > 2$ replaced by 2-input XOR-gates as described in Section 3.1.\n\n- **The protocol:**\n\n  1. $P_1$ constructs the garbled circuit using Algorithm 1 and sends it (i.e. the garbled tables) to $P_2$.\n\n  2. Let $W_1,.., W_{u_1}$ be the circuit input wires corresponding to $x$, and let $W_{u_1+1},..,W_{u_1+u_2}$ be the circuit input wires corresponding to $y$. Then, \n\n     ​\t(a) $P_1$ sends $P_2$ the garbled values $w^{x_1}_1,..,w^{x_{u_1}}_{u_1}$.\n\n     ​\t(b) For every $i \\in \\{1, .., u_2\\}$, $P_1$ and $P_2$ execute a 1-out-of-2 oblivious transfer protocol, where $P_1$’s input is $(k^0_{u_1+i}, k^1_{u_1+i})$, and $P_2$’s input is $y_i$. All $u_2$ OT instances can be run in parallel.\n\n  3. $P_2$ now has the garbled tables and the garblings of circuit’s input wires. $P_2$ evaluates the garbled circuit, as described in Alg. 2, and outputs $f(x, y)$.\n\n----\n\n","slug":"论文笔记-Improved-Garbled-Circuit-Free-XOR-Gates-and-Applications","published":1,"updated":"2020-08-23T14:33:37.436Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cke79q4tm004b88ps1yag47sr","content":"<p><em>Vladimir Kolesnikov, Thomas Schneider</em></p>\n<p> <a href=\"https://dblp.uni-trier.de/db/conf/icalp/icalp2008-2.html#KolesnikovS08\" target=\"_blank\" rel=\"noopener\">ICALP (2) 2008</a></p>\n<p><a href=\"https://dl.acm.org/doi/10.1007/978-3-540-70583-3_40\" target=\"_blank\" rel=\"noopener\">https://dl.acm.org/doi/10.1007/978-3-540-70583-3_40</a></p>\n<a id=\"more\"></a>\n<h1 id=\"摘要\"><a href=\"#摘要\" class=\"headerlink\" title=\"摘要\"></a>摘要</h1><p>本文提出了一种新的用于两方安全函数评估(SFE)的乱码电路结构。在本文的单轮协议中，XOR门的评估是“免费的”，这导致了对最佳乱码电路实现的相应改进(例如Fairplay)。</p>\n<p>本文几乎完全使用XOR门来构建置换网络和通用电路(UC)；这使得它们的SFE(在计算和通信方面)提高了多达4倍。本文还改进了整数加法和等价性测试，最高可达2倍。</p>\n<p>本文依赖随机预言(RO)假设。本文的构造在半诚实模型中被证明是安全的。</p>\n<h2 id=\"本文的贡献\"><a href=\"#本文的贡献\" class=\"headerlink\" title=\"本文的贡献\"></a>本文的贡献</h2><ul>\n<li>在半诚实模型下，本文提出了一种新的用于两方安全函数评估(SFE)的乱码电路结构。</li>\n<li>在本文的一轮协议中，XOR门的计算是“免费的”(也就是说，不使用相关的乱码表和相应的散列或对称密钥操作)。在处理其他门时，本文的构造与最好的乱码电路实现(例如Fairplay)一样有效。</li>\n</ul>\n<h1 id=\"Setting-and-Preliminaries\"><a href=\"#Setting-and-Preliminaries\" class=\"headerlink\" title=\"Setting and Preliminaries\"></a>Setting and Preliminaries</h1><p>两方通用安全函数评估(SFE)允许双方评估其各自输入 $x$ 和 $y$ 上的任何函数，同时保持 $x$ 和 $y$ 的隐私。</p>\n<p>本文考虑具有 $k$ 个门和任意扇出的非循环布尔电路。也就是说，每个门的(单个)输出可以用作任意数量的门的输入。本文假设电路的门 $G_1,…,G_k$ 按拓扑排序。该顺序(不一定是唯一的)确保第 $i$ 个门 $G_i$ 不具有作为连续门 $G_j,\\ j&gt;i$ 的输出的输入。总是可以通过 $O(k)$ 计算在非循环电路上获得拓扑顺序。</p>\n<p>本文专注于半诚实的模式，在这种模式下，参与者遵循协议，但试图从执行记录中学习信息。</p>\n<p>本文使用以下标准符号：$\\in_R$ 表示均匀随机采样，$|$ 表示位串的连接。$\\langle a, b \\rangle$ 是一个包括了 $a,b$ 两个元素的向量，且其比特串表示为 $a | b$。$W_c = g(W_a, W_b)$ 表示2输入门 $G$，其用输入线 $W_a,W_b$ 和输出线 $W_c$ 计算函数 $g: {0,1}^2 \\rightarrow {0,1 }$。</p>\n<p>设 $N$ 为安全参数。设 $S$ 是无限集，设 $X={X<em>s}</em>{s \\in S}$ 和 $Y={Y<em>s}</em>{s \\in S}$ 为分布全体。我们说 $X$ 和 $Y$ 在计算上是不可区分的，记为 $X \\overset{c}{\\equiv} Y$，如果对每个非均匀多项式时间微分器 $D$ 和所有足够大的 $s \\in S, \\ |Pr[D(X_s)=1]−Pr[D(Y_s)=1]|&lt;1/p(|s|) $ 对每个多项式 $p$。</p>\n<p><strong>随机预言。</strong>RO模型是一个有用的抽象。RO只是一个随机选择的函数 ${0,1}^* \\mapsto {0,1}^N$ -一个不能被多项式参与者完全存储或遍历的大对象。RO模型为所有参与者提供了Oracle访问此类功能的权限。实际上，RO由散列函数(如SHA)建模。</p>\n<p><strong>不经意传输(OT)。</strong>2选1OT是两方协议。<em>发送方</em> $P<em>1$ 具有两个秘密 $m_0,m_1$，<em>接收方</em> $P_2$ 具有选择位 $i \\in {0,1}$。在协议的最后，$P_2$ 得到 $m_i$，但没有获得关于 $m</em>{i-1}$ 的任何信息，$P_1$ 没有获得关于 $i$ 的任何信息。</p>\n<p><strong>姚氏乱码电路(GC)。</strong>参与者 $P_1$ 首先扰乱电路 $C$：对于每条线 $W_i$ 的值 $j$，他随机选择两个秘密 $w^0_i$ 和 $w^1_i$，其中 $w^j_i$ 是一个乱值，或者说是乱码。(注：$w^j_i$ 不透露 $j$。)。此外对于每个门 $G_i$，$P_1$ 创建具有以下属性的乱码表 $T_i$ 并将其发送到 $P_2$：给定一组 $G_i$ 的输入乱码，$T_i$ 允许恢复相应 $G_i$ 的输出的乱码，而不透露其他信息。然后参与方输入的乱码被(不经意地)传输到 $P_2$。现在 $P_2$ 可以使用表格 $T_i$ 通过逐个门地评估乱码电路来简单地获得乱码输出。如果在给定输入上对 $C$ 求值时，$W_i$ 取值 $j$，则称 $W_i$ 的乱码 $w^j_i$ <em>有效</em>。观察到，对于每根导线，$P_2$ 只能获得其有效乱码。电路的输出线没有乱码(或其乱码被公布)，因此 $P_2$ (仅)获知电路的输出，而不学习内部线路值。$P_1$ 从(半诚实的) $P_2$ 学习输出。(这一步在半诚实模型中是微不足道的，通常不会在分析中考虑。)。GC的正确性源于表 $T_i$ 的构建方法。任何一方都不会从协议执行中获知任何附加信息。</p>\n<h1 id=\"本文的协议\"><a href=\"#本文的协议\" class=\"headerlink\" title=\"本文的协议\"></a>本文的协议</h1><p>首先，本文展示了XOR门 $G$ 的SFE实现，它源自[14]中的一个。设 $G$ 有两根输入线 $W_a, W_b$，输出线 $W_c$。按如下方式对导线值进行乱码处理：随机选择 $w^0_a, w^0_b, R \\in_R {0,1}^N$。设 $w^0_c = w^0_a \\oplus w^0_b$ 和 $\\forall i \\in {a,b,c}: w^1_i = w^0_i \\oplus R$。很容易看出，乱码门输出只需对乱码门输入进行异或运算即可获得：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{align}\nw^0_c &= w^0_a \\oplus w^0_b = (w^0_a \\oplus R) \\oplus (w^0_b \\oplus R) = w^1_a \\oplus w^1_b \\\\\nw^1_c &= w^0_c \\oplus R = w^0_a \\oplus (w^0_b \\oplus R) = w^0_a \\oplus w^1_b = (w^0_a \\oplus R) \\oplus w^0_b = w^1_a \\oplus w^0_b\n\\end{align}</script><p>且乱码 $w^j_i$ 不会透露它们对应的线路值。</p>\n<p>上述异或结构对乱码值施加的限制：电路中每根导线的两个值的乱码必须相差相同的值，即对于某个全局 $R$，$\\forall i: w^1_i = w^0_i \\oplus R$。相比之下，在以前的GC结构中，所有乱码 $w^j_i$ 是独立随机选择的，并且安全性证明依赖于该性质。</p>\n<h2 id=\"本文的乱码电路构造\"><a href=\"#本文的乱码电路构造\" class=\"headerlink\" title=\"本文的乱码电路构造\"></a>本文的乱码电路构造</h2><p>设 $C$ 是一个电路。首先注意到，NOT门可以通过简单地消除它们并颠倒导线的值和乱码的对应关系来“免费”实现。</p>\n<p>在下面的Alg.1中，每个乱码 $w= \\langle k, p \\rangle$ 由密钥 $k \\in {0,1}^N$ 和排列位 $p \\in {0,1}$ 组成。密钥用于表条目的解密，$p$ 用于选择要解密的条目。每条导线的两个乱码 $w^0_i, w^1_i$ 按照异或构造的要求相关：对于选定的 $R\\in_R {0,1}^N$，$\\forall i: w^1_i = \\langle k^1_i, p^1_i \\rangle = \\langle k^0_i \\oplus R, p^0_i \\oplus 1 \\rangle$，其中 $w^0_i = \\langle k^0_i, p^0_i \\rangle$。$H: {0,1}^* \\mapsto {0,1}^{N+1}$ 是一个RO。</p>\n<p>现在我们将上述想法形式化，并给出GC结构(Alg.1)和评估(Alg.2)。在SFE中，Alg.1由 $P_1$ 执行，Alg.2由 $P_2$ 执行。</p>\n<p><img src=\"http://images.yingwai.top/picgo/freeXORa1.png\" alt=\"\"></p>\n<p>注意，本文的表项加密(步骤3(C)iii)类似于Fairplay。Fairplay使用 $e_{v_a,v_b} = H(k^{v_a}_a | i | p^{v_a}_a | p^{v_b}_b) \\oplus$ $H(k^{v_b}_b | i | p^{v_a}_a | p^{v_b}_b) \\oplus$ $w^{g_i(v_a, v_b)}_c$。这是一个不重要的区别；我们可以使用Fairplay的加密。</p>\n<p><strong>安全方面的直觉。</strong>Alg.1使用RO $H$ 的输出作为一次性垫来加密乱码表中的乱码输出值(步骤3(C)III)和乱码输出表(步骤4a)。注意，在本文的整个构造过程中，$H$ 的输入(密钥和门索引)的任何特定组合都用于加密至多一个表项。(本文假设 $H$ 中的串联和字符串表示是“正确的”。)。此外，由于被篡改电路的评估者每条线路只知道一个被篡改的值，所以他可以精确地解密 $G_i$ 的乱码表中的一个条目。所有其他条目都使用多次赋值器无法猜到的至少一个密钥进行加密。因此，在他看来，每根电线的两个乱值中的一个看起来是随机的。</p>\n<p>现在给出相应的GC评估算法，由 $P_2$ 运行。回想一下，$P_2$ 会从 $P_1$ 获取所有乱码表格和 $P_1$ 输入值的乱码。由 $P_2$ 保存的输入值的乱码通过OT发送。</p>\n<p><img src=\"http://images.yingwai.top/picgo/freeXORa2.png\" alt=\"\"></p>\n<p>GC构造和评估算法可以直接用于以标准方式获得基于GC的SFE协议。为完整起见，本文包含了对此协议的描述。</p>\n<hr>\n<p><strong>Protocol 1.</strong> <em>(Two-party SFE protocol):</em></p>\n<ul>\n<li><p><strong>Inputs:</strong>  $P<em>1$ has private input $x = \\langle x_1,..,x</em>{u<em>1} \\rangle \\in {0,1}^{u_1}$and $P_2$ has private input $y = \\langle y_1,..,y</em>{u_2} \\rangle \\in {0,1}^{u_2}$.</p>\n</li>\n<li><p><strong>Auxiliary input:</strong>  A boolean acyclic circuit $C$ such that $\\forall x \\in {0,1}^{u_1}, y \\in {0,1}^{u_2}$, it holds that $C(x,y) = f(x,y)$, where $f: {0,1}^{u_1} \\times {0,1}^{u_2} \\rightarrow {0,1}^v$. We require that $C$ is such that if a circuit-output wire leaves some gate $G$, then gate $G$ has no other wires leading from it into other gates (i.e., no circuit-output wire is also a gate-input wire). Likewise, a circuit-input wire that is also a circuit-output wire enters no gates. We also require that $C$ is modified to contain no NOT-gates and all n-input XOR-gates with $n &gt; 2$ replaced by 2-input XOR-gates as described in Section 3.1.</p>\n</li>\n<li><p><strong>The protocol:</strong></p>\n<ol>\n<li><p>$P_1$ constructs the garbled circuit using Algorithm 1 and sends it (i.e. the garbled tables) to $P_2$.</p>\n</li>\n<li><p>Let $W<em>1,.., W</em>{u<em>1}$ be the circuit input wires corresponding to $x$, and let $W</em>{u<em>1+1},..,W</em>{u_1+u_2}$ be the circuit input wires corresponding to $y$. Then, </p>\n<p>​    (a) $P<em>1$ sends $P_2$ the garbled values $w^{x_1}_1,..,w^{x</em>{u<em>1}}</em>{u_1}$.</p>\n<p>​    (b) For every $i \\in {1, .., u<em>2}$, $P_1$ and $P_2$ execute a 1-out-of-2 oblivious transfer protocol, where $P_1$’s input is $(k^0</em>{u<em>1+i}, k^1</em>{u_1+i})$, and $P_2$’s input is $y_i$. All $u_2$ OT instances can be run in parallel.</p>\n</li>\n<li><p>$P_2$ now has the garbled tables and the garblings of circuit’s input wires. $P_2$ evaluates the garbled circuit, as described in Alg. 2, and outputs $f(x, y)$.</p>\n</li>\n</ol>\n</li>\n</ul>\n<hr>\n","site":{"data":{}},"excerpt":"<p><em>Vladimir Kolesnikov, Thomas Schneider</em></p>\n<p> <a href=\"https://dblp.uni-trier.de/db/conf/icalp/icalp2008-2.html#KolesnikovS08\" target=\"_blank\" rel=\"noopener\">ICALP (2) 2008</a></p>\n<p><a href=\"https://dl.acm.org/doi/10.1007/978-3-540-70583-3_40\" target=\"_blank\" rel=\"noopener\">https://dl.acm.org/doi/10.1007/978-3-540-70583-3_40</a></p>","more":"<h1 id=\"摘要\"><a href=\"#摘要\" class=\"headerlink\" title=\"摘要\"></a>摘要</h1><p>本文提出了一种新的用于两方安全函数评估(SFE)的乱码电路结构。在本文的单轮协议中，XOR门的评估是“免费的”，这导致了对最佳乱码电路实现的相应改进(例如Fairplay)。</p>\n<p>本文几乎完全使用XOR门来构建置换网络和通用电路(UC)；这使得它们的SFE(在计算和通信方面)提高了多达4倍。本文还改进了整数加法和等价性测试，最高可达2倍。</p>\n<p>本文依赖随机预言(RO)假设。本文的构造在半诚实模型中被证明是安全的。</p>\n<h2 id=\"本文的贡献\"><a href=\"#本文的贡献\" class=\"headerlink\" title=\"本文的贡献\"></a>本文的贡献</h2><ul>\n<li>在半诚实模型下，本文提出了一种新的用于两方安全函数评估(SFE)的乱码电路结构。</li>\n<li>在本文的一轮协议中，XOR门的计算是“免费的”(也就是说，不使用相关的乱码表和相应的散列或对称密钥操作)。在处理其他门时，本文的构造与最好的乱码电路实现(例如Fairplay)一样有效。</li>\n</ul>\n<h1 id=\"Setting-and-Preliminaries\"><a href=\"#Setting-and-Preliminaries\" class=\"headerlink\" title=\"Setting and Preliminaries\"></a>Setting and Preliminaries</h1><p>两方通用安全函数评估(SFE)允许双方评估其各自输入 $x$ 和 $y$ 上的任何函数，同时保持 $x$ 和 $y$ 的隐私。</p>\n<p>本文考虑具有 $k$ 个门和任意扇出的非循环布尔电路。也就是说，每个门的(单个)输出可以用作任意数量的门的输入。本文假设电路的门 $G_1,…,G_k$ 按拓扑排序。该顺序(不一定是唯一的)确保第 $i$ 个门 $G_i$ 不具有作为连续门 $G_j,\\ j&gt;i$ 的输出的输入。总是可以通过 $O(k)$ 计算在非循环电路上获得拓扑顺序。</p>\n<p>本文专注于半诚实的模式，在这种模式下，参与者遵循协议，但试图从执行记录中学习信息。</p>\n<p>本文使用以下标准符号：$\\in_R$ 表示均匀随机采样，$|$ 表示位串的连接。$\\langle a, b \\rangle$ 是一个包括了 $a,b$ 两个元素的向量，且其比特串表示为 $a | b$。$W_c = g(W_a, W_b)$ 表示2输入门 $G$，其用输入线 $W_a,W_b$ 和输出线 $W_c$ 计算函数 $g: {0,1}^2 \\rightarrow {0,1 }$。</p>\n<p>设 $N$ 为安全参数。设 $S$ 是无限集，设 $X={X<em>s}</em>{s \\in S}$ 和 $Y={Y<em>s}</em>{s \\in S}$ 为分布全体。我们说 $X$ 和 $Y$ 在计算上是不可区分的，记为 $X \\overset{c}{\\equiv} Y$，如果对每个非均匀多项式时间微分器 $D$ 和所有足够大的 $s \\in S, \\ |Pr[D(X_s)=1]−Pr[D(Y_s)=1]|&lt;1/p(|s|) $ 对每个多项式 $p$。</p>\n<p><strong>随机预言。</strong>RO模型是一个有用的抽象。RO只是一个随机选择的函数 ${0,1}^* \\mapsto {0,1}^N$ -一个不能被多项式参与者完全存储或遍历的大对象。RO模型为所有参与者提供了Oracle访问此类功能的权限。实际上，RO由散列函数(如SHA)建模。</p>\n<p><strong>不经意传输(OT)。</strong>2选1OT是两方协议。<em>发送方</em> $P<em>1$ 具有两个秘密 $m_0,m_1$，<em>接收方</em> $P_2$ 具有选择位 $i \\in {0,1}$。在协议的最后，$P_2$ 得到 $m_i$，但没有获得关于 $m</em>{i-1}$ 的任何信息，$P_1$ 没有获得关于 $i$ 的任何信息。</p>\n<p><strong>姚氏乱码电路(GC)。</strong>参与者 $P_1$ 首先扰乱电路 $C$：对于每条线 $W_i$ 的值 $j$，他随机选择两个秘密 $w^0_i$ 和 $w^1_i$，其中 $w^j_i$ 是一个乱值，或者说是乱码。(注：$w^j_i$ 不透露 $j$。)。此外对于每个门 $G_i$，$P_1$ 创建具有以下属性的乱码表 $T_i$ 并将其发送到 $P_2$：给定一组 $G_i$ 的输入乱码，$T_i$ 允许恢复相应 $G_i$ 的输出的乱码，而不透露其他信息。然后参与方输入的乱码被(不经意地)传输到 $P_2$。现在 $P_2$ 可以使用表格 $T_i$ 通过逐个门地评估乱码电路来简单地获得乱码输出。如果在给定输入上对 $C$ 求值时，$W_i$ 取值 $j$，则称 $W_i$ 的乱码 $w^j_i$ <em>有效</em>。观察到，对于每根导线，$P_2$ 只能获得其有效乱码。电路的输出线没有乱码(或其乱码被公布)，因此 $P_2$ (仅)获知电路的输出，而不学习内部线路值。$P_1$ 从(半诚实的) $P_2$ 学习输出。(这一步在半诚实模型中是微不足道的，通常不会在分析中考虑。)。GC的正确性源于表 $T_i$ 的构建方法。任何一方都不会从协议执行中获知任何附加信息。</p>\n<h1 id=\"本文的协议\"><a href=\"#本文的协议\" class=\"headerlink\" title=\"本文的协议\"></a>本文的协议</h1><p>首先，本文展示了XOR门 $G$ 的SFE实现，它源自[14]中的一个。设 $G$ 有两根输入线 $W_a, W_b$，输出线 $W_c$。按如下方式对导线值进行乱码处理：随机选择 $w^0_a, w^0_b, R \\in_R {0,1}^N$。设 $w^0_c = w^0_a \\oplus w^0_b$ 和 $\\forall i \\in {a,b,c}: w^1_i = w^0_i \\oplus R$。很容易看出，乱码门输出只需对乱码门输入进行异或运算即可获得：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{align}\nw^0_c &= w^0_a \\oplus w^0_b = (w^0_a \\oplus R) \\oplus (w^0_b \\oplus R) = w^1_a \\oplus w^1_b \\\\\nw^1_c &= w^0_c \\oplus R = w^0_a \\oplus (w^0_b \\oplus R) = w^0_a \\oplus w^1_b = (w^0_a \\oplus R) \\oplus w^0_b = w^1_a \\oplus w^0_b\n\\end{align}</script><p>且乱码 $w^j_i$ 不会透露它们对应的线路值。</p>\n<p>上述异或结构对乱码值施加的限制：电路中每根导线的两个值的乱码必须相差相同的值，即对于某个全局 $R$，$\\forall i: w^1_i = w^0_i \\oplus R$。相比之下，在以前的GC结构中，所有乱码 $w^j_i$ 是独立随机选择的，并且安全性证明依赖于该性质。</p>\n<h2 id=\"本文的乱码电路构造\"><a href=\"#本文的乱码电路构造\" class=\"headerlink\" title=\"本文的乱码电路构造\"></a>本文的乱码电路构造</h2><p>设 $C$ 是一个电路。首先注意到，NOT门可以通过简单地消除它们并颠倒导线的值和乱码的对应关系来“免费”实现。</p>\n<p>在下面的Alg.1中，每个乱码 $w= \\langle k, p \\rangle$ 由密钥 $k \\in {0,1}^N$ 和排列位 $p \\in {0,1}$ 组成。密钥用于表条目的解密，$p$ 用于选择要解密的条目。每条导线的两个乱码 $w^0_i, w^1_i$ 按照异或构造的要求相关：对于选定的 $R\\in_R {0,1}^N$，$\\forall i: w^1_i = \\langle k^1_i, p^1_i \\rangle = \\langle k^0_i \\oplus R, p^0_i \\oplus 1 \\rangle$，其中 $w^0_i = \\langle k^0_i, p^0_i \\rangle$。$H: {0,1}^* \\mapsto {0,1}^{N+1}$ 是一个RO。</p>\n<p>现在我们将上述想法形式化，并给出GC结构(Alg.1)和评估(Alg.2)。在SFE中，Alg.1由 $P_1$ 执行，Alg.2由 $P_2$ 执行。</p>\n<p><img src=\"http://images.yingwai.top/picgo/freeXORa1.png\" alt=\"\"></p>\n<p>注意，本文的表项加密(步骤3(C)iii)类似于Fairplay。Fairplay使用 $e_{v_a,v_b} = H(k^{v_a}_a | i | p^{v_a}_a | p^{v_b}_b) \\oplus$ $H(k^{v_b}_b | i | p^{v_a}_a | p^{v_b}_b) \\oplus$ $w^{g_i(v_a, v_b)}_c$。这是一个不重要的区别；我们可以使用Fairplay的加密。</p>\n<p><strong>安全方面的直觉。</strong>Alg.1使用RO $H$ 的输出作为一次性垫来加密乱码表中的乱码输出值(步骤3(C)III)和乱码输出表(步骤4a)。注意，在本文的整个构造过程中，$H$ 的输入(密钥和门索引)的任何特定组合都用于加密至多一个表项。(本文假设 $H$ 中的串联和字符串表示是“正确的”。)。此外，由于被篡改电路的评估者每条线路只知道一个被篡改的值，所以他可以精确地解密 $G_i$ 的乱码表中的一个条目。所有其他条目都使用多次赋值器无法猜到的至少一个密钥进行加密。因此，在他看来，每根电线的两个乱值中的一个看起来是随机的。</p>\n<p>现在给出相应的GC评估算法，由 $P_2$ 运行。回想一下，$P_2$ 会从 $P_1$ 获取所有乱码表格和 $P_1$ 输入值的乱码。由 $P_2$ 保存的输入值的乱码通过OT发送。</p>\n<p><img src=\"http://images.yingwai.top/picgo/freeXORa2.png\" alt=\"\"></p>\n<p>GC构造和评估算法可以直接用于以标准方式获得基于GC的SFE协议。为完整起见，本文包含了对此协议的描述。</p>\n<hr>\n<p><strong>Protocol 1.</strong> <em>(Two-party SFE protocol):</em></p>\n<ul>\n<li><p><strong>Inputs:</strong>  $P<em>1$ has private input $x = \\langle x_1,..,x</em>{u<em>1} \\rangle \\in {0,1}^{u_1}$and $P_2$ has private input $y = \\langle y_1,..,y</em>{u_2} \\rangle \\in {0,1}^{u_2}$.</p>\n</li>\n<li><p><strong>Auxiliary input:</strong>  A boolean acyclic circuit $C$ such that $\\forall x \\in {0,1}^{u_1}, y \\in {0,1}^{u_2}$, it holds that $C(x,y) = f(x,y)$, where $f: {0,1}^{u_1} \\times {0,1}^{u_2} \\rightarrow {0,1}^v$. We require that $C$ is such that if a circuit-output wire leaves some gate $G$, then gate $G$ has no other wires leading from it into other gates (i.e., no circuit-output wire is also a gate-input wire). Likewise, a circuit-input wire that is also a circuit-output wire enters no gates. We also require that $C$ is modified to contain no NOT-gates and all n-input XOR-gates with $n &gt; 2$ replaced by 2-input XOR-gates as described in Section 3.1.</p>\n</li>\n<li><p><strong>The protocol:</strong></p>\n<ol>\n<li><p>$P_1$ constructs the garbled circuit using Algorithm 1 and sends it (i.e. the garbled tables) to $P_2$.</p>\n</li>\n<li><p>Let $W<em>1,.., W</em>{u<em>1}$ be the circuit input wires corresponding to $x$, and let $W</em>{u<em>1+1},..,W</em>{u_1+u_2}$ be the circuit input wires corresponding to $y$. Then, </p>\n<p>​    (a) $P<em>1$ sends $P_2$ the garbled values $w^{x_1}_1,..,w^{x</em>{u<em>1}}</em>{u_1}$.</p>\n<p>​    (b) For every $i \\in {1, .., u<em>2}$, $P_1$ and $P_2$ execute a 1-out-of-2 oblivious transfer protocol, where $P_1$’s input is $(k^0</em>{u<em>1+i}, k^1</em>{u_1+i})$, and $P_2$’s input is $y_i$. All $u_2$ OT instances can be run in parallel.</p>\n</li>\n<li><p>$P_2$ now has the garbled tables and the garblings of circuit’s input wires. $P_2$ evaluates the garbled circuit, as described in Alg. 2, and outputs $f(x, y)$.</p>\n</li>\n</ol>\n</li>\n</ul>\n<hr>"},{"title":"论文笔记 Linear-Regression on Packed Encrypted Data in the Two-Server Model","date":"2020-08-09T09:03:33.000Z","_content":"\n*Adi Akavia, Hayim Shaul, Mor Weiss, Zohar Yakhini*\n\n[WAHC'19: Proceedings of the 7th ACM Workshop on Encrypted Computing & Applied Homomorphic Cryptography](https://dl.acm.org/doi/proceedings/10.1145/3338469)\n\nhttps://dl.acm.org/doi/abs/10.1145/3338469.3358942\n\n<!--more-->\n\n![](http://images.yingwai.top/picgo/LoPED.png)\n\n# 摘要\n\n从包含大量独立样本的联合训练数据中开发机器学习模型是一项重要的任务，可以显著提高学习模型的潜在适用性和预测能力。由于单个用户(如医院或单个实验室)通常以高置信度收集不支持准确学习的数据集，因此希望在不损害数据隐私的情况下组合来自多个用户的数据。在这篇文章中，我们开发了一种隐私保护解决方案，用于从多方(“数据所有者”)共同贡献的数据中学习线性回归模型。我们的协议是基于Giacomelli等人的协议。(ACNS 2018)，利用两个非合谋服务器和线性同态加密(LHE)学习正则化线性回归模型。我们的方法使用不同的LHE方案，使我们能够显著减少同态操作的数量和运行时间，以及总的运行时间复杂度。我们协议的另一个优点是潜在的LHE方案基于与Giacomelli等人不同的(和后量子安全的)安全假设。我们的方法利用中国剩余定理和单指令多数据表示法来获得改进的性能。对于1000x40线性回归任务，对于同态操作，我们可以在总共3秒内学习到一个模型，而文献中报道的时间超过了100秒。我们的方法还可以扩展到更大的功能空间：我们实现了一个可以处理1000x100线性回归任务的系统，在数据所有者进行更重要的离线预处理之后，投入了数分钟的服务器计算时间。我们打算将我们的协议和实现整合到一个全面的系统中，该系统可以在更大范围内处理安全的联合学习。\n\n\n\n## 本文贡献\n\n* 线性-压缩加密数据的回归(LoPED)。提出了一种新的PPRR协议，称为“分组加密数据线性回归协议(LoPED)。\n* 同态计算时间加速：分析结果。与[6]相比，LoPED在同态运算的数量上提供了高达 $\\Theta(d^2)$ 的加速比，其中 $d$ 是特征的数量。更准确地说，加速比是 $\\Theta(\\mathsf{sl})$，其中 $\\mathsf{sl} \\leq d^2$ 是每个SIMD密文中封装的时隙数目。\n* 同态计算时间加速：实验结果。我们实现了我们的协议并进行了大量的实验，证明了同态运算(又名LHE-COMP)运行时的大幅加速；参见表1。\n* 安全性。LoPED基于后量子安全假设，与[6]中使用的基于Paillier的实现形成对比；这是我们系统的一个额外优势。\n\n\n\n# PRELIMINARIES\n\n## 岭回归\n\n线性回归的损失函数：\n$$\nf(w) = \\sum^m_{i = 1} \\left(y_i - x^T_i w \\right)^2\n$$\n于是 $\\boldsymbol{w}$ 的最优解为\n$$\n\\hat{\\boldsymbol{w}}^{*}=\\underset{\\hat{\\boldsymbol{w}}}{\\arg \\min }(\\boldsymbol{y}-\\mathbf{X} \\hat{\\boldsymbol{w}})^{\\mathrm{T}}(\\boldsymbol{y}-\\mathbf{X} \\hat{\\boldsymbol{w}})\n$$\n对 $\\hat{\\boldsymbol{w}}$ 求导并令导数为零，当 $\\mathbf{X}^{\\mathrm{T}} \\mathbf{X}$ 为满秩或正定矩阵时可得\n$$\n\\hat{\\boldsymbol{w}}^{*}=\\left(\\mathbf{X}^{\\mathrm{T}} \\mathbf{X}\\right)^{-1} \\mathbf{X}^{\\mathrm{T}} \\boldsymbol{y}\n$$\n然而现实中 $\\mathbf{X}^{\\mathrm{T}} \\mathbf{X}$ 往往不是满秩矩阵。例如在许多任务中会遇到大量的变量，其数目甚至超过样例数，导致 $\\mathbf{X}$ 的列数多于行数，$\\mathbf{X}^{\\mathrm{T}} \\mathbf{X}$ 显然不满秩。从上式可以看出在计算回归系数的时候，我们需要计算矩阵 $\\mathbf{X}^{\\mathrm{T}} \\mathbf{X}$ 的逆，但是如果该矩阵是个奇异矩阵，则无法对其进行求解。\n\n因此如果出现上面的情况，我们需要对最初的标准线性回归做一定的变化使原先无法求逆的矩阵变得非奇异，使得问题可以稳定求解。我们可以通过缩减的方式来处理这些问题，例如岭回归。\n\n岭回归是在标准线性回归的损失函数基础上添加了一个惩罚项 $\\lambda \\sum^n_{i=1} w^2_i$，称为L2正则化。\n\n这个时候损失函数的形式为\n$$\nf(w) = \\sum^m_{i = 1} \\left(y_i - x^T_i w \\right)^2 + \\lambda \\sum^n_{i=1} w^2_i\n$$\n将岭回归系数用矩阵的形式表示：\n$$\n\\hat{w}=\\left(X^{T} X+\\lambda I\\right)^{-1} X^{T} y\n$$\n可以看到，就是通过将 $\\mathbf{X}^{\\mathrm{T}} \\mathbf{X}$ 加上一个单位矩阵似的矩阵变成非奇异矩阵并可以进行求逆运算。\n\n\n\n## 线性同态加密(LHE)\n\nLHE是一种公钥加密方案，它允许人们在不知道秘密解密密钥的情况下，在加密的“幕后”执行线性运算。我们假设在密钥生成过程中，可以通过指定 $N \\in \\mathbb{N}$ 来选择明文空间，从而执行模 $N$ 的同态运算。这是通过将明文模 $N$ 显式地合并到方案的排列中来实现的。\n\n线性同态加密(LHE)方案 $\\mathcal{E}=(\\mathsf{KG}, \\mathsf{Enc},\\mathsf{Dec},\\mathsf{Eval}) $ 由四个算法组成，其中 $\\mathsf{KG}, \\mathsf{Enc}$ 和 $\\mathsf{Eval}$ 是PPT算法，$\\mathsf{Dec}$ 是(确定性)多项式时间。算法具有以下语法：\n\n* $\\mathsf{KG}(1^\\sigma, N)$ 将安全参数 $σ$ 和 $N \\in \\mathbb{N}$ 作为输入。它输出一对公开和秘密加密密钥 $(\\mathsf{pk}, \\mathsf{sk})$。我们假设  $\\mathsf{pk}$ 在其描述中包含 $N$，而不失一般性。\n* $\\mathsf{Enc}(\\mathsf{pk}, \\mathsf{msg})$ 将公钥 $\\mathsf{pk}$ 和消息 $\\mathsf{msg} \\in \\mathbb{Z}_N$ 作为输入，输出密文 $\\mathsf{c}$。\n* $\\mathsf{Dec}(\\mathsf{sk},\\mathsf{c})$ 将秘密解密密钥 $\\mathsf{sk}$ 和密文 $\\mathsf{c}$ 作为输入，并输出明文消息 $\\mathsf{msg'}$。\n* $\\mathsf{Eval}(\\mathsf{pk}, C, \\mathsf{c}_1,..., \\mathsf{c}_k)$ 将公钥 $\\mathsf{pk}$、电路 $C: \\mathbb{Z}^k_N \\rightarrow \\mathbb{Z}^l_N$，其中 $l, k \\in \\mathbb{N}$ 和 $k$ 个密文 $\\mathsf{c}_1,...,\\mathsf{c}_k$ 作为输入，并输出 $l$ 个密文 $(\\mathsf{c}'_1,...,\\mathsf{c}'_l)$。\n\n\n\n# 问题陈述\n\n## 在联合数据上的岭回归\n\n由于每个用户所拥有的数据样本是有限的，往往训练不出来比较好的模型。于是很自然地可以想到与其他用户一起来训练一个模型，每个用户都将自己的数据提供出来，此时样本的数量就足以训练出一个好的模型。这里不同用户的数据样本都是具有同样特征的。\n\n但这样就会有隐私泄露的问题，用户都不想别人知道自己的数据，于是就需要引入隐私保护。这里假设协议的参与者都是城市且好奇的。\n\n\n\n## Privacy-Preserving Ridge Regression with only Linearly-Homomorphic Encryption 中的方案\n\n在这篇文章之前最好的双服务器模型PPRR方案是 [*Privacy-Preserving Ridge Regression with only Linearly-Homomorphic Encryption*](https://yuyingwai.cn/2020/08/10/论文笔记-Privacy-Preserving-Ridge-Regression-with-only-Linearly-Homomorphic-Encryption/) 中的方案，如图1所示，\n\n![](http://images.yingwai.top/picgo/LoPEDf1.png)\n\n该协议对参数 $n, d, \\ell, \\lambda$ 进行操作，并选择明文环 $\\mathbb{Z}_N$ 满足：\n$$\nN > 2d(d - 1)^{\\frac{d-1}{2}}10^{4\\ell d}(n^2 + \\lambda)^{2d} \\tag{1}\n$$\n在初始化阶段，$\\mathcal{S}_2$ 生成LHE密钥 $(\\mathsf{pk}, \\mathsf{sk})$，然后发布公钥 $\\mathsf{pk}$。然后该协议对在多个数据所有者之间水平划分的输入 $(X|\\vec{y}) \\in \\mathbb{R}^{n \\times (d+1)}$ 训练岭回归模型，如下所示。\n\n1. 首先每个数据拥有者计算其对于 $d \\times d$ 矩阵 $A = X^T X + \\lambda I$ 的份额，将其缩放为嵌入 $\\mathbb{Z}_N$ 的整数值，用LHE方案加密该份额，并将密文发送给 $\\mathcal{S}_1$。用类似的方式计算 $\\vec{b} = X^T \\cdot \\vec{y}$。\n2. 其次 $\\mathcal{S}_1$ 将所有的份额结合起来获得 $A$ 的逐项输入加密 $\\mathbf{A}$，假设其在 $\\mathbb{Z}^{d \\times d}_N$ 中是可逆的。然后 $\\mathcal{S}_1$ 使用同态性质对 $A$ 进行盲化，具体为 $\\mathcal{S}_1$ 使用LHE计算 $A \\cdot R$ 的加密 $\\mathbf{C}$，其中 $R \\in \\mathsf{GL}(d, \\mathbb{Z}_N)$ 是一个随机的可逆矩阵。用类似的方法盲化 $\\vec{b}$，得到 $\\vec{\\mathbf{v}}$ 为加密后的 $\\vec{v} = \\vec{b} + A \\cdot \\vec{r}$，其中 $r \\in \\mathbb{Z}^d_N$ 是一致随机的。然后 $\\mathcal{S}_1$ 将 $\\mathbf{C}$ 和 $\\vec{\\mathbf{v}}$ 发送给 $\\mathcal{S}_2$。\n3. $\\mathcal{S}_2$ 使用密钥解密，求解线性系统 $C \\cdot \\vec{w}^* = \\vec{v} \\bmod N$ 来获得盲化后的模型 $\\vec{w}^*$，然后发送给 $\\mathcal{S}_1$。\n4. 最后 $\\mathcal{S}_1$ 去除盲化获得模型 $\\vec{w}' = R \\cdot \\vec{w}^* - \\vec{r} \\in \\mathbb{Z}^d_N$。对 $\\vec{w}'$ 使用有理数重构获得输出模型 $\\vec{w} \\in \\mathbb{Q}^d$，然后 $\\mathcal{S}_1$ 对各方进行广播。\n\n\n\n# 本文的隐私保护岭回归协议\n\n本文的模型与 *Privacy-Preserving Ridge Regression with only Linearly-Homomorphic Encryption* 中的模型一样，主要包括两个主体：数据拥有者 $DO$ 和服务器 $\\mathcal{S}$。其中数据拥有者的数量是已知的；服务器有两个，$\\mathcal{S}_1$ 负责将 $DO$ 的数据聚合，$\\mathcal{S}_2$ 负责更新权重。分为了三个阶段：初始化、上传输入和训练阶段。\n\n![](http://images.yingwai.top/picgo/LoPEDf2.png)\n\n\n\n## 初始化\n\n初始化（图2）包括 $\\mathcal{S}_2$ 生成LHE方案密钥，和发布公钥。\n\n由于 *Privacy-Preserving Ridge Regression with only Linearly-Homomorphic Encryption* 中的明文模数太大，而HElib和SEAL分别只支持62位和60位的明文模数，因此本文使用了中国剩余定理(CRT)来将明文空间缩小，使用 $\\mathbb{Z}_{p_1},...,\\mathbb{Z}_{p_t}$ 中的消息列表来表示 $\\mathbb{Z}_N$ 中的消息，使得 $N = \\prod^t_{i=1} p_i$，每个模 $p_i$ 需要独立的加密密钥也由 $\\mathcal{S}_2$ 来生成。（前面提到的另一个方案中的操作是直接在 $\\mathbb{Z}_N$ 中进行的，因此 $\\mathcal{S}_2$ 仅生成一对密钥 $(\\mathsf{pk}, \\mathsf{sk})$。）\n\n\n\n## 上传输入\n\n在图一中我们假设输入在数据拥有者之间水平分割，类似横向联邦学习（样本的联合）。\n\n令 $X \\in \\mathbb{R}^{n \\times d}, \\vec{y} \\in \\mathbb{R}^{n \\times 1}$ 分别表示数据矩阵和响应向量，于是存在 $[n]$ 的分割 $I_1,...,I_m$ 使得 $DO_j$ 拥有 $X^j = X_{I_j} = (X_k : k \\in I_j)$（$X_k$ 表示 $X$ 的第 $k$ 行）和 $\\vec{y}^j = \\vec{y}_{I_j} = (y_k)_{k \\in I_j}$。这些输入按比例缩放并嵌入到足够大的 $N$ 的 $\\mathbb{Z}_N$ 中（有关 $N$ 的要求请参见公式1）。对每个 $1 \\leq j \\leq m$，令 $A^j = \\sum_{k \\in I_j} \\left(X^j_k \\right)^T \\cdot X^j_k \\in \\mathbb{Z}^{d \\times d}_N$，和 $\\vec{b}_j = \\sum_{k \\in I_j} X^j_k \\cdot \\vec{y}^j_k \\in \\mathbb{Z}^d_N$。每个 $DO_j$ 在本地从他的输入计算 $A^j, \\vec{b}^j$，计算\n$$\nA^{j,p_i} = \\left(A^j \\bmod p_i \\right) \\quad \\mathrm{and} \\quad \\vec{b}^{j, p_i} = \\left(\\vec{b}^j \\bmod p_i \\right)\n$$\n然后发送加密后的 $A^{j, p_i}, \\vec{b}^{j, p_i}, i \\in [t]$ 给 $\\mathcal{S}_1$。\n\n\n\n## 训练\n\n![](http://images.yingwai.top/picgo/LoPEDf3.png)\n\n在这个阶段，$\\mathcal{S}_1$ 结合以及盲化来自所有数据拥有者的数据，$\\mathcal{S}_2$ 对盲化后的数据执行学习。\n\n在使用下面的方式将来自所有数据拥有者的数据组合后可以获得 $A = X^T X + \\lambda I$（其中 $\\lambda$ 是图1中的正则化参数，$I$ 是单位矩阵）和 $\\vec{b} = X^T \\vec{y}$：在前一个阶段 $\\mathcal{S}_1$ 获得了 $A^1,...,A^m$ 和 $\\vec{b}^1,...,\\vec{b}^m$，于是有\n$$\nA = \\sum^{m}_{j=1} A_j + \\lambda I \\quad \\mathrm{and} \\quad b = \\sum^m_{j=1} b_j\n$$\n因为本文使用CRT表示，需要计算 $A^{p_i} = A \\bmod p_i$ 和 $\\vec{b}^{p_i} = \\vec{b} \\bmod p_i$ 对每个 $i \\in [t]$，而不是 $A, \\vec{b}$。为此，$\\mathcal{S}_1$ 使用LHE方案的线性同态从 $A^{j, p_i}, \\vec{b}^{j, p_i}$ 计算 $A^{p_i}, \\vec{b}^{p_i}$（参见图3中的步骤1）。\n\n本文的盲化方法类似3.2小节中的描述，但需要进行一些修改去兼容CRT表示。具体地说，$\\mathcal{S}_1$ 选择一个随机的可逆矩阵 $R \\in \\mathbb{Z}^{d \\times d}_{N}$ 和随机的 $\\vec{r} \\in \\mathbb{Z}^d_N$，然后计算 $C = A \\cdot R$ 和 $\\vec{v} = \\vec{b} + A \\cdot \\vec{r}$。另外，由于对每个 $i \\in [t]$，对 $A^{p_i}, \\vec{b}^{p_i}$ 的操作是在 $\\mathbb{Z}_{p_i}$ 内的，所以使用 $R^{p_i} = R \\bmod p_i$ 和 $\\vec{r}^{p_i} = \\vec{r} \\bmod p_i$ 来执行盲化，于是盲化后的数据矩阵和响应向量分别为 $C^{p_i} = A^{p_i} \\cdot R^{p_i} \\bmod p_i$ 和 $\\vec{v}^{p_i} = \\vec{b}^{p_i} + A^{p_i} \\cdot \\vec{r}^{p_i} \\bmod p_i$（见图3中的步骤3a）。$C^{p_i}, \\vec{v}^{p_i}$ 是由 $\\mathcal{S}_1$ 使用LHE方案的线性同态来计算的，然后发送给 $\\mathcal{S}_2$。$\\mathcal{S}_2$ 解密这些密文来获取 $C^{p_i}, \\vec{v}^{p_i}, i \\in [t]$，然后使用CRT重构来恢复 $C, \\vec{v}$。\n\n然后 $\\mathcal{S}_2$ 计算 $C^{-1} = \\mathsf{adj}(C) / \\mathsf{det}(C)$（其中 $\\mathsf{adj}(C), \\mathsf{det}(c)$ 分别表示 $C$ 的伴随矩阵和行列式）来求解线性系统 $C \\cdot \\vec{w} = \\vec{v}$，获得盲化后的模型 $\\vec{w}^*$ 并发送给 $\\mathcal{S}_1$。于是 $\\mathcal{S}_1$ 可以计算 $\\vec{w} = R \\cdot \\vec{w}^* - \\vec{r}$ 来去盲化。这给出了 $\\mathbb{Z}^d_N$ 中的一个模型，$\\mathbb{Q}^d$ 中的相应模型可以使用有理重构从该模型中重构出来(参见第3.2节中的讨论)。\n\n\n\n# 将SIMD集成到LoPED\n\n## SIMD背景知识\n\n支持单指令多数据(SIMD)的加密方案和实现包括：Brakerski-Gentry-Vaikuntanathan和Fan-Vercauteren的基于RLWE的方案(通常称为BGV/FV)及其在HElib和SEAL库中的实现。这些方案允许在单个密文中将多个消息“打包”在不同的“槽”中。本文将打包参数，即打包在一个密文中的消息数目记为 $\\mathsf{sl}$，并且密文中的不同时隙记为 $\\mathbf{c} = (\\mathbf{c}(1),...,\\mathbf{c}(\\mathsf{sl}))$。对打包密文的操作以SIMD（单指令多数据）方式完成。例如，由 $c=a \\odot b$ 表示的SIMD乘法定义为 $\\mathbf{c}(i) = \\mathbf{a}(i) \\odot \\mathbf{b}(i)$，其中 $i = 1,...,\\mathsf{sl}$。\n\n重要的是要注意，在整个计算过程中幼稚地使用SIMD可能不会提高效率，因为涉及不同时隙上的计算的操作(例如，矩阵乘法，见下文)会招致高开销，这实际上可能会损害效率。\n\n\n\n## 将SIMD集成到LoPED\n\n首先看看LoPED中同态计算的操作：\n\n1. 向量相加（图3步骤1）\n2. 矩阵相加（图3步骤1）\n3. 矩阵相乘（图3步骤3a）\n4. 矩阵向量乘法（图3步骤3a）\n\n在这些操作中最昂贵的是第三个，因此本文将其与作者引入的矢量的新表示法以及作者为有效执行上述其他操作而设计的新协议相结合。\n\n\n\n### 矩阵编码和逐个矩阵乘法\n\n如上所述，本文使用 *Secure Out-sourced Matrix Computation and Application to Neural Networks* 的方案来使用SIMD进行高效的矩阵乘法，因此使用它们的矩阵编码。上面的方案区分从左侧相乘的矩阵和从右侧相乘的矩阵，并对每个矩阵使用不同的编码。设 $L$ 和 $R$ 是两个 $d\\times d$ 矩阵，我们希望计算 $A=L \\cdot R$，现在描述 $L$ 和 $R$ 的编码。\n\n\n\n#### Type-L 和 Type-R 编码以及 Type-N 表示\n\n本文将矩阵 $L$（乘积中的左矩阵）的编码表示为 Type-L 编码，其由 $L$ 的 $d$ 个旋转 $L_1,...,L_d$ 组成，其中 $L_i$ 为一个 $L$ 旋转其行后计算得到的 $d \\times d$ 矩阵；类似地，将矩阵 $R$（乘积中的右矩阵）的编码表示为 Type-R 编码，也由 $d$ 个旋转组成，每个 $R_i$ 是 $R$ 旋转其列后得到的 $d \\times d$ 矩阵（例子见图4）。然后用 Type-N 表示不作任何处理的原始矩阵的排列。\n\n对于以上两种编码，个人的理解是（拿 $L$ 来说）：\n\n* $L_1$：第 $i$ 行的元素往前移动 $i-1$ 个位置（前 $i-1$ 个移动到后面）；\n* $L_2$：第 $i$ 行的元素往前移动 $i$ 个位置；\n* 以此类推：$L_j$：第 $i$ 行的元素往前移动 $i+j-2$ 个位置。\n\n$R$ 也是类似的。\n\n作者还说到可以将这 $d$ 个矩阵打包到较少数量的密文中，从而减少开销。具体地说，原来的矩阵表示需要 $d^2$ 密文，而本文的表示需要 $d \\cdot \\lceil \\frac{d^2}{\\mathsf{sl}} \\rceil$ 密文(当 $\\mathsf{sl} > d$ 时，其优于 $d^2$)。\n\n\n\n#### 逐个矩阵乘法\n\n![](http://images.yingwai.top/picgo/LoPEDf4.png)\n\n矩阵乘法的例子见上图，计算 $A = L \\cdot R$ 可以分解成计算 $A = \\sum^d_{i=1} A_i$，其中 $A_i = L_i \\odot R_i$ 为两个矩阵的对应元素相乘。\n\n在我们的协议中，我们将加密矩阵与公共矩阵相乘(参见图3中的步骤3a)。这是使用基础LHE方案的 $\\mathsf{Eval}$ 算法完成的，用 $\\mathsf{Eval}(\\mathsf{pk},\\mathsf{MatMult}, \\mathbf{L}, R)$ 表示在输入电路 $C_{\\mathsf{MatMult}, R}$ 和密文 $\\mathbf{L}$ 上运行 $\\mathsf{Eval}$，其中 $C_{\\mathsf{MatMult}, R}$ 输入一个矩阵 $L$ 的Type-L编码，计算输出得到其与一个公共矩阵 $R$ 的乘积 $A = L \\cdot R$。\n\n\n\n#### 通过序列化提高效率\n\n本文通过将多个矩阵条目打包到单个密文中来提高效率（并克服了保存每个矩阵的多个旋转副本所带来的开销）。这是通过首先将 $d \\times d$ 矩阵表示(“序列化”)为长度为 $d^2$ 的向量来实现的。\n\n![](http://images.yingwai.top/picgo/LoPEDf5.png)\n\n就是将矩阵从左到右、从上到下，按列的顺序打包到密文中。也就是说，$A$ 的元素 $A_{c,l}$ 出现在串行化后的 $A$ 的第 $((c−1)d+l)$ 个位置。然后，可以将串行化矩阵（如果需要则用零填充）加密成密文（打包到时隙中）。\n\n\n\n### 向量表示\n\n本文描述了两种不同的矢量编码，每种编码都用于优化不同操作的复杂度。第一个编码称之为Type-M，允许高效的矩阵-向量乘法。第二种编码称之为Type-A，允许高效的向量相加。\n\n![](http://images.yingwai.top/picgo/LoPEDf6.png)\n\n在计算矩阵-向量乘法时，首先将向量映射为一个 $d \\times d$ 矩阵（Type-M编码：其中第一列为向量，其余列用0填充），然后再将该矩阵编码为Type-R矩阵，进行矩阵乘法。而Type-A编码则是对Type-M矩阵的序列化。\n\n我们注意到，虽然可以对类型M编码执行加法，但它的效率低于将两个类型A编码相加。例如当 $\\mathsf{sl}=d$ 时，将两个Type-M向量相加需要 $d$ 次运算，但是添加两个Type-A编码只需要一次操作。\n\n![](http://images.yingwai.top/picgo/LoPEDf7.png)\n\nType-M编码的向量与Type-L编码的矩阵相乘得到的结果序列化后，直接把多余的0去掉就可以变成与Type-A编码的向量格式一致，从而可以直接把两个向量相加（例子见图7）。\n\n","source":"_posts/论文笔记-Linear-Regression-on-Packed-Encrypted-Data-in-the-Two-Server-Model.md","raw":"---\ntitle: 论文笔记 Linear-Regression on Packed Encrypted Data in the Two-Server Model\ndate: 2020-08-09 17:03:33\ncategories: Papers\ntags: [PPML, Linear Regression, HE]\n---\n\n*Adi Akavia, Hayim Shaul, Mor Weiss, Zohar Yakhini*\n\n[WAHC'19: Proceedings of the 7th ACM Workshop on Encrypted Computing & Applied Homomorphic Cryptography](https://dl.acm.org/doi/proceedings/10.1145/3338469)\n\nhttps://dl.acm.org/doi/abs/10.1145/3338469.3358942\n\n<!--more-->\n\n![](http://images.yingwai.top/picgo/LoPED.png)\n\n# 摘要\n\n从包含大量独立样本的联合训练数据中开发机器学习模型是一项重要的任务，可以显著提高学习模型的潜在适用性和预测能力。由于单个用户(如医院或单个实验室)通常以高置信度收集不支持准确学习的数据集，因此希望在不损害数据隐私的情况下组合来自多个用户的数据。在这篇文章中，我们开发了一种隐私保护解决方案，用于从多方(“数据所有者”)共同贡献的数据中学习线性回归模型。我们的协议是基于Giacomelli等人的协议。(ACNS 2018)，利用两个非合谋服务器和线性同态加密(LHE)学习正则化线性回归模型。我们的方法使用不同的LHE方案，使我们能够显著减少同态操作的数量和运行时间，以及总的运行时间复杂度。我们协议的另一个优点是潜在的LHE方案基于与Giacomelli等人不同的(和后量子安全的)安全假设。我们的方法利用中国剩余定理和单指令多数据表示法来获得改进的性能。对于1000x40线性回归任务，对于同态操作，我们可以在总共3秒内学习到一个模型，而文献中报道的时间超过了100秒。我们的方法还可以扩展到更大的功能空间：我们实现了一个可以处理1000x100线性回归任务的系统，在数据所有者进行更重要的离线预处理之后，投入了数分钟的服务器计算时间。我们打算将我们的协议和实现整合到一个全面的系统中，该系统可以在更大范围内处理安全的联合学习。\n\n\n\n## 本文贡献\n\n* 线性-压缩加密数据的回归(LoPED)。提出了一种新的PPRR协议，称为“分组加密数据线性回归协议(LoPED)。\n* 同态计算时间加速：分析结果。与[6]相比，LoPED在同态运算的数量上提供了高达 $\\Theta(d^2)$ 的加速比，其中 $d$ 是特征的数量。更准确地说，加速比是 $\\Theta(\\mathsf{sl})$，其中 $\\mathsf{sl} \\leq d^2$ 是每个SIMD密文中封装的时隙数目。\n* 同态计算时间加速：实验结果。我们实现了我们的协议并进行了大量的实验，证明了同态运算(又名LHE-COMP)运行时的大幅加速；参见表1。\n* 安全性。LoPED基于后量子安全假设，与[6]中使用的基于Paillier的实现形成对比；这是我们系统的一个额外优势。\n\n\n\n# PRELIMINARIES\n\n## 岭回归\n\n线性回归的损失函数：\n$$\nf(w) = \\sum^m_{i = 1} \\left(y_i - x^T_i w \\right)^2\n$$\n于是 $\\boldsymbol{w}$ 的最优解为\n$$\n\\hat{\\boldsymbol{w}}^{*}=\\underset{\\hat{\\boldsymbol{w}}}{\\arg \\min }(\\boldsymbol{y}-\\mathbf{X} \\hat{\\boldsymbol{w}})^{\\mathrm{T}}(\\boldsymbol{y}-\\mathbf{X} \\hat{\\boldsymbol{w}})\n$$\n对 $\\hat{\\boldsymbol{w}}$ 求导并令导数为零，当 $\\mathbf{X}^{\\mathrm{T}} \\mathbf{X}$ 为满秩或正定矩阵时可得\n$$\n\\hat{\\boldsymbol{w}}^{*}=\\left(\\mathbf{X}^{\\mathrm{T}} \\mathbf{X}\\right)^{-1} \\mathbf{X}^{\\mathrm{T}} \\boldsymbol{y}\n$$\n然而现实中 $\\mathbf{X}^{\\mathrm{T}} \\mathbf{X}$ 往往不是满秩矩阵。例如在许多任务中会遇到大量的变量，其数目甚至超过样例数，导致 $\\mathbf{X}$ 的列数多于行数，$\\mathbf{X}^{\\mathrm{T}} \\mathbf{X}$ 显然不满秩。从上式可以看出在计算回归系数的时候，我们需要计算矩阵 $\\mathbf{X}^{\\mathrm{T}} \\mathbf{X}$ 的逆，但是如果该矩阵是个奇异矩阵，则无法对其进行求解。\n\n因此如果出现上面的情况，我们需要对最初的标准线性回归做一定的变化使原先无法求逆的矩阵变得非奇异，使得问题可以稳定求解。我们可以通过缩减的方式来处理这些问题，例如岭回归。\n\n岭回归是在标准线性回归的损失函数基础上添加了一个惩罚项 $\\lambda \\sum^n_{i=1} w^2_i$，称为L2正则化。\n\n这个时候损失函数的形式为\n$$\nf(w) = \\sum^m_{i = 1} \\left(y_i - x^T_i w \\right)^2 + \\lambda \\sum^n_{i=1} w^2_i\n$$\n将岭回归系数用矩阵的形式表示：\n$$\n\\hat{w}=\\left(X^{T} X+\\lambda I\\right)^{-1} X^{T} y\n$$\n可以看到，就是通过将 $\\mathbf{X}^{\\mathrm{T}} \\mathbf{X}$ 加上一个单位矩阵似的矩阵变成非奇异矩阵并可以进行求逆运算。\n\n\n\n## 线性同态加密(LHE)\n\nLHE是一种公钥加密方案，它允许人们在不知道秘密解密密钥的情况下，在加密的“幕后”执行线性运算。我们假设在密钥生成过程中，可以通过指定 $N \\in \\mathbb{N}$ 来选择明文空间，从而执行模 $N$ 的同态运算。这是通过将明文模 $N$ 显式地合并到方案的排列中来实现的。\n\n线性同态加密(LHE)方案 $\\mathcal{E}=(\\mathsf{KG}, \\mathsf{Enc},\\mathsf{Dec},\\mathsf{Eval}) $ 由四个算法组成，其中 $\\mathsf{KG}, \\mathsf{Enc}$ 和 $\\mathsf{Eval}$ 是PPT算法，$\\mathsf{Dec}$ 是(确定性)多项式时间。算法具有以下语法：\n\n* $\\mathsf{KG}(1^\\sigma, N)$ 将安全参数 $σ$ 和 $N \\in \\mathbb{N}$ 作为输入。它输出一对公开和秘密加密密钥 $(\\mathsf{pk}, \\mathsf{sk})$。我们假设  $\\mathsf{pk}$ 在其描述中包含 $N$，而不失一般性。\n* $\\mathsf{Enc}(\\mathsf{pk}, \\mathsf{msg})$ 将公钥 $\\mathsf{pk}$ 和消息 $\\mathsf{msg} \\in \\mathbb{Z}_N$ 作为输入，输出密文 $\\mathsf{c}$。\n* $\\mathsf{Dec}(\\mathsf{sk},\\mathsf{c})$ 将秘密解密密钥 $\\mathsf{sk}$ 和密文 $\\mathsf{c}$ 作为输入，并输出明文消息 $\\mathsf{msg'}$。\n* $\\mathsf{Eval}(\\mathsf{pk}, C, \\mathsf{c}_1,..., \\mathsf{c}_k)$ 将公钥 $\\mathsf{pk}$、电路 $C: \\mathbb{Z}^k_N \\rightarrow \\mathbb{Z}^l_N$，其中 $l, k \\in \\mathbb{N}$ 和 $k$ 个密文 $\\mathsf{c}_1,...,\\mathsf{c}_k$ 作为输入，并输出 $l$ 个密文 $(\\mathsf{c}'_1,...,\\mathsf{c}'_l)$。\n\n\n\n# 问题陈述\n\n## 在联合数据上的岭回归\n\n由于每个用户所拥有的数据样本是有限的，往往训练不出来比较好的模型。于是很自然地可以想到与其他用户一起来训练一个模型，每个用户都将自己的数据提供出来，此时样本的数量就足以训练出一个好的模型。这里不同用户的数据样本都是具有同样特征的。\n\n但这样就会有隐私泄露的问题，用户都不想别人知道自己的数据，于是就需要引入隐私保护。这里假设协议的参与者都是城市且好奇的。\n\n\n\n## Privacy-Preserving Ridge Regression with only Linearly-Homomorphic Encryption 中的方案\n\n在这篇文章之前最好的双服务器模型PPRR方案是 [*Privacy-Preserving Ridge Regression with only Linearly-Homomorphic Encryption*](https://yuyingwai.cn/2020/08/10/论文笔记-Privacy-Preserving-Ridge-Regression-with-only-Linearly-Homomorphic-Encryption/) 中的方案，如图1所示，\n\n![](http://images.yingwai.top/picgo/LoPEDf1.png)\n\n该协议对参数 $n, d, \\ell, \\lambda$ 进行操作，并选择明文环 $\\mathbb{Z}_N$ 满足：\n$$\nN > 2d(d - 1)^{\\frac{d-1}{2}}10^{4\\ell d}(n^2 + \\lambda)^{2d} \\tag{1}\n$$\n在初始化阶段，$\\mathcal{S}_2$ 生成LHE密钥 $(\\mathsf{pk}, \\mathsf{sk})$，然后发布公钥 $\\mathsf{pk}$。然后该协议对在多个数据所有者之间水平划分的输入 $(X|\\vec{y}) \\in \\mathbb{R}^{n \\times (d+1)}$ 训练岭回归模型，如下所示。\n\n1. 首先每个数据拥有者计算其对于 $d \\times d$ 矩阵 $A = X^T X + \\lambda I$ 的份额，将其缩放为嵌入 $\\mathbb{Z}_N$ 的整数值，用LHE方案加密该份额，并将密文发送给 $\\mathcal{S}_1$。用类似的方式计算 $\\vec{b} = X^T \\cdot \\vec{y}$。\n2. 其次 $\\mathcal{S}_1$ 将所有的份额结合起来获得 $A$ 的逐项输入加密 $\\mathbf{A}$，假设其在 $\\mathbb{Z}^{d \\times d}_N$ 中是可逆的。然后 $\\mathcal{S}_1$ 使用同态性质对 $A$ 进行盲化，具体为 $\\mathcal{S}_1$ 使用LHE计算 $A \\cdot R$ 的加密 $\\mathbf{C}$，其中 $R \\in \\mathsf{GL}(d, \\mathbb{Z}_N)$ 是一个随机的可逆矩阵。用类似的方法盲化 $\\vec{b}$，得到 $\\vec{\\mathbf{v}}$ 为加密后的 $\\vec{v} = \\vec{b} + A \\cdot \\vec{r}$，其中 $r \\in \\mathbb{Z}^d_N$ 是一致随机的。然后 $\\mathcal{S}_1$ 将 $\\mathbf{C}$ 和 $\\vec{\\mathbf{v}}$ 发送给 $\\mathcal{S}_2$。\n3. $\\mathcal{S}_2$ 使用密钥解密，求解线性系统 $C \\cdot \\vec{w}^* = \\vec{v} \\bmod N$ 来获得盲化后的模型 $\\vec{w}^*$，然后发送给 $\\mathcal{S}_1$。\n4. 最后 $\\mathcal{S}_1$ 去除盲化获得模型 $\\vec{w}' = R \\cdot \\vec{w}^* - \\vec{r} \\in \\mathbb{Z}^d_N$。对 $\\vec{w}'$ 使用有理数重构获得输出模型 $\\vec{w} \\in \\mathbb{Q}^d$，然后 $\\mathcal{S}_1$ 对各方进行广播。\n\n\n\n# 本文的隐私保护岭回归协议\n\n本文的模型与 *Privacy-Preserving Ridge Regression with only Linearly-Homomorphic Encryption* 中的模型一样，主要包括两个主体：数据拥有者 $DO$ 和服务器 $\\mathcal{S}$。其中数据拥有者的数量是已知的；服务器有两个，$\\mathcal{S}_1$ 负责将 $DO$ 的数据聚合，$\\mathcal{S}_2$ 负责更新权重。分为了三个阶段：初始化、上传输入和训练阶段。\n\n![](http://images.yingwai.top/picgo/LoPEDf2.png)\n\n\n\n## 初始化\n\n初始化（图2）包括 $\\mathcal{S}_2$ 生成LHE方案密钥，和发布公钥。\n\n由于 *Privacy-Preserving Ridge Regression with only Linearly-Homomorphic Encryption* 中的明文模数太大，而HElib和SEAL分别只支持62位和60位的明文模数，因此本文使用了中国剩余定理(CRT)来将明文空间缩小，使用 $\\mathbb{Z}_{p_1},...,\\mathbb{Z}_{p_t}$ 中的消息列表来表示 $\\mathbb{Z}_N$ 中的消息，使得 $N = \\prod^t_{i=1} p_i$，每个模 $p_i$ 需要独立的加密密钥也由 $\\mathcal{S}_2$ 来生成。（前面提到的另一个方案中的操作是直接在 $\\mathbb{Z}_N$ 中进行的，因此 $\\mathcal{S}_2$ 仅生成一对密钥 $(\\mathsf{pk}, \\mathsf{sk})$。）\n\n\n\n## 上传输入\n\n在图一中我们假设输入在数据拥有者之间水平分割，类似横向联邦学习（样本的联合）。\n\n令 $X \\in \\mathbb{R}^{n \\times d}, \\vec{y} \\in \\mathbb{R}^{n \\times 1}$ 分别表示数据矩阵和响应向量，于是存在 $[n]$ 的分割 $I_1,...,I_m$ 使得 $DO_j$ 拥有 $X^j = X_{I_j} = (X_k : k \\in I_j)$（$X_k$ 表示 $X$ 的第 $k$ 行）和 $\\vec{y}^j = \\vec{y}_{I_j} = (y_k)_{k \\in I_j}$。这些输入按比例缩放并嵌入到足够大的 $N$ 的 $\\mathbb{Z}_N$ 中（有关 $N$ 的要求请参见公式1）。对每个 $1 \\leq j \\leq m$，令 $A^j = \\sum_{k \\in I_j} \\left(X^j_k \\right)^T \\cdot X^j_k \\in \\mathbb{Z}^{d \\times d}_N$，和 $\\vec{b}_j = \\sum_{k \\in I_j} X^j_k \\cdot \\vec{y}^j_k \\in \\mathbb{Z}^d_N$。每个 $DO_j$ 在本地从他的输入计算 $A^j, \\vec{b}^j$，计算\n$$\nA^{j,p_i} = \\left(A^j \\bmod p_i \\right) \\quad \\mathrm{and} \\quad \\vec{b}^{j, p_i} = \\left(\\vec{b}^j \\bmod p_i \\right)\n$$\n然后发送加密后的 $A^{j, p_i}, \\vec{b}^{j, p_i}, i \\in [t]$ 给 $\\mathcal{S}_1$。\n\n\n\n## 训练\n\n![](http://images.yingwai.top/picgo/LoPEDf3.png)\n\n在这个阶段，$\\mathcal{S}_1$ 结合以及盲化来自所有数据拥有者的数据，$\\mathcal{S}_2$ 对盲化后的数据执行学习。\n\n在使用下面的方式将来自所有数据拥有者的数据组合后可以获得 $A = X^T X + \\lambda I$（其中 $\\lambda$ 是图1中的正则化参数，$I$ 是单位矩阵）和 $\\vec{b} = X^T \\vec{y}$：在前一个阶段 $\\mathcal{S}_1$ 获得了 $A^1,...,A^m$ 和 $\\vec{b}^1,...,\\vec{b}^m$，于是有\n$$\nA = \\sum^{m}_{j=1} A_j + \\lambda I \\quad \\mathrm{and} \\quad b = \\sum^m_{j=1} b_j\n$$\n因为本文使用CRT表示，需要计算 $A^{p_i} = A \\bmod p_i$ 和 $\\vec{b}^{p_i} = \\vec{b} \\bmod p_i$ 对每个 $i \\in [t]$，而不是 $A, \\vec{b}$。为此，$\\mathcal{S}_1$ 使用LHE方案的线性同态从 $A^{j, p_i}, \\vec{b}^{j, p_i}$ 计算 $A^{p_i}, \\vec{b}^{p_i}$（参见图3中的步骤1）。\n\n本文的盲化方法类似3.2小节中的描述，但需要进行一些修改去兼容CRT表示。具体地说，$\\mathcal{S}_1$ 选择一个随机的可逆矩阵 $R \\in \\mathbb{Z}^{d \\times d}_{N}$ 和随机的 $\\vec{r} \\in \\mathbb{Z}^d_N$，然后计算 $C = A \\cdot R$ 和 $\\vec{v} = \\vec{b} + A \\cdot \\vec{r}$。另外，由于对每个 $i \\in [t]$，对 $A^{p_i}, \\vec{b}^{p_i}$ 的操作是在 $\\mathbb{Z}_{p_i}$ 内的，所以使用 $R^{p_i} = R \\bmod p_i$ 和 $\\vec{r}^{p_i} = \\vec{r} \\bmod p_i$ 来执行盲化，于是盲化后的数据矩阵和响应向量分别为 $C^{p_i} = A^{p_i} \\cdot R^{p_i} \\bmod p_i$ 和 $\\vec{v}^{p_i} = \\vec{b}^{p_i} + A^{p_i} \\cdot \\vec{r}^{p_i} \\bmod p_i$（见图3中的步骤3a）。$C^{p_i}, \\vec{v}^{p_i}$ 是由 $\\mathcal{S}_1$ 使用LHE方案的线性同态来计算的，然后发送给 $\\mathcal{S}_2$。$\\mathcal{S}_2$ 解密这些密文来获取 $C^{p_i}, \\vec{v}^{p_i}, i \\in [t]$，然后使用CRT重构来恢复 $C, \\vec{v}$。\n\n然后 $\\mathcal{S}_2$ 计算 $C^{-1} = \\mathsf{adj}(C) / \\mathsf{det}(C)$（其中 $\\mathsf{adj}(C), \\mathsf{det}(c)$ 分别表示 $C$ 的伴随矩阵和行列式）来求解线性系统 $C \\cdot \\vec{w} = \\vec{v}$，获得盲化后的模型 $\\vec{w}^*$ 并发送给 $\\mathcal{S}_1$。于是 $\\mathcal{S}_1$ 可以计算 $\\vec{w} = R \\cdot \\vec{w}^* - \\vec{r}$ 来去盲化。这给出了 $\\mathbb{Z}^d_N$ 中的一个模型，$\\mathbb{Q}^d$ 中的相应模型可以使用有理重构从该模型中重构出来(参见第3.2节中的讨论)。\n\n\n\n# 将SIMD集成到LoPED\n\n## SIMD背景知识\n\n支持单指令多数据(SIMD)的加密方案和实现包括：Brakerski-Gentry-Vaikuntanathan和Fan-Vercauteren的基于RLWE的方案(通常称为BGV/FV)及其在HElib和SEAL库中的实现。这些方案允许在单个密文中将多个消息“打包”在不同的“槽”中。本文将打包参数，即打包在一个密文中的消息数目记为 $\\mathsf{sl}$，并且密文中的不同时隙记为 $\\mathbf{c} = (\\mathbf{c}(1),...,\\mathbf{c}(\\mathsf{sl}))$。对打包密文的操作以SIMD（单指令多数据）方式完成。例如，由 $c=a \\odot b$ 表示的SIMD乘法定义为 $\\mathbf{c}(i) = \\mathbf{a}(i) \\odot \\mathbf{b}(i)$，其中 $i = 1,...,\\mathsf{sl}$。\n\n重要的是要注意，在整个计算过程中幼稚地使用SIMD可能不会提高效率，因为涉及不同时隙上的计算的操作(例如，矩阵乘法，见下文)会招致高开销，这实际上可能会损害效率。\n\n\n\n## 将SIMD集成到LoPED\n\n首先看看LoPED中同态计算的操作：\n\n1. 向量相加（图3步骤1）\n2. 矩阵相加（图3步骤1）\n3. 矩阵相乘（图3步骤3a）\n4. 矩阵向量乘法（图3步骤3a）\n\n在这些操作中最昂贵的是第三个，因此本文将其与作者引入的矢量的新表示法以及作者为有效执行上述其他操作而设计的新协议相结合。\n\n\n\n### 矩阵编码和逐个矩阵乘法\n\n如上所述，本文使用 *Secure Out-sourced Matrix Computation and Application to Neural Networks* 的方案来使用SIMD进行高效的矩阵乘法，因此使用它们的矩阵编码。上面的方案区分从左侧相乘的矩阵和从右侧相乘的矩阵，并对每个矩阵使用不同的编码。设 $L$ 和 $R$ 是两个 $d\\times d$ 矩阵，我们希望计算 $A=L \\cdot R$，现在描述 $L$ 和 $R$ 的编码。\n\n\n\n#### Type-L 和 Type-R 编码以及 Type-N 表示\n\n本文将矩阵 $L$（乘积中的左矩阵）的编码表示为 Type-L 编码，其由 $L$ 的 $d$ 个旋转 $L_1,...,L_d$ 组成，其中 $L_i$ 为一个 $L$ 旋转其行后计算得到的 $d \\times d$ 矩阵；类似地，将矩阵 $R$（乘积中的右矩阵）的编码表示为 Type-R 编码，也由 $d$ 个旋转组成，每个 $R_i$ 是 $R$ 旋转其列后得到的 $d \\times d$ 矩阵（例子见图4）。然后用 Type-N 表示不作任何处理的原始矩阵的排列。\n\n对于以上两种编码，个人的理解是（拿 $L$ 来说）：\n\n* $L_1$：第 $i$ 行的元素往前移动 $i-1$ 个位置（前 $i-1$ 个移动到后面）；\n* $L_2$：第 $i$ 行的元素往前移动 $i$ 个位置；\n* 以此类推：$L_j$：第 $i$ 行的元素往前移动 $i+j-2$ 个位置。\n\n$R$ 也是类似的。\n\n作者还说到可以将这 $d$ 个矩阵打包到较少数量的密文中，从而减少开销。具体地说，原来的矩阵表示需要 $d^2$ 密文，而本文的表示需要 $d \\cdot \\lceil \\frac{d^2}{\\mathsf{sl}} \\rceil$ 密文(当 $\\mathsf{sl} > d$ 时，其优于 $d^2$)。\n\n\n\n#### 逐个矩阵乘法\n\n![](http://images.yingwai.top/picgo/LoPEDf4.png)\n\n矩阵乘法的例子见上图，计算 $A = L \\cdot R$ 可以分解成计算 $A = \\sum^d_{i=1} A_i$，其中 $A_i = L_i \\odot R_i$ 为两个矩阵的对应元素相乘。\n\n在我们的协议中，我们将加密矩阵与公共矩阵相乘(参见图3中的步骤3a)。这是使用基础LHE方案的 $\\mathsf{Eval}$ 算法完成的，用 $\\mathsf{Eval}(\\mathsf{pk},\\mathsf{MatMult}, \\mathbf{L}, R)$ 表示在输入电路 $C_{\\mathsf{MatMult}, R}$ 和密文 $\\mathbf{L}$ 上运行 $\\mathsf{Eval}$，其中 $C_{\\mathsf{MatMult}, R}$ 输入一个矩阵 $L$ 的Type-L编码，计算输出得到其与一个公共矩阵 $R$ 的乘积 $A = L \\cdot R$。\n\n\n\n#### 通过序列化提高效率\n\n本文通过将多个矩阵条目打包到单个密文中来提高效率（并克服了保存每个矩阵的多个旋转副本所带来的开销）。这是通过首先将 $d \\times d$ 矩阵表示(“序列化”)为长度为 $d^2$ 的向量来实现的。\n\n![](http://images.yingwai.top/picgo/LoPEDf5.png)\n\n就是将矩阵从左到右、从上到下，按列的顺序打包到密文中。也就是说，$A$ 的元素 $A_{c,l}$ 出现在串行化后的 $A$ 的第 $((c−1)d+l)$ 个位置。然后，可以将串行化矩阵（如果需要则用零填充）加密成密文（打包到时隙中）。\n\n\n\n### 向量表示\n\n本文描述了两种不同的矢量编码，每种编码都用于优化不同操作的复杂度。第一个编码称之为Type-M，允许高效的矩阵-向量乘法。第二种编码称之为Type-A，允许高效的向量相加。\n\n![](http://images.yingwai.top/picgo/LoPEDf6.png)\n\n在计算矩阵-向量乘法时，首先将向量映射为一个 $d \\times d$ 矩阵（Type-M编码：其中第一列为向量，其余列用0填充），然后再将该矩阵编码为Type-R矩阵，进行矩阵乘法。而Type-A编码则是对Type-M矩阵的序列化。\n\n我们注意到，虽然可以对类型M编码执行加法，但它的效率低于将两个类型A编码相加。例如当 $\\mathsf{sl}=d$ 时，将两个Type-M向量相加需要 $d$ 次运算，但是添加两个Type-A编码只需要一次操作。\n\n![](http://images.yingwai.top/picgo/LoPEDf7.png)\n\nType-M编码的向量与Type-L编码的矩阵相乘得到的结果序列化后，直接把多余的0去掉就可以变成与Type-A编码的向量格式一致，从而可以直接把两个向量相加（例子见图7）。\n\n","slug":"论文笔记-Linear-Regression-on-Packed-Encrypted-Data-in-the-Two-Server-Model","published":1,"updated":"2020-08-23T14:33:37.436Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cke79q4tn004e88ps2zq23kxk","content":"<p><em>Adi Akavia, Hayim Shaul, Mor Weiss, Zohar Yakhini</em></p>\n<p><a href=\"https://dl.acm.org/doi/proceedings/10.1145/3338469\" target=\"_blank\" rel=\"noopener\">WAHC’19: Proceedings of the 7th ACM Workshop on Encrypted Computing &amp; Applied Homomorphic Cryptography</a></p>\n<p><a href=\"https://dl.acm.org/doi/abs/10.1145/3338469.3358942\" target=\"_blank\" rel=\"noopener\">https://dl.acm.org/doi/abs/10.1145/3338469.3358942</a></p>\n<a id=\"more\"></a>\n<p><img src=\"http://images.yingwai.top/picgo/LoPED.png\" alt=\"\"></p>\n<h1 id=\"摘要\"><a href=\"#摘要\" class=\"headerlink\" title=\"摘要\"></a>摘要</h1><p>从包含大量独立样本的联合训练数据中开发机器学习模型是一项重要的任务，可以显著提高学习模型的潜在适用性和预测能力。由于单个用户(如医院或单个实验室)通常以高置信度收集不支持准确学习的数据集，因此希望在不损害数据隐私的情况下组合来自多个用户的数据。在这篇文章中，我们开发了一种隐私保护解决方案，用于从多方(“数据所有者”)共同贡献的数据中学习线性回归模型。我们的协议是基于Giacomelli等人的协议。(ACNS 2018)，利用两个非合谋服务器和线性同态加密(LHE)学习正则化线性回归模型。我们的方法使用不同的LHE方案，使我们能够显著减少同态操作的数量和运行时间，以及总的运行时间复杂度。我们协议的另一个优点是潜在的LHE方案基于与Giacomelli等人不同的(和后量子安全的)安全假设。我们的方法利用中国剩余定理和单指令多数据表示法来获得改进的性能。对于1000x40线性回归任务，对于同态操作，我们可以在总共3秒内学习到一个模型，而文献中报道的时间超过了100秒。我们的方法还可以扩展到更大的功能空间：我们实现了一个可以处理1000x100线性回归任务的系统，在数据所有者进行更重要的离线预处理之后，投入了数分钟的服务器计算时间。我们打算将我们的协议和实现整合到一个全面的系统中，该系统可以在更大范围内处理安全的联合学习。</p>\n<h2 id=\"本文贡献\"><a href=\"#本文贡献\" class=\"headerlink\" title=\"本文贡献\"></a>本文贡献</h2><ul>\n<li>线性-压缩加密数据的回归(LoPED)。提出了一种新的PPRR协议，称为“分组加密数据线性回归协议(LoPED)。</li>\n<li>同态计算时间加速：分析结果。与[6]相比，LoPED在同态运算的数量上提供了高达 $\\Theta(d^2)$ 的加速比，其中 $d$ 是特征的数量。更准确地说，加速比是 $\\Theta(\\mathsf{sl})$，其中 $\\mathsf{sl} \\leq d^2$ 是每个SIMD密文中封装的时隙数目。</li>\n<li>同态计算时间加速：实验结果。我们实现了我们的协议并进行了大量的实验，证明了同态运算(又名LHE-COMP)运行时的大幅加速；参见表1。</li>\n<li>安全性。LoPED基于后量子安全假设，与[6]中使用的基于Paillier的实现形成对比；这是我们系统的一个额外优势。</li>\n</ul>\n<h1 id=\"PRELIMINARIES\"><a href=\"#PRELIMINARIES\" class=\"headerlink\" title=\"PRELIMINARIES\"></a>PRELIMINARIES</h1><h2 id=\"岭回归\"><a href=\"#岭回归\" class=\"headerlink\" title=\"岭回归\"></a>岭回归</h2><p>线性回归的损失函数：</p>\n<script type=\"math/tex; mode=display\">\nf(w) = \\sum^m_{i = 1} \\left(y_i - x^T_i w \\right)^2</script><p>于是 $\\boldsymbol{w}$ 的最优解为</p>\n<script type=\"math/tex; mode=display\">\n\\hat{\\boldsymbol{w}}^{*}=\\underset{\\hat{\\boldsymbol{w}}}{\\arg \\min }(\\boldsymbol{y}-\\mathbf{X} \\hat{\\boldsymbol{w}})^{\\mathrm{T}}(\\boldsymbol{y}-\\mathbf{X} \\hat{\\boldsymbol{w}})</script><p>对 $\\hat{\\boldsymbol{w}}$ 求导并令导数为零，当 $\\mathbf{X}^{\\mathrm{T}} \\mathbf{X}$ 为满秩或正定矩阵时可得</p>\n<script type=\"math/tex; mode=display\">\n\\hat{\\boldsymbol{w}}^{*}=\\left(\\mathbf{X}^{\\mathrm{T}} \\mathbf{X}\\right)^{-1} \\mathbf{X}^{\\mathrm{T}} \\boldsymbol{y}</script><p>然而现实中 $\\mathbf{X}^{\\mathrm{T}} \\mathbf{X}$ 往往不是满秩矩阵。例如在许多任务中会遇到大量的变量，其数目甚至超过样例数，导致 $\\mathbf{X}$ 的列数多于行数，$\\mathbf{X}^{\\mathrm{T}} \\mathbf{X}$ 显然不满秩。从上式可以看出在计算回归系数的时候，我们需要计算矩阵 $\\mathbf{X}^{\\mathrm{T}} \\mathbf{X}$ 的逆，但是如果该矩阵是个奇异矩阵，则无法对其进行求解。</p>\n<p>因此如果出现上面的情况，我们需要对最初的标准线性回归做一定的变化使原先无法求逆的矩阵变得非奇异，使得问题可以稳定求解。我们可以通过缩减的方式来处理这些问题，例如岭回归。</p>\n<p>岭回归是在标准线性回归的损失函数基础上添加了一个惩罚项 $\\lambda \\sum^n_{i=1} w^2_i$，称为L2正则化。</p>\n<p>这个时候损失函数的形式为</p>\n<script type=\"math/tex; mode=display\">\nf(w) = \\sum^m_{i = 1} \\left(y_i - x^T_i w \\right)^2 + \\lambda \\sum^n_{i=1} w^2_i</script><p>将岭回归系数用矩阵的形式表示：</p>\n<script type=\"math/tex; mode=display\">\n\\hat{w}=\\left(X^{T} X+\\lambda I\\right)^{-1} X^{T} y</script><p>可以看到，就是通过将 $\\mathbf{X}^{\\mathrm{T}} \\mathbf{X}$ 加上一个单位矩阵似的矩阵变成非奇异矩阵并可以进行求逆运算。</p>\n<h2 id=\"线性同态加密-LHE\"><a href=\"#线性同态加密-LHE\" class=\"headerlink\" title=\"线性同态加密(LHE)\"></a>线性同态加密(LHE)</h2><p>LHE是一种公钥加密方案，它允许人们在不知道秘密解密密钥的情况下，在加密的“幕后”执行线性运算。我们假设在密钥生成过程中，可以通过指定 $N \\in \\mathbb{N}$ 来选择明文空间，从而执行模 $N$ 的同态运算。这是通过将明文模 $N$ 显式地合并到方案的排列中来实现的。</p>\n<p>线性同态加密(LHE)方案 $\\mathcal{E}=(\\mathsf{KG}, \\mathsf{Enc},\\mathsf{Dec},\\mathsf{Eval}) $ 由四个算法组成，其中 $\\mathsf{KG}, \\mathsf{Enc}$ 和 $\\mathsf{Eval}$ 是PPT算法，$\\mathsf{Dec}$ 是(确定性)多项式时间。算法具有以下语法：</p>\n<ul>\n<li>$\\mathsf{KG}(1^\\sigma, N)$ 将安全参数 $σ$ 和 $N \\in \\mathbb{N}$ 作为输入。它输出一对公开和秘密加密密钥 $(\\mathsf{pk}, \\mathsf{sk})$。我们假设  $\\mathsf{pk}$ 在其描述中包含 $N$，而不失一般性。</li>\n<li>$\\mathsf{Enc}(\\mathsf{pk}, \\mathsf{msg})$ 将公钥 $\\mathsf{pk}$ 和消息 $\\mathsf{msg} \\in \\mathbb{Z}_N$ 作为输入，输出密文 $\\mathsf{c}$。</li>\n<li>$\\mathsf{Dec}(\\mathsf{sk},\\mathsf{c})$ 将秘密解密密钥 $\\mathsf{sk}$ 和密文 $\\mathsf{c}$ 作为输入，并输出明文消息 $\\mathsf{msg’}$。</li>\n<li>$\\mathsf{Eval}(\\mathsf{pk}, C, \\mathsf{c}_1,…, \\mathsf{c}_k)$ 将公钥 $\\mathsf{pk}$、电路 $C: \\mathbb{Z}^k_N \\rightarrow \\mathbb{Z}^l_N$，其中 $l, k \\in \\mathbb{N}$ 和 $k$ 个密文 $\\mathsf{c}_1,…,\\mathsf{c}_k$ 作为输入，并输出 $l$ 个密文 $(\\mathsf{c}’_1,…,\\mathsf{c}’_l)$。</li>\n</ul>\n<h1 id=\"问题陈述\"><a href=\"#问题陈述\" class=\"headerlink\" title=\"问题陈述\"></a>问题陈述</h1><h2 id=\"在联合数据上的岭回归\"><a href=\"#在联合数据上的岭回归\" class=\"headerlink\" title=\"在联合数据上的岭回归\"></a>在联合数据上的岭回归</h2><p>由于每个用户所拥有的数据样本是有限的，往往训练不出来比较好的模型。于是很自然地可以想到与其他用户一起来训练一个模型，每个用户都将自己的数据提供出来，此时样本的数量就足以训练出一个好的模型。这里不同用户的数据样本都是具有同样特征的。</p>\n<p>但这样就会有隐私泄露的问题，用户都不想别人知道自己的数据，于是就需要引入隐私保护。这里假设协议的参与者都是城市且好奇的。</p>\n<h2 id=\"Privacy-Preserving-Ridge-Regression-with-only-Linearly-Homomorphic-Encryption-中的方案\"><a href=\"#Privacy-Preserving-Ridge-Regression-with-only-Linearly-Homomorphic-Encryption-中的方案\" class=\"headerlink\" title=\"Privacy-Preserving Ridge Regression with only Linearly-Homomorphic Encryption 中的方案\"></a>Privacy-Preserving Ridge Regression with only Linearly-Homomorphic Encryption 中的方案</h2><p>在这篇文章之前最好的双服务器模型PPRR方案是 <a href=\"https://yuyingwai.cn/2020/08/10/论文笔记-Privacy-Preserving-Ridge-Regression-with-only-Linearly-Homomorphic-Encryption/\" target=\"_blank\" rel=\"noopener\"><em>Privacy-Preserving Ridge Regression with only Linearly-Homomorphic Encryption</em></a> 中的方案，如图1所示，</p>\n<p><img src=\"http://images.yingwai.top/picgo/LoPEDf1.png\" alt=\"\"></p>\n<p>该协议对参数 $n, d, \\ell, \\lambda$ 进行操作，并选择明文环 $\\mathbb{Z}_N$ 满足：</p>\n<script type=\"math/tex; mode=display\">\nN > 2d(d - 1)^{\\frac{d-1}{2}}10^{4\\ell d}(n^2 + \\lambda)^{2d} \\tag{1}</script><p>在初始化阶段，$\\mathcal{S}_2$ 生成LHE密钥 $(\\mathsf{pk}, \\mathsf{sk})$，然后发布公钥 $\\mathsf{pk}$。然后该协议对在多个数据所有者之间水平划分的输入 $(X|\\vec{y}) \\in \\mathbb{R}^{n \\times (d+1)}$ 训练岭回归模型，如下所示。</p>\n<ol>\n<li>首先每个数据拥有者计算其对于 $d \\times d$ 矩阵 $A = X^T X + \\lambda I$ 的份额，将其缩放为嵌入 $\\mathbb{Z}_N$ 的整数值，用LHE方案加密该份额，并将密文发送给 $\\mathcal{S}_1$。用类似的方式计算 $\\vec{b} = X^T \\cdot \\vec{y}$。</li>\n<li>其次 $\\mathcal{S}_1$ 将所有的份额结合起来获得 $A$ 的逐项输入加密 $\\mathbf{A}$，假设其在 $\\mathbb{Z}^{d \\times d}_N$ 中是可逆的。然后 $\\mathcal{S}_1$ 使用同态性质对 $A$ 进行盲化，具体为 $\\mathcal{S}_1$ 使用LHE计算 $A \\cdot R$ 的加密 $\\mathbf{C}$，其中 $R \\in \\mathsf{GL}(d, \\mathbb{Z}_N)$ 是一个随机的可逆矩阵。用类似的方法盲化 $\\vec{b}$，得到 $\\vec{\\mathbf{v}}$ 为加密后的 $\\vec{v} = \\vec{b} + A \\cdot \\vec{r}$，其中 $r \\in \\mathbb{Z}^d_N$ 是一致随机的。然后 $\\mathcal{S}_1$ 将 $\\mathbf{C}$ 和 $\\vec{\\mathbf{v}}$ 发送给 $\\mathcal{S}_2$。</li>\n<li>$\\mathcal{S}_2$ 使用密钥解密，求解线性系统 $C \\cdot \\vec{w}^<em> = \\vec{v} \\bmod N$ 来获得盲化后的模型 $\\vec{w}^</em>$，然后发送给 $\\mathcal{S}_1$。</li>\n<li>最后 $\\mathcal{S}_1$ 去除盲化获得模型 $\\vec{w}’ = R \\cdot \\vec{w}^* - \\vec{r} \\in \\mathbb{Z}^d_N$。对 $\\vec{w}’$ 使用有理数重构获得输出模型 $\\vec{w} \\in \\mathbb{Q}^d$，然后 $\\mathcal{S}_1$ 对各方进行广播。</li>\n</ol>\n<h1 id=\"本文的隐私保护岭回归协议\"><a href=\"#本文的隐私保护岭回归协议\" class=\"headerlink\" title=\"本文的隐私保护岭回归协议\"></a>本文的隐私保护岭回归协议</h1><p>本文的模型与 <em>Privacy-Preserving Ridge Regression with only Linearly-Homomorphic Encryption</em> 中的模型一样，主要包括两个主体：数据拥有者 $DO$ 和服务器 $\\mathcal{S}$。其中数据拥有者的数量是已知的；服务器有两个，$\\mathcal{S}_1$ 负责将 $DO$ 的数据聚合，$\\mathcal{S}_2$ 负责更新权重。分为了三个阶段：初始化、上传输入和训练阶段。</p>\n<p><img src=\"http://images.yingwai.top/picgo/LoPEDf2.png\" alt=\"\"></p>\n<h2 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h2><p>初始化（图2）包括 $\\mathcal{S}_2$ 生成LHE方案密钥，和发布公钥。</p>\n<p>由于 <em>Privacy-Preserving Ridge Regression with only Linearly-Homomorphic Encryption</em> 中的明文模数太大，而HElib和SEAL分别只支持62位和60位的明文模数，因此本文使用了中国剩余定理(CRT)来将明文空间缩小，使用 $\\mathbb{Z}<em>{p_1},…,\\mathbb{Z}</em>{p<em>t}$ 中的消息列表来表示 $\\mathbb{Z}_N$ 中的消息，使得 $N = \\prod^t</em>{i=1} p_i$，每个模 $p_i$ 需要独立的加密密钥也由 $\\mathcal{S}_2$ 来生成。（前面提到的另一个方案中的操作是直接在 $\\mathbb{Z}_N$ 中进行的，因此 $\\mathcal{S}_2$ 仅生成一对密钥 $(\\mathsf{pk}, \\mathsf{sk})$。）</p>\n<h2 id=\"上传输入\"><a href=\"#上传输入\" class=\"headerlink\" title=\"上传输入\"></a>上传输入</h2><p>在图一中我们假设输入在数据拥有者之间水平分割，类似横向联邦学习（样本的联合）。</p>\n<p>令 $X \\in \\mathbb{R}^{n \\times d}, \\vec{y} \\in \\mathbb{R}^{n \\times 1}$ 分别表示数据矩阵和响应向量，于是存在 $[n]$ 的分割 $I<em>1,…,I_m$ 使得 $DO_j$ 拥有 $X^j = X</em>{I<em>j} = (X_k : k \\in I_j)$（$X_k$ 表示 $X$ 的第 $k$ 行）和 $\\vec{y}^j = \\vec{y}</em>{I<em>j} = (y_k)</em>{k \\in I<em>j}$。这些输入按比例缩放并嵌入到足够大的 $N$ 的 $\\mathbb{Z}_N$ 中（有关 $N$ 的要求请参见公式1）。对每个 $1 \\leq j \\leq m$，令 $A^j = \\sum</em>{k \\in I<em>j} \\left(X^j_k \\right)^T \\cdot X^j_k \\in \\mathbb{Z}^{d \\times d}_N$，和 $\\vec{b}_j = \\sum</em>{k \\in I_j} X^j_k \\cdot \\vec{y}^j_k \\in \\mathbb{Z}^d_N$。每个 $DO_j$ 在本地从他的输入计算 $A^j, \\vec{b}^j$，计算</p>\n<script type=\"math/tex; mode=display\">\nA^{j,p_i} = \\left(A^j \\bmod p_i \\right) \\quad \\mathrm{and} \\quad \\vec{b}^{j, p_i} = \\left(\\vec{b}^j \\bmod p_i \\right)</script><p>然后发送加密后的 $A^{j, p_i}, \\vec{b}^{j, p_i}, i \\in [t]$ 给 $\\mathcal{S}_1$。</p>\n<h2 id=\"训练\"><a href=\"#训练\" class=\"headerlink\" title=\"训练\"></a>训练</h2><p><img src=\"http://images.yingwai.top/picgo/LoPEDf3.png\" alt=\"\"></p>\n<p>在这个阶段，$\\mathcal{S}_1$ 结合以及盲化来自所有数据拥有者的数据，$\\mathcal{S}_2$ 对盲化后的数据执行学习。</p>\n<p>在使用下面的方式将来自所有数据拥有者的数据组合后可以获得 $A = X^T X + \\lambda I$（其中 $\\lambda$ 是图1中的正则化参数，$I$ 是单位矩阵）和 $\\vec{b} = X^T \\vec{y}$：在前一个阶段 $\\mathcal{S}_1$ 获得了 $A^1,…,A^m$ 和 $\\vec{b}^1,…,\\vec{b}^m$，于是有</p>\n<script type=\"math/tex; mode=display\">\nA = \\sum^{m}_{j=1} A_j + \\lambda I \\quad \\mathrm{and} \\quad b = \\sum^m_{j=1} b_j</script><p>因为本文使用CRT表示，需要计算 $A^{p_i} = A \\bmod p_i$ 和 $\\vec{b}^{p_i} = \\vec{b} \\bmod p_i$ 对每个 $i \\in [t]$，而不是 $A, \\vec{b}$。为此，$\\mathcal{S}_1$ 使用LHE方案的线性同态从 $A^{j, p_i}, \\vec{b}^{j, p_i}$ 计算 $A^{p_i}, \\vec{b}^{p_i}$（参见图3中的步骤1）。</p>\n<p>本文的盲化方法类似3.2小节中的描述，但需要进行一些修改去兼容CRT表示。具体地说，$\\mathcal{S}<em>1$ 选择一个随机的可逆矩阵 $R \\in \\mathbb{Z}^{d \\times d}</em>{N}$ 和随机的 $\\vec{r} \\in \\mathbb{Z}^d<em>N$，然后计算 $C = A \\cdot R$ 和 $\\vec{v} = \\vec{b} + A \\cdot \\vec{r}$。另外，由于对每个 $i \\in [t]$，对 $A^{p_i}, \\vec{b}^{p_i}$ 的操作是在 $\\mathbb{Z}</em>{p_i}$ 内的，所以使用 $R^{p_i} = R \\bmod p_i$ 和 $\\vec{r}^{p_i} = \\vec{r} \\bmod p_i$ 来执行盲化，于是盲化后的数据矩阵和响应向量分别为 $C^{p_i} = A^{p_i} \\cdot R^{p_i} \\bmod p_i$ 和 $\\vec{v}^{p_i} = \\vec{b}^{p_i} + A^{p_i} \\cdot \\vec{r}^{p_i} \\bmod p_i$（见图3中的步骤3a）。$C^{p_i}, \\vec{v}^{p_i}$ 是由 $\\mathcal{S}_1$ 使用LHE方案的线性同态来计算的，然后发送给 $\\mathcal{S}_2$。$\\mathcal{S}_2$ 解密这些密文来获取 $C^{p_i}, \\vec{v}^{p_i}, i \\in [t]$，然后使用CRT重构来恢复 $C, \\vec{v}$。</p>\n<p>然后 $\\mathcal{S}_2$ 计算 $C^{-1} = \\mathsf{adj}(C) / \\mathsf{det}(C)$（其中 $\\mathsf{adj}(C), \\mathsf{det}(c)$ 分别表示 $C$ 的伴随矩阵和行列式）来求解线性系统 $C \\cdot \\vec{w} = \\vec{v}$，获得盲化后的模型 $\\vec{w}^<em>$ 并发送给 $\\mathcal{S}_1$。于是 $\\mathcal{S}_1$ 可以计算 $\\vec{w} = R \\cdot \\vec{w}^</em> - \\vec{r}$ 来去盲化。这给出了 $\\mathbb{Z}^d_N$ 中的一个模型，$\\mathbb{Q}^d$ 中的相应模型可以使用有理重构从该模型中重构出来(参见第3.2节中的讨论)。</p>\n<h1 id=\"将SIMD集成到LoPED\"><a href=\"#将SIMD集成到LoPED\" class=\"headerlink\" title=\"将SIMD集成到LoPED\"></a>将SIMD集成到LoPED</h1><h2 id=\"SIMD背景知识\"><a href=\"#SIMD背景知识\" class=\"headerlink\" title=\"SIMD背景知识\"></a>SIMD背景知识</h2><p>支持单指令多数据(SIMD)的加密方案和实现包括：Brakerski-Gentry-Vaikuntanathan和Fan-Vercauteren的基于RLWE的方案(通常称为BGV/FV)及其在HElib和SEAL库中的实现。这些方案允许在单个密文中将多个消息“打包”在不同的“槽”中。本文将打包参数，即打包在一个密文中的消息数目记为 $\\mathsf{sl}$，并且密文中的不同时隙记为 $\\mathbf{c} = (\\mathbf{c}(1),…,\\mathbf{c}(\\mathsf{sl}))$。对打包密文的操作以SIMD（单指令多数据）方式完成。例如，由 $c=a \\odot b$ 表示的SIMD乘法定义为 $\\mathbf{c}(i) = \\mathbf{a}(i) \\odot \\mathbf{b}(i)$，其中 $i = 1,…,\\mathsf{sl}$。</p>\n<p>重要的是要注意，在整个计算过程中幼稚地使用SIMD可能不会提高效率，因为涉及不同时隙上的计算的操作(例如，矩阵乘法，见下文)会招致高开销，这实际上可能会损害效率。</p>\n<h2 id=\"将SIMD集成到LoPED-1\"><a href=\"#将SIMD集成到LoPED-1\" class=\"headerlink\" title=\"将SIMD集成到LoPED\"></a>将SIMD集成到LoPED</h2><p>首先看看LoPED中同态计算的操作：</p>\n<ol>\n<li>向量相加（图3步骤1）</li>\n<li>矩阵相加（图3步骤1）</li>\n<li>矩阵相乘（图3步骤3a）</li>\n<li>矩阵向量乘法（图3步骤3a）</li>\n</ol>\n<p>在这些操作中最昂贵的是第三个，因此本文将其与作者引入的矢量的新表示法以及作者为有效执行上述其他操作而设计的新协议相结合。</p>\n<h3 id=\"矩阵编码和逐个矩阵乘法\"><a href=\"#矩阵编码和逐个矩阵乘法\" class=\"headerlink\" title=\"矩阵编码和逐个矩阵乘法\"></a>矩阵编码和逐个矩阵乘法</h3><p>如上所述，本文使用 <em>Secure Out-sourced Matrix Computation and Application to Neural Networks</em> 的方案来使用SIMD进行高效的矩阵乘法，因此使用它们的矩阵编码。上面的方案区分从左侧相乘的矩阵和从右侧相乘的矩阵，并对每个矩阵使用不同的编码。设 $L$ 和 $R$ 是两个 $d\\times d$ 矩阵，我们希望计算 $A=L \\cdot R$，现在描述 $L$ 和 $R$ 的编码。</p>\n<h4 id=\"Type-L-和-Type-R-编码以及-Type-N-表示\"><a href=\"#Type-L-和-Type-R-编码以及-Type-N-表示\" class=\"headerlink\" title=\"Type-L 和 Type-R 编码以及 Type-N 表示\"></a>Type-L 和 Type-R 编码以及 Type-N 表示</h4><p>本文将矩阵 $L$（乘积中的左矩阵）的编码表示为 Type-L 编码，其由 $L$ 的 $d$ 个旋转 $L_1,…,L_d$ 组成，其中 $L_i$ 为一个 $L$ 旋转其行后计算得到的 $d \\times d$ 矩阵；类似地，将矩阵 $R$（乘积中的右矩阵）的编码表示为 Type-R 编码，也由 $d$ 个旋转组成，每个 $R_i$ 是 $R$ 旋转其列后得到的 $d \\times d$ 矩阵（例子见图4）。然后用 Type-N 表示不作任何处理的原始矩阵的排列。</p>\n<p>对于以上两种编码，个人的理解是（拿 $L$ 来说）：</p>\n<ul>\n<li>$L_1$：第 $i$ 行的元素往前移动 $i-1$ 个位置（前 $i-1$ 个移动到后面）；</li>\n<li>$L_2$：第 $i$ 行的元素往前移动 $i$ 个位置；</li>\n<li>以此类推：$L_j$：第 $i$ 行的元素往前移动 $i+j-2$ 个位置。</li>\n</ul>\n<p>$R$ 也是类似的。</p>\n<p>作者还说到可以将这 $d$ 个矩阵打包到较少数量的密文中，从而减少开销。具体地说，原来的矩阵表示需要 $d^2$ 密文，而本文的表示需要 $d \\cdot \\lceil \\frac{d^2}{\\mathsf{sl}} \\rceil$ 密文(当 $\\mathsf{sl} &gt; d$ 时，其优于 $d^2$)。</p>\n<h4 id=\"逐个矩阵乘法\"><a href=\"#逐个矩阵乘法\" class=\"headerlink\" title=\"逐个矩阵乘法\"></a>逐个矩阵乘法</h4><p><img src=\"http://images.yingwai.top/picgo/LoPEDf4.png\" alt=\"\"></p>\n<p>矩阵乘法的例子见上图，计算 $A = L \\cdot R$ 可以分解成计算 $A = \\sum^d_{i=1} A_i$，其中 $A_i = L_i \\odot R_i$ 为两个矩阵的对应元素相乘。</p>\n<p>在我们的协议中，我们将加密矩阵与公共矩阵相乘(参见图3中的步骤3a)。这是使用基础LHE方案的 $\\mathsf{Eval}$ 算法完成的，用 $\\mathsf{Eval}(\\mathsf{pk},\\mathsf{MatMult}, \\mathbf{L}, R)$ 表示在输入电路 $C<em>{\\mathsf{MatMult}, R}$ 和密文 $\\mathbf{L}$ 上运行 $\\mathsf{Eval}$，其中 $C</em>{\\mathsf{MatMult}, R}$ 输入一个矩阵 $L$ 的Type-L编码，计算输出得到其与一个公共矩阵 $R$ 的乘积 $A = L \\cdot R$。</p>\n<h4 id=\"通过序列化提高效率\"><a href=\"#通过序列化提高效率\" class=\"headerlink\" title=\"通过序列化提高效率\"></a>通过序列化提高效率</h4><p>本文通过将多个矩阵条目打包到单个密文中来提高效率（并克服了保存每个矩阵的多个旋转副本所带来的开销）。这是通过首先将 $d \\times d$ 矩阵表示(“序列化”)为长度为 $d^2$ 的向量来实现的。</p>\n<p><img src=\"http://images.yingwai.top/picgo/LoPEDf5.png\" alt=\"\"></p>\n<p>就是将矩阵从左到右、从上到下，按列的顺序打包到密文中。也就是说，$A$ 的元素 $A_{c,l}$ 出现在串行化后的 $A$ 的第 $((c−1)d+l)$ 个位置。然后，可以将串行化矩阵（如果需要则用零填充）加密成密文（打包到时隙中）。</p>\n<h3 id=\"向量表示\"><a href=\"#向量表示\" class=\"headerlink\" title=\"向量表示\"></a>向量表示</h3><p>本文描述了两种不同的矢量编码，每种编码都用于优化不同操作的复杂度。第一个编码称之为Type-M，允许高效的矩阵-向量乘法。第二种编码称之为Type-A，允许高效的向量相加。</p>\n<p><img src=\"http://images.yingwai.top/picgo/LoPEDf6.png\" alt=\"\"></p>\n<p>在计算矩阵-向量乘法时，首先将向量映射为一个 $d \\times d$ 矩阵（Type-M编码：其中第一列为向量，其余列用0填充），然后再将该矩阵编码为Type-R矩阵，进行矩阵乘法。而Type-A编码则是对Type-M矩阵的序列化。</p>\n<p>我们注意到，虽然可以对类型M编码执行加法，但它的效率低于将两个类型A编码相加。例如当 $\\mathsf{sl}=d$ 时，将两个Type-M向量相加需要 $d$ 次运算，但是添加两个Type-A编码只需要一次操作。</p>\n<p><img src=\"http://images.yingwai.top/picgo/LoPEDf7.png\" alt=\"\"></p>\n<p>Type-M编码的向量与Type-L编码的矩阵相乘得到的结果序列化后，直接把多余的0去掉就可以变成与Type-A编码的向量格式一致，从而可以直接把两个向量相加（例子见图7）。</p>\n","site":{"data":{}},"excerpt":"<p><em>Adi Akavia, Hayim Shaul, Mor Weiss, Zohar Yakhini</em></p>\n<p><a href=\"https://dl.acm.org/doi/proceedings/10.1145/3338469\" target=\"_blank\" rel=\"noopener\">WAHC’19: Proceedings of the 7th ACM Workshop on Encrypted Computing &amp; Applied Homomorphic Cryptography</a></p>\n<p><a href=\"https://dl.acm.org/doi/abs/10.1145/3338469.3358942\" target=\"_blank\" rel=\"noopener\">https://dl.acm.org/doi/abs/10.1145/3338469.3358942</a></p>","more":"<p><img src=\"http://images.yingwai.top/picgo/LoPED.png\" alt=\"\"></p>\n<h1 id=\"摘要\"><a href=\"#摘要\" class=\"headerlink\" title=\"摘要\"></a>摘要</h1><p>从包含大量独立样本的联合训练数据中开发机器学习模型是一项重要的任务，可以显著提高学习模型的潜在适用性和预测能力。由于单个用户(如医院或单个实验室)通常以高置信度收集不支持准确学习的数据集，因此希望在不损害数据隐私的情况下组合来自多个用户的数据。在这篇文章中，我们开发了一种隐私保护解决方案，用于从多方(“数据所有者”)共同贡献的数据中学习线性回归模型。我们的协议是基于Giacomelli等人的协议。(ACNS 2018)，利用两个非合谋服务器和线性同态加密(LHE)学习正则化线性回归模型。我们的方法使用不同的LHE方案，使我们能够显著减少同态操作的数量和运行时间，以及总的运行时间复杂度。我们协议的另一个优点是潜在的LHE方案基于与Giacomelli等人不同的(和后量子安全的)安全假设。我们的方法利用中国剩余定理和单指令多数据表示法来获得改进的性能。对于1000x40线性回归任务，对于同态操作，我们可以在总共3秒内学习到一个模型，而文献中报道的时间超过了100秒。我们的方法还可以扩展到更大的功能空间：我们实现了一个可以处理1000x100线性回归任务的系统，在数据所有者进行更重要的离线预处理之后，投入了数分钟的服务器计算时间。我们打算将我们的协议和实现整合到一个全面的系统中，该系统可以在更大范围内处理安全的联合学习。</p>\n<h2 id=\"本文贡献\"><a href=\"#本文贡献\" class=\"headerlink\" title=\"本文贡献\"></a>本文贡献</h2><ul>\n<li>线性-压缩加密数据的回归(LoPED)。提出了一种新的PPRR协议，称为“分组加密数据线性回归协议(LoPED)。</li>\n<li>同态计算时间加速：分析结果。与[6]相比，LoPED在同态运算的数量上提供了高达 $\\Theta(d^2)$ 的加速比，其中 $d$ 是特征的数量。更准确地说，加速比是 $\\Theta(\\mathsf{sl})$，其中 $\\mathsf{sl} \\leq d^2$ 是每个SIMD密文中封装的时隙数目。</li>\n<li>同态计算时间加速：实验结果。我们实现了我们的协议并进行了大量的实验，证明了同态运算(又名LHE-COMP)运行时的大幅加速；参见表1。</li>\n<li>安全性。LoPED基于后量子安全假设，与[6]中使用的基于Paillier的实现形成对比；这是我们系统的一个额外优势。</li>\n</ul>\n<h1 id=\"PRELIMINARIES\"><a href=\"#PRELIMINARIES\" class=\"headerlink\" title=\"PRELIMINARIES\"></a>PRELIMINARIES</h1><h2 id=\"岭回归\"><a href=\"#岭回归\" class=\"headerlink\" title=\"岭回归\"></a>岭回归</h2><p>线性回归的损失函数：</p>\n<script type=\"math/tex; mode=display\">\nf(w) = \\sum^m_{i = 1} \\left(y_i - x^T_i w \\right)^2</script><p>于是 $\\boldsymbol{w}$ 的最优解为</p>\n<script type=\"math/tex; mode=display\">\n\\hat{\\boldsymbol{w}}^{*}=\\underset{\\hat{\\boldsymbol{w}}}{\\arg \\min }(\\boldsymbol{y}-\\mathbf{X} \\hat{\\boldsymbol{w}})^{\\mathrm{T}}(\\boldsymbol{y}-\\mathbf{X} \\hat{\\boldsymbol{w}})</script><p>对 $\\hat{\\boldsymbol{w}}$ 求导并令导数为零，当 $\\mathbf{X}^{\\mathrm{T}} \\mathbf{X}$ 为满秩或正定矩阵时可得</p>\n<script type=\"math/tex; mode=display\">\n\\hat{\\boldsymbol{w}}^{*}=\\left(\\mathbf{X}^{\\mathrm{T}} \\mathbf{X}\\right)^{-1} \\mathbf{X}^{\\mathrm{T}} \\boldsymbol{y}</script><p>然而现实中 $\\mathbf{X}^{\\mathrm{T}} \\mathbf{X}$ 往往不是满秩矩阵。例如在许多任务中会遇到大量的变量，其数目甚至超过样例数，导致 $\\mathbf{X}$ 的列数多于行数，$\\mathbf{X}^{\\mathrm{T}} \\mathbf{X}$ 显然不满秩。从上式可以看出在计算回归系数的时候，我们需要计算矩阵 $\\mathbf{X}^{\\mathrm{T}} \\mathbf{X}$ 的逆，但是如果该矩阵是个奇异矩阵，则无法对其进行求解。</p>\n<p>因此如果出现上面的情况，我们需要对最初的标准线性回归做一定的变化使原先无法求逆的矩阵变得非奇异，使得问题可以稳定求解。我们可以通过缩减的方式来处理这些问题，例如岭回归。</p>\n<p>岭回归是在标准线性回归的损失函数基础上添加了一个惩罚项 $\\lambda \\sum^n_{i=1} w^2_i$，称为L2正则化。</p>\n<p>这个时候损失函数的形式为</p>\n<script type=\"math/tex; mode=display\">\nf(w) = \\sum^m_{i = 1} \\left(y_i - x^T_i w \\right)^2 + \\lambda \\sum^n_{i=1} w^2_i</script><p>将岭回归系数用矩阵的形式表示：</p>\n<script type=\"math/tex; mode=display\">\n\\hat{w}=\\left(X^{T} X+\\lambda I\\right)^{-1} X^{T} y</script><p>可以看到，就是通过将 $\\mathbf{X}^{\\mathrm{T}} \\mathbf{X}$ 加上一个单位矩阵似的矩阵变成非奇异矩阵并可以进行求逆运算。</p>\n<h2 id=\"线性同态加密-LHE\"><a href=\"#线性同态加密-LHE\" class=\"headerlink\" title=\"线性同态加密(LHE)\"></a>线性同态加密(LHE)</h2><p>LHE是一种公钥加密方案，它允许人们在不知道秘密解密密钥的情况下，在加密的“幕后”执行线性运算。我们假设在密钥生成过程中，可以通过指定 $N \\in \\mathbb{N}$ 来选择明文空间，从而执行模 $N$ 的同态运算。这是通过将明文模 $N$ 显式地合并到方案的排列中来实现的。</p>\n<p>线性同态加密(LHE)方案 $\\mathcal{E}=(\\mathsf{KG}, \\mathsf{Enc},\\mathsf{Dec},\\mathsf{Eval}) $ 由四个算法组成，其中 $\\mathsf{KG}, \\mathsf{Enc}$ 和 $\\mathsf{Eval}$ 是PPT算法，$\\mathsf{Dec}$ 是(确定性)多项式时间。算法具有以下语法：</p>\n<ul>\n<li>$\\mathsf{KG}(1^\\sigma, N)$ 将安全参数 $σ$ 和 $N \\in \\mathbb{N}$ 作为输入。它输出一对公开和秘密加密密钥 $(\\mathsf{pk}, \\mathsf{sk})$。我们假设  $\\mathsf{pk}$ 在其描述中包含 $N$，而不失一般性。</li>\n<li>$\\mathsf{Enc}(\\mathsf{pk}, \\mathsf{msg})$ 将公钥 $\\mathsf{pk}$ 和消息 $\\mathsf{msg} \\in \\mathbb{Z}_N$ 作为输入，输出密文 $\\mathsf{c}$。</li>\n<li>$\\mathsf{Dec}(\\mathsf{sk},\\mathsf{c})$ 将秘密解密密钥 $\\mathsf{sk}$ 和密文 $\\mathsf{c}$ 作为输入，并输出明文消息 $\\mathsf{msg’}$。</li>\n<li>$\\mathsf{Eval}(\\mathsf{pk}, C, \\mathsf{c}_1,…, \\mathsf{c}_k)$ 将公钥 $\\mathsf{pk}$、电路 $C: \\mathbb{Z}^k_N \\rightarrow \\mathbb{Z}^l_N$，其中 $l, k \\in \\mathbb{N}$ 和 $k$ 个密文 $\\mathsf{c}_1,…,\\mathsf{c}_k$ 作为输入，并输出 $l$ 个密文 $(\\mathsf{c}’_1,…,\\mathsf{c}’_l)$。</li>\n</ul>\n<h1 id=\"问题陈述\"><a href=\"#问题陈述\" class=\"headerlink\" title=\"问题陈述\"></a>问题陈述</h1><h2 id=\"在联合数据上的岭回归\"><a href=\"#在联合数据上的岭回归\" class=\"headerlink\" title=\"在联合数据上的岭回归\"></a>在联合数据上的岭回归</h2><p>由于每个用户所拥有的数据样本是有限的，往往训练不出来比较好的模型。于是很自然地可以想到与其他用户一起来训练一个模型，每个用户都将自己的数据提供出来，此时样本的数量就足以训练出一个好的模型。这里不同用户的数据样本都是具有同样特征的。</p>\n<p>但这样就会有隐私泄露的问题，用户都不想别人知道自己的数据，于是就需要引入隐私保护。这里假设协议的参与者都是城市且好奇的。</p>\n<h2 id=\"Privacy-Preserving-Ridge-Regression-with-only-Linearly-Homomorphic-Encryption-中的方案\"><a href=\"#Privacy-Preserving-Ridge-Regression-with-only-Linearly-Homomorphic-Encryption-中的方案\" class=\"headerlink\" title=\"Privacy-Preserving Ridge Regression with only Linearly-Homomorphic Encryption 中的方案\"></a>Privacy-Preserving Ridge Regression with only Linearly-Homomorphic Encryption 中的方案</h2><p>在这篇文章之前最好的双服务器模型PPRR方案是 <a href=\"https://yuyingwai.cn/2020/08/10/论文笔记-Privacy-Preserving-Ridge-Regression-with-only-Linearly-Homomorphic-Encryption/\" target=\"_blank\" rel=\"noopener\"><em>Privacy-Preserving Ridge Regression with only Linearly-Homomorphic Encryption</em></a> 中的方案，如图1所示，</p>\n<p><img src=\"http://images.yingwai.top/picgo/LoPEDf1.png\" alt=\"\"></p>\n<p>该协议对参数 $n, d, \\ell, \\lambda$ 进行操作，并选择明文环 $\\mathbb{Z}_N$ 满足：</p>\n<script type=\"math/tex; mode=display\">\nN > 2d(d - 1)^{\\frac{d-1}{2}}10^{4\\ell d}(n^2 + \\lambda)^{2d} \\tag{1}</script><p>在初始化阶段，$\\mathcal{S}_2$ 生成LHE密钥 $(\\mathsf{pk}, \\mathsf{sk})$，然后发布公钥 $\\mathsf{pk}$。然后该协议对在多个数据所有者之间水平划分的输入 $(X|\\vec{y}) \\in \\mathbb{R}^{n \\times (d+1)}$ 训练岭回归模型，如下所示。</p>\n<ol>\n<li>首先每个数据拥有者计算其对于 $d \\times d$ 矩阵 $A = X^T X + \\lambda I$ 的份额，将其缩放为嵌入 $\\mathbb{Z}_N$ 的整数值，用LHE方案加密该份额，并将密文发送给 $\\mathcal{S}_1$。用类似的方式计算 $\\vec{b} = X^T \\cdot \\vec{y}$。</li>\n<li>其次 $\\mathcal{S}_1$ 将所有的份额结合起来获得 $A$ 的逐项输入加密 $\\mathbf{A}$，假设其在 $\\mathbb{Z}^{d \\times d}_N$ 中是可逆的。然后 $\\mathcal{S}_1$ 使用同态性质对 $A$ 进行盲化，具体为 $\\mathcal{S}_1$ 使用LHE计算 $A \\cdot R$ 的加密 $\\mathbf{C}$，其中 $R \\in \\mathsf{GL}(d, \\mathbb{Z}_N)$ 是一个随机的可逆矩阵。用类似的方法盲化 $\\vec{b}$，得到 $\\vec{\\mathbf{v}}$ 为加密后的 $\\vec{v} = \\vec{b} + A \\cdot \\vec{r}$，其中 $r \\in \\mathbb{Z}^d_N$ 是一致随机的。然后 $\\mathcal{S}_1$ 将 $\\mathbf{C}$ 和 $\\vec{\\mathbf{v}}$ 发送给 $\\mathcal{S}_2$。</li>\n<li>$\\mathcal{S}_2$ 使用密钥解密，求解线性系统 $C \\cdot \\vec{w}^<em> = \\vec{v} \\bmod N$ 来获得盲化后的模型 $\\vec{w}^</em>$，然后发送给 $\\mathcal{S}_1$。</li>\n<li>最后 $\\mathcal{S}_1$ 去除盲化获得模型 $\\vec{w}’ = R \\cdot \\vec{w}^* - \\vec{r} \\in \\mathbb{Z}^d_N$。对 $\\vec{w}’$ 使用有理数重构获得输出模型 $\\vec{w} \\in \\mathbb{Q}^d$，然后 $\\mathcal{S}_1$ 对各方进行广播。</li>\n</ol>\n<h1 id=\"本文的隐私保护岭回归协议\"><a href=\"#本文的隐私保护岭回归协议\" class=\"headerlink\" title=\"本文的隐私保护岭回归协议\"></a>本文的隐私保护岭回归协议</h1><p>本文的模型与 <em>Privacy-Preserving Ridge Regression with only Linearly-Homomorphic Encryption</em> 中的模型一样，主要包括两个主体：数据拥有者 $DO$ 和服务器 $\\mathcal{S}$。其中数据拥有者的数量是已知的；服务器有两个，$\\mathcal{S}_1$ 负责将 $DO$ 的数据聚合，$\\mathcal{S}_2$ 负责更新权重。分为了三个阶段：初始化、上传输入和训练阶段。</p>\n<p><img src=\"http://images.yingwai.top/picgo/LoPEDf2.png\" alt=\"\"></p>\n<h2 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h2><p>初始化（图2）包括 $\\mathcal{S}_2$ 生成LHE方案密钥，和发布公钥。</p>\n<p>由于 <em>Privacy-Preserving Ridge Regression with only Linearly-Homomorphic Encryption</em> 中的明文模数太大，而HElib和SEAL分别只支持62位和60位的明文模数，因此本文使用了中国剩余定理(CRT)来将明文空间缩小，使用 $\\mathbb{Z}<em>{p_1},…,\\mathbb{Z}</em>{p<em>t}$ 中的消息列表来表示 $\\mathbb{Z}_N$ 中的消息，使得 $N = \\prod^t</em>{i=1} p_i$，每个模 $p_i$ 需要独立的加密密钥也由 $\\mathcal{S}_2$ 来生成。（前面提到的另一个方案中的操作是直接在 $\\mathbb{Z}_N$ 中进行的，因此 $\\mathcal{S}_2$ 仅生成一对密钥 $(\\mathsf{pk}, \\mathsf{sk})$。）</p>\n<h2 id=\"上传输入\"><a href=\"#上传输入\" class=\"headerlink\" title=\"上传输入\"></a>上传输入</h2><p>在图一中我们假设输入在数据拥有者之间水平分割，类似横向联邦学习（样本的联合）。</p>\n<p>令 $X \\in \\mathbb{R}^{n \\times d}, \\vec{y} \\in \\mathbb{R}^{n \\times 1}$ 分别表示数据矩阵和响应向量，于是存在 $[n]$ 的分割 $I<em>1,…,I_m$ 使得 $DO_j$ 拥有 $X^j = X</em>{I<em>j} = (X_k : k \\in I_j)$（$X_k$ 表示 $X$ 的第 $k$ 行）和 $\\vec{y}^j = \\vec{y}</em>{I<em>j} = (y_k)</em>{k \\in I<em>j}$。这些输入按比例缩放并嵌入到足够大的 $N$ 的 $\\mathbb{Z}_N$ 中（有关 $N$ 的要求请参见公式1）。对每个 $1 \\leq j \\leq m$，令 $A^j = \\sum</em>{k \\in I<em>j} \\left(X^j_k \\right)^T \\cdot X^j_k \\in \\mathbb{Z}^{d \\times d}_N$，和 $\\vec{b}_j = \\sum</em>{k \\in I_j} X^j_k \\cdot \\vec{y}^j_k \\in \\mathbb{Z}^d_N$。每个 $DO_j$ 在本地从他的输入计算 $A^j, \\vec{b}^j$，计算</p>\n<script type=\"math/tex; mode=display\">\nA^{j,p_i} = \\left(A^j \\bmod p_i \\right) \\quad \\mathrm{and} \\quad \\vec{b}^{j, p_i} = \\left(\\vec{b}^j \\bmod p_i \\right)</script><p>然后发送加密后的 $A^{j, p_i}, \\vec{b}^{j, p_i}, i \\in [t]$ 给 $\\mathcal{S}_1$。</p>\n<h2 id=\"训练\"><a href=\"#训练\" class=\"headerlink\" title=\"训练\"></a>训练</h2><p><img src=\"http://images.yingwai.top/picgo/LoPEDf3.png\" alt=\"\"></p>\n<p>在这个阶段，$\\mathcal{S}_1$ 结合以及盲化来自所有数据拥有者的数据，$\\mathcal{S}_2$ 对盲化后的数据执行学习。</p>\n<p>在使用下面的方式将来自所有数据拥有者的数据组合后可以获得 $A = X^T X + \\lambda I$（其中 $\\lambda$ 是图1中的正则化参数，$I$ 是单位矩阵）和 $\\vec{b} = X^T \\vec{y}$：在前一个阶段 $\\mathcal{S}_1$ 获得了 $A^1,…,A^m$ 和 $\\vec{b}^1,…,\\vec{b}^m$，于是有</p>\n<script type=\"math/tex; mode=display\">\nA = \\sum^{m}_{j=1} A_j + \\lambda I \\quad \\mathrm{and} \\quad b = \\sum^m_{j=1} b_j</script><p>因为本文使用CRT表示，需要计算 $A^{p_i} = A \\bmod p_i$ 和 $\\vec{b}^{p_i} = \\vec{b} \\bmod p_i$ 对每个 $i \\in [t]$，而不是 $A, \\vec{b}$。为此，$\\mathcal{S}_1$ 使用LHE方案的线性同态从 $A^{j, p_i}, \\vec{b}^{j, p_i}$ 计算 $A^{p_i}, \\vec{b}^{p_i}$（参见图3中的步骤1）。</p>\n<p>本文的盲化方法类似3.2小节中的描述，但需要进行一些修改去兼容CRT表示。具体地说，$\\mathcal{S}<em>1$ 选择一个随机的可逆矩阵 $R \\in \\mathbb{Z}^{d \\times d}</em>{N}$ 和随机的 $\\vec{r} \\in \\mathbb{Z}^d<em>N$，然后计算 $C = A \\cdot R$ 和 $\\vec{v} = \\vec{b} + A \\cdot \\vec{r}$。另外，由于对每个 $i \\in [t]$，对 $A^{p_i}, \\vec{b}^{p_i}$ 的操作是在 $\\mathbb{Z}</em>{p_i}$ 内的，所以使用 $R^{p_i} = R \\bmod p_i$ 和 $\\vec{r}^{p_i} = \\vec{r} \\bmod p_i$ 来执行盲化，于是盲化后的数据矩阵和响应向量分别为 $C^{p_i} = A^{p_i} \\cdot R^{p_i} \\bmod p_i$ 和 $\\vec{v}^{p_i} = \\vec{b}^{p_i} + A^{p_i} \\cdot \\vec{r}^{p_i} \\bmod p_i$（见图3中的步骤3a）。$C^{p_i}, \\vec{v}^{p_i}$ 是由 $\\mathcal{S}_1$ 使用LHE方案的线性同态来计算的，然后发送给 $\\mathcal{S}_2$。$\\mathcal{S}_2$ 解密这些密文来获取 $C^{p_i}, \\vec{v}^{p_i}, i \\in [t]$，然后使用CRT重构来恢复 $C, \\vec{v}$。</p>\n<p>然后 $\\mathcal{S}_2$ 计算 $C^{-1} = \\mathsf{adj}(C) / \\mathsf{det}(C)$（其中 $\\mathsf{adj}(C), \\mathsf{det}(c)$ 分别表示 $C$ 的伴随矩阵和行列式）来求解线性系统 $C \\cdot \\vec{w} = \\vec{v}$，获得盲化后的模型 $\\vec{w}^<em>$ 并发送给 $\\mathcal{S}_1$。于是 $\\mathcal{S}_1$ 可以计算 $\\vec{w} = R \\cdot \\vec{w}^</em> - \\vec{r}$ 来去盲化。这给出了 $\\mathbb{Z}^d_N$ 中的一个模型，$\\mathbb{Q}^d$ 中的相应模型可以使用有理重构从该模型中重构出来(参见第3.2节中的讨论)。</p>\n<h1 id=\"将SIMD集成到LoPED\"><a href=\"#将SIMD集成到LoPED\" class=\"headerlink\" title=\"将SIMD集成到LoPED\"></a>将SIMD集成到LoPED</h1><h2 id=\"SIMD背景知识\"><a href=\"#SIMD背景知识\" class=\"headerlink\" title=\"SIMD背景知识\"></a>SIMD背景知识</h2><p>支持单指令多数据(SIMD)的加密方案和实现包括：Brakerski-Gentry-Vaikuntanathan和Fan-Vercauteren的基于RLWE的方案(通常称为BGV/FV)及其在HElib和SEAL库中的实现。这些方案允许在单个密文中将多个消息“打包”在不同的“槽”中。本文将打包参数，即打包在一个密文中的消息数目记为 $\\mathsf{sl}$，并且密文中的不同时隙记为 $\\mathbf{c} = (\\mathbf{c}(1),…,\\mathbf{c}(\\mathsf{sl}))$。对打包密文的操作以SIMD（单指令多数据）方式完成。例如，由 $c=a \\odot b$ 表示的SIMD乘法定义为 $\\mathbf{c}(i) = \\mathbf{a}(i) \\odot \\mathbf{b}(i)$，其中 $i = 1,…,\\mathsf{sl}$。</p>\n<p>重要的是要注意，在整个计算过程中幼稚地使用SIMD可能不会提高效率，因为涉及不同时隙上的计算的操作(例如，矩阵乘法，见下文)会招致高开销，这实际上可能会损害效率。</p>\n<h2 id=\"将SIMD集成到LoPED-1\"><a href=\"#将SIMD集成到LoPED-1\" class=\"headerlink\" title=\"将SIMD集成到LoPED\"></a>将SIMD集成到LoPED</h2><p>首先看看LoPED中同态计算的操作：</p>\n<ol>\n<li>向量相加（图3步骤1）</li>\n<li>矩阵相加（图3步骤1）</li>\n<li>矩阵相乘（图3步骤3a）</li>\n<li>矩阵向量乘法（图3步骤3a）</li>\n</ol>\n<p>在这些操作中最昂贵的是第三个，因此本文将其与作者引入的矢量的新表示法以及作者为有效执行上述其他操作而设计的新协议相结合。</p>\n<h3 id=\"矩阵编码和逐个矩阵乘法\"><a href=\"#矩阵编码和逐个矩阵乘法\" class=\"headerlink\" title=\"矩阵编码和逐个矩阵乘法\"></a>矩阵编码和逐个矩阵乘法</h3><p>如上所述，本文使用 <em>Secure Out-sourced Matrix Computation and Application to Neural Networks</em> 的方案来使用SIMD进行高效的矩阵乘法，因此使用它们的矩阵编码。上面的方案区分从左侧相乘的矩阵和从右侧相乘的矩阵，并对每个矩阵使用不同的编码。设 $L$ 和 $R$ 是两个 $d\\times d$ 矩阵，我们希望计算 $A=L \\cdot R$，现在描述 $L$ 和 $R$ 的编码。</p>\n<h4 id=\"Type-L-和-Type-R-编码以及-Type-N-表示\"><a href=\"#Type-L-和-Type-R-编码以及-Type-N-表示\" class=\"headerlink\" title=\"Type-L 和 Type-R 编码以及 Type-N 表示\"></a>Type-L 和 Type-R 编码以及 Type-N 表示</h4><p>本文将矩阵 $L$（乘积中的左矩阵）的编码表示为 Type-L 编码，其由 $L$ 的 $d$ 个旋转 $L_1,…,L_d$ 组成，其中 $L_i$ 为一个 $L$ 旋转其行后计算得到的 $d \\times d$ 矩阵；类似地，将矩阵 $R$（乘积中的右矩阵）的编码表示为 Type-R 编码，也由 $d$ 个旋转组成，每个 $R_i$ 是 $R$ 旋转其列后得到的 $d \\times d$ 矩阵（例子见图4）。然后用 Type-N 表示不作任何处理的原始矩阵的排列。</p>\n<p>对于以上两种编码，个人的理解是（拿 $L$ 来说）：</p>\n<ul>\n<li>$L_1$：第 $i$ 行的元素往前移动 $i-1$ 个位置（前 $i-1$ 个移动到后面）；</li>\n<li>$L_2$：第 $i$ 行的元素往前移动 $i$ 个位置；</li>\n<li>以此类推：$L_j$：第 $i$ 行的元素往前移动 $i+j-2$ 个位置。</li>\n</ul>\n<p>$R$ 也是类似的。</p>\n<p>作者还说到可以将这 $d$ 个矩阵打包到较少数量的密文中，从而减少开销。具体地说，原来的矩阵表示需要 $d^2$ 密文，而本文的表示需要 $d \\cdot \\lceil \\frac{d^2}{\\mathsf{sl}} \\rceil$ 密文(当 $\\mathsf{sl} &gt; d$ 时，其优于 $d^2$)。</p>\n<h4 id=\"逐个矩阵乘法\"><a href=\"#逐个矩阵乘法\" class=\"headerlink\" title=\"逐个矩阵乘法\"></a>逐个矩阵乘法</h4><p><img src=\"http://images.yingwai.top/picgo/LoPEDf4.png\" alt=\"\"></p>\n<p>矩阵乘法的例子见上图，计算 $A = L \\cdot R$ 可以分解成计算 $A = \\sum^d_{i=1} A_i$，其中 $A_i = L_i \\odot R_i$ 为两个矩阵的对应元素相乘。</p>\n<p>在我们的协议中，我们将加密矩阵与公共矩阵相乘(参见图3中的步骤3a)。这是使用基础LHE方案的 $\\mathsf{Eval}$ 算法完成的，用 $\\mathsf{Eval}(\\mathsf{pk},\\mathsf{MatMult}, \\mathbf{L}, R)$ 表示在输入电路 $C<em>{\\mathsf{MatMult}, R}$ 和密文 $\\mathbf{L}$ 上运行 $\\mathsf{Eval}$，其中 $C</em>{\\mathsf{MatMult}, R}$ 输入一个矩阵 $L$ 的Type-L编码，计算输出得到其与一个公共矩阵 $R$ 的乘积 $A = L \\cdot R$。</p>\n<h4 id=\"通过序列化提高效率\"><a href=\"#通过序列化提高效率\" class=\"headerlink\" title=\"通过序列化提高效率\"></a>通过序列化提高效率</h4><p>本文通过将多个矩阵条目打包到单个密文中来提高效率（并克服了保存每个矩阵的多个旋转副本所带来的开销）。这是通过首先将 $d \\times d$ 矩阵表示(“序列化”)为长度为 $d^2$ 的向量来实现的。</p>\n<p><img src=\"http://images.yingwai.top/picgo/LoPEDf5.png\" alt=\"\"></p>\n<p>就是将矩阵从左到右、从上到下，按列的顺序打包到密文中。也就是说，$A$ 的元素 $A_{c,l}$ 出现在串行化后的 $A$ 的第 $((c−1)d+l)$ 个位置。然后，可以将串行化矩阵（如果需要则用零填充）加密成密文（打包到时隙中）。</p>\n<h3 id=\"向量表示\"><a href=\"#向量表示\" class=\"headerlink\" title=\"向量表示\"></a>向量表示</h3><p>本文描述了两种不同的矢量编码，每种编码都用于优化不同操作的复杂度。第一个编码称之为Type-M，允许高效的矩阵-向量乘法。第二种编码称之为Type-A，允许高效的向量相加。</p>\n<p><img src=\"http://images.yingwai.top/picgo/LoPEDf6.png\" alt=\"\"></p>\n<p>在计算矩阵-向量乘法时，首先将向量映射为一个 $d \\times d$ 矩阵（Type-M编码：其中第一列为向量，其余列用0填充），然后再将该矩阵编码为Type-R矩阵，进行矩阵乘法。而Type-A编码则是对Type-M矩阵的序列化。</p>\n<p>我们注意到，虽然可以对类型M编码执行加法，但它的效率低于将两个类型A编码相加。例如当 $\\mathsf{sl}=d$ 时，将两个Type-M向量相加需要 $d$ 次运算，但是添加两个Type-A编码只需要一次操作。</p>\n<p><img src=\"http://images.yingwai.top/picgo/LoPEDf7.png\" alt=\"\"></p>\n<p>Type-M编码的向量与Type-L编码的矩阵相乘得到的结果序列化后，直接把多余的0去掉就可以变成与Type-A编码的向量格式一致，从而可以直接把两个向量相加（例子见图7）。</p>"},{"title":"论文笔记 Oblivious Neural Network Predictions via MiniONN Transformations","date":"2020-05-26T08:09:23.000Z","_content":"\n*Jian Liu, Mika Juuti, Yao Lu, N. Asokan*\n\nCCS 2017\n\nhttps://dl.acm.org/doi/10.1145/3133956.3134056\n\n<!--more-->\n\n\n\n# 摘要\n\n托管在云服务中的机器学习模型越来越受欢迎，但存在隐私风险：向该服务发送预测请求的客户端需要披露潜在的敏感信息。在本文中，我们探讨了隐私保护预测问题：在每次预测之后，服务器对客户端的输入一无所知，客户端对模型一无所知。\n\n我们提出了MiniONN，这是第一种将现有的神经网络转换为不经意的神经网络的方法，该网络以合理的效率支持隐私保护预测。与以前的工作不同，MiniONN不需要改变模型的训练方式。为此，我们为神经网络预测模型中常用的操作设计了健忘协议。我们证明了MiniONN在响应延迟和消息大小方面优于现有的工作。通过对标准数据集训练的几种典型神经网络模型的变换，证明了MiniONN的广泛适用性。\n\n**关键词**：隐私；机器学习；神经网络预测；安全两方计算\n\n\n\n## 贡献\n\n* 提出了MiniONN，这是第一个**可以将任何普通神经网络模型转换为不经意神经网络**的技术，而不需要对训练阶段进行任何修改。\n* **为神经网络预测中的常见操作设计了不经意的协议**。特别地，作者**使非线性函数(例如，Sigmoid和tanh)服从于作者的ONN变换**，而精确度损失可以忽略不计。\n* 构建了**MiniONN的完整实现**，并通过使用它来**转换从几个标准数据集训练**的神经网络模型来展示其广泛的适用性。特别是，对于从MNIST数据集[38]训练的相同模型，MiniONN的性能**明显**好于以前的工作[28, 44]。\n* 分析了**模型复杂性对转换后的ONN的预测精度和计算/通信开销的影响**。讨论了神经网络设计者如何在预测精度和开销之间选择合适的折衷方案。\n\n\n\n# BACKGROUND AND PRELIMINARIES\n\n![](http://images.yingwai.top/picgo/minionnt1.png)\n\n<center>\n    <i>表1 符号表示</i>\n</center>\n\n\n\n# MiniONN概述\n\n在本节中，通过转换以下形式的神经网络来解释MiniONN的基本思想：\n$$\n\\mathbf{z} := \\mathbf{W'} \\cdot f(\\mathbf{W} \\cdot \\mathbf{x} + \\mathbf{b}) + \\mathbf{b'} \\tag{4}\n$$\n其中$\\mathbf{x} = \\left[ \\begin{matrix} x_1\\\\ x_2 \\end{matrix} \\right]$，$\\mathbf{W} = \\left[ \\begin{matrix} w_{1,1} & w_{1,2}\\\\ w_{2,1} & w_{2,2} \\end{matrix} \\right]$，$\\mathbf{b} = \\left[ \\begin{matrix} b_1\\\\ b_2 \\end{matrix} \\right]$，$\\mathbf{W'} = \\left[ \\begin{matrix} w'_{1,1} & w'_{1,2}\\\\ w'_{2,1} & w'_{2,2} \\end{matrix} \\right]$ 以及 $\\mathbf{b'} = \\left[ \\begin{matrix} b'_1\\\\ b'_2 \\end{matrix} \\right]$。\n\nMiniONN的核心思想是让 $\\mathcal{S}$ 和 $\\mathcal{C}$ 加法共享神经网络每一层的输入和输出值。也就是说，在每一层的开始，$\\mathcal{S}$ 和 $\\mathcal{C}$ 将各自持有一份“份额”，使得份额的模加等于该神经网络的非不经意版本中对该层的输入。输出值将用作下一层的输入。\n\n为此，让 $\\mathcal{S}$ 和 $\\mathcal{C}$ 首先进入预计算阶段(该阶段独立于 $\\mathcal{C}$ 的输入$\\mathbf{x}$)，在该阶段中，它们为权重矩阵的每一行(在本例中为 $\\mathbf{W}$ 和 $\\mathbf{W'}$)联合生成一组点积三元组 $\\left \\langle u,v,\\mathbf{w} \\cdot \\mathbf{r} \\right \\rangle$。具体地说，对于 $\\mathbf{w}$的每一行，$\\mathcal{S}$ 和 $\\mathcal{C}$，运行一个协议，该协议安全地实现理想功能 $\\mathcal{F}$ 三元组(在图1中)，以生成点积三元组，从而：\n$$\n\\begin{align}\nu_1 + v_1 (\\bmod N) &= w_{1,1} r_1 + w_{1,2} r_2,\\\\\nu_2 + v_2 (\\bmod N) &= w_{2,1} r_1 + w_{2,2} r_2,\\\\\nu'_1 + v'_1 (\\bmod N) &= w'_{1,1} r'_1 + w'_{1,2} r'_2,\\\\\nu'_2 + v'_2 (\\bmod N) &= w'_{2,1} r'_1 + w'_{2,2} r'_2.\n\\end{align}\n$$\n![](http://images.yingwai.top/picgo/minionnf1.png)\n\n<center>\n    <i>图1 理想的生成点积三元组的功能</i>\n</center>\n\n当 $\\mathcal{C}$ 想要请求 $\\mathcal{S}$ 计算向量 $\\mathbf{x}=[x_1,x_2]$ 的预测时，对于每个 $x_i$，$\\mathcal{C}$ 选择在预计算阶段中生成的三元组，并使用它的 $r_i$ 来盲化 $x_i$。\n$$\n\\begin{align}\nx_1^{\\mathcal{C}} &:= r_1, x_1^{\\mathcal{S}} := x_1 - r_1 (\\bmod N),\\\\\nx_2^{\\mathcal{C}} &:= r_2, x_2^{\\mathcal{S}} := x_2 - r_2 (\\bmod N).\n\\end{align}\n$$\n然后 $\\mathcal{C}$ 然后发送 $\\mathbf{x}^{\\mathcal{S}}$ 给 $\\mathcal{S}$，$\\mathcal{S}$ 计算\n$$\n\\begin{align}\ny_1^{\\mathcal{S}} &:= w_{1,1} x_1^{\\mathcal{S}} + w_{1,2} x_2^{\\mathcal{S}} + b_1 + u_1 (\\bmod N),\\\\\ny_2^{\\mathcal{S}} &:= w_{2,1} x_1^{\\mathcal{S}} + w_{2,2} x_2^{\\mathcal{S}} + b_2 + u_2 (\\bmod N).\n\\end{align}\n$$\n同时，$\\mathcal{C}$ 设：\n$$\n\\begin{align}\ny_1^{\\mathcal{C}} &:= v_1 (\\bmod N),\\\\\ny_2^{\\mathcal{C}} &:= v_2 (\\bmod N).\n\\end{align}\n$$\n显然\n$$\n\\begin{align}\ny_1^{\\mathcal{C}} + y_1^{\\mathcal{S}} &= w_{1,1} x_1 + w_{1,2} x_2 + b_1 (\\bmod N),\\\\\ny_2^{\\mathcal{C}} + y_2^{\\mathcal{S}} &= w_{2,1} x_1 + w_{2,2} x_2 + b_2 (\\bmod N).\n\\end{align}\n$$\n因此，在此交互结束时，$\\mathcal{S}$ 和 $\\mathcal{C}$ 相加地共享由层1中的线性变换产生的输出值 $\\mathbf{y}$，而不需要 $\\mathcal{S}$ 学习输入 $\\mathbf{x}$，任何一方都不学习 $\\mathbf{y}$。\n\n对于激活/池化操作 $f()$，$\\mathcal{S}$ 和 $\\mathcal{C}$ 运行安全地实现图2中的理想功能的协议，该协议隐式地重构每个 $y_i := y^{\\mathcal{C}}_i + y^{\\mathcal{S}}_i (\\bmod N)$ 并返回 $x^{\\mathcal{S}}_i := f(y_i) - x^{\\mathcal{C}}_i$ 给 $\\mathcal{S}$，其中 $x^{\\mathcal{C}}_i$ 是来自预计算阶段的先前共享的三元组的 $\\mathcal{C}$ 分量，即 $x_1^{\\mathcal{C}} := r'_1$ 和 $x_2^{\\mathcal{C}} := r'_2$。\n\n![](http://images.yingwai.top/picgo/minionnf2.png)\n\n<center>\n    <i>图2 理想的不经意激活/池化f()的功能</i>\n</center>\n\n最后一层的变换与第一层相同。也就是说，$\\mathcal{S}$ 计算：\n$$\n\\begin{align}\ny_1^{\\mathcal{S}} &:= w'_{1,1} x_1^{\\mathcal{S}} + w'_{1,2} x_2^{\\mathcal{S}} + b'_1 + u'_1 (\\bmod N),\\\\\ny_2^{\\mathcal{S}} &:= w'_{2,1} x_1^{\\mathcal{S}} + w'_{2,2} x_2^{\\mathcal{S}} + b'_2 + u'_2 (\\bmod N);\n\\end{align}\n$$\n$\\mathcal{C}$ 设：\n$$\n\\begin{align}\ny_1^{\\mathcal{C}} &:= v'_1 (\\bmod N),\\\\\ny_2^{\\mathcal{C}} &:= v'_2 (\\bmod N),\n\\end{align}\n$$\n最后，$\\mathcal{S}$ 将 $[y_1^{\\mathcal{S}}, y_2^{\\mathcal{S}}]$ 返回给 $\\mathcal{C}$，$\\mathcal{C}$ 输出最终预测：\n$$\n\\begin{align}\nz_1 &:= y_1^{\\mathcal{C}} + y_1^{\\mathcal{S}},\\\\\nz_2 &:= y_2^{\\mathcal{C}} + y_2^{\\mathcal{S}}.\n\\end{align}\n$$\n注意到MiniONN在 $\\mathbb{Z}_N$ 中工作，而神经网络需要浮点计算。一种简单地解决办法是把神经网络中的值与一个固定的常数相乘，将小数部分放大到整数。一种类似的技术被用来减少神经网络预测中的存储器需求，而精确度损失可以忽略不计[42]。必须确保任何(中间)结果的绝对值不会超过 $\\lfloor N/2 \\rfloor$。","source":"_posts/论文笔记-Oblivious-Neural-Network-Predictions-via-MiniONN-Transformations.md","raw":"---\ntitle: 论文笔记 Oblivious Neural Network Predictions via MiniONN Transformations\ndate: 2020-05-26 16:09:23\ncategories: Papers\ntags: [密码学, PPML, MPC, Neural Network]\n---\n\n*Jian Liu, Mika Juuti, Yao Lu, N. Asokan*\n\nCCS 2017\n\nhttps://dl.acm.org/doi/10.1145/3133956.3134056\n\n<!--more-->\n\n\n\n# 摘要\n\n托管在云服务中的机器学习模型越来越受欢迎，但存在隐私风险：向该服务发送预测请求的客户端需要披露潜在的敏感信息。在本文中，我们探讨了隐私保护预测问题：在每次预测之后，服务器对客户端的输入一无所知，客户端对模型一无所知。\n\n我们提出了MiniONN，这是第一种将现有的神经网络转换为不经意的神经网络的方法，该网络以合理的效率支持隐私保护预测。与以前的工作不同，MiniONN不需要改变模型的训练方式。为此，我们为神经网络预测模型中常用的操作设计了健忘协议。我们证明了MiniONN在响应延迟和消息大小方面优于现有的工作。通过对标准数据集训练的几种典型神经网络模型的变换，证明了MiniONN的广泛适用性。\n\n**关键词**：隐私；机器学习；神经网络预测；安全两方计算\n\n\n\n## 贡献\n\n* 提出了MiniONN，这是第一个**可以将任何普通神经网络模型转换为不经意神经网络**的技术，而不需要对训练阶段进行任何修改。\n* **为神经网络预测中的常见操作设计了不经意的协议**。特别地，作者**使非线性函数(例如，Sigmoid和tanh)服从于作者的ONN变换**，而精确度损失可以忽略不计。\n* 构建了**MiniONN的完整实现**，并通过使用它来**转换从几个标准数据集训练**的神经网络模型来展示其广泛的适用性。特别是，对于从MNIST数据集[38]训练的相同模型，MiniONN的性能**明显**好于以前的工作[28, 44]。\n* 分析了**模型复杂性对转换后的ONN的预测精度和计算/通信开销的影响**。讨论了神经网络设计者如何在预测精度和开销之间选择合适的折衷方案。\n\n\n\n# BACKGROUND AND PRELIMINARIES\n\n![](http://images.yingwai.top/picgo/minionnt1.png)\n\n<center>\n    <i>表1 符号表示</i>\n</center>\n\n\n\n# MiniONN概述\n\n在本节中，通过转换以下形式的神经网络来解释MiniONN的基本思想：\n$$\n\\mathbf{z} := \\mathbf{W'} \\cdot f(\\mathbf{W} \\cdot \\mathbf{x} + \\mathbf{b}) + \\mathbf{b'} \\tag{4}\n$$\n其中$\\mathbf{x} = \\left[ \\begin{matrix} x_1\\\\ x_2 \\end{matrix} \\right]$，$\\mathbf{W} = \\left[ \\begin{matrix} w_{1,1} & w_{1,2}\\\\ w_{2,1} & w_{2,2} \\end{matrix} \\right]$，$\\mathbf{b} = \\left[ \\begin{matrix} b_1\\\\ b_2 \\end{matrix} \\right]$，$\\mathbf{W'} = \\left[ \\begin{matrix} w'_{1,1} & w'_{1,2}\\\\ w'_{2,1} & w'_{2,2} \\end{matrix} \\right]$ 以及 $\\mathbf{b'} = \\left[ \\begin{matrix} b'_1\\\\ b'_2 \\end{matrix} \\right]$。\n\nMiniONN的核心思想是让 $\\mathcal{S}$ 和 $\\mathcal{C}$ 加法共享神经网络每一层的输入和输出值。也就是说，在每一层的开始，$\\mathcal{S}$ 和 $\\mathcal{C}$ 将各自持有一份“份额”，使得份额的模加等于该神经网络的非不经意版本中对该层的输入。输出值将用作下一层的输入。\n\n为此，让 $\\mathcal{S}$ 和 $\\mathcal{C}$ 首先进入预计算阶段(该阶段独立于 $\\mathcal{C}$ 的输入$\\mathbf{x}$)，在该阶段中，它们为权重矩阵的每一行(在本例中为 $\\mathbf{W}$ 和 $\\mathbf{W'}$)联合生成一组点积三元组 $\\left \\langle u,v,\\mathbf{w} \\cdot \\mathbf{r} \\right \\rangle$。具体地说，对于 $\\mathbf{w}$的每一行，$\\mathcal{S}$ 和 $\\mathcal{C}$，运行一个协议，该协议安全地实现理想功能 $\\mathcal{F}$ 三元组(在图1中)，以生成点积三元组，从而：\n$$\n\\begin{align}\nu_1 + v_1 (\\bmod N) &= w_{1,1} r_1 + w_{1,2} r_2,\\\\\nu_2 + v_2 (\\bmod N) &= w_{2,1} r_1 + w_{2,2} r_2,\\\\\nu'_1 + v'_1 (\\bmod N) &= w'_{1,1} r'_1 + w'_{1,2} r'_2,\\\\\nu'_2 + v'_2 (\\bmod N) &= w'_{2,1} r'_1 + w'_{2,2} r'_2.\n\\end{align}\n$$\n![](http://images.yingwai.top/picgo/minionnf1.png)\n\n<center>\n    <i>图1 理想的生成点积三元组的功能</i>\n</center>\n\n当 $\\mathcal{C}$ 想要请求 $\\mathcal{S}$ 计算向量 $\\mathbf{x}=[x_1,x_2]$ 的预测时，对于每个 $x_i$，$\\mathcal{C}$ 选择在预计算阶段中生成的三元组，并使用它的 $r_i$ 来盲化 $x_i$。\n$$\n\\begin{align}\nx_1^{\\mathcal{C}} &:= r_1, x_1^{\\mathcal{S}} := x_1 - r_1 (\\bmod N),\\\\\nx_2^{\\mathcal{C}} &:= r_2, x_2^{\\mathcal{S}} := x_2 - r_2 (\\bmod N).\n\\end{align}\n$$\n然后 $\\mathcal{C}$ 然后发送 $\\mathbf{x}^{\\mathcal{S}}$ 给 $\\mathcal{S}$，$\\mathcal{S}$ 计算\n$$\n\\begin{align}\ny_1^{\\mathcal{S}} &:= w_{1,1} x_1^{\\mathcal{S}} + w_{1,2} x_2^{\\mathcal{S}} + b_1 + u_1 (\\bmod N),\\\\\ny_2^{\\mathcal{S}} &:= w_{2,1} x_1^{\\mathcal{S}} + w_{2,2} x_2^{\\mathcal{S}} + b_2 + u_2 (\\bmod N).\n\\end{align}\n$$\n同时，$\\mathcal{C}$ 设：\n$$\n\\begin{align}\ny_1^{\\mathcal{C}} &:= v_1 (\\bmod N),\\\\\ny_2^{\\mathcal{C}} &:= v_2 (\\bmod N).\n\\end{align}\n$$\n显然\n$$\n\\begin{align}\ny_1^{\\mathcal{C}} + y_1^{\\mathcal{S}} &= w_{1,1} x_1 + w_{1,2} x_2 + b_1 (\\bmod N),\\\\\ny_2^{\\mathcal{C}} + y_2^{\\mathcal{S}} &= w_{2,1} x_1 + w_{2,2} x_2 + b_2 (\\bmod N).\n\\end{align}\n$$\n因此，在此交互结束时，$\\mathcal{S}$ 和 $\\mathcal{C}$ 相加地共享由层1中的线性变换产生的输出值 $\\mathbf{y}$，而不需要 $\\mathcal{S}$ 学习输入 $\\mathbf{x}$，任何一方都不学习 $\\mathbf{y}$。\n\n对于激活/池化操作 $f()$，$\\mathcal{S}$ 和 $\\mathcal{C}$ 运行安全地实现图2中的理想功能的协议，该协议隐式地重构每个 $y_i := y^{\\mathcal{C}}_i + y^{\\mathcal{S}}_i (\\bmod N)$ 并返回 $x^{\\mathcal{S}}_i := f(y_i) - x^{\\mathcal{C}}_i$ 给 $\\mathcal{S}$，其中 $x^{\\mathcal{C}}_i$ 是来自预计算阶段的先前共享的三元组的 $\\mathcal{C}$ 分量，即 $x_1^{\\mathcal{C}} := r'_1$ 和 $x_2^{\\mathcal{C}} := r'_2$。\n\n![](http://images.yingwai.top/picgo/minionnf2.png)\n\n<center>\n    <i>图2 理想的不经意激活/池化f()的功能</i>\n</center>\n\n最后一层的变换与第一层相同。也就是说，$\\mathcal{S}$ 计算：\n$$\n\\begin{align}\ny_1^{\\mathcal{S}} &:= w'_{1,1} x_1^{\\mathcal{S}} + w'_{1,2} x_2^{\\mathcal{S}} + b'_1 + u'_1 (\\bmod N),\\\\\ny_2^{\\mathcal{S}} &:= w'_{2,1} x_1^{\\mathcal{S}} + w'_{2,2} x_2^{\\mathcal{S}} + b'_2 + u'_2 (\\bmod N);\n\\end{align}\n$$\n$\\mathcal{C}$ 设：\n$$\n\\begin{align}\ny_1^{\\mathcal{C}} &:= v'_1 (\\bmod N),\\\\\ny_2^{\\mathcal{C}} &:= v'_2 (\\bmod N),\n\\end{align}\n$$\n最后，$\\mathcal{S}$ 将 $[y_1^{\\mathcal{S}}, y_2^{\\mathcal{S}}]$ 返回给 $\\mathcal{C}$，$\\mathcal{C}$ 输出最终预测：\n$$\n\\begin{align}\nz_1 &:= y_1^{\\mathcal{C}} + y_1^{\\mathcal{S}},\\\\\nz_2 &:= y_2^{\\mathcal{C}} + y_2^{\\mathcal{S}}.\n\\end{align}\n$$\n注意到MiniONN在 $\\mathbb{Z}_N$ 中工作，而神经网络需要浮点计算。一种简单地解决办法是把神经网络中的值与一个固定的常数相乘，将小数部分放大到整数。一种类似的技术被用来减少神经网络预测中的存储器需求，而精确度损失可以忽略不计[42]。必须确保任何(中间)结果的绝对值不会超过 $\\lfloor N/2 \\rfloor$。","slug":"论文笔记-Oblivious-Neural-Network-Predictions-via-MiniONN-Transformations","published":1,"updated":"2020-08-23T14:33:37.437Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cke79q4tp004i88ps1c75bhk0","content":"<p><em>Jian Liu, Mika Juuti, Yao Lu, N. Asokan</em></p>\n<p>CCS 2017</p>\n<p><a href=\"https://dl.acm.org/doi/10.1145/3133956.3134056\" target=\"_blank\" rel=\"noopener\">https://dl.acm.org/doi/10.1145/3133956.3134056</a></p>\n<a id=\"more\"></a>\n<h1 id=\"摘要\"><a href=\"#摘要\" class=\"headerlink\" title=\"摘要\"></a>摘要</h1><p>托管在云服务中的机器学习模型越来越受欢迎，但存在隐私风险：向该服务发送预测请求的客户端需要披露潜在的敏感信息。在本文中，我们探讨了隐私保护预测问题：在每次预测之后，服务器对客户端的输入一无所知，客户端对模型一无所知。</p>\n<p>我们提出了MiniONN，这是第一种将现有的神经网络转换为不经意的神经网络的方法，该网络以合理的效率支持隐私保护预测。与以前的工作不同，MiniONN不需要改变模型的训练方式。为此，我们为神经网络预测模型中常用的操作设计了健忘协议。我们证明了MiniONN在响应延迟和消息大小方面优于现有的工作。通过对标准数据集训练的几种典型神经网络模型的变换，证明了MiniONN的广泛适用性。</p>\n<p><strong>关键词</strong>：隐私；机器学习；神经网络预测；安全两方计算</p>\n<h2 id=\"贡献\"><a href=\"#贡献\" class=\"headerlink\" title=\"贡献\"></a>贡献</h2><ul>\n<li>提出了MiniONN，这是第一个<strong>可以将任何普通神经网络模型转换为不经意神经网络</strong>的技术，而不需要对训练阶段进行任何修改。</li>\n<li><strong>为神经网络预测中的常见操作设计了不经意的协议</strong>。特别地，作者<strong>使非线性函数(例如，Sigmoid和tanh)服从于作者的ONN变换</strong>，而精确度损失可以忽略不计。</li>\n<li>构建了<strong>MiniONN的完整实现</strong>，并通过使用它来<strong>转换从几个标准数据集训练</strong>的神经网络模型来展示其广泛的适用性。特别是，对于从MNIST数据集[38]训练的相同模型，MiniONN的性能<strong>明显</strong>好于以前的工作[28, 44]。</li>\n<li>分析了<strong>模型复杂性对转换后的ONN的预测精度和计算/通信开销的影响</strong>。讨论了神经网络设计者如何在预测精度和开销之间选择合适的折衷方案。</li>\n</ul>\n<h1 id=\"BACKGROUND-AND-PRELIMINARIES\"><a href=\"#BACKGROUND-AND-PRELIMINARIES\" class=\"headerlink\" title=\"BACKGROUND AND PRELIMINARIES\"></a>BACKGROUND AND PRELIMINARIES</h1><p><img src=\"http://images.yingwai.top/picgo/minionnt1.png\" alt=\"\"></p>\n<center>\n    <i>表1 符号表示</i>\n</center>\n\n\n\n<h1 id=\"MiniONN概述\"><a href=\"#MiniONN概述\" class=\"headerlink\" title=\"MiniONN概述\"></a>MiniONN概述</h1><p>在本节中，通过转换以下形式的神经网络来解释MiniONN的基本思想：</p>\n<script type=\"math/tex; mode=display\">\n\\mathbf{z} := \\mathbf{W'} \\cdot f(\\mathbf{W} \\cdot \\mathbf{x} + \\mathbf{b}) + \\mathbf{b'} \\tag{4}</script><p>其中$\\mathbf{x} = \\left[ \\begin{matrix} x<em>1\\ x_2 \\end{matrix} \\right]$，$\\mathbf{W} = \\left[ \\begin{matrix} w</em>{1,1} &amp; w<em>{1,2}\\ w</em>{2,1} &amp; w<em>{2,2} \\end{matrix} \\right]$，$\\mathbf{b} = \\left[ \\begin{matrix} b_1\\ b_2 \\end{matrix} \\right]$，$\\mathbf{W’} = \\left[ \\begin{matrix} w’</em>{1,1} &amp; w’<em>{1,2}\\ w’</em>{2,1} &amp; w’_{2,2} \\end{matrix} \\right]$ 以及 $\\mathbf{b’} = \\left[ \\begin{matrix} b’_1\\ b’_2 \\end{matrix} \\right]$。</p>\n<p>MiniONN的核心思想是让 $\\mathcal{S}$ 和 $\\mathcal{C}$ 加法共享神经网络每一层的输入和输出值。也就是说，在每一层的开始，$\\mathcal{S}$ 和 $\\mathcal{C}$ 将各自持有一份“份额”，使得份额的模加等于该神经网络的非不经意版本中对该层的输入。输出值将用作下一层的输入。</p>\n<p>为此，让 $\\mathcal{S}$ 和 $\\mathcal{C}$ 首先进入预计算阶段(该阶段独立于 $\\mathcal{C}$ 的输入$\\mathbf{x}$)，在该阶段中，它们为权重矩阵的每一行(在本例中为 $\\mathbf{W}$ 和 $\\mathbf{W’}$)联合生成一组点积三元组 $\\left \\langle u,v,\\mathbf{w} \\cdot \\mathbf{r} \\right \\rangle$。具体地说，对于 $\\mathbf{w}$的每一行，$\\mathcal{S}$ 和 $\\mathcal{C}$，运行一个协议，该协议安全地实现理想功能 $\\mathcal{F}$ 三元组(在图1中)，以生成点积三元组，从而：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{align}\nu_1 + v_1 (\\bmod N) &= w_{1,1} r_1 + w_{1,2} r_2,\\\\\nu_2 + v_2 (\\bmod N) &= w_{2,1} r_1 + w_{2,2} r_2,\\\\\nu'_1 + v'_1 (\\bmod N) &= w'_{1,1} r'_1 + w'_{1,2} r'_2,\\\\\nu'_2 + v'_2 (\\bmod N) &= w'_{2,1} r'_1 + w'_{2,2} r'_2.\n\\end{align}</script><p><img src=\"http://images.yingwai.top/picgo/minionnf1.png\" alt=\"\"></p>\n<center>\n    <i>图1 理想的生成点积三元组的功能</i>\n</center>\n\n<p>当 $\\mathcal{C}$ 想要请求 $\\mathcal{S}$ 计算向量 $\\mathbf{x}=[x_1,x_2]$ 的预测时，对于每个 $x_i$，$\\mathcal{C}$ 选择在预计算阶段中生成的三元组，并使用它的 $r_i$ 来盲化 $x_i$。</p>\n<script type=\"math/tex; mode=display\">\n\\begin{align}\nx_1^{\\mathcal{C}} &:= r_1, x_1^{\\mathcal{S}} := x_1 - r_1 (\\bmod N),\\\\\nx_2^{\\mathcal{C}} &:= r_2, x_2^{\\mathcal{S}} := x_2 - r_2 (\\bmod N).\n\\end{align}</script><p>然后 $\\mathcal{C}$ 然后发送 $\\mathbf{x}^{\\mathcal{S}}$ 给 $\\mathcal{S}$，$\\mathcal{S}$ 计算</p>\n<script type=\"math/tex; mode=display\">\n\\begin{align}\ny_1^{\\mathcal{S}} &:= w_{1,1} x_1^{\\mathcal{S}} + w_{1,2} x_2^{\\mathcal{S}} + b_1 + u_1 (\\bmod N),\\\\\ny_2^{\\mathcal{S}} &:= w_{2,1} x_1^{\\mathcal{S}} + w_{2,2} x_2^{\\mathcal{S}} + b_2 + u_2 (\\bmod N).\n\\end{align}</script><p>同时，$\\mathcal{C}$ 设：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{align}\ny_1^{\\mathcal{C}} &:= v_1 (\\bmod N),\\\\\ny_2^{\\mathcal{C}} &:= v_2 (\\bmod N).\n\\end{align}</script><p>显然</p>\n<script type=\"math/tex; mode=display\">\n\\begin{align}\ny_1^{\\mathcal{C}} + y_1^{\\mathcal{S}} &= w_{1,1} x_1 + w_{1,2} x_2 + b_1 (\\bmod N),\\\\\ny_2^{\\mathcal{C}} + y_2^{\\mathcal{S}} &= w_{2,1} x_1 + w_{2,2} x_2 + b_2 (\\bmod N).\n\\end{align}</script><p>因此，在此交互结束时，$\\mathcal{S}$ 和 $\\mathcal{C}$ 相加地共享由层1中的线性变换产生的输出值 $\\mathbf{y}$，而不需要 $\\mathcal{S}$ 学习输入 $\\mathbf{x}$，任何一方都不学习 $\\mathbf{y}$。</p>\n<p>对于激活/池化操作 $f()$，$\\mathcal{S}$ 和 $\\mathcal{C}$ 运行安全地实现图2中的理想功能的协议，该协议隐式地重构每个 $y_i := y^{\\mathcal{C}}_i + y^{\\mathcal{S}}_i (\\bmod N)$ 并返回 $x^{\\mathcal{S}}_i := f(y_i) - x^{\\mathcal{C}}_i$ 给 $\\mathcal{S}$，其中 $x^{\\mathcal{C}}_i$ 是来自预计算阶段的先前共享的三元组的 $\\mathcal{C}$ 分量，即 $x_1^{\\mathcal{C}} := r’_1$ 和 $x_2^{\\mathcal{C}} := r’_2$。</p>\n<p><img src=\"http://images.yingwai.top/picgo/minionnf2.png\" alt=\"\"></p>\n<center>\n    <i>图2 理想的不经意激活/池化f()的功能</i>\n</center>\n\n<p>最后一层的变换与第一层相同。也就是说，$\\mathcal{S}$ 计算：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{align}\ny_1^{\\mathcal{S}} &:= w'_{1,1} x_1^{\\mathcal{S}} + w'_{1,2} x_2^{\\mathcal{S}} + b'_1 + u'_1 (\\bmod N),\\\\\ny_2^{\\mathcal{S}} &:= w'_{2,1} x_1^{\\mathcal{S}} + w'_{2,2} x_2^{\\mathcal{S}} + b'_2 + u'_2 (\\bmod N);\n\\end{align}</script><p>$\\mathcal{C}$ 设：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{align}\ny_1^{\\mathcal{C}} &:= v'_1 (\\bmod N),\\\\\ny_2^{\\mathcal{C}} &:= v'_2 (\\bmod N),\n\\end{align}</script><p>最后，$\\mathcal{S}$ 将 $[y_1^{\\mathcal{S}}, y_2^{\\mathcal{S}}]$ 返回给 $\\mathcal{C}$，$\\mathcal{C}$ 输出最终预测：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{align}\nz_1 &:= y_1^{\\mathcal{C}} + y_1^{\\mathcal{S}},\\\\\nz_2 &:= y_2^{\\mathcal{C}} + y_2^{\\mathcal{S}}.\n\\end{align}</script><p>注意到MiniONN在 $\\mathbb{Z}_N$ 中工作，而神经网络需要浮点计算。一种简单地解决办法是把神经网络中的值与一个固定的常数相乘，将小数部分放大到整数。一种类似的技术被用来减少神经网络预测中的存储器需求，而精确度损失可以忽略不计[42]。必须确保任何(中间)结果的绝对值不会超过 $\\lfloor N/2 \\rfloor$。</p>\n","site":{"data":{}},"excerpt":"<p><em>Jian Liu, Mika Juuti, Yao Lu, N. Asokan</em></p>\n<p>CCS 2017</p>\n<p><a href=\"https://dl.acm.org/doi/10.1145/3133956.3134056\" target=\"_blank\" rel=\"noopener\">https://dl.acm.org/doi/10.1145/3133956.3134056</a></p>","more":"<h1 id=\"摘要\"><a href=\"#摘要\" class=\"headerlink\" title=\"摘要\"></a>摘要</h1><p>托管在云服务中的机器学习模型越来越受欢迎，但存在隐私风险：向该服务发送预测请求的客户端需要披露潜在的敏感信息。在本文中，我们探讨了隐私保护预测问题：在每次预测之后，服务器对客户端的输入一无所知，客户端对模型一无所知。</p>\n<p>我们提出了MiniONN，这是第一种将现有的神经网络转换为不经意的神经网络的方法，该网络以合理的效率支持隐私保护预测。与以前的工作不同，MiniONN不需要改变模型的训练方式。为此，我们为神经网络预测模型中常用的操作设计了健忘协议。我们证明了MiniONN在响应延迟和消息大小方面优于现有的工作。通过对标准数据集训练的几种典型神经网络模型的变换，证明了MiniONN的广泛适用性。</p>\n<p><strong>关键词</strong>：隐私；机器学习；神经网络预测；安全两方计算</p>\n<h2 id=\"贡献\"><a href=\"#贡献\" class=\"headerlink\" title=\"贡献\"></a>贡献</h2><ul>\n<li>提出了MiniONN，这是第一个<strong>可以将任何普通神经网络模型转换为不经意神经网络</strong>的技术，而不需要对训练阶段进行任何修改。</li>\n<li><strong>为神经网络预测中的常见操作设计了不经意的协议</strong>。特别地，作者<strong>使非线性函数(例如，Sigmoid和tanh)服从于作者的ONN变换</strong>，而精确度损失可以忽略不计。</li>\n<li>构建了<strong>MiniONN的完整实现</strong>，并通过使用它来<strong>转换从几个标准数据集训练</strong>的神经网络模型来展示其广泛的适用性。特别是，对于从MNIST数据集[38]训练的相同模型，MiniONN的性能<strong>明显</strong>好于以前的工作[28, 44]。</li>\n<li>分析了<strong>模型复杂性对转换后的ONN的预测精度和计算/通信开销的影响</strong>。讨论了神经网络设计者如何在预测精度和开销之间选择合适的折衷方案。</li>\n</ul>\n<h1 id=\"BACKGROUND-AND-PRELIMINARIES\"><a href=\"#BACKGROUND-AND-PRELIMINARIES\" class=\"headerlink\" title=\"BACKGROUND AND PRELIMINARIES\"></a>BACKGROUND AND PRELIMINARIES</h1><p><img src=\"http://images.yingwai.top/picgo/minionnt1.png\" alt=\"\"></p>\n<center>\n    <i>表1 符号表示</i>\n</center>\n\n\n\n<h1 id=\"MiniONN概述\"><a href=\"#MiniONN概述\" class=\"headerlink\" title=\"MiniONN概述\"></a>MiniONN概述</h1><p>在本节中，通过转换以下形式的神经网络来解释MiniONN的基本思想：</p>\n<script type=\"math/tex; mode=display\">\n\\mathbf{z} := \\mathbf{W'} \\cdot f(\\mathbf{W} \\cdot \\mathbf{x} + \\mathbf{b}) + \\mathbf{b'} \\tag{4}</script><p>其中$\\mathbf{x} = \\left[ \\begin{matrix} x<em>1\\ x_2 \\end{matrix} \\right]$，$\\mathbf{W} = \\left[ \\begin{matrix} w</em>{1,1} &amp; w<em>{1,2}\\ w</em>{2,1} &amp; w<em>{2,2} \\end{matrix} \\right]$，$\\mathbf{b} = \\left[ \\begin{matrix} b_1\\ b_2 \\end{matrix} \\right]$，$\\mathbf{W’} = \\left[ \\begin{matrix} w’</em>{1,1} &amp; w’<em>{1,2}\\ w’</em>{2,1} &amp; w’_{2,2} \\end{matrix} \\right]$ 以及 $\\mathbf{b’} = \\left[ \\begin{matrix} b’_1\\ b’_2 \\end{matrix} \\right]$。</p>\n<p>MiniONN的核心思想是让 $\\mathcal{S}$ 和 $\\mathcal{C}$ 加法共享神经网络每一层的输入和输出值。也就是说，在每一层的开始，$\\mathcal{S}$ 和 $\\mathcal{C}$ 将各自持有一份“份额”，使得份额的模加等于该神经网络的非不经意版本中对该层的输入。输出值将用作下一层的输入。</p>\n<p>为此，让 $\\mathcal{S}$ 和 $\\mathcal{C}$ 首先进入预计算阶段(该阶段独立于 $\\mathcal{C}$ 的输入$\\mathbf{x}$)，在该阶段中，它们为权重矩阵的每一行(在本例中为 $\\mathbf{W}$ 和 $\\mathbf{W’}$)联合生成一组点积三元组 $\\left \\langle u,v,\\mathbf{w} \\cdot \\mathbf{r} \\right \\rangle$。具体地说，对于 $\\mathbf{w}$的每一行，$\\mathcal{S}$ 和 $\\mathcal{C}$，运行一个协议，该协议安全地实现理想功能 $\\mathcal{F}$ 三元组(在图1中)，以生成点积三元组，从而：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{align}\nu_1 + v_1 (\\bmod N) &= w_{1,1} r_1 + w_{1,2} r_2,\\\\\nu_2 + v_2 (\\bmod N) &= w_{2,1} r_1 + w_{2,2} r_2,\\\\\nu'_1 + v'_1 (\\bmod N) &= w'_{1,1} r'_1 + w'_{1,2} r'_2,\\\\\nu'_2 + v'_2 (\\bmod N) &= w'_{2,1} r'_1 + w'_{2,2} r'_2.\n\\end{align}</script><p><img src=\"http://images.yingwai.top/picgo/minionnf1.png\" alt=\"\"></p>\n<center>\n    <i>图1 理想的生成点积三元组的功能</i>\n</center>\n\n<p>当 $\\mathcal{C}$ 想要请求 $\\mathcal{S}$ 计算向量 $\\mathbf{x}=[x_1,x_2]$ 的预测时，对于每个 $x_i$，$\\mathcal{C}$ 选择在预计算阶段中生成的三元组，并使用它的 $r_i$ 来盲化 $x_i$。</p>\n<script type=\"math/tex; mode=display\">\n\\begin{align}\nx_1^{\\mathcal{C}} &:= r_1, x_1^{\\mathcal{S}} := x_1 - r_1 (\\bmod N),\\\\\nx_2^{\\mathcal{C}} &:= r_2, x_2^{\\mathcal{S}} := x_2 - r_2 (\\bmod N).\n\\end{align}</script><p>然后 $\\mathcal{C}$ 然后发送 $\\mathbf{x}^{\\mathcal{S}}$ 给 $\\mathcal{S}$，$\\mathcal{S}$ 计算</p>\n<script type=\"math/tex; mode=display\">\n\\begin{align}\ny_1^{\\mathcal{S}} &:= w_{1,1} x_1^{\\mathcal{S}} + w_{1,2} x_2^{\\mathcal{S}} + b_1 + u_1 (\\bmod N),\\\\\ny_2^{\\mathcal{S}} &:= w_{2,1} x_1^{\\mathcal{S}} + w_{2,2} x_2^{\\mathcal{S}} + b_2 + u_2 (\\bmod N).\n\\end{align}</script><p>同时，$\\mathcal{C}$ 设：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{align}\ny_1^{\\mathcal{C}} &:= v_1 (\\bmod N),\\\\\ny_2^{\\mathcal{C}} &:= v_2 (\\bmod N).\n\\end{align}</script><p>显然</p>\n<script type=\"math/tex; mode=display\">\n\\begin{align}\ny_1^{\\mathcal{C}} + y_1^{\\mathcal{S}} &= w_{1,1} x_1 + w_{1,2} x_2 + b_1 (\\bmod N),\\\\\ny_2^{\\mathcal{C}} + y_2^{\\mathcal{S}} &= w_{2,1} x_1 + w_{2,2} x_2 + b_2 (\\bmod N).\n\\end{align}</script><p>因此，在此交互结束时，$\\mathcal{S}$ 和 $\\mathcal{C}$ 相加地共享由层1中的线性变换产生的输出值 $\\mathbf{y}$，而不需要 $\\mathcal{S}$ 学习输入 $\\mathbf{x}$，任何一方都不学习 $\\mathbf{y}$。</p>\n<p>对于激活/池化操作 $f()$，$\\mathcal{S}$ 和 $\\mathcal{C}$ 运行安全地实现图2中的理想功能的协议，该协议隐式地重构每个 $y_i := y^{\\mathcal{C}}_i + y^{\\mathcal{S}}_i (\\bmod N)$ 并返回 $x^{\\mathcal{S}}_i := f(y_i) - x^{\\mathcal{C}}_i$ 给 $\\mathcal{S}$，其中 $x^{\\mathcal{C}}_i$ 是来自预计算阶段的先前共享的三元组的 $\\mathcal{C}$ 分量，即 $x_1^{\\mathcal{C}} := r’_1$ 和 $x_2^{\\mathcal{C}} := r’_2$。</p>\n<p><img src=\"http://images.yingwai.top/picgo/minionnf2.png\" alt=\"\"></p>\n<center>\n    <i>图2 理想的不经意激活/池化f()的功能</i>\n</center>\n\n<p>最后一层的变换与第一层相同。也就是说，$\\mathcal{S}$ 计算：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{align}\ny_1^{\\mathcal{S}} &:= w'_{1,1} x_1^{\\mathcal{S}} + w'_{1,2} x_2^{\\mathcal{S}} + b'_1 + u'_1 (\\bmod N),\\\\\ny_2^{\\mathcal{S}} &:= w'_{2,1} x_1^{\\mathcal{S}} + w'_{2,2} x_2^{\\mathcal{S}} + b'_2 + u'_2 (\\bmod N);\n\\end{align}</script><p>$\\mathcal{C}$ 设：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{align}\ny_1^{\\mathcal{C}} &:= v'_1 (\\bmod N),\\\\\ny_2^{\\mathcal{C}} &:= v'_2 (\\bmod N),\n\\end{align}</script><p>最后，$\\mathcal{S}$ 将 $[y_1^{\\mathcal{S}}, y_2^{\\mathcal{S}}]$ 返回给 $\\mathcal{C}$，$\\mathcal{C}$ 输出最终预测：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{align}\nz_1 &:= y_1^{\\mathcal{C}} + y_1^{\\mathcal{S}},\\\\\nz_2 &:= y_2^{\\mathcal{C}} + y_2^{\\mathcal{S}}.\n\\end{align}</script><p>注意到MiniONN在 $\\mathbb{Z}_N$ 中工作，而神经网络需要浮点计算。一种简单地解决办法是把神经网络中的值与一个固定的常数相乘，将小数部分放大到整数。一种类似的技术被用来减少神经网络预测中的存储器需求，而精确度损失可以忽略不计[42]。必须确保任何(中间)结果的绝对值不会超过 $\\lfloor N/2 \\rfloor$。</p>"},{"title":"论文笔记 Privacy-preserving SVM on Outsourced Genomic Data via Secure Multi-party Computation","date":"2020-07-02T02:22:19.000Z","_content":"\n*Huajie Chen, Ali Burak Ünal, Mete Akgün, Nico Pfeifer∗*\n\n[IWSPA@CODASPY 2020](https://dblp.uni-trier.de/db/conf/codaspy/iwspa2020.html#ChenUAP20)\n\nhttps://dl.acm.org/doi/abs/10.1145/3375708.3380316\n\n<!--more-->\n\n# 摘要\n\n机器学习方法以其高效、强大的数据挖掘能力被广泛应用于医学数据研究等领域。然而，将不受保护的数据提交给试图训练机器学习模型的第三方，当第三方受到对手的攻击时，可能会受到数据泄露和隐私侵犯的影响。因此，设计一种执行加密计算的协议是不可避免的。为了解决这个问题，我们提出了基于安全多方计算的协议来私下训练支持向量机模型。利用半诚实对手模型和不经意转移，所提出的协议能够在不牺牲个人隐私的情况下对来自不同来源的组合数据进行非线性支持向量机训练。这些协议被应用于在HIV序列数据上训练具有径向基函数核的支持向量机模型，以预测某种抗病毒药物的疗效，这只有在病毒只能使用人类CCR5辅助受体进入细胞的情况下才有效。以10个由随机生成的整数组成的数据源(每个数据源包含100个标记样本)的合成数据为基准，该协议在算术/布尔电路中分别平均消耗了2991.386/166.912毫秒的在线时间。优化后的参数对训练数据的交叉验证平均达到0.5819 F1分，随后在由CCR5及其亚型蛋白序列组成的测试数据集上交叉验证达到0.7058 F1分。在实际数据上的完整训练和测试过程，编码后总共包含766个样本，924个特征，分别使用算术/布尔电路平均耗时43.75/15.84秒，与文献中的一些现有研究相比，这表明了我们协议的有效性和高效性。\n\n\n\n# INTRODUCTION\n\n近年来，机器学习方法在许多科学研究领域得到了广泛的应用，通过发现数据中的模式来解决问题。在医疗数据上应用机器学习方法，例如支持向量机(SVM)，使得能够检测先前未知或对于人类实体来说太难识别的模式。因此，它可以为医疗技术的发展做出贡献。例如，通过使用聚类、多维缩放和支持向量机来表征新的艾滋病毒耐药突变[19]。以“稀疏组套索回归”为核心的基于网络的预后预测(NOP)方法已被编制成基于基因表达谱的乳腺癌状态预测方法[1]，人工神经网络(ANN)可以给出癌症的预测和预后[3]。\n\n随着最新的技术，如第二代/第三代DNA测序，获得完整的人类基因组已经变得高效和廉价，导致许多研究解决了各种与健康相关的研究问题。然而，在第三方访问数据的过程中，患者的隐私可能会受到泄露。针对这一问题，设计了基于安全多方计算(MPC)[13，14]和同态加密[6，8，10]的隐私保护机器学习方法。然而，这些方法在不同的安全假设下表现出不同的性能。这意味着他们必须在隐私和性能之间进行权衡。据我们所知，利用预测控制训练非线性支持向量机缺乏有效的方法。\n\n\n\n## Contributions\n\n在本文中，我们设计并实现了一个基于MPC的解决方案，将支持向量机训练外包给两个非合谋的代理服务器。我们的目标是使支持向量机在来自多个来源的海量数据上的隐私保护训练变得高效。为此，我们提出了基于算术秘密共享的Beaver乘法三元组[2]和基于布尔秘密共享的Goldreich-MicaliWigderson(GMW)协议[7]的两种不同的解决方案。我们使用单指令多数据(SIMD)操作，允许并行化来提高协议的性能。\n\n在我们的协议中，初始化阶段可以在本地完成。来自各种数据源(如医院)的基因组序列数据首先采用独热编码进行编码。接下来，编码序列被分成两份，并分别分配给计算方。自己的点积也在当地计算、拆分并分发给各方。在训练过程中，在计算方之间进行MPC，得到计算结果，然后将计算结果发送给用户并进行重构，得到包含来自不同来源的数据的点积以及来自同一方的数据的点积的完整的GRAM矩阵。最后，用户在所需的核矩阵上训练SVM模型，该核矩阵可以通过导出的GRAM矩阵来计算。类别标签在纯文本域中发送，因为它们不会显示关于样本的任何额外信息。\n\n我们将我们的方案应用于HIV序列数据，以预测某种抗病毒药物的疗效，只有当病毒只能使用人类CCR5辅助受体进入细胞时，这种方法才有效。我们设计的基于算术和布尔电路的协议对10个由随机生成的整数组成的数据源的在线执行电路消耗了2991.38/166.912毫秒的时间，每个数据源包含100个带标签的样本，每个样本中有924个特征，即列。我们通过F1-Score对我们的结果进行了评估，训练数据的平均得分为0.5819，测试数据的平均得分为0.7058，证明了该协议的有效性。在算术/布尔电路协议中，对实际数据的完整训练和测试过程分别花费了算术/布尔电路协议的43.75/15.84秒，编码后总共包含766个样本，924个特征。\n\n论文的其余部分安排如下：第二部分介绍了相关工作。第3节和第4节分别列出了所需的预备知识和协议的详细概念。第五节对协议进行了评价和进一步的讨论。第六节对本文进行了总结。\n\n\n\n# PRELIMINARIES\n\n在这一部分中，给出了我们的方法所使用的方法和算法。\n\n\n\n## 序列独热编码\n\n在数据预处理阶段，我们使用的序列通过一次热编码被编码成数字形式。假设 $c_i$ 是序列 $S$ 中位置 $i$ 处的角色，其中 $i \\in \\mathbb{Z}, i< |S|$。因为有20个氨基酸残基和1个GAP，所以 $c_i$ 可以编码成21位的形式。\n\n例如，如果 $c_i$ 是丙氨酸，则 $c_i$ 将被编码为 \"$1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0$\"，如果 $c_i$ 是一个GAP，则 $c_i$ 为 \"$0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1$\"。随着编码程序的迭代，整个序列将被编码成上述格式。\n\n\n\n## 序列相似性的度量\n\n为了评估序列的相似性，利用了汉明距离的倒数。汉明距离被描述为在具有相同长度的两个字符串之间的相同位置处的不同字符对的数量。例如，给定两个长度相同的字符串 $s_1$ 和 $s_2$，每个字符串中总共有 $l$ 个字符。$D_{\\mathbb{H}}$ 为字符串 $s_1$ 和 $s_2$ 定义的汉明距离：\n$$\nD_{\\mathbb{H}}(s_1, s_2) = \\sum^{l}_{i=1}I(s_1(i),s_2(i))\n$$\n其中 $l$ 是序列的长度，$I$ 是函数，如果给定的两个字符 $s_1(i)$ 和 $$s_2(i)$$ 相同，则该函数返回1，否则返回0。在本项目中，两个序列的碱基相似度与汉明距离成反比，即 $l-D_{\\mathbb{H}}(s_1, s_2)$。\n\n根据第3.1节，现在可以将一个序列视为二进制值的一个向量 $\\vec{v}$。如果同一位置的任意两个序列中的任意两个字符相同，则这两个编码字符的点积 $\\vec{v_1} \\cdot \\vec{v_2}$ 结果为1，否则为0。在这种情况下，两个序列的相似性越大，点积就越高。一旦计算了所有可能的序列对的相似度，就获得了矩阵 $\\mathbf{M} \\in \\mathbb{Z}^{n \\times n}$，其中 $n$ 表示计算中涉及的序列的数目。\n\n\n\n## 安全多方计算\n\n这里作者采用两方的设置，可以参考[ABY](https://yuyingwai.cn/2020/06/11/论文笔记-ABY-A-Framework-for-Efficient-Mixed-Protocol-Secure-Two-Party-Computation/)中第2节的算术共享和布尔共享。\n\n\n\n## 支持向量机\n\n支持向量机作为一种有监督的机器学习方法，经常被用来解决分类问题。它们已被证明在解决中、低尺度预测问题上优于许多其他方法，特别是在结合核函数的情况下。支持向量机的优化问题表示如下：\n$$\n\\begin{align}\n\\min_{\\omega \\in \\mathbb{R}^d, b\\in \\mathbb{R}, \\xi \\in \\mathbb{R}^n} \\ \\ \\  &\\frac{1}{2} ||\\omega||^2 + \\frac{C}{n}\\sum^n_{i=1} \\xi_i \\\\\n\\mbox{s.t.} \\ \\ \\  &Y_i(\\langle \\omega, X_i \\rangle + b) \\geq 1 - \\xi_i \\tag{1} \\\\\n &i=1,...,n,\\  \\xi_i \\geq 0\n\\end{align}\n$$\n其中，$\\omega, b, \\xi, C, n$ 遵循列出的顺序，分别表示具有 $n$ 维数的向量、干扰 $\\omega$ 和 $X_i$ 之间的点积的参数、确定点可以超出超平面多远的参数、惩罚的权重以及数据点的数量 $Y$。$X_i$ 和 $Y_i$ 表示数据特征向量及其标注。在上述支持向量机模型中，数据点被允许穿过超平面，但将受到松弛变量 $\\xi_i$ 的惩罚，该松弛变量由惩罚因子 $C$ 缩放。通过调整 $C$，可以改变惩罚的权重。\n\n\n\n## 径向基函数核\n\nRBF核因其有效性和普适性而被广泛应用于支持向量机分类中[9]，其核函数定义如下：\n$$\n\\begin{align}\nK(\\vec{x}, \\vec{y}) &= \\exp(- \\frac{||\\vec{x} - \\vec{y}||^2}{2\\sigma^2}) \\tag{2}\\\\ \n&= \\exp(-\\frac{\\vec{x} \\cdot \\vec{x} - 2 \\vec{x} \\cdot \\vec{y} + \\vec{y} \\cdot \\vec{y}}{2 \\sigma^2})\n\\end{align}\n$$\n\n在这个方程中，“$\\cdot$” 表示向量之间的点积算子，而 $\\sigma$ 则作为调整相似度的参数，当 $\\sigma$ 增大时，指数函数的结果将趋于接近1，表明两个序列的相似度较高，反之亦然，此外，方程的第二行表明，在我们的协议中，只能根据用于计算径向基核矩阵的向量的点积来计算径向基核。\n\n\n\n# 隐私保护支持向量机\n\n在这一部分中，我们系统地描述了我们的隐私保护支持向量机协议。在4.1节中，我们将对其进行概述，随后将详细说明协议的各个阶段。这里继承了3.3节中的记号。\n\n\n\n## 系统概述\n\n在我们的协议中，来自多个医疗机构的基因组数据集以秘密共享的形式被外包给两个非共谋的代理服务器。两个非合谋的代理服务器在收到允许查询数据的第三方(如研究人员)的请求后，执行MPC以生成支持向量机训练所需的样本的GRAM矩阵。协议结构如图1所示，在此协议中，有以下各方扮演的角色：\n\n1. **数据源：**在此上下文中，它们是医疗机构，表示为 $H_j$，其中 $j \\in \\mathbb{N}^+ , j \\leq n$，其中 $n$ 表示数据源的数量。他们以秘密共享的形式将基因组数据上传到两个代理服务器。\n2. **用户：**用户 $U$，例如科学研究人员，他请求两个代理服务器对秘密共享数据执行一些安全计算，以产生用于支持向量机训练的格拉姆矩阵。\n3. **两个代理服务器：**两个非合谋服务器作为计算方，记为 $P_i$，其中 $i \\in \\{0,1\\}$ 负责格拉姆矩阵的安全计算。在利用基因组数据训练机器学习模型的同时，选择两个不完全信任的第三方被认为是确保隐私保护的最实用和最实惠的解决方案[17]。\n\n![](http://images.yingwai.top/picgo/ppossvmf1.png)\n\n<center>\n    <i>图1 协议结构：从数据源到MPC，最终到用户进程</i>\n</center>\n\n\n\n\n### 初始化\n\n1. $H_j$ 中的原始序列数据在本地编码为数字矢量(参见第4.2节)。\n2. 在 $H_j$ 中，编码的序列数据在本地被分成两个共享 $A/B$，并分别发送到 $P_0$ 和 $P_1$ (参见第4.3节)。\n3. 在 $H_j$ 中本地预先计算自身点积，然后它们也被分成两个份额 $A/B$，并分别发送到 $P_0$ 和 $P_1$ (参见第4.4节)。\n\n\n\n### 训练过程\n\n4. 接收到来自 $U$ 的查询后，在 $P_0$ 和 $P_1$ 之间进行预测编码，以在包含编码序列的文件之间获得所需的处理数据(参见第4.5节和第4.6节)。\n5. 然后对自积和交叉点乘积进行积分以获得整个格拉姆矩阵，并将其传递给 $U$ (参见第4.7节)。\n6. 在 $U$ 中使用格拉姆矩阵来训练支持向量机模型并测试结果模型(参见第4.8节)。\n\n\n\n## 蛋白质序列编码\n\n序列编码功能采用代表一个残基的一个字符，并将其编码为21位格式，如3.1节所述。输出文件包含编码序列，其中每行代表一个蛋白质序列，21列中的每一列代表一个残基(或gap)。\n\n\n\n## 编码数据的秘密共享\n\n使用算术共享和布尔共享将原始编码数据分割成两个共享。在基于算术共享的协议中，产生的随机整数小于 $2^l$。此后，随机整数将作为共享并帮助构建另一个共享。在基于布尔共享的协议中，随机比特被生成为一个共享，并且它们被用来构造另一个共享。最终，在这两种协议中，两个共享将分别写入两个文件。使用算术共享的编码数据的秘密共享如图2所示。\n\n![](http://images.yingwai.top/picgo/ppossvmf2.png)\n\n<center>\n    <i>图2 共享数据生成</i>\n</center>\n\n\n\n\n## 本地计算自点积\n\n数据源计算“自身点积”，这意味着每个数据点的两个实例的点积是在本地计算的。这样的本地计算降低了总的通信成本。该过程的结果是由前面提到的共享数据生成技术产生的点积矩阵的两部分。点积矩阵的份额接下来被分发到两个第三方代理服务器上，即 $P_0$ 和 $P_1$，然后可以在 $U$ 上重建这些份额。\n\n\n\n## 使用算术电路进行点积计算\n\n所有需要乘成两个长数组的文件都被集成，省略了重复SIMD数据生成的不必要步骤。例如，假设文件 $A$、文件 $B$、文件 $C$ 分别表示为 $f_a$，$f_b$ 和 $f_c$，则这些文件中分别包含3、2和1个共享编码序列，由 $a_i,b_i,c_i$ 表示，其中 $i$ 表示某个文件中的序列索引。长阵列A将是 “$a_1a_2a_3a_1a_2a_3a_1a_2a_3b_1b_2$”，而另一个长阵列将是 “$b_1b_1b_1b_2b_2b_2c_1c_1c_1c_1c_1$”。这些操作分别称为 $\\mbox{GetLongArrayA}()$ 和 $\\mbox{GetLongArrayB}()$。\n\n![](http://images.yingwai.top/picgo/ppossvma1.png)\n\n算法1首先构造两个长数组，以减少创建SIMD数据的次数。通过一次乘以两个长阵列，成功地降低了协议的运行时间。此算法省略了文件与其自身之间的点积计算，因为它可以先前本地计算，如第4.4节所述。通过将数组放入SIMD共享，从而实现对多个数据的操作。在乘法之后，然后执行每个点积计算块中的乘法结果的求和，以便分别对来自两个向量的每对元素的乘法进行局部求和。最后，将最终结果加载到数组中。图3显示了基于算术电路的安全协议的一般结构。\n\n\n\n## 基于布尔电路的点积计算\n\n算法2类似于算法1。协议的结构如图3所示。两者之间的区别在于共享类型和电路类型。在此上下文中，仅在0和1之间执行乘法，这符合布尔共享的位长(1位)。因此，布尔电路中的安全与运算可以取代算术电路中的安全乘法，实现更好的计算性能。因此，共享的位长可以减少到1，这可以在通信过程中节省大量的计算能力。就布尔份额而言，它与算术份额差别很大，因此在以以前的方式局部相乘后无法求和。因此，设计了基于安全加法的特定函数，用于在点积块中对乘法结果求和。\n\n![](http://images.yingwai.top/picgo/ppossvmf3.png)\n\n<center>\n    <i>图3 点积计算</i>\n</center>\n\n![](http://images.yingwai.top/picgo/ppossvma2_.png)\n\n\n\n## 结果数组集成与点积矩阵生成\n\n通过我们的协议，可以在 $U$ 上手动将自身的点积重构成一个数组。然后计算自/交叉点乘积数组中访问位置的索引表。基于索引表，将生成 $2D$ 矢量，即 $n \\times n$ 矩阵，其中 $n$ 表示计算中涉及的序列总数，并将其写入文件中作为最终输出。在机器学习中，必须严格遵循数据和标签的顺序，这样才能正确地训练模型。因此，数组的排序过程是必不可少的。\n\n\n\n## 支持向量机交叉验证实验\n\n在所有数据中，随机选取20%的数据对模型进行检验。在计算格拉姆矩阵的基础上，通过5次交叉验证对支持向量机的误分类惩罚参数 $C$、类不平衡权值 $W$ 和径向基函数的相似度调整参数 $\\sigma$ 进行优化。$C$ 和 $\\sigma$ 分别在集合 $s_C=[10^{-3},10^{-2},\\cdot \\cdot \\cdot,10^2, 10^3]$，$S_{\\sigma}=[0.125, 0.25, 0.5, 1, 2, 4, 8]$ 上进行优化，而类权重选自集合 $S_W = [1:1,1:2,1:4,1:8,1:16]$，前者表示标签0的类权重，前者占多数，后者表示标签1的类权重。最终，确定在优化过程中达到最高F1得分的参数集。然后，利用这些最优参数对最终模型进行训练。最后，利用测试数据对训练好的模型进行检验，并用F1得分对预测结果进行评估。\n\n\n\n## 安全性分析\n\n将数据外包给 $N$ 非合谋、半诚实的第三方是在[11]中首次研究的。给出了通用解决方案的安全性证明。在我们的协议中，利用[11]中的外包思想，多个医疗机构将基因组数据外包给两个非合谋、半诚实的第三方。我们需要保护个人的隐私，他们的基因组数据被外包给两个非串通的服务器。我们基于算术电路和布尔电路的协议的安全性依赖于分别基于Beaver乘法三元组的协议[2]和GMW协议[7]的已证明的安全性。一个半诚实的对手最多可以攻破一个代理服务器，就可以获得个人私有基因组数据的一份。我们知道基因组数据是通过算术或布尔共享来共享的，所以它看起来像是统一随机的数据。这确保了敌手不能获得任何有关个人的私人基因组数据。我们的协议是安全的，不会受到恶意数据提供商和用户的攻击。数据提供者仅以共享的形式向两个代理服务器发送基因组数据，并且不接收来自其他方的任何消息。他们的恶意输入不会导致任何数据泄露。用户输入的任何变化都会导致不同的分析响应。这确保了针对恶意用户的安全性。所有通信方之间的机密性、完整性和认证都是使用最先进的技术(如TLS[5])提供的。\n\n\n\n# CONCLUSION\n\n本文提出了两种支持向量机隐私保护训练方案，用于支持向量机对来自多个来源的外包基因组数据的隐私保护训练。在我们的方案中，我们利用算术秘密共享、布尔秘密共享和不经意转移来同时保证支持向量机训练的安全和高效。我们的协议在两个半可信代理服务器上执行，每个服务器只访问训练支持向量机所需的结果点积的一部分。我们的方案在半诚实对手模型下是安全的。我们在真实的HIV数据集和合成数据集上进行了实验，以显示我们协议的有效性和效率。在未来的工作中，我们将使我们的协议在不显著降低性能的情况下确保免受恶意攻击的安全。","source":"_posts/论文笔记-Privacy-preserving-SVM-on-Outsourced-Genomic-Data-via-Secure-Multi-party-Computation.md","raw":"---\ntitle: >-\n  论文笔记 Privacy-preserving SVM on Outsourced Genomic Data via Secure Multi-party\n  Computation\ndate: 2020-07-02 10:22:19\ncategories: Papers\ntags: [SVM, MPC, PPML, Secret Sharing, HIV co-receptor prediction]\n---\n\n*Huajie Chen, Ali Burak Ünal, Mete Akgün, Nico Pfeifer∗*\n\n[IWSPA@CODASPY 2020](https://dblp.uni-trier.de/db/conf/codaspy/iwspa2020.html#ChenUAP20)\n\nhttps://dl.acm.org/doi/abs/10.1145/3375708.3380316\n\n<!--more-->\n\n# 摘要\n\n机器学习方法以其高效、强大的数据挖掘能力被广泛应用于医学数据研究等领域。然而，将不受保护的数据提交给试图训练机器学习模型的第三方，当第三方受到对手的攻击时，可能会受到数据泄露和隐私侵犯的影响。因此，设计一种执行加密计算的协议是不可避免的。为了解决这个问题，我们提出了基于安全多方计算的协议来私下训练支持向量机模型。利用半诚实对手模型和不经意转移，所提出的协议能够在不牺牲个人隐私的情况下对来自不同来源的组合数据进行非线性支持向量机训练。这些协议被应用于在HIV序列数据上训练具有径向基函数核的支持向量机模型，以预测某种抗病毒药物的疗效，这只有在病毒只能使用人类CCR5辅助受体进入细胞的情况下才有效。以10个由随机生成的整数组成的数据源(每个数据源包含100个标记样本)的合成数据为基准，该协议在算术/布尔电路中分别平均消耗了2991.386/166.912毫秒的在线时间。优化后的参数对训练数据的交叉验证平均达到0.5819 F1分，随后在由CCR5及其亚型蛋白序列组成的测试数据集上交叉验证达到0.7058 F1分。在实际数据上的完整训练和测试过程，编码后总共包含766个样本，924个特征，分别使用算术/布尔电路平均耗时43.75/15.84秒，与文献中的一些现有研究相比，这表明了我们协议的有效性和高效性。\n\n\n\n# INTRODUCTION\n\n近年来，机器学习方法在许多科学研究领域得到了广泛的应用，通过发现数据中的模式来解决问题。在医疗数据上应用机器学习方法，例如支持向量机(SVM)，使得能够检测先前未知或对于人类实体来说太难识别的模式。因此，它可以为医疗技术的发展做出贡献。例如，通过使用聚类、多维缩放和支持向量机来表征新的艾滋病毒耐药突变[19]。以“稀疏组套索回归”为核心的基于网络的预后预测(NOP)方法已被编制成基于基因表达谱的乳腺癌状态预测方法[1]，人工神经网络(ANN)可以给出癌症的预测和预后[3]。\n\n随着最新的技术，如第二代/第三代DNA测序，获得完整的人类基因组已经变得高效和廉价，导致许多研究解决了各种与健康相关的研究问题。然而，在第三方访问数据的过程中，患者的隐私可能会受到泄露。针对这一问题，设计了基于安全多方计算(MPC)[13，14]和同态加密[6，8，10]的隐私保护机器学习方法。然而，这些方法在不同的安全假设下表现出不同的性能。这意味着他们必须在隐私和性能之间进行权衡。据我们所知，利用预测控制训练非线性支持向量机缺乏有效的方法。\n\n\n\n## Contributions\n\n在本文中，我们设计并实现了一个基于MPC的解决方案，将支持向量机训练外包给两个非合谋的代理服务器。我们的目标是使支持向量机在来自多个来源的海量数据上的隐私保护训练变得高效。为此，我们提出了基于算术秘密共享的Beaver乘法三元组[2]和基于布尔秘密共享的Goldreich-MicaliWigderson(GMW)协议[7]的两种不同的解决方案。我们使用单指令多数据(SIMD)操作，允许并行化来提高协议的性能。\n\n在我们的协议中，初始化阶段可以在本地完成。来自各种数据源(如医院)的基因组序列数据首先采用独热编码进行编码。接下来，编码序列被分成两份，并分别分配给计算方。自己的点积也在当地计算、拆分并分发给各方。在训练过程中，在计算方之间进行MPC，得到计算结果，然后将计算结果发送给用户并进行重构，得到包含来自不同来源的数据的点积以及来自同一方的数据的点积的完整的GRAM矩阵。最后，用户在所需的核矩阵上训练SVM模型，该核矩阵可以通过导出的GRAM矩阵来计算。类别标签在纯文本域中发送，因为它们不会显示关于样本的任何额外信息。\n\n我们将我们的方案应用于HIV序列数据，以预测某种抗病毒药物的疗效，只有当病毒只能使用人类CCR5辅助受体进入细胞时，这种方法才有效。我们设计的基于算术和布尔电路的协议对10个由随机生成的整数组成的数据源的在线执行电路消耗了2991.38/166.912毫秒的时间，每个数据源包含100个带标签的样本，每个样本中有924个特征，即列。我们通过F1-Score对我们的结果进行了评估，训练数据的平均得分为0.5819，测试数据的平均得分为0.7058，证明了该协议的有效性。在算术/布尔电路协议中，对实际数据的完整训练和测试过程分别花费了算术/布尔电路协议的43.75/15.84秒，编码后总共包含766个样本，924个特征。\n\n论文的其余部分安排如下：第二部分介绍了相关工作。第3节和第4节分别列出了所需的预备知识和协议的详细概念。第五节对协议进行了评价和进一步的讨论。第六节对本文进行了总结。\n\n\n\n# PRELIMINARIES\n\n在这一部分中，给出了我们的方法所使用的方法和算法。\n\n\n\n## 序列独热编码\n\n在数据预处理阶段，我们使用的序列通过一次热编码被编码成数字形式。假设 $c_i$ 是序列 $S$ 中位置 $i$ 处的角色，其中 $i \\in \\mathbb{Z}, i< |S|$。因为有20个氨基酸残基和1个GAP，所以 $c_i$ 可以编码成21位的形式。\n\n例如，如果 $c_i$ 是丙氨酸，则 $c_i$ 将被编码为 \"$1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0$\"，如果 $c_i$ 是一个GAP，则 $c_i$ 为 \"$0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1$\"。随着编码程序的迭代，整个序列将被编码成上述格式。\n\n\n\n## 序列相似性的度量\n\n为了评估序列的相似性，利用了汉明距离的倒数。汉明距离被描述为在具有相同长度的两个字符串之间的相同位置处的不同字符对的数量。例如，给定两个长度相同的字符串 $s_1$ 和 $s_2$，每个字符串中总共有 $l$ 个字符。$D_{\\mathbb{H}}$ 为字符串 $s_1$ 和 $s_2$ 定义的汉明距离：\n$$\nD_{\\mathbb{H}}(s_1, s_2) = \\sum^{l}_{i=1}I(s_1(i),s_2(i))\n$$\n其中 $l$ 是序列的长度，$I$ 是函数，如果给定的两个字符 $s_1(i)$ 和 $$s_2(i)$$ 相同，则该函数返回1，否则返回0。在本项目中，两个序列的碱基相似度与汉明距离成反比，即 $l-D_{\\mathbb{H}}(s_1, s_2)$。\n\n根据第3.1节，现在可以将一个序列视为二进制值的一个向量 $\\vec{v}$。如果同一位置的任意两个序列中的任意两个字符相同，则这两个编码字符的点积 $\\vec{v_1} \\cdot \\vec{v_2}$ 结果为1，否则为0。在这种情况下，两个序列的相似性越大，点积就越高。一旦计算了所有可能的序列对的相似度，就获得了矩阵 $\\mathbf{M} \\in \\mathbb{Z}^{n \\times n}$，其中 $n$ 表示计算中涉及的序列的数目。\n\n\n\n## 安全多方计算\n\n这里作者采用两方的设置，可以参考[ABY](https://yuyingwai.cn/2020/06/11/论文笔记-ABY-A-Framework-for-Efficient-Mixed-Protocol-Secure-Two-Party-Computation/)中第2节的算术共享和布尔共享。\n\n\n\n## 支持向量机\n\n支持向量机作为一种有监督的机器学习方法，经常被用来解决分类问题。它们已被证明在解决中、低尺度预测问题上优于许多其他方法，特别是在结合核函数的情况下。支持向量机的优化问题表示如下：\n$$\n\\begin{align}\n\\min_{\\omega \\in \\mathbb{R}^d, b\\in \\mathbb{R}, \\xi \\in \\mathbb{R}^n} \\ \\ \\  &\\frac{1}{2} ||\\omega||^2 + \\frac{C}{n}\\sum^n_{i=1} \\xi_i \\\\\n\\mbox{s.t.} \\ \\ \\  &Y_i(\\langle \\omega, X_i \\rangle + b) \\geq 1 - \\xi_i \\tag{1} \\\\\n &i=1,...,n,\\  \\xi_i \\geq 0\n\\end{align}\n$$\n其中，$\\omega, b, \\xi, C, n$ 遵循列出的顺序，分别表示具有 $n$ 维数的向量、干扰 $\\omega$ 和 $X_i$ 之间的点积的参数、确定点可以超出超平面多远的参数、惩罚的权重以及数据点的数量 $Y$。$X_i$ 和 $Y_i$ 表示数据特征向量及其标注。在上述支持向量机模型中，数据点被允许穿过超平面，但将受到松弛变量 $\\xi_i$ 的惩罚，该松弛变量由惩罚因子 $C$ 缩放。通过调整 $C$，可以改变惩罚的权重。\n\n\n\n## 径向基函数核\n\nRBF核因其有效性和普适性而被广泛应用于支持向量机分类中[9]，其核函数定义如下：\n$$\n\\begin{align}\nK(\\vec{x}, \\vec{y}) &= \\exp(- \\frac{||\\vec{x} - \\vec{y}||^2}{2\\sigma^2}) \\tag{2}\\\\ \n&= \\exp(-\\frac{\\vec{x} \\cdot \\vec{x} - 2 \\vec{x} \\cdot \\vec{y} + \\vec{y} \\cdot \\vec{y}}{2 \\sigma^2})\n\\end{align}\n$$\n\n在这个方程中，“$\\cdot$” 表示向量之间的点积算子，而 $\\sigma$ 则作为调整相似度的参数，当 $\\sigma$ 增大时，指数函数的结果将趋于接近1，表明两个序列的相似度较高，反之亦然，此外，方程的第二行表明，在我们的协议中，只能根据用于计算径向基核矩阵的向量的点积来计算径向基核。\n\n\n\n# 隐私保护支持向量机\n\n在这一部分中，我们系统地描述了我们的隐私保护支持向量机协议。在4.1节中，我们将对其进行概述，随后将详细说明协议的各个阶段。这里继承了3.3节中的记号。\n\n\n\n## 系统概述\n\n在我们的协议中，来自多个医疗机构的基因组数据集以秘密共享的形式被外包给两个非共谋的代理服务器。两个非合谋的代理服务器在收到允许查询数据的第三方(如研究人员)的请求后，执行MPC以生成支持向量机训练所需的样本的GRAM矩阵。协议结构如图1所示，在此协议中，有以下各方扮演的角色：\n\n1. **数据源：**在此上下文中，它们是医疗机构，表示为 $H_j$，其中 $j \\in \\mathbb{N}^+ , j \\leq n$，其中 $n$ 表示数据源的数量。他们以秘密共享的形式将基因组数据上传到两个代理服务器。\n2. **用户：**用户 $U$，例如科学研究人员，他请求两个代理服务器对秘密共享数据执行一些安全计算，以产生用于支持向量机训练的格拉姆矩阵。\n3. **两个代理服务器：**两个非合谋服务器作为计算方，记为 $P_i$，其中 $i \\in \\{0,1\\}$ 负责格拉姆矩阵的安全计算。在利用基因组数据训练机器学习模型的同时，选择两个不完全信任的第三方被认为是确保隐私保护的最实用和最实惠的解决方案[17]。\n\n![](http://images.yingwai.top/picgo/ppossvmf1.png)\n\n<center>\n    <i>图1 协议结构：从数据源到MPC，最终到用户进程</i>\n</center>\n\n\n\n\n### 初始化\n\n1. $H_j$ 中的原始序列数据在本地编码为数字矢量(参见第4.2节)。\n2. 在 $H_j$ 中，编码的序列数据在本地被分成两个共享 $A/B$，并分别发送到 $P_0$ 和 $P_1$ (参见第4.3节)。\n3. 在 $H_j$ 中本地预先计算自身点积，然后它们也被分成两个份额 $A/B$，并分别发送到 $P_0$ 和 $P_1$ (参见第4.4节)。\n\n\n\n### 训练过程\n\n4. 接收到来自 $U$ 的查询后，在 $P_0$ 和 $P_1$ 之间进行预测编码，以在包含编码序列的文件之间获得所需的处理数据(参见第4.5节和第4.6节)。\n5. 然后对自积和交叉点乘积进行积分以获得整个格拉姆矩阵，并将其传递给 $U$ (参见第4.7节)。\n6. 在 $U$ 中使用格拉姆矩阵来训练支持向量机模型并测试结果模型(参见第4.8节)。\n\n\n\n## 蛋白质序列编码\n\n序列编码功能采用代表一个残基的一个字符，并将其编码为21位格式，如3.1节所述。输出文件包含编码序列，其中每行代表一个蛋白质序列，21列中的每一列代表一个残基(或gap)。\n\n\n\n## 编码数据的秘密共享\n\n使用算术共享和布尔共享将原始编码数据分割成两个共享。在基于算术共享的协议中，产生的随机整数小于 $2^l$。此后，随机整数将作为共享并帮助构建另一个共享。在基于布尔共享的协议中，随机比特被生成为一个共享，并且它们被用来构造另一个共享。最终，在这两种协议中，两个共享将分别写入两个文件。使用算术共享的编码数据的秘密共享如图2所示。\n\n![](http://images.yingwai.top/picgo/ppossvmf2.png)\n\n<center>\n    <i>图2 共享数据生成</i>\n</center>\n\n\n\n\n## 本地计算自点积\n\n数据源计算“自身点积”，这意味着每个数据点的两个实例的点积是在本地计算的。这样的本地计算降低了总的通信成本。该过程的结果是由前面提到的共享数据生成技术产生的点积矩阵的两部分。点积矩阵的份额接下来被分发到两个第三方代理服务器上，即 $P_0$ 和 $P_1$，然后可以在 $U$ 上重建这些份额。\n\n\n\n## 使用算术电路进行点积计算\n\n所有需要乘成两个长数组的文件都被集成，省略了重复SIMD数据生成的不必要步骤。例如，假设文件 $A$、文件 $B$、文件 $C$ 分别表示为 $f_a$，$f_b$ 和 $f_c$，则这些文件中分别包含3、2和1个共享编码序列，由 $a_i,b_i,c_i$ 表示，其中 $i$ 表示某个文件中的序列索引。长阵列A将是 “$a_1a_2a_3a_1a_2a_3a_1a_2a_3b_1b_2$”，而另一个长阵列将是 “$b_1b_1b_1b_2b_2b_2c_1c_1c_1c_1c_1$”。这些操作分别称为 $\\mbox{GetLongArrayA}()$ 和 $\\mbox{GetLongArrayB}()$。\n\n![](http://images.yingwai.top/picgo/ppossvma1.png)\n\n算法1首先构造两个长数组，以减少创建SIMD数据的次数。通过一次乘以两个长阵列，成功地降低了协议的运行时间。此算法省略了文件与其自身之间的点积计算，因为它可以先前本地计算，如第4.4节所述。通过将数组放入SIMD共享，从而实现对多个数据的操作。在乘法之后，然后执行每个点积计算块中的乘法结果的求和，以便分别对来自两个向量的每对元素的乘法进行局部求和。最后，将最终结果加载到数组中。图3显示了基于算术电路的安全协议的一般结构。\n\n\n\n## 基于布尔电路的点积计算\n\n算法2类似于算法1。协议的结构如图3所示。两者之间的区别在于共享类型和电路类型。在此上下文中，仅在0和1之间执行乘法，这符合布尔共享的位长(1位)。因此，布尔电路中的安全与运算可以取代算术电路中的安全乘法，实现更好的计算性能。因此，共享的位长可以减少到1，这可以在通信过程中节省大量的计算能力。就布尔份额而言，它与算术份额差别很大，因此在以以前的方式局部相乘后无法求和。因此，设计了基于安全加法的特定函数，用于在点积块中对乘法结果求和。\n\n![](http://images.yingwai.top/picgo/ppossvmf3.png)\n\n<center>\n    <i>图3 点积计算</i>\n</center>\n\n![](http://images.yingwai.top/picgo/ppossvma2_.png)\n\n\n\n## 结果数组集成与点积矩阵生成\n\n通过我们的协议，可以在 $U$ 上手动将自身的点积重构成一个数组。然后计算自/交叉点乘积数组中访问位置的索引表。基于索引表，将生成 $2D$ 矢量，即 $n \\times n$ 矩阵，其中 $n$ 表示计算中涉及的序列总数，并将其写入文件中作为最终输出。在机器学习中，必须严格遵循数据和标签的顺序，这样才能正确地训练模型。因此，数组的排序过程是必不可少的。\n\n\n\n## 支持向量机交叉验证实验\n\n在所有数据中，随机选取20%的数据对模型进行检验。在计算格拉姆矩阵的基础上，通过5次交叉验证对支持向量机的误分类惩罚参数 $C$、类不平衡权值 $W$ 和径向基函数的相似度调整参数 $\\sigma$ 进行优化。$C$ 和 $\\sigma$ 分别在集合 $s_C=[10^{-3},10^{-2},\\cdot \\cdot \\cdot,10^2, 10^3]$，$S_{\\sigma}=[0.125, 0.25, 0.5, 1, 2, 4, 8]$ 上进行优化，而类权重选自集合 $S_W = [1:1,1:2,1:4,1:8,1:16]$，前者表示标签0的类权重，前者占多数，后者表示标签1的类权重。最终，确定在优化过程中达到最高F1得分的参数集。然后，利用这些最优参数对最终模型进行训练。最后，利用测试数据对训练好的模型进行检验，并用F1得分对预测结果进行评估。\n\n\n\n## 安全性分析\n\n将数据外包给 $N$ 非合谋、半诚实的第三方是在[11]中首次研究的。给出了通用解决方案的安全性证明。在我们的协议中，利用[11]中的外包思想，多个医疗机构将基因组数据外包给两个非合谋、半诚实的第三方。我们需要保护个人的隐私，他们的基因组数据被外包给两个非串通的服务器。我们基于算术电路和布尔电路的协议的安全性依赖于分别基于Beaver乘法三元组的协议[2]和GMW协议[7]的已证明的安全性。一个半诚实的对手最多可以攻破一个代理服务器，就可以获得个人私有基因组数据的一份。我们知道基因组数据是通过算术或布尔共享来共享的，所以它看起来像是统一随机的数据。这确保了敌手不能获得任何有关个人的私人基因组数据。我们的协议是安全的，不会受到恶意数据提供商和用户的攻击。数据提供者仅以共享的形式向两个代理服务器发送基因组数据，并且不接收来自其他方的任何消息。他们的恶意输入不会导致任何数据泄露。用户输入的任何变化都会导致不同的分析响应。这确保了针对恶意用户的安全性。所有通信方之间的机密性、完整性和认证都是使用最先进的技术(如TLS[5])提供的。\n\n\n\n# CONCLUSION\n\n本文提出了两种支持向量机隐私保护训练方案，用于支持向量机对来自多个来源的外包基因组数据的隐私保护训练。在我们的方案中，我们利用算术秘密共享、布尔秘密共享和不经意转移来同时保证支持向量机训练的安全和高效。我们的协议在两个半可信代理服务器上执行，每个服务器只访问训练支持向量机所需的结果点积的一部分。我们的方案在半诚实对手模型下是安全的。我们在真实的HIV数据集和合成数据集上进行了实验，以显示我们协议的有效性和效率。在未来的工作中，我们将使我们的协议在不显著降低性能的情况下确保免受恶意攻击的安全。","slug":"论文笔记-Privacy-preserving-SVM-on-Outsourced-Genomic-Data-via-Secure-Multi-party-Computation","published":1,"updated":"2020-08-23T14:33:37.437Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cke79q4tq004l88ps4h9fbz47","content":"<p><em>Huajie Chen, Ali Burak Ünal, Mete Akgün, Nico Pfeifer∗</em></p>\n<p><a href=\"https://dblp.uni-trier.de/db/conf/codaspy/iwspa2020.html#ChenUAP20\" target=\"_blank\" rel=\"noopener\">IWSPA@CODASPY 2020</a></p>\n<p><a href=\"https://dl.acm.org/doi/abs/10.1145/3375708.3380316\" target=\"_blank\" rel=\"noopener\">https://dl.acm.org/doi/abs/10.1145/3375708.3380316</a></p>\n<a id=\"more\"></a>\n<h1 id=\"摘要\"><a href=\"#摘要\" class=\"headerlink\" title=\"摘要\"></a>摘要</h1><p>机器学习方法以其高效、强大的数据挖掘能力被广泛应用于医学数据研究等领域。然而，将不受保护的数据提交给试图训练机器学习模型的第三方，当第三方受到对手的攻击时，可能会受到数据泄露和隐私侵犯的影响。因此，设计一种执行加密计算的协议是不可避免的。为了解决这个问题，我们提出了基于安全多方计算的协议来私下训练支持向量机模型。利用半诚实对手模型和不经意转移，所提出的协议能够在不牺牲个人隐私的情况下对来自不同来源的组合数据进行非线性支持向量机训练。这些协议被应用于在HIV序列数据上训练具有径向基函数核的支持向量机模型，以预测某种抗病毒药物的疗效，这只有在病毒只能使用人类CCR5辅助受体进入细胞的情况下才有效。以10个由随机生成的整数组成的数据源(每个数据源包含100个标记样本)的合成数据为基准，该协议在算术/布尔电路中分别平均消耗了2991.386/166.912毫秒的在线时间。优化后的参数对训练数据的交叉验证平均达到0.5819 F1分，随后在由CCR5及其亚型蛋白序列组成的测试数据集上交叉验证达到0.7058 F1分。在实际数据上的完整训练和测试过程，编码后总共包含766个样本，924个特征，分别使用算术/布尔电路平均耗时43.75/15.84秒，与文献中的一些现有研究相比，这表明了我们协议的有效性和高效性。</p>\n<h1 id=\"INTRODUCTION\"><a href=\"#INTRODUCTION\" class=\"headerlink\" title=\"INTRODUCTION\"></a>INTRODUCTION</h1><p>近年来，机器学习方法在许多科学研究领域得到了广泛的应用，通过发现数据中的模式来解决问题。在医疗数据上应用机器学习方法，例如支持向量机(SVM)，使得能够检测先前未知或对于人类实体来说太难识别的模式。因此，它可以为医疗技术的发展做出贡献。例如，通过使用聚类、多维缩放和支持向量机来表征新的艾滋病毒耐药突变[19]。以“稀疏组套索回归”为核心的基于网络的预后预测(NOP)方法已被编制成基于基因表达谱的乳腺癌状态预测方法[1]，人工神经网络(ANN)可以给出癌症的预测和预后[3]。</p>\n<p>随着最新的技术，如第二代/第三代DNA测序，获得完整的人类基因组已经变得高效和廉价，导致许多研究解决了各种与健康相关的研究问题。然而，在第三方访问数据的过程中，患者的隐私可能会受到泄露。针对这一问题，设计了基于安全多方计算(MPC)[13，14]和同态加密[6，8，10]的隐私保护机器学习方法。然而，这些方法在不同的安全假设下表现出不同的性能。这意味着他们必须在隐私和性能之间进行权衡。据我们所知，利用预测控制训练非线性支持向量机缺乏有效的方法。</p>\n<h2 id=\"Contributions\"><a href=\"#Contributions\" class=\"headerlink\" title=\"Contributions\"></a>Contributions</h2><p>在本文中，我们设计并实现了一个基于MPC的解决方案，将支持向量机训练外包给两个非合谋的代理服务器。我们的目标是使支持向量机在来自多个来源的海量数据上的隐私保护训练变得高效。为此，我们提出了基于算术秘密共享的Beaver乘法三元组[2]和基于布尔秘密共享的Goldreich-MicaliWigderson(GMW)协议[7]的两种不同的解决方案。我们使用单指令多数据(SIMD)操作，允许并行化来提高协议的性能。</p>\n<p>在我们的协议中，初始化阶段可以在本地完成。来自各种数据源(如医院)的基因组序列数据首先采用独热编码进行编码。接下来，编码序列被分成两份，并分别分配给计算方。自己的点积也在当地计算、拆分并分发给各方。在训练过程中，在计算方之间进行MPC，得到计算结果，然后将计算结果发送给用户并进行重构，得到包含来自不同来源的数据的点积以及来自同一方的数据的点积的完整的GRAM矩阵。最后，用户在所需的核矩阵上训练SVM模型，该核矩阵可以通过导出的GRAM矩阵来计算。类别标签在纯文本域中发送，因为它们不会显示关于样本的任何额外信息。</p>\n<p>我们将我们的方案应用于HIV序列数据，以预测某种抗病毒药物的疗效，只有当病毒只能使用人类CCR5辅助受体进入细胞时，这种方法才有效。我们设计的基于算术和布尔电路的协议对10个由随机生成的整数组成的数据源的在线执行电路消耗了2991.38/166.912毫秒的时间，每个数据源包含100个带标签的样本，每个样本中有924个特征，即列。我们通过F1-Score对我们的结果进行了评估，训练数据的平均得分为0.5819，测试数据的平均得分为0.7058，证明了该协议的有效性。在算术/布尔电路协议中，对实际数据的完整训练和测试过程分别花费了算术/布尔电路协议的43.75/15.84秒，编码后总共包含766个样本，924个特征。</p>\n<p>论文的其余部分安排如下：第二部分介绍了相关工作。第3节和第4节分别列出了所需的预备知识和协议的详细概念。第五节对协议进行了评价和进一步的讨论。第六节对本文进行了总结。</p>\n<h1 id=\"PRELIMINARIES\"><a href=\"#PRELIMINARIES\" class=\"headerlink\" title=\"PRELIMINARIES\"></a>PRELIMINARIES</h1><p>在这一部分中，给出了我们的方法所使用的方法和算法。</p>\n<h2 id=\"序列独热编码\"><a href=\"#序列独热编码\" class=\"headerlink\" title=\"序列独热编码\"></a>序列独热编码</h2><p>在数据预处理阶段，我们使用的序列通过一次热编码被编码成数字形式。假设 $c_i$ 是序列 $S$ 中位置 $i$ 处的角色，其中 $i \\in \\mathbb{Z}, i&lt; |S|$。因为有20个氨基酸残基和1个GAP，所以 $c_i$ 可以编码成21位的形式。</p>\n<p>例如，如果 $c_i$ 是丙氨酸，则 $c_i$ 将被编码为 “$1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0$”，如果 $c_i$ 是一个GAP，则 $c_i$ 为 “$0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1$”。随着编码程序的迭代，整个序列将被编码成上述格式。</p>\n<h2 id=\"序列相似性的度量\"><a href=\"#序列相似性的度量\" class=\"headerlink\" title=\"序列相似性的度量\"></a>序列相似性的度量</h2><p>为了评估序列的相似性，利用了汉明距离的倒数。汉明距离被描述为在具有相同长度的两个字符串之间的相同位置处的不同字符对的数量。例如，给定两个长度相同的字符串 $s<em>1$ 和 $s_2$，每个字符串中总共有 $l$ 个字符。$D</em>{\\mathbb{H}}$ 为字符串 $s_1$ 和 $s_2$ 定义的汉明距离：</p>\n<script type=\"math/tex; mode=display\">\nD_{\\mathbb{H}}(s_1, s_2) = \\sum^{l}_{i=1}I(s_1(i),s_2(i))</script><p>其中 $l$ 是序列的长度，$I$ 是函数，如果给定的两个字符 $s<em>1(i)$ 和 <script type=\"math/tex\">s_2(i)</script> 相同，则该函数返回1，否则返回0。在本项目中，两个序列的碱基相似度与汉明距离成反比，即 $l-D</em>{\\mathbb{H}}(s_1, s_2)$。</p>\n<p>根据第3.1节，现在可以将一个序列视为二进制值的一个向量 $\\vec{v}$。如果同一位置的任意两个序列中的任意两个字符相同，则这两个编码字符的点积 $\\vec{v_1} \\cdot \\vec{v_2}$ 结果为1，否则为0。在这种情况下，两个序列的相似性越大，点积就越高。一旦计算了所有可能的序列对的相似度，就获得了矩阵 $\\mathbf{M} \\in \\mathbb{Z}^{n \\times n}$，其中 $n$ 表示计算中涉及的序列的数目。</p>\n<h2 id=\"安全多方计算\"><a href=\"#安全多方计算\" class=\"headerlink\" title=\"安全多方计算\"></a>安全多方计算</h2><p>这里作者采用两方的设置，可以参考<a href=\"https://yuyingwai.cn/2020/06/11/论文笔记-ABY-A-Framework-for-Efficient-Mixed-Protocol-Secure-Two-Party-Computation/\" target=\"_blank\" rel=\"noopener\">ABY</a>中第2节的算术共享和布尔共享。</p>\n<h2 id=\"支持向量机\"><a href=\"#支持向量机\" class=\"headerlink\" title=\"支持向量机\"></a>支持向量机</h2><p>支持向量机作为一种有监督的机器学习方法，经常被用来解决分类问题。它们已被证明在解决中、低尺度预测问题上优于许多其他方法，特别是在结合核函数的情况下。支持向量机的优化问题表示如下：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{align}\n\\min_{\\omega \\in \\mathbb{R}^d, b\\in \\mathbb{R}, \\xi \\in \\mathbb{R}^n} \\ \\ \\  &\\frac{1}{2} ||\\omega||^2 + \\frac{C}{n}\\sum^n_{i=1} \\xi_i \\\\\n\\mbox{s.t.} \\ \\ \\  &Y_i(\\langle \\omega, X_i \\rangle + b) \\geq 1 - \\xi_i \\tag{1} \\\\\n &i=1,...,n,\\  \\xi_i \\geq 0\n\\end{align}</script><p>其中，$\\omega, b, \\xi, C, n$ 遵循列出的顺序，分别表示具有 $n$ 维数的向量、干扰 $\\omega$ 和 $X_i$ 之间的点积的参数、确定点可以超出超平面多远的参数、惩罚的权重以及数据点的数量 $Y$。$X_i$ 和 $Y_i$ 表示数据特征向量及其标注。在上述支持向量机模型中，数据点被允许穿过超平面，但将受到松弛变量 $\\xi_i$ 的惩罚，该松弛变量由惩罚因子 $C$ 缩放。通过调整 $C$，可以改变惩罚的权重。</p>\n<h2 id=\"径向基函数核\"><a href=\"#径向基函数核\" class=\"headerlink\" title=\"径向基函数核\"></a>径向基函数核</h2><p>RBF核因其有效性和普适性而被广泛应用于支持向量机分类中[9]，其核函数定义如下：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{align}\nK(\\vec{x}, \\vec{y}) &= \\exp(- \\frac{||\\vec{x} - \\vec{y}||^2}{2\\sigma^2}) \\tag{2}\\\\ \n&= \\exp(-\\frac{\\vec{x} \\cdot \\vec{x} - 2 \\vec{x} \\cdot \\vec{y} + \\vec{y} \\cdot \\vec{y}}{2 \\sigma^2})\n\\end{align}</script><p>在这个方程中，“$\\cdot$” 表示向量之间的点积算子，而 $\\sigma$ 则作为调整相似度的参数，当 $\\sigma$ 增大时，指数函数的结果将趋于接近1，表明两个序列的相似度较高，反之亦然，此外，方程的第二行表明，在我们的协议中，只能根据用于计算径向基核矩阵的向量的点积来计算径向基核。</p>\n<h1 id=\"隐私保护支持向量机\"><a href=\"#隐私保护支持向量机\" class=\"headerlink\" title=\"隐私保护支持向量机\"></a>隐私保护支持向量机</h1><p>在这一部分中，我们系统地描述了我们的隐私保护支持向量机协议。在4.1节中，我们将对其进行概述，随后将详细说明协议的各个阶段。这里继承了3.3节中的记号。</p>\n<h2 id=\"系统概述\"><a href=\"#系统概述\" class=\"headerlink\" title=\"系统概述\"></a>系统概述</h2><p>在我们的协议中，来自多个医疗机构的基因组数据集以秘密共享的形式被外包给两个非共谋的代理服务器。两个非合谋的代理服务器在收到允许查询数据的第三方(如研究人员)的请求后，执行MPC以生成支持向量机训练所需的样本的GRAM矩阵。协议结构如图1所示，在此协议中，有以下各方扮演的角色：</p>\n<ol>\n<li><strong>数据源：</strong>在此上下文中，它们是医疗机构，表示为 $H_j$，其中 $j \\in \\mathbb{N}^+ , j \\leq n$，其中 $n$ 表示数据源的数量。他们以秘密共享的形式将基因组数据上传到两个代理服务器。</li>\n<li><strong>用户：</strong>用户 $U$，例如科学研究人员，他请求两个代理服务器对秘密共享数据执行一些安全计算，以产生用于支持向量机训练的格拉姆矩阵。</li>\n<li><strong>两个代理服务器：</strong>两个非合谋服务器作为计算方，记为 $P_i$，其中 $i \\in {0,1}$ 负责格拉姆矩阵的安全计算。在利用基因组数据训练机器学习模型的同时，选择两个不完全信任的第三方被认为是确保隐私保护的最实用和最实惠的解决方案[17]。</li>\n</ol>\n<p><img src=\"http://images.yingwai.top/picgo/ppossvmf1.png\" alt=\"\"></p>\n<center>\n    <i>图1 协议结构：从数据源到MPC，最终到用户进程</i>\n</center>\n\n\n\n\n<h3 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h3><ol>\n<li>$H_j$ 中的原始序列数据在本地编码为数字矢量(参见第4.2节)。</li>\n<li>在 $H_j$ 中，编码的序列数据在本地被分成两个共享 $A/B$，并分别发送到 $P_0$ 和 $P_1$ (参见第4.3节)。</li>\n<li>在 $H_j$ 中本地预先计算自身点积，然后它们也被分成两个份额 $A/B$，并分别发送到 $P_0$ 和 $P_1$ (参见第4.4节)。</li>\n</ol>\n<h3 id=\"训练过程\"><a href=\"#训练过程\" class=\"headerlink\" title=\"训练过程\"></a>训练过程</h3><ol>\n<li>接收到来自 $U$ 的查询后，在 $P_0$ 和 $P_1$ 之间进行预测编码，以在包含编码序列的文件之间获得所需的处理数据(参见第4.5节和第4.6节)。</li>\n<li>然后对自积和交叉点乘积进行积分以获得整个格拉姆矩阵，并将其传递给 $U$ (参见第4.7节)。</li>\n<li>在 $U$ 中使用格拉姆矩阵来训练支持向量机模型并测试结果模型(参见第4.8节)。</li>\n</ol>\n<h2 id=\"蛋白质序列编码\"><a href=\"#蛋白质序列编码\" class=\"headerlink\" title=\"蛋白质序列编码\"></a>蛋白质序列编码</h2><p>序列编码功能采用代表一个残基的一个字符，并将其编码为21位格式，如3.1节所述。输出文件包含编码序列，其中每行代表一个蛋白质序列，21列中的每一列代表一个残基(或gap)。</p>\n<h2 id=\"编码数据的秘密共享\"><a href=\"#编码数据的秘密共享\" class=\"headerlink\" title=\"编码数据的秘密共享\"></a>编码数据的秘密共享</h2><p>使用算术共享和布尔共享将原始编码数据分割成两个共享。在基于算术共享的协议中，产生的随机整数小于 $2^l$。此后，随机整数将作为共享并帮助构建另一个共享。在基于布尔共享的协议中，随机比特被生成为一个共享，并且它们被用来构造另一个共享。最终，在这两种协议中，两个共享将分别写入两个文件。使用算术共享的编码数据的秘密共享如图2所示。</p>\n<p><img src=\"http://images.yingwai.top/picgo/ppossvmf2.png\" alt=\"\"></p>\n<center>\n    <i>图2 共享数据生成</i>\n</center>\n\n\n\n\n<h2 id=\"本地计算自点积\"><a href=\"#本地计算自点积\" class=\"headerlink\" title=\"本地计算自点积\"></a>本地计算自点积</h2><p>数据源计算“自身点积”，这意味着每个数据点的两个实例的点积是在本地计算的。这样的本地计算降低了总的通信成本。该过程的结果是由前面提到的共享数据生成技术产生的点积矩阵的两部分。点积矩阵的份额接下来被分发到两个第三方代理服务器上，即 $P_0$ 和 $P_1$，然后可以在 $U$ 上重建这些份额。</p>\n<h2 id=\"使用算术电路进行点积计算\"><a href=\"#使用算术电路进行点积计算\" class=\"headerlink\" title=\"使用算术电路进行点积计算\"></a>使用算术电路进行点积计算</h2><p>所有需要乘成两个长数组的文件都被集成，省略了重复SIMD数据生成的不必要步骤。例如，假设文件 $A$、文件 $B$、文件 $C$ 分别表示为 $f_a$，$f_b$ 和 $f_c$，则这些文件中分别包含3、2和1个共享编码序列，由 $a_i,b_i,c_i$ 表示，其中 $i$ 表示某个文件中的序列索引。长阵列A将是 “$a_1a_2a_3a_1a_2a_3a_1a_2a_3b_1b_2$”，而另一个长阵列将是 “$b_1b_1b_1b_2b_2b_2c_1c_1c_1c_1c_1$”。这些操作分别称为 $\\mbox{GetLongArrayA}()$ 和 $\\mbox{GetLongArrayB}()$。</p>\n<p><img src=\"http://images.yingwai.top/picgo/ppossvma1.png\" alt=\"\"></p>\n<p>算法1首先构造两个长数组，以减少创建SIMD数据的次数。通过一次乘以两个长阵列，成功地降低了协议的运行时间。此算法省略了文件与其自身之间的点积计算，因为它可以先前本地计算，如第4.4节所述。通过将数组放入SIMD共享，从而实现对多个数据的操作。在乘法之后，然后执行每个点积计算块中的乘法结果的求和，以便分别对来自两个向量的每对元素的乘法进行局部求和。最后，将最终结果加载到数组中。图3显示了基于算术电路的安全协议的一般结构。</p>\n<h2 id=\"基于布尔电路的点积计算\"><a href=\"#基于布尔电路的点积计算\" class=\"headerlink\" title=\"基于布尔电路的点积计算\"></a>基于布尔电路的点积计算</h2><p>算法2类似于算法1。协议的结构如图3所示。两者之间的区别在于共享类型和电路类型。在此上下文中，仅在0和1之间执行乘法，这符合布尔共享的位长(1位)。因此，布尔电路中的安全与运算可以取代算术电路中的安全乘法，实现更好的计算性能。因此，共享的位长可以减少到1，这可以在通信过程中节省大量的计算能力。就布尔份额而言，它与算术份额差别很大，因此在以以前的方式局部相乘后无法求和。因此，设计了基于安全加法的特定函数，用于在点积块中对乘法结果求和。</p>\n<p><img src=\"http://images.yingwai.top/picgo/ppossvmf3.png\" alt=\"\"></p>\n<center>\n    <i>图3 点积计算</i>\n</center>\n\n<p><img src=\"http://images.yingwai.top/picgo/ppossvma2_.png\" alt=\"\"></p>\n<h2 id=\"结果数组集成与点积矩阵生成\"><a href=\"#结果数组集成与点积矩阵生成\" class=\"headerlink\" title=\"结果数组集成与点积矩阵生成\"></a>结果数组集成与点积矩阵生成</h2><p>通过我们的协议，可以在 $U$ 上手动将自身的点积重构成一个数组。然后计算自/交叉点乘积数组中访问位置的索引表。基于索引表，将生成 $2D$ 矢量，即 $n \\times n$ 矩阵，其中 $n$ 表示计算中涉及的序列总数，并将其写入文件中作为最终输出。在机器学习中，必须严格遵循数据和标签的顺序，这样才能正确地训练模型。因此，数组的排序过程是必不可少的。</p>\n<h2 id=\"支持向量机交叉验证实验\"><a href=\"#支持向量机交叉验证实验\" class=\"headerlink\" title=\"支持向量机交叉验证实验\"></a>支持向量机交叉验证实验</h2><p>在所有数据中，随机选取20%的数据对模型进行检验。在计算格拉姆矩阵的基础上，通过5次交叉验证对支持向量机的误分类惩罚参数 $C$、类不平衡权值 $W$ 和径向基函数的相似度调整参数 $\\sigma$ 进行优化。$C$ 和 $\\sigma$ 分别在集合 $s<em>C=[10^{-3},10^{-2},\\cdot \\cdot \\cdot,10^2, 10^3]$，$S</em>{\\sigma}=[0.125, 0.25, 0.5, 1, 2, 4, 8]$ 上进行优化，而类权重选自集合 $S_W = [1:1,1:2,1:4,1:8,1:16]$，前者表示标签0的类权重，前者占多数，后者表示标签1的类权重。最终，确定在优化过程中达到最高F1得分的参数集。然后，利用这些最优参数对最终模型进行训练。最后，利用测试数据对训练好的模型进行检验，并用F1得分对预测结果进行评估。</p>\n<h2 id=\"安全性分析\"><a href=\"#安全性分析\" class=\"headerlink\" title=\"安全性分析\"></a>安全性分析</h2><p>将数据外包给 $N$ 非合谋、半诚实的第三方是在[11]中首次研究的。给出了通用解决方案的安全性证明。在我们的协议中，利用[11]中的外包思想，多个医疗机构将基因组数据外包给两个非合谋、半诚实的第三方。我们需要保护个人的隐私，他们的基因组数据被外包给两个非串通的服务器。我们基于算术电路和布尔电路的协议的安全性依赖于分别基于Beaver乘法三元组的协议[2]和GMW协议[7]的已证明的安全性。一个半诚实的对手最多可以攻破一个代理服务器，就可以获得个人私有基因组数据的一份。我们知道基因组数据是通过算术或布尔共享来共享的，所以它看起来像是统一随机的数据。这确保了敌手不能获得任何有关个人的私人基因组数据。我们的协议是安全的，不会受到恶意数据提供商和用户的攻击。数据提供者仅以共享的形式向两个代理服务器发送基因组数据，并且不接收来自其他方的任何消息。他们的恶意输入不会导致任何数据泄露。用户输入的任何变化都会导致不同的分析响应。这确保了针对恶意用户的安全性。所有通信方之间的机密性、完整性和认证都是使用最先进的技术(如TLS[5])提供的。</p>\n<h1 id=\"CONCLUSION\"><a href=\"#CONCLUSION\" class=\"headerlink\" title=\"CONCLUSION\"></a>CONCLUSION</h1><p>本文提出了两种支持向量机隐私保护训练方案，用于支持向量机对来自多个来源的外包基因组数据的隐私保护训练。在我们的方案中，我们利用算术秘密共享、布尔秘密共享和不经意转移来同时保证支持向量机训练的安全和高效。我们的协议在两个半可信代理服务器上执行，每个服务器只访问训练支持向量机所需的结果点积的一部分。我们的方案在半诚实对手模型下是安全的。我们在真实的HIV数据集和合成数据集上进行了实验，以显示我们协议的有效性和效率。在未来的工作中，我们将使我们的协议在不显著降低性能的情况下确保免受恶意攻击的安全。</p>\n","site":{"data":{}},"excerpt":"<p><em>Huajie Chen, Ali Burak Ünal, Mete Akgün, Nico Pfeifer∗</em></p>\n<p><a href=\"https://dblp.uni-trier.de/db/conf/codaspy/iwspa2020.html#ChenUAP20\" target=\"_blank\" rel=\"noopener\">IWSPA@CODASPY 2020</a></p>\n<p><a href=\"https://dl.acm.org/doi/abs/10.1145/3375708.3380316\" target=\"_blank\" rel=\"noopener\">https://dl.acm.org/doi/abs/10.1145/3375708.3380316</a></p>","more":"<h1 id=\"摘要\"><a href=\"#摘要\" class=\"headerlink\" title=\"摘要\"></a>摘要</h1><p>机器学习方法以其高效、强大的数据挖掘能力被广泛应用于医学数据研究等领域。然而，将不受保护的数据提交给试图训练机器学习模型的第三方，当第三方受到对手的攻击时，可能会受到数据泄露和隐私侵犯的影响。因此，设计一种执行加密计算的协议是不可避免的。为了解决这个问题，我们提出了基于安全多方计算的协议来私下训练支持向量机模型。利用半诚实对手模型和不经意转移，所提出的协议能够在不牺牲个人隐私的情况下对来自不同来源的组合数据进行非线性支持向量机训练。这些协议被应用于在HIV序列数据上训练具有径向基函数核的支持向量机模型，以预测某种抗病毒药物的疗效，这只有在病毒只能使用人类CCR5辅助受体进入细胞的情况下才有效。以10个由随机生成的整数组成的数据源(每个数据源包含100个标记样本)的合成数据为基准，该协议在算术/布尔电路中分别平均消耗了2991.386/166.912毫秒的在线时间。优化后的参数对训练数据的交叉验证平均达到0.5819 F1分，随后在由CCR5及其亚型蛋白序列组成的测试数据集上交叉验证达到0.7058 F1分。在实际数据上的完整训练和测试过程，编码后总共包含766个样本，924个特征，分别使用算术/布尔电路平均耗时43.75/15.84秒，与文献中的一些现有研究相比，这表明了我们协议的有效性和高效性。</p>\n<h1 id=\"INTRODUCTION\"><a href=\"#INTRODUCTION\" class=\"headerlink\" title=\"INTRODUCTION\"></a>INTRODUCTION</h1><p>近年来，机器学习方法在许多科学研究领域得到了广泛的应用，通过发现数据中的模式来解决问题。在医疗数据上应用机器学习方法，例如支持向量机(SVM)，使得能够检测先前未知或对于人类实体来说太难识别的模式。因此，它可以为医疗技术的发展做出贡献。例如，通过使用聚类、多维缩放和支持向量机来表征新的艾滋病毒耐药突变[19]。以“稀疏组套索回归”为核心的基于网络的预后预测(NOP)方法已被编制成基于基因表达谱的乳腺癌状态预测方法[1]，人工神经网络(ANN)可以给出癌症的预测和预后[3]。</p>\n<p>随着最新的技术，如第二代/第三代DNA测序，获得完整的人类基因组已经变得高效和廉价，导致许多研究解决了各种与健康相关的研究问题。然而，在第三方访问数据的过程中，患者的隐私可能会受到泄露。针对这一问题，设计了基于安全多方计算(MPC)[13，14]和同态加密[6，8，10]的隐私保护机器学习方法。然而，这些方法在不同的安全假设下表现出不同的性能。这意味着他们必须在隐私和性能之间进行权衡。据我们所知，利用预测控制训练非线性支持向量机缺乏有效的方法。</p>\n<h2 id=\"Contributions\"><a href=\"#Contributions\" class=\"headerlink\" title=\"Contributions\"></a>Contributions</h2><p>在本文中，我们设计并实现了一个基于MPC的解决方案，将支持向量机训练外包给两个非合谋的代理服务器。我们的目标是使支持向量机在来自多个来源的海量数据上的隐私保护训练变得高效。为此，我们提出了基于算术秘密共享的Beaver乘法三元组[2]和基于布尔秘密共享的Goldreich-MicaliWigderson(GMW)协议[7]的两种不同的解决方案。我们使用单指令多数据(SIMD)操作，允许并行化来提高协议的性能。</p>\n<p>在我们的协议中，初始化阶段可以在本地完成。来自各种数据源(如医院)的基因组序列数据首先采用独热编码进行编码。接下来，编码序列被分成两份，并分别分配给计算方。自己的点积也在当地计算、拆分并分发给各方。在训练过程中，在计算方之间进行MPC，得到计算结果，然后将计算结果发送给用户并进行重构，得到包含来自不同来源的数据的点积以及来自同一方的数据的点积的完整的GRAM矩阵。最后，用户在所需的核矩阵上训练SVM模型，该核矩阵可以通过导出的GRAM矩阵来计算。类别标签在纯文本域中发送，因为它们不会显示关于样本的任何额外信息。</p>\n<p>我们将我们的方案应用于HIV序列数据，以预测某种抗病毒药物的疗效，只有当病毒只能使用人类CCR5辅助受体进入细胞时，这种方法才有效。我们设计的基于算术和布尔电路的协议对10个由随机生成的整数组成的数据源的在线执行电路消耗了2991.38/166.912毫秒的时间，每个数据源包含100个带标签的样本，每个样本中有924个特征，即列。我们通过F1-Score对我们的结果进行了评估，训练数据的平均得分为0.5819，测试数据的平均得分为0.7058，证明了该协议的有效性。在算术/布尔电路协议中，对实际数据的完整训练和测试过程分别花费了算术/布尔电路协议的43.75/15.84秒，编码后总共包含766个样本，924个特征。</p>\n<p>论文的其余部分安排如下：第二部分介绍了相关工作。第3节和第4节分别列出了所需的预备知识和协议的详细概念。第五节对协议进行了评价和进一步的讨论。第六节对本文进行了总结。</p>\n<h1 id=\"PRELIMINARIES\"><a href=\"#PRELIMINARIES\" class=\"headerlink\" title=\"PRELIMINARIES\"></a>PRELIMINARIES</h1><p>在这一部分中，给出了我们的方法所使用的方法和算法。</p>\n<h2 id=\"序列独热编码\"><a href=\"#序列独热编码\" class=\"headerlink\" title=\"序列独热编码\"></a>序列独热编码</h2><p>在数据预处理阶段，我们使用的序列通过一次热编码被编码成数字形式。假设 $c_i$ 是序列 $S$ 中位置 $i$ 处的角色，其中 $i \\in \\mathbb{Z}, i&lt; |S|$。因为有20个氨基酸残基和1个GAP，所以 $c_i$ 可以编码成21位的形式。</p>\n<p>例如，如果 $c_i$ 是丙氨酸，则 $c_i$ 将被编码为 “$1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0$”，如果 $c_i$ 是一个GAP，则 $c_i$ 为 “$0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1$”。随着编码程序的迭代，整个序列将被编码成上述格式。</p>\n<h2 id=\"序列相似性的度量\"><a href=\"#序列相似性的度量\" class=\"headerlink\" title=\"序列相似性的度量\"></a>序列相似性的度量</h2><p>为了评估序列的相似性，利用了汉明距离的倒数。汉明距离被描述为在具有相同长度的两个字符串之间的相同位置处的不同字符对的数量。例如，给定两个长度相同的字符串 $s<em>1$ 和 $s_2$，每个字符串中总共有 $l$ 个字符。$D</em>{\\mathbb{H}}$ 为字符串 $s_1$ 和 $s_2$ 定义的汉明距离：</p>\n<script type=\"math/tex; mode=display\">\nD_{\\mathbb{H}}(s_1, s_2) = \\sum^{l}_{i=1}I(s_1(i),s_2(i))</script><p>其中 $l$ 是序列的长度，$I$ 是函数，如果给定的两个字符 $s<em>1(i)$ 和 <script type=\"math/tex\">s_2(i)</script> 相同，则该函数返回1，否则返回0。在本项目中，两个序列的碱基相似度与汉明距离成反比，即 $l-D</em>{\\mathbb{H}}(s_1, s_2)$。</p>\n<p>根据第3.1节，现在可以将一个序列视为二进制值的一个向量 $\\vec{v}$。如果同一位置的任意两个序列中的任意两个字符相同，则这两个编码字符的点积 $\\vec{v_1} \\cdot \\vec{v_2}$ 结果为1，否则为0。在这种情况下，两个序列的相似性越大，点积就越高。一旦计算了所有可能的序列对的相似度，就获得了矩阵 $\\mathbf{M} \\in \\mathbb{Z}^{n \\times n}$，其中 $n$ 表示计算中涉及的序列的数目。</p>\n<h2 id=\"安全多方计算\"><a href=\"#安全多方计算\" class=\"headerlink\" title=\"安全多方计算\"></a>安全多方计算</h2><p>这里作者采用两方的设置，可以参考<a href=\"https://yuyingwai.cn/2020/06/11/论文笔记-ABY-A-Framework-for-Efficient-Mixed-Protocol-Secure-Two-Party-Computation/\" target=\"_blank\" rel=\"noopener\">ABY</a>中第2节的算术共享和布尔共享。</p>\n<h2 id=\"支持向量机\"><a href=\"#支持向量机\" class=\"headerlink\" title=\"支持向量机\"></a>支持向量机</h2><p>支持向量机作为一种有监督的机器学习方法，经常被用来解决分类问题。它们已被证明在解决中、低尺度预测问题上优于许多其他方法，特别是在结合核函数的情况下。支持向量机的优化问题表示如下：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{align}\n\\min_{\\omega \\in \\mathbb{R}^d, b\\in \\mathbb{R}, \\xi \\in \\mathbb{R}^n} \\ \\ \\  &\\frac{1}{2} ||\\omega||^2 + \\frac{C}{n}\\sum^n_{i=1} \\xi_i \\\\\n\\mbox{s.t.} \\ \\ \\  &Y_i(\\langle \\omega, X_i \\rangle + b) \\geq 1 - \\xi_i \\tag{1} \\\\\n &i=1,...,n,\\  \\xi_i \\geq 0\n\\end{align}</script><p>其中，$\\omega, b, \\xi, C, n$ 遵循列出的顺序，分别表示具有 $n$ 维数的向量、干扰 $\\omega$ 和 $X_i$ 之间的点积的参数、确定点可以超出超平面多远的参数、惩罚的权重以及数据点的数量 $Y$。$X_i$ 和 $Y_i$ 表示数据特征向量及其标注。在上述支持向量机模型中，数据点被允许穿过超平面，但将受到松弛变量 $\\xi_i$ 的惩罚，该松弛变量由惩罚因子 $C$ 缩放。通过调整 $C$，可以改变惩罚的权重。</p>\n<h2 id=\"径向基函数核\"><a href=\"#径向基函数核\" class=\"headerlink\" title=\"径向基函数核\"></a>径向基函数核</h2><p>RBF核因其有效性和普适性而被广泛应用于支持向量机分类中[9]，其核函数定义如下：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{align}\nK(\\vec{x}, \\vec{y}) &= \\exp(- \\frac{||\\vec{x} - \\vec{y}||^2}{2\\sigma^2}) \\tag{2}\\\\ \n&= \\exp(-\\frac{\\vec{x} \\cdot \\vec{x} - 2 \\vec{x} \\cdot \\vec{y} + \\vec{y} \\cdot \\vec{y}}{2 \\sigma^2})\n\\end{align}</script><p>在这个方程中，“$\\cdot$” 表示向量之间的点积算子，而 $\\sigma$ 则作为调整相似度的参数，当 $\\sigma$ 增大时，指数函数的结果将趋于接近1，表明两个序列的相似度较高，反之亦然，此外，方程的第二行表明，在我们的协议中，只能根据用于计算径向基核矩阵的向量的点积来计算径向基核。</p>\n<h1 id=\"隐私保护支持向量机\"><a href=\"#隐私保护支持向量机\" class=\"headerlink\" title=\"隐私保护支持向量机\"></a>隐私保护支持向量机</h1><p>在这一部分中，我们系统地描述了我们的隐私保护支持向量机协议。在4.1节中，我们将对其进行概述，随后将详细说明协议的各个阶段。这里继承了3.3节中的记号。</p>\n<h2 id=\"系统概述\"><a href=\"#系统概述\" class=\"headerlink\" title=\"系统概述\"></a>系统概述</h2><p>在我们的协议中，来自多个医疗机构的基因组数据集以秘密共享的形式被外包给两个非共谋的代理服务器。两个非合谋的代理服务器在收到允许查询数据的第三方(如研究人员)的请求后，执行MPC以生成支持向量机训练所需的样本的GRAM矩阵。协议结构如图1所示，在此协议中，有以下各方扮演的角色：</p>\n<ol>\n<li><strong>数据源：</strong>在此上下文中，它们是医疗机构，表示为 $H_j$，其中 $j \\in \\mathbb{N}^+ , j \\leq n$，其中 $n$ 表示数据源的数量。他们以秘密共享的形式将基因组数据上传到两个代理服务器。</li>\n<li><strong>用户：</strong>用户 $U$，例如科学研究人员，他请求两个代理服务器对秘密共享数据执行一些安全计算，以产生用于支持向量机训练的格拉姆矩阵。</li>\n<li><strong>两个代理服务器：</strong>两个非合谋服务器作为计算方，记为 $P_i$，其中 $i \\in {0,1}$ 负责格拉姆矩阵的安全计算。在利用基因组数据训练机器学习模型的同时，选择两个不完全信任的第三方被认为是确保隐私保护的最实用和最实惠的解决方案[17]。</li>\n</ol>\n<p><img src=\"http://images.yingwai.top/picgo/ppossvmf1.png\" alt=\"\"></p>\n<center>\n    <i>图1 协议结构：从数据源到MPC，最终到用户进程</i>\n</center>\n\n\n\n\n<h3 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h3><ol>\n<li>$H_j$ 中的原始序列数据在本地编码为数字矢量(参见第4.2节)。</li>\n<li>在 $H_j$ 中，编码的序列数据在本地被分成两个共享 $A/B$，并分别发送到 $P_0$ 和 $P_1$ (参见第4.3节)。</li>\n<li>在 $H_j$ 中本地预先计算自身点积，然后它们也被分成两个份额 $A/B$，并分别发送到 $P_0$ 和 $P_1$ (参见第4.4节)。</li>\n</ol>\n<h3 id=\"训练过程\"><a href=\"#训练过程\" class=\"headerlink\" title=\"训练过程\"></a>训练过程</h3><ol>\n<li>接收到来自 $U$ 的查询后，在 $P_0$ 和 $P_1$ 之间进行预测编码，以在包含编码序列的文件之间获得所需的处理数据(参见第4.5节和第4.6节)。</li>\n<li>然后对自积和交叉点乘积进行积分以获得整个格拉姆矩阵，并将其传递给 $U$ (参见第4.7节)。</li>\n<li>在 $U$ 中使用格拉姆矩阵来训练支持向量机模型并测试结果模型(参见第4.8节)。</li>\n</ol>\n<h2 id=\"蛋白质序列编码\"><a href=\"#蛋白质序列编码\" class=\"headerlink\" title=\"蛋白质序列编码\"></a>蛋白质序列编码</h2><p>序列编码功能采用代表一个残基的一个字符，并将其编码为21位格式，如3.1节所述。输出文件包含编码序列，其中每行代表一个蛋白质序列，21列中的每一列代表一个残基(或gap)。</p>\n<h2 id=\"编码数据的秘密共享\"><a href=\"#编码数据的秘密共享\" class=\"headerlink\" title=\"编码数据的秘密共享\"></a>编码数据的秘密共享</h2><p>使用算术共享和布尔共享将原始编码数据分割成两个共享。在基于算术共享的协议中，产生的随机整数小于 $2^l$。此后，随机整数将作为共享并帮助构建另一个共享。在基于布尔共享的协议中，随机比特被生成为一个共享，并且它们被用来构造另一个共享。最终，在这两种协议中，两个共享将分别写入两个文件。使用算术共享的编码数据的秘密共享如图2所示。</p>\n<p><img src=\"http://images.yingwai.top/picgo/ppossvmf2.png\" alt=\"\"></p>\n<center>\n    <i>图2 共享数据生成</i>\n</center>\n\n\n\n\n<h2 id=\"本地计算自点积\"><a href=\"#本地计算自点积\" class=\"headerlink\" title=\"本地计算自点积\"></a>本地计算自点积</h2><p>数据源计算“自身点积”，这意味着每个数据点的两个实例的点积是在本地计算的。这样的本地计算降低了总的通信成本。该过程的结果是由前面提到的共享数据生成技术产生的点积矩阵的两部分。点积矩阵的份额接下来被分发到两个第三方代理服务器上，即 $P_0$ 和 $P_1$，然后可以在 $U$ 上重建这些份额。</p>\n<h2 id=\"使用算术电路进行点积计算\"><a href=\"#使用算术电路进行点积计算\" class=\"headerlink\" title=\"使用算术电路进行点积计算\"></a>使用算术电路进行点积计算</h2><p>所有需要乘成两个长数组的文件都被集成，省略了重复SIMD数据生成的不必要步骤。例如，假设文件 $A$、文件 $B$、文件 $C$ 分别表示为 $f_a$，$f_b$ 和 $f_c$，则这些文件中分别包含3、2和1个共享编码序列，由 $a_i,b_i,c_i$ 表示，其中 $i$ 表示某个文件中的序列索引。长阵列A将是 “$a_1a_2a_3a_1a_2a_3a_1a_2a_3b_1b_2$”，而另一个长阵列将是 “$b_1b_1b_1b_2b_2b_2c_1c_1c_1c_1c_1$”。这些操作分别称为 $\\mbox{GetLongArrayA}()$ 和 $\\mbox{GetLongArrayB}()$。</p>\n<p><img src=\"http://images.yingwai.top/picgo/ppossvma1.png\" alt=\"\"></p>\n<p>算法1首先构造两个长数组，以减少创建SIMD数据的次数。通过一次乘以两个长阵列，成功地降低了协议的运行时间。此算法省略了文件与其自身之间的点积计算，因为它可以先前本地计算，如第4.4节所述。通过将数组放入SIMD共享，从而实现对多个数据的操作。在乘法之后，然后执行每个点积计算块中的乘法结果的求和，以便分别对来自两个向量的每对元素的乘法进行局部求和。最后，将最终结果加载到数组中。图3显示了基于算术电路的安全协议的一般结构。</p>\n<h2 id=\"基于布尔电路的点积计算\"><a href=\"#基于布尔电路的点积计算\" class=\"headerlink\" title=\"基于布尔电路的点积计算\"></a>基于布尔电路的点积计算</h2><p>算法2类似于算法1。协议的结构如图3所示。两者之间的区别在于共享类型和电路类型。在此上下文中，仅在0和1之间执行乘法，这符合布尔共享的位长(1位)。因此，布尔电路中的安全与运算可以取代算术电路中的安全乘法，实现更好的计算性能。因此，共享的位长可以减少到1，这可以在通信过程中节省大量的计算能力。就布尔份额而言，它与算术份额差别很大，因此在以以前的方式局部相乘后无法求和。因此，设计了基于安全加法的特定函数，用于在点积块中对乘法结果求和。</p>\n<p><img src=\"http://images.yingwai.top/picgo/ppossvmf3.png\" alt=\"\"></p>\n<center>\n    <i>图3 点积计算</i>\n</center>\n\n<p><img src=\"http://images.yingwai.top/picgo/ppossvma2_.png\" alt=\"\"></p>\n<h2 id=\"结果数组集成与点积矩阵生成\"><a href=\"#结果数组集成与点积矩阵生成\" class=\"headerlink\" title=\"结果数组集成与点积矩阵生成\"></a>结果数组集成与点积矩阵生成</h2><p>通过我们的协议，可以在 $U$ 上手动将自身的点积重构成一个数组。然后计算自/交叉点乘积数组中访问位置的索引表。基于索引表，将生成 $2D$ 矢量，即 $n \\times n$ 矩阵，其中 $n$ 表示计算中涉及的序列总数，并将其写入文件中作为最终输出。在机器学习中，必须严格遵循数据和标签的顺序，这样才能正确地训练模型。因此，数组的排序过程是必不可少的。</p>\n<h2 id=\"支持向量机交叉验证实验\"><a href=\"#支持向量机交叉验证实验\" class=\"headerlink\" title=\"支持向量机交叉验证实验\"></a>支持向量机交叉验证实验</h2><p>在所有数据中，随机选取20%的数据对模型进行检验。在计算格拉姆矩阵的基础上，通过5次交叉验证对支持向量机的误分类惩罚参数 $C$、类不平衡权值 $W$ 和径向基函数的相似度调整参数 $\\sigma$ 进行优化。$C$ 和 $\\sigma$ 分别在集合 $s<em>C=[10^{-3},10^{-2},\\cdot \\cdot \\cdot,10^2, 10^3]$，$S</em>{\\sigma}=[0.125, 0.25, 0.5, 1, 2, 4, 8]$ 上进行优化，而类权重选自集合 $S_W = [1:1,1:2,1:4,1:8,1:16]$，前者表示标签0的类权重，前者占多数，后者表示标签1的类权重。最终，确定在优化过程中达到最高F1得分的参数集。然后，利用这些最优参数对最终模型进行训练。最后，利用测试数据对训练好的模型进行检验，并用F1得分对预测结果进行评估。</p>\n<h2 id=\"安全性分析\"><a href=\"#安全性分析\" class=\"headerlink\" title=\"安全性分析\"></a>安全性分析</h2><p>将数据外包给 $N$ 非合谋、半诚实的第三方是在[11]中首次研究的。给出了通用解决方案的安全性证明。在我们的协议中，利用[11]中的外包思想，多个医疗机构将基因组数据外包给两个非合谋、半诚实的第三方。我们需要保护个人的隐私，他们的基因组数据被外包给两个非串通的服务器。我们基于算术电路和布尔电路的协议的安全性依赖于分别基于Beaver乘法三元组的协议[2]和GMW协议[7]的已证明的安全性。一个半诚实的对手最多可以攻破一个代理服务器，就可以获得个人私有基因组数据的一份。我们知道基因组数据是通过算术或布尔共享来共享的，所以它看起来像是统一随机的数据。这确保了敌手不能获得任何有关个人的私人基因组数据。我们的协议是安全的，不会受到恶意数据提供商和用户的攻击。数据提供者仅以共享的形式向两个代理服务器发送基因组数据，并且不接收来自其他方的任何消息。他们的恶意输入不会导致任何数据泄露。用户输入的任何变化都会导致不同的分析响应。这确保了针对恶意用户的安全性。所有通信方之间的机密性、完整性和认证都是使用最先进的技术(如TLS[5])提供的。</p>\n<h1 id=\"CONCLUSION\"><a href=\"#CONCLUSION\" class=\"headerlink\" title=\"CONCLUSION\"></a>CONCLUSION</h1><p>本文提出了两种支持向量机隐私保护训练方案，用于支持向量机对来自多个来源的外包基因组数据的隐私保护训练。在我们的方案中，我们利用算术秘密共享、布尔秘密共享和不经意转移来同时保证支持向量机训练的安全和高效。我们的协议在两个半可信代理服务器上执行，每个服务器只访问训练支持向量机所需的结果点积的一部分。我们的方案在半诚实对手模型下是安全的。我们在真实的HIV数据集和合成数据集上进行了实验，以显示我们协议的有效性和效率。在未来的工作中，我们将使我们的协议在不显著降低性能的情况下确保免受恶意攻击的安全。</p>"},{"title":"论文笔记 Privacy-Preserving Ridge Regression with only Linearly-Homomorphic Encryption","date":"2020-08-10T11:49:57.000Z","_content":"\n*Irene Giacomelli, Somesh Jha, Marc Joye, C. David Page, and Kyonghwan Yoon*\n\n[ACNS 2018](https://dblp.uni-trier.de/db/conf/acns/acns2018.html#GiacomelliJJPY18)\n\nhttps://link.springer.com/chapter/10.1007/978-3-319-93387-0_13\n\n<!--more-->\n\n# 摘要\n\n具有L2范数正则化的线性回归(即岭回归)是一种重要的统计技术，它使用线性函数来模拟某些解释值和结果值之间的关系。在许多应用中(例如，个性化医疗中的预测建模)，这些值表示由不愿意共享它们的几个不同方拥有的敏感数据。在这种情况下，训练线性回归模型变得具有挑战性，并且需要特定的密码解决方案。尼古拉恩科等人优雅地解决了这个问题。在标准普尔(奥克兰)2013年。他们提出了一个双服务器系统，使用线性同态加密(LHE)和姚的两方协议(乱码电路)。在这项工作中，我们提出了一种新的系统，它可以只使用LHE(即不使用姚的协议)来训练脊线性回归模型。这极大地提高了整体性能(在计算和通信方面)，因为姚的协议是以前解决方案中的主要瓶颈。在人工生成数据集和真实数据集上验证了该系统的有效性。\n\n\n\n## 本文的贡献\n\n本文提出了一种新的两服务台模型中的岭回归系统。\n\n* 对于第一阶段，作者扩展了Nikolaenko等人使用的方法，涉及使用标记同态加密技术加密任意划分的数据集，以支持通过LHE方案加密的密文对之间的乘法。通过这种方式，作者展示了仅基于LHE的解决方案可以处理比水平分区情况更复杂的场景。\n\n* 对于第二阶段，作者通过设计一个只利用底层加密方案的线性同态性质求解 $A \\boldsymbol{w}=\\boldsymbol{b}$ 的加性同态两方协议来避免姚的协议。这可以提高整体性能，特别是显著降低通信开销。作为一个亮点，如果我们水平划分(分成10个大小相等的部分)1000万个实例和20个特征的数据集，我们的隐私保护回归方法运行在2分钟以内，产生1.3MB的通信开销。在[23]中提出的系统需要超过50min和270MB的交换数据来执行类似的计算。\n\n* 最后，作者注意到基于梯度下降的解决方案使用迭代算法，并且存在估计迭代次数 $t$ 的问题。或者 $t$ 被固定为确保找到模型的良好近似的高值，这为协议带来了更高的复杂度；或者 $t$ 是基于数据集自适应地选择的，这在隐私保护设置中可能是不可行的；或者 $t$ 是基于数据集自适应地选择的，这在隐私保护设置中可能是不可行的。本文求解 $A \\boldsymbol{w}=\\boldsymbol{b}$ 的解决方案不存在这个问题。\n\n\n\n# Background\n\n## 线性回归\n\n见[LoPED](https://yuyingwai.cn/2020/08/09/论文笔记-Linear-Regression-on-Packed-Encrypted-Data-in-the-Two-Server-Model/)中的2.1小节。\n\n\n\n## 密码工具\n\n一般的加法同态算法只能计算一个密文和一个明文的乘积：\n$$\n\\mathsf{cMult}(a,c) = c \\odot c \\cdots \\odot c \\quad (a \\ \\mathrm{times})\n$$\n而不能计算两个密文的乘积 $c \\times c'$。因此作者在这里使用了一种称为 *labeled-homomorphic encryption*（labHE）的同态加密技术：\n\n令 $(\\mathsf{Gen, Enc, Dec})$ 为一个具有安全参数 $\\kappa$ 和明文空间 $\\mathcal{M}$ 的LHE方案。假设乘法运算在 $\\mathcal{M}$ 中给出；例如 $(\\mathcal{M}, +, \\cdot)$ 是一个有限环。令 $F: \\{0,1 \\}^s \\times \\mathcal{L} \\rightarrow \\mathcal{M}$ 是一个有种子空间为 $\\{0,1\\}^s \\ (s = \\mathrm{poly}(\\kappa))$ 以及标记空间 $\\mathcal{L}$ 的伪随机函数。定义：\n\n* $\\mathsf{labGen}(\\kappa)$：对输入 $\\kappa$，它运行 $\\mathsf{Gen}(\\kappa)$ 然后输出 $(sk, pk)$。\n\n* $\\mathsf{localGen}(pk)$：对于每个用户 $i$ 以及公钥作为输入，它在 $\\{0,1\\}^s$ 中选取随机种子 $\\sigma_i$ 然后计算 $pk_i = \\mathsf{Enc}_{pk}(\\underline{\\sigma_i})$，其中 $\\underline{\\sigma_i}$ 是作为 $\\mathcal{M}$ 中元素的 $\\sigma_i$ 的编码。它输出 $(\\sigma_i, pk_i)$。\n\n* $\\mathsf{labEnc}_{pk}(\\sigma_i, m, \\tau)$：对来自用户 $i$ 的一个带有标签 $\\tau \\in \\mathcal{L}$ 的消息 $m \\in \\mathcal{M}$，它计算 $b = F(\\sigma_i, \\tau)$ 然后输出标记的密文 $\\boldsymbol{c} = (a, c) \\in \\mathcal{M \\times C}$，其中 $a = m - b$ 在 $\\mathcal{M}$ 中而 $c = \\mathsf{Enc}_{pk}(b)$。\n\n* $\\mathsf{labMult}(\\boldsymbol{c, c'})$：输入两个标记的密文 $\\boldsymbol{c} = (a, c)$ 和 $\\boldsymbol{c'} = (a', c')$，它计算一个密文下的“乘积” $d = \\mathsf{labMult}(\\boldsymbol{c, c'})$ 为 $d = \\mathsf{Enc}_{pk}(a \\cdot a') \\odot \\mathsf{cMult}(a, c') \\odot \\mathsf{cMult}(a', c)$。容易验证 $\\mathsf{Dec}_{sk}(d) = m \\cdot m' - b \\cdot b'$：\n  $$\n  \\begin{align}\n  m \\cdot m' &= (a+b)(a'+b')\\\\\n  &= a \\cdot a' + a \\cdot c' + a' \\cdot c + b \\cdot b'\n  \\end{align}\n  $$\n\n* $\\mathsf{labDec}_{sk}(pk_i, pk_j, \\tilde{c})$：输入 $\\tilde{c}$，它首先从 $\\mathsf{Dec}_{sk}(pk_i)$ 恢复 $\\sigma_i$ 和 $\\sigma_j$。然后，它对所有 $t = 1,...,n$ 计算 $b_t = F(\\sigma_i, \\tau_t)$ 和 $b'_t = F(\\sigma_j, \\tau_t')$。最后，它计算 $\\tilde{b} = \\sum^n_{t=1} b_t \\cdot b_t'$ 和 $\\tilde{m} = \\mathsf{Dec}_{sk}(\\tilde{c}) + \\tilde{b}$。容易验证 $\\tilde{m} = \\sum^n_{t=1} m_t \\cdot m_t'$。\n\n\n\n# 系统概览\n\n[LoPED](https://yuyingwai.cn/2020/08/09/论文笔记-Linear-Regression-on-Packed-Encrypted-Data-in-the-Two-Server-Model/)是基于本篇文章的，因此设定差不多。本文考虑这样的设置，其中训练数据集对于想要训练岭回归模型的实体不是明文可用的。相反，后者可以访问数据的加密副本，因此需要处理密钥的一方的帮助才能了解所需的模型。更准确地说，本文中的协议是为以下各方设计的：\n\n* *数据拥有者*：有 $m$ 个数据拥有者 $DO_1,...,DO_m$；每个 $DO_i$ 都有一个私有的数据集 $\\mathcal{D}_i$ ，并且愿意共享其加密后的版本。\n* *机器学习引擎*（MLE）：这是希望对通过合并本地数据集 $\\mathcal{D}_1,...,\\mathcal{D}_m$ 而获得的数据集 $\\mathcal{D}$ 运行线性回归算法，但只能访问它们的加密副本的一方。因此，MLE需要加密服务提供商的帮助。\n* *加密服务提供商*（CSP）负责初始化系统中使用的加密方案，并与MLE交互以帮助其完成其任务(计算线性回归模型)。CSP管理加密密钥，并且是唯一能够解密的实体。\n\n本文假设MLE和CSP没有串通，而且所有涉及的各方都是诚实但好奇的。此外，本文假设对于协议中涉及的每一对参与方，都存在一个私有的、经过身份验证的对等信道。特别是，任何两个参与者之间的通信都不能被窃听。\n\n本文的目标是确保MLE获得模型，而MLE和CSP都不会学习到模型本身所揭示的关于私有数据集 $\\mathcal{D}_i$ 的任何其他信息。即使在两个服务器(MLE或CSP)中的一个与一些数据所有者勾结的情况下，它们也不应该了解关于诚实的数据所有者持有的数据的额外信息。为了实现这一目标，本文设计了一个系统，它可以被视为由前面提到的 $m+2$ 方运行的多方协议，并由一系列步骤指定。该系统具有以下两阶段架构：\n\n**阶段1（聚合本地数据集）：**CSP生成密钥对 $(sk,pk)$，保存 $sk$ 以及公开 $pk$；每个 $DO_i$ 用 $pk$ 加密自己的数据集 $\\mathcal{D}_i$ 并发送给MLE。MLE使用接收到的密文和同态的特性来获得 $A$ 和 $\\boldsymbol{b}$ 的密文。\n\n**阶段2（计算模型）：**MLE盲化 $A$ 和 $\\boldsymbol{b}$ 并发送给CSP；后者解密对盲化后的数据解密并运行给定的算法。该算法的输出（“盲化模型”）是一个向量 $\\tilde{\\boldsymbol{w}}$，CSP把它发送给MLE，后者去盲化后获得 $\\boldsymbol{w}^*$。\n\n* MLE选取一个随机可逆矩阵 $R \\in \\mathrm{GL}(d, \\mathcal{M})$ 和随机向量 $\\boldsymbol{r} \\in \\mathcal{M}$，然后使用线性同态加密的性质计算 $C' = \\mathsf{Enc}_{pk}(AR)$ 和 $\\boldsymbol{d'} = \\mathsf{Enc}_{pk}(\\boldsymbol{b} + A \\boldsymbol{r})$。值 $C = AR$ 和 $\\boldsymbol{d} = \\boldsymbol{b} + A \\boldsymbol{r}$ 就是“盲化数据”。\n* CSP解密 $C'$ 和 $\\boldsymbol{d'}$，然后计算 $\\tilde{\\boldsymbol{w}} = C^{-1} \\boldsymbol{d}$。向量 $\\tilde{\\boldsymbol{w}}$ 为“盲化模型”，发送回给MLE。\n* MLE计算 $\\boldsymbol{w}^* = R \\tilde{\\boldsymbol{w}} - \\boldsymbol{r}$，容易验证 $R \\tilde{\\boldsymbol{w}} - \\boldsymbol{r} = R(AR)^{-1}(\\boldsymbol{b} + A \\boldsymbol{r}) - \\boldsymbol{r} = A^{-1} \\boldsymbol{b}$。\n\n\n\n# 协议描述\n\n## 阶段1：聚合数据集\n\n两种情况，第一种情况为 $X$ 和 $\\boldsymbol{y}$ 的数据集被水平划分为 $m$ 个数据集，即每个 $DO$ 拥有：\n$$\n\\mathcal{D}_k = \\{(\\boldsymbol{x}_{n_{k-1}+1}, y_{n_{k-1}+1}),...,(\\boldsymbol{x}_{n_k}, y_{n_k}) \\} \\tag{2}\n$$\n其中 $k = 1,...,m \\ (0 = n_0 < n_1<\\cdots<n_m=m)$。这种情况下就是每个 $DO_i$ 对其数据集 $A$ 和 $\\boldsymbol{b}$ 的所有项加密发送给MLE，后者进行聚合：\n\n![](http://images.yingwai.top/picgo/PPRRwoLHEp1.png)\n\n第二种情况为每个 $DO$ 拥有 $X$ 和 $\\boldsymbol{y}$ 中的某些元素：\n$$\n\\mathcal{D}_{k}=\\left\\{X[i, j]=\\boldsymbol{x}_{i}[j] \\mid(i, j) \\in D_{k}\\right\\} \\cup\\left\\{\\boldsymbol{y}[i]=y_{i} \\mid(i, 0) \\in D_{k}\\right\\} \\tag{3}\n$$\n其中 $D_{k} \\subseteq\\{1, \\ldots, n\\} \\times\\{0,1, \\ldots, d\\}$。这种情况下，要计算矩阵 $A$ 和向量 $\\boldsymbol{b}$ 就要把来自两个用户的数据乘在一起（例如一方拥有 $X$ 而另一方拥有 $\\boldsymbol{y}$），此时可以用到前面的 $\\mathsf{labMult}$：\n\n![](http://images.yingwai.top/picgo/PPRRwoLHEp2.png)\n\n\n\n## 阶段2：计算模型\n\n在阶段1的最后，MLE知道了 $A$ 和 $\\boldsymbol{b}$ 的密文。第3节中已经描述过大致的过程，即MLE先发送盲化后的数据给CSP，后者求解得到盲化后的模型后发送回给MLE，最后MLE去盲化得到模型 $\\boldsymbol{w}^*$：\n\n![](http://images.yingwai.top/picgo/PPRRwoLHEp3.png)\n\n\n\n## 参数的选择\n\n在 $\\Pi_2$ 的最后一步使用了有理数重构从 $\\mathbb{Z}_N$ 中计算的 $A \\boldsymbol{w} = \\boldsymbol{b}$ 的解中恢复 $\\boldsymbol{w}^* \\in \\mathbb{Q}^d$。如果有理数 $t=r/s$ 且 $−R\\leq r\\leq R, 0<s \\leq S$ 以及 $\\gcd(s,N)=1$ 在 $\\mathbb{Z}_N$ 中表示为 $t' = rs^{-1} \\bmod N$，则拉格朗日-高斯算法在 $2RS <N$ 的情况下唯一地恢复 $r$ 和 $s$。\n\n由于 $\\boldsymbol{w}^* = A^{-1}\\boldsymbol{b} = \\frac{1}{\\mathrm{det}(A)} \\mathrm{adj}(A)\\boldsymbol{b} \\in \\mathbb{Q}^d$，为了使得选择的 $N$ 满足前面提到的条件，需要限制 $\\mathrm{det}(A)$ 和向量 $\\mathrm{adj}(A)\\boldsymbol{b}$ 的条目。令 $\\alpha = \\max \\{\\|A \\|_{\\infty},\\| \\boldsymbol{b} \\|_{\\infty} \\}$，利用Hadamard不等式，有 $0 < \\mathrm{det}(A) \\leq \\alpha^d$（$A$ 是正定矩阵）和 $\\| \\mathrm{adj}(A)\\boldsymbol{b} \\|_{\\infty} \\leq d(d-1)^{\\frac{d-1}{2}} \\alpha^d$。\n\n对 $X$ 和 $\\boldsymbol{y}$ 使用与第二节相同的假设（即 $X$ 和 $\\boldsymbol{y}$ 的条目都是 $[-\\delta, \\delta]$ 中的实数，有最多 $\\ell$ 位小数），有 $\\alpha \\leq 10^{2\\ell}(n \\delta^2 + \\lambda)$。由此得出条件 $2RS < N$ 在以下情况时满足：\n$$\n2d(d-1)^{\\frac{d-1}{2}} 10^{4\\ell d}(n\\delta^2 + \\lambda)^{2d} < N \\tag{4}\n$$\n\n\n## 复杂度\n\n[SecureML](https://yuyingwai.cn/2020/06/17/论文笔记-SecureML-A-System-for-Scalable-Privacy-Preserving-Machine-Learning/)仅使用相加的秘密共享和海狸三元组来设计假设数据集的任意分区的系统。就通信复杂度而言，SecureML在任意划分的情况下比本文的解决方案执行得更好。然而，如果训练数据集是水平划分的，并且 $n \\gg d$（例如 $n=Θ(d^{2.5})$）。例如，如果 $d=100, n=105$时，SecureML中的系统只有预处理阶段的200MB，而 $Π_{1,\\mathrm{hor}}+Π_2$ 的总成本小于120MB。\n\n","source":"_posts/论文笔记-Privacy-Preserving-Ridge-Regression-with-only-Linearly-Homomorphic-Encryption.md","raw":"---\ntitle: >-\n  论文笔记 Privacy-Preserving Ridge Regression with only Linearly-Homomorphic\n  Encryption\ndate: 2020-08-10 19:49:57\ncategories: Papers\ntags: [PPML, Linear Regression, HE]\n---\n\n*Irene Giacomelli, Somesh Jha, Marc Joye, C. David Page, and Kyonghwan Yoon*\n\n[ACNS 2018](https://dblp.uni-trier.de/db/conf/acns/acns2018.html#GiacomelliJJPY18)\n\nhttps://link.springer.com/chapter/10.1007/978-3-319-93387-0_13\n\n<!--more-->\n\n# 摘要\n\n具有L2范数正则化的线性回归(即岭回归)是一种重要的统计技术，它使用线性函数来模拟某些解释值和结果值之间的关系。在许多应用中(例如，个性化医疗中的预测建模)，这些值表示由不愿意共享它们的几个不同方拥有的敏感数据。在这种情况下，训练线性回归模型变得具有挑战性，并且需要特定的密码解决方案。尼古拉恩科等人优雅地解决了这个问题。在标准普尔(奥克兰)2013年。他们提出了一个双服务器系统，使用线性同态加密(LHE)和姚的两方协议(乱码电路)。在这项工作中，我们提出了一种新的系统，它可以只使用LHE(即不使用姚的协议)来训练脊线性回归模型。这极大地提高了整体性能(在计算和通信方面)，因为姚的协议是以前解决方案中的主要瓶颈。在人工生成数据集和真实数据集上验证了该系统的有效性。\n\n\n\n## 本文的贡献\n\n本文提出了一种新的两服务台模型中的岭回归系统。\n\n* 对于第一阶段，作者扩展了Nikolaenko等人使用的方法，涉及使用标记同态加密技术加密任意划分的数据集，以支持通过LHE方案加密的密文对之间的乘法。通过这种方式，作者展示了仅基于LHE的解决方案可以处理比水平分区情况更复杂的场景。\n\n* 对于第二阶段，作者通过设计一个只利用底层加密方案的线性同态性质求解 $A \\boldsymbol{w}=\\boldsymbol{b}$ 的加性同态两方协议来避免姚的协议。这可以提高整体性能，特别是显著降低通信开销。作为一个亮点，如果我们水平划分(分成10个大小相等的部分)1000万个实例和20个特征的数据集，我们的隐私保护回归方法运行在2分钟以内，产生1.3MB的通信开销。在[23]中提出的系统需要超过50min和270MB的交换数据来执行类似的计算。\n\n* 最后，作者注意到基于梯度下降的解决方案使用迭代算法，并且存在估计迭代次数 $t$ 的问题。或者 $t$ 被固定为确保找到模型的良好近似的高值，这为协议带来了更高的复杂度；或者 $t$ 是基于数据集自适应地选择的，这在隐私保护设置中可能是不可行的；或者 $t$ 是基于数据集自适应地选择的，这在隐私保护设置中可能是不可行的。本文求解 $A \\boldsymbol{w}=\\boldsymbol{b}$ 的解决方案不存在这个问题。\n\n\n\n# Background\n\n## 线性回归\n\n见[LoPED](https://yuyingwai.cn/2020/08/09/论文笔记-Linear-Regression-on-Packed-Encrypted-Data-in-the-Two-Server-Model/)中的2.1小节。\n\n\n\n## 密码工具\n\n一般的加法同态算法只能计算一个密文和一个明文的乘积：\n$$\n\\mathsf{cMult}(a,c) = c \\odot c \\cdots \\odot c \\quad (a \\ \\mathrm{times})\n$$\n而不能计算两个密文的乘积 $c \\times c'$。因此作者在这里使用了一种称为 *labeled-homomorphic encryption*（labHE）的同态加密技术：\n\n令 $(\\mathsf{Gen, Enc, Dec})$ 为一个具有安全参数 $\\kappa$ 和明文空间 $\\mathcal{M}$ 的LHE方案。假设乘法运算在 $\\mathcal{M}$ 中给出；例如 $(\\mathcal{M}, +, \\cdot)$ 是一个有限环。令 $F: \\{0,1 \\}^s \\times \\mathcal{L} \\rightarrow \\mathcal{M}$ 是一个有种子空间为 $\\{0,1\\}^s \\ (s = \\mathrm{poly}(\\kappa))$ 以及标记空间 $\\mathcal{L}$ 的伪随机函数。定义：\n\n* $\\mathsf{labGen}(\\kappa)$：对输入 $\\kappa$，它运行 $\\mathsf{Gen}(\\kappa)$ 然后输出 $(sk, pk)$。\n\n* $\\mathsf{localGen}(pk)$：对于每个用户 $i$ 以及公钥作为输入，它在 $\\{0,1\\}^s$ 中选取随机种子 $\\sigma_i$ 然后计算 $pk_i = \\mathsf{Enc}_{pk}(\\underline{\\sigma_i})$，其中 $\\underline{\\sigma_i}$ 是作为 $\\mathcal{M}$ 中元素的 $\\sigma_i$ 的编码。它输出 $(\\sigma_i, pk_i)$。\n\n* $\\mathsf{labEnc}_{pk}(\\sigma_i, m, \\tau)$：对来自用户 $i$ 的一个带有标签 $\\tau \\in \\mathcal{L}$ 的消息 $m \\in \\mathcal{M}$，它计算 $b = F(\\sigma_i, \\tau)$ 然后输出标记的密文 $\\boldsymbol{c} = (a, c) \\in \\mathcal{M \\times C}$，其中 $a = m - b$ 在 $\\mathcal{M}$ 中而 $c = \\mathsf{Enc}_{pk}(b)$。\n\n* $\\mathsf{labMult}(\\boldsymbol{c, c'})$：输入两个标记的密文 $\\boldsymbol{c} = (a, c)$ 和 $\\boldsymbol{c'} = (a', c')$，它计算一个密文下的“乘积” $d = \\mathsf{labMult}(\\boldsymbol{c, c'})$ 为 $d = \\mathsf{Enc}_{pk}(a \\cdot a') \\odot \\mathsf{cMult}(a, c') \\odot \\mathsf{cMult}(a', c)$。容易验证 $\\mathsf{Dec}_{sk}(d) = m \\cdot m' - b \\cdot b'$：\n  $$\n  \\begin{align}\n  m \\cdot m' &= (a+b)(a'+b')\\\\\n  &= a \\cdot a' + a \\cdot c' + a' \\cdot c + b \\cdot b'\n  \\end{align}\n  $$\n\n* $\\mathsf{labDec}_{sk}(pk_i, pk_j, \\tilde{c})$：输入 $\\tilde{c}$，它首先从 $\\mathsf{Dec}_{sk}(pk_i)$ 恢复 $\\sigma_i$ 和 $\\sigma_j$。然后，它对所有 $t = 1,...,n$ 计算 $b_t = F(\\sigma_i, \\tau_t)$ 和 $b'_t = F(\\sigma_j, \\tau_t')$。最后，它计算 $\\tilde{b} = \\sum^n_{t=1} b_t \\cdot b_t'$ 和 $\\tilde{m} = \\mathsf{Dec}_{sk}(\\tilde{c}) + \\tilde{b}$。容易验证 $\\tilde{m} = \\sum^n_{t=1} m_t \\cdot m_t'$。\n\n\n\n# 系统概览\n\n[LoPED](https://yuyingwai.cn/2020/08/09/论文笔记-Linear-Regression-on-Packed-Encrypted-Data-in-the-Two-Server-Model/)是基于本篇文章的，因此设定差不多。本文考虑这样的设置，其中训练数据集对于想要训练岭回归模型的实体不是明文可用的。相反，后者可以访问数据的加密副本，因此需要处理密钥的一方的帮助才能了解所需的模型。更准确地说，本文中的协议是为以下各方设计的：\n\n* *数据拥有者*：有 $m$ 个数据拥有者 $DO_1,...,DO_m$；每个 $DO_i$ 都有一个私有的数据集 $\\mathcal{D}_i$ ，并且愿意共享其加密后的版本。\n* *机器学习引擎*（MLE）：这是希望对通过合并本地数据集 $\\mathcal{D}_1,...,\\mathcal{D}_m$ 而获得的数据集 $\\mathcal{D}$ 运行线性回归算法，但只能访问它们的加密副本的一方。因此，MLE需要加密服务提供商的帮助。\n* *加密服务提供商*（CSP）负责初始化系统中使用的加密方案，并与MLE交互以帮助其完成其任务(计算线性回归模型)。CSP管理加密密钥，并且是唯一能够解密的实体。\n\n本文假设MLE和CSP没有串通，而且所有涉及的各方都是诚实但好奇的。此外，本文假设对于协议中涉及的每一对参与方，都存在一个私有的、经过身份验证的对等信道。特别是，任何两个参与者之间的通信都不能被窃听。\n\n本文的目标是确保MLE获得模型，而MLE和CSP都不会学习到模型本身所揭示的关于私有数据集 $\\mathcal{D}_i$ 的任何其他信息。即使在两个服务器(MLE或CSP)中的一个与一些数据所有者勾结的情况下，它们也不应该了解关于诚实的数据所有者持有的数据的额外信息。为了实现这一目标，本文设计了一个系统，它可以被视为由前面提到的 $m+2$ 方运行的多方协议，并由一系列步骤指定。该系统具有以下两阶段架构：\n\n**阶段1（聚合本地数据集）：**CSP生成密钥对 $(sk,pk)$，保存 $sk$ 以及公开 $pk$；每个 $DO_i$ 用 $pk$ 加密自己的数据集 $\\mathcal{D}_i$ 并发送给MLE。MLE使用接收到的密文和同态的特性来获得 $A$ 和 $\\boldsymbol{b}$ 的密文。\n\n**阶段2（计算模型）：**MLE盲化 $A$ 和 $\\boldsymbol{b}$ 并发送给CSP；后者解密对盲化后的数据解密并运行给定的算法。该算法的输出（“盲化模型”）是一个向量 $\\tilde{\\boldsymbol{w}}$，CSP把它发送给MLE，后者去盲化后获得 $\\boldsymbol{w}^*$。\n\n* MLE选取一个随机可逆矩阵 $R \\in \\mathrm{GL}(d, \\mathcal{M})$ 和随机向量 $\\boldsymbol{r} \\in \\mathcal{M}$，然后使用线性同态加密的性质计算 $C' = \\mathsf{Enc}_{pk}(AR)$ 和 $\\boldsymbol{d'} = \\mathsf{Enc}_{pk}(\\boldsymbol{b} + A \\boldsymbol{r})$。值 $C = AR$ 和 $\\boldsymbol{d} = \\boldsymbol{b} + A \\boldsymbol{r}$ 就是“盲化数据”。\n* CSP解密 $C'$ 和 $\\boldsymbol{d'}$，然后计算 $\\tilde{\\boldsymbol{w}} = C^{-1} \\boldsymbol{d}$。向量 $\\tilde{\\boldsymbol{w}}$ 为“盲化模型”，发送回给MLE。\n* MLE计算 $\\boldsymbol{w}^* = R \\tilde{\\boldsymbol{w}} - \\boldsymbol{r}$，容易验证 $R \\tilde{\\boldsymbol{w}} - \\boldsymbol{r} = R(AR)^{-1}(\\boldsymbol{b} + A \\boldsymbol{r}) - \\boldsymbol{r} = A^{-1} \\boldsymbol{b}$。\n\n\n\n# 协议描述\n\n## 阶段1：聚合数据集\n\n两种情况，第一种情况为 $X$ 和 $\\boldsymbol{y}$ 的数据集被水平划分为 $m$ 个数据集，即每个 $DO$ 拥有：\n$$\n\\mathcal{D}_k = \\{(\\boldsymbol{x}_{n_{k-1}+1}, y_{n_{k-1}+1}),...,(\\boldsymbol{x}_{n_k}, y_{n_k}) \\} \\tag{2}\n$$\n其中 $k = 1,...,m \\ (0 = n_0 < n_1<\\cdots<n_m=m)$。这种情况下就是每个 $DO_i$ 对其数据集 $A$ 和 $\\boldsymbol{b}$ 的所有项加密发送给MLE，后者进行聚合：\n\n![](http://images.yingwai.top/picgo/PPRRwoLHEp1.png)\n\n第二种情况为每个 $DO$ 拥有 $X$ 和 $\\boldsymbol{y}$ 中的某些元素：\n$$\n\\mathcal{D}_{k}=\\left\\{X[i, j]=\\boldsymbol{x}_{i}[j] \\mid(i, j) \\in D_{k}\\right\\} \\cup\\left\\{\\boldsymbol{y}[i]=y_{i} \\mid(i, 0) \\in D_{k}\\right\\} \\tag{3}\n$$\n其中 $D_{k} \\subseteq\\{1, \\ldots, n\\} \\times\\{0,1, \\ldots, d\\}$。这种情况下，要计算矩阵 $A$ 和向量 $\\boldsymbol{b}$ 就要把来自两个用户的数据乘在一起（例如一方拥有 $X$ 而另一方拥有 $\\boldsymbol{y}$），此时可以用到前面的 $\\mathsf{labMult}$：\n\n![](http://images.yingwai.top/picgo/PPRRwoLHEp2.png)\n\n\n\n## 阶段2：计算模型\n\n在阶段1的最后，MLE知道了 $A$ 和 $\\boldsymbol{b}$ 的密文。第3节中已经描述过大致的过程，即MLE先发送盲化后的数据给CSP，后者求解得到盲化后的模型后发送回给MLE，最后MLE去盲化得到模型 $\\boldsymbol{w}^*$：\n\n![](http://images.yingwai.top/picgo/PPRRwoLHEp3.png)\n\n\n\n## 参数的选择\n\n在 $\\Pi_2$ 的最后一步使用了有理数重构从 $\\mathbb{Z}_N$ 中计算的 $A \\boldsymbol{w} = \\boldsymbol{b}$ 的解中恢复 $\\boldsymbol{w}^* \\in \\mathbb{Q}^d$。如果有理数 $t=r/s$ 且 $−R\\leq r\\leq R, 0<s \\leq S$ 以及 $\\gcd(s,N)=1$ 在 $\\mathbb{Z}_N$ 中表示为 $t' = rs^{-1} \\bmod N$，则拉格朗日-高斯算法在 $2RS <N$ 的情况下唯一地恢复 $r$ 和 $s$。\n\n由于 $\\boldsymbol{w}^* = A^{-1}\\boldsymbol{b} = \\frac{1}{\\mathrm{det}(A)} \\mathrm{adj}(A)\\boldsymbol{b} \\in \\mathbb{Q}^d$，为了使得选择的 $N$ 满足前面提到的条件，需要限制 $\\mathrm{det}(A)$ 和向量 $\\mathrm{adj}(A)\\boldsymbol{b}$ 的条目。令 $\\alpha = \\max \\{\\|A \\|_{\\infty},\\| \\boldsymbol{b} \\|_{\\infty} \\}$，利用Hadamard不等式，有 $0 < \\mathrm{det}(A) \\leq \\alpha^d$（$A$ 是正定矩阵）和 $\\| \\mathrm{adj}(A)\\boldsymbol{b} \\|_{\\infty} \\leq d(d-1)^{\\frac{d-1}{2}} \\alpha^d$。\n\n对 $X$ 和 $\\boldsymbol{y}$ 使用与第二节相同的假设（即 $X$ 和 $\\boldsymbol{y}$ 的条目都是 $[-\\delta, \\delta]$ 中的实数，有最多 $\\ell$ 位小数），有 $\\alpha \\leq 10^{2\\ell}(n \\delta^2 + \\lambda)$。由此得出条件 $2RS < N$ 在以下情况时满足：\n$$\n2d(d-1)^{\\frac{d-1}{2}} 10^{4\\ell d}(n\\delta^2 + \\lambda)^{2d} < N \\tag{4}\n$$\n\n\n## 复杂度\n\n[SecureML](https://yuyingwai.cn/2020/06/17/论文笔记-SecureML-A-System-for-Scalable-Privacy-Preserving-Machine-Learning/)仅使用相加的秘密共享和海狸三元组来设计假设数据集的任意分区的系统。就通信复杂度而言，SecureML在任意划分的情况下比本文的解决方案执行得更好。然而，如果训练数据集是水平划分的，并且 $n \\gg d$（例如 $n=Θ(d^{2.5})$）。例如，如果 $d=100, n=105$时，SecureML中的系统只有预处理阶段的200MB，而 $Π_{1,\\mathrm{hor}}+Π_2$ 的总成本小于120MB。\n\n","slug":"论文笔记-Privacy-Preserving-Ridge-Regression-with-only-Linearly-Homomorphic-Encryption","published":1,"updated":"2020-08-23T14:33:37.437Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cke79q4tt004p88ps6tu39m8r","content":"<p><em>Irene Giacomelli, Somesh Jha, Marc Joye, C. David Page, and Kyonghwan Yoon</em></p>\n<p><a href=\"https://dblp.uni-trier.de/db/conf/acns/acns2018.html#GiacomelliJJPY18\" target=\"_blank\" rel=\"noopener\">ACNS 2018</a></p>\n<p><a href=\"https://link.springer.com/chapter/10.1007/978-3-319-93387-0_13\" target=\"_blank\" rel=\"noopener\">https://link.springer.com/chapter/10.1007/978-3-319-93387-0_13</a></p>\n<a id=\"more\"></a>\n<h1 id=\"摘要\"><a href=\"#摘要\" class=\"headerlink\" title=\"摘要\"></a>摘要</h1><p>具有L2范数正则化的线性回归(即岭回归)是一种重要的统计技术，它使用线性函数来模拟某些解释值和结果值之间的关系。在许多应用中(例如，个性化医疗中的预测建模)，这些值表示由不愿意共享它们的几个不同方拥有的敏感数据。在这种情况下，训练线性回归模型变得具有挑战性，并且需要特定的密码解决方案。尼古拉恩科等人优雅地解决了这个问题。在标准普尔(奥克兰)2013年。他们提出了一个双服务器系统，使用线性同态加密(LHE)和姚的两方协议(乱码电路)。在这项工作中，我们提出了一种新的系统，它可以只使用LHE(即不使用姚的协议)来训练脊线性回归模型。这极大地提高了整体性能(在计算和通信方面)，因为姚的协议是以前解决方案中的主要瓶颈。在人工生成数据集和真实数据集上验证了该系统的有效性。</p>\n<h2 id=\"本文的贡献\"><a href=\"#本文的贡献\" class=\"headerlink\" title=\"本文的贡献\"></a>本文的贡献</h2><p>本文提出了一种新的两服务台模型中的岭回归系统。</p>\n<ul>\n<li><p>对于第一阶段，作者扩展了Nikolaenko等人使用的方法，涉及使用标记同态加密技术加密任意划分的数据集，以支持通过LHE方案加密的密文对之间的乘法。通过这种方式，作者展示了仅基于LHE的解决方案可以处理比水平分区情况更复杂的场景。</p>\n</li>\n<li><p>对于第二阶段，作者通过设计一个只利用底层加密方案的线性同态性质求解 $A \\boldsymbol{w}=\\boldsymbol{b}$ 的加性同态两方协议来避免姚的协议。这可以提高整体性能，特别是显著降低通信开销。作为一个亮点，如果我们水平划分(分成10个大小相等的部分)1000万个实例和20个特征的数据集，我们的隐私保护回归方法运行在2分钟以内，产生1.3MB的通信开销。在[23]中提出的系统需要超过50min和270MB的交换数据来执行类似的计算。</p>\n</li>\n<li><p>最后，作者注意到基于梯度下降的解决方案使用迭代算法，并且存在估计迭代次数 $t$ 的问题。或者 $t$ 被固定为确保找到模型的良好近似的高值，这为协议带来了更高的复杂度；或者 $t$ 是基于数据集自适应地选择的，这在隐私保护设置中可能是不可行的；或者 $t$ 是基于数据集自适应地选择的，这在隐私保护设置中可能是不可行的。本文求解 $A \\boldsymbol{w}=\\boldsymbol{b}$ 的解决方案不存在这个问题。</p>\n</li>\n</ul>\n<h1 id=\"Background\"><a href=\"#Background\" class=\"headerlink\" title=\"Background\"></a>Background</h1><h2 id=\"线性回归\"><a href=\"#线性回归\" class=\"headerlink\" title=\"线性回归\"></a>线性回归</h2><p>见<a href=\"https://yuyingwai.cn/2020/08/09/论文笔记-Linear-Regression-on-Packed-Encrypted-Data-in-the-Two-Server-Model/\" target=\"_blank\" rel=\"noopener\">LoPED</a>中的2.1小节。</p>\n<h2 id=\"密码工具\"><a href=\"#密码工具\" class=\"headerlink\" title=\"密码工具\"></a>密码工具</h2><p>一般的加法同态算法只能计算一个密文和一个明文的乘积：</p>\n<script type=\"math/tex; mode=display\">\n\\mathsf{cMult}(a,c) = c \\odot c \\cdots \\odot c \\quad (a \\ \\mathrm{times})</script><p>而不能计算两个密文的乘积 $c \\times c’$。因此作者在这里使用了一种称为 <em>labeled-homomorphic encryption</em>（labHE）的同态加密技术：</p>\n<p>令 $(\\mathsf{Gen, Enc, Dec})$ 为一个具有安全参数 $\\kappa$ 和明文空间 $\\mathcal{M}$ 的LHE方案。假设乘法运算在 $\\mathcal{M}$ 中给出；例如 $(\\mathcal{M}, +, \\cdot)$ 是一个有限环。令 $F: {0,1 }^s \\times \\mathcal{L} \\rightarrow \\mathcal{M}$ 是一个有种子空间为 ${0,1}^s \\ (s = \\mathrm{poly}(\\kappa))$ 以及标记空间 $\\mathcal{L}$ 的伪随机函数。定义：</p>\n<ul>\n<li><p>$\\mathsf{labGen}(\\kappa)$：对输入 $\\kappa$，它运行 $\\mathsf{Gen}(\\kappa)$ 然后输出 $(sk, pk)$。</p>\n</li>\n<li><p>$\\mathsf{localGen}(pk)$：对于每个用户 $i$ 以及公钥作为输入，它在 ${0,1}^s$ 中选取随机种子 $\\sigma<em>i$ 然后计算 $pk_i = \\mathsf{Enc}</em>{pk}(\\underline{\\sigma_i})$，其中 $\\underline{\\sigma_i}$ 是作为 $\\mathcal{M}$ 中元素的 $\\sigma_i$ 的编码。它输出 $(\\sigma_i, pk_i)$。</p>\n</li>\n<li><p>$\\mathsf{labEnc}<em>{pk}(\\sigma_i, m, \\tau)$：对来自用户 $i$ 的一个带有标签 $\\tau \\in \\mathcal{L}$ 的消息 $m \\in \\mathcal{M}$，它计算 $b = F(\\sigma_i, \\tau)$ 然后输出标记的密文 $\\boldsymbol{c} = (a, c) \\in \\mathcal{M \\times C}$，其中 $a = m - b$ 在 $\\mathcal{M}$ 中而 $c = \\mathsf{Enc}</em>{pk}(b)$。</p>\n</li>\n<li><p>$\\mathsf{labMult}(\\boldsymbol{c, c’})$：输入两个标记的密文 $\\boldsymbol{c} = (a, c)$ 和 $\\boldsymbol{c’} = (a’, c’)$，它计算一个密文下的“乘积” $d = \\mathsf{labMult}(\\boldsymbol{c, c’})$ 为 $d = \\mathsf{Enc}<em>{pk}(a \\cdot a’) \\odot \\mathsf{cMult}(a, c’) \\odot \\mathsf{cMult}(a’, c)$。容易验证 $\\mathsf{Dec}</em>{sk}(d) = m \\cdot m’ - b \\cdot b’$：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{align}\nm \\cdot m' &= (a+b)(a'+b')\\\\\n&= a \\cdot a' + a \\cdot c' + a' \\cdot c + b \\cdot b'\n\\end{align}</script></li>\n<li><p>$\\mathsf{labDec}<em>{sk}(pk_i, pk_j, \\tilde{c})$：输入 $\\tilde{c}$，它首先从 $\\mathsf{Dec}</em>{sk}(pk<em>i)$ 恢复 $\\sigma_i$ 和 $\\sigma_j$。然后，它对所有 $t = 1,…,n$ 计算 $b_t = F(\\sigma_i, \\tau_t)$ 和 $b’_t = F(\\sigma_j, \\tau_t’)$。最后，它计算 $\\tilde{b} = \\sum^n</em>{t=1} b<em>t \\cdot b_t’$ 和 $\\tilde{m} = \\mathsf{Dec}</em>{sk}(\\tilde{c}) + \\tilde{b}$。容易验证 $\\tilde{m} = \\sum^n_{t=1} m_t \\cdot m_t’$。</p>\n</li>\n</ul>\n<h1 id=\"系统概览\"><a href=\"#系统概览\" class=\"headerlink\" title=\"系统概览\"></a>系统概览</h1><p><a href=\"https://yuyingwai.cn/2020/08/09/论文笔记-Linear-Regression-on-Packed-Encrypted-Data-in-the-Two-Server-Model/\" target=\"_blank\" rel=\"noopener\">LoPED</a>是基于本篇文章的，因此设定差不多。本文考虑这样的设置，其中训练数据集对于想要训练岭回归模型的实体不是明文可用的。相反，后者可以访问数据的加密副本，因此需要处理密钥的一方的帮助才能了解所需的模型。更准确地说，本文中的协议是为以下各方设计的：</p>\n<ul>\n<li><em>数据拥有者</em>：有 $m$ 个数据拥有者 $DO_1,…,DO_m$；每个 $DO_i$ 都有一个私有的数据集 $\\mathcal{D}_i$ ，并且愿意共享其加密后的版本。</li>\n<li><em>机器学习引擎</em>（MLE）：这是希望对通过合并本地数据集 $\\mathcal{D}_1,…,\\mathcal{D}_m$ 而获得的数据集 $\\mathcal{D}$ 运行线性回归算法，但只能访问它们的加密副本的一方。因此，MLE需要加密服务提供商的帮助。</li>\n<li><em>加密服务提供商</em>（CSP）负责初始化系统中使用的加密方案，并与MLE交互以帮助其完成其任务(计算线性回归模型)。CSP管理加密密钥，并且是唯一能够解密的实体。</li>\n</ul>\n<p>本文假设MLE和CSP没有串通，而且所有涉及的各方都是诚实但好奇的。此外，本文假设对于协议中涉及的每一对参与方，都存在一个私有的、经过身份验证的对等信道。特别是，任何两个参与者之间的通信都不能被窃听。</p>\n<p>本文的目标是确保MLE获得模型，而MLE和CSP都不会学习到模型本身所揭示的关于私有数据集 $\\mathcal{D}_i$ 的任何其他信息。即使在两个服务器(MLE或CSP)中的一个与一些数据所有者勾结的情况下，它们也不应该了解关于诚实的数据所有者持有的数据的额外信息。为了实现这一目标，本文设计了一个系统，它可以被视为由前面提到的 $m+2$ 方运行的多方协议，并由一系列步骤指定。该系统具有以下两阶段架构：</p>\n<p><strong>阶段1（聚合本地数据集）：</strong>CSP生成密钥对 $(sk,pk)$，保存 $sk$ 以及公开 $pk$；每个 $DO_i$ 用 $pk$ 加密自己的数据集 $\\mathcal{D}_i$ 并发送给MLE。MLE使用接收到的密文和同态的特性来获得 $A$ 和 $\\boldsymbol{b}$ 的密文。</p>\n<p><strong>阶段2（计算模型）：</strong>MLE盲化 $A$ 和 $\\boldsymbol{b}$ 并发送给CSP；后者解密对盲化后的数据解密并运行给定的算法。该算法的输出（“盲化模型”）是一个向量 $\\tilde{\\boldsymbol{w}}$，CSP把它发送给MLE，后者去盲化后获得 $\\boldsymbol{w}^*$。</p>\n<ul>\n<li>MLE选取一个随机可逆矩阵 $R \\in \\mathrm{GL}(d, \\mathcal{M})$ 和随机向量 $\\boldsymbol{r} \\in \\mathcal{M}$，然后使用线性同态加密的性质计算 $C’ = \\mathsf{Enc}<em>{pk}(AR)$ 和 $\\boldsymbol{d’} = \\mathsf{Enc}</em>{pk}(\\boldsymbol{b} + A \\boldsymbol{r})$。值 $C = AR$ 和 $\\boldsymbol{d} = \\boldsymbol{b} + A \\boldsymbol{r}$ 就是“盲化数据”。</li>\n<li>CSP解密 $C’$ 和 $\\boldsymbol{d’}$，然后计算 $\\tilde{\\boldsymbol{w}} = C^{-1} \\boldsymbol{d}$。向量 $\\tilde{\\boldsymbol{w}}$ 为“盲化模型”，发送回给MLE。</li>\n<li>MLE计算 $\\boldsymbol{w}^* = R \\tilde{\\boldsymbol{w}} - \\boldsymbol{r}$，容易验证 $R \\tilde{\\boldsymbol{w}} - \\boldsymbol{r} = R(AR)^{-1}(\\boldsymbol{b} + A \\boldsymbol{r}) - \\boldsymbol{r} = A^{-1} \\boldsymbol{b}$。</li>\n</ul>\n<h1 id=\"协议描述\"><a href=\"#协议描述\" class=\"headerlink\" title=\"协议描述\"></a>协议描述</h1><h2 id=\"阶段1：聚合数据集\"><a href=\"#阶段1：聚合数据集\" class=\"headerlink\" title=\"阶段1：聚合数据集\"></a>阶段1：聚合数据集</h2><p>两种情况，第一种情况为 $X$ 和 $\\boldsymbol{y}$ 的数据集被水平划分为 $m$ 个数据集，即每个 $DO$ 拥有：</p>\n<script type=\"math/tex; mode=display\">\n\\mathcal{D}_k = \\{(\\boldsymbol{x}_{n_{k-1}+1}, y_{n_{k-1}+1}),...,(\\boldsymbol{x}_{n_k}, y_{n_k}) \\} \\tag{2}</script><p>其中 $k = 1,…,m \\ (0 = n_0 &lt; n_1&lt;\\cdots&lt;n_m=m)$。这种情况下就是每个 $DO_i$ 对其数据集 $A$ 和 $\\boldsymbol{b}$ 的所有项加密发送给MLE，后者进行聚合：</p>\n<p><img src=\"http://images.yingwai.top/picgo/PPRRwoLHEp1.png\" alt=\"\"></p>\n<p>第二种情况为每个 $DO$ 拥有 $X$ 和 $\\boldsymbol{y}$ 中的某些元素：</p>\n<script type=\"math/tex; mode=display\">\n\\mathcal{D}_{k}=\\left\\{X[i, j]=\\boldsymbol{x}_{i}[j] \\mid(i, j) \\in D_{k}\\right\\} \\cup\\left\\{\\boldsymbol{y}[i]=y_{i} \\mid(i, 0) \\in D_{k}\\right\\} \\tag{3}</script><p>其中 $D_{k} \\subseteq{1, \\ldots, n} \\times{0,1, \\ldots, d}$。这种情况下，要计算矩阵 $A$ 和向量 $\\boldsymbol{b}$ 就要把来自两个用户的数据乘在一起（例如一方拥有 $X$ 而另一方拥有 $\\boldsymbol{y}$），此时可以用到前面的 $\\mathsf{labMult}$：</p>\n<p><img src=\"http://images.yingwai.top/picgo/PPRRwoLHEp2.png\" alt=\"\"></p>\n<h2 id=\"阶段2：计算模型\"><a href=\"#阶段2：计算模型\" class=\"headerlink\" title=\"阶段2：计算模型\"></a>阶段2：计算模型</h2><p>在阶段1的最后，MLE知道了 $A$ 和 $\\boldsymbol{b}$ 的密文。第3节中已经描述过大致的过程，即MLE先发送盲化后的数据给CSP，后者求解得到盲化后的模型后发送回给MLE，最后MLE去盲化得到模型 $\\boldsymbol{w}^*$：</p>\n<p><img src=\"http://images.yingwai.top/picgo/PPRRwoLHEp3.png\" alt=\"\"></p>\n<h2 id=\"参数的选择\"><a href=\"#参数的选择\" class=\"headerlink\" title=\"参数的选择\"></a>参数的选择</h2><p>在 $\\Pi_2$ 的最后一步使用了有理数重构从 $\\mathbb{Z}_N$ 中计算的 $A \\boldsymbol{w} = \\boldsymbol{b}$ 的解中恢复 $\\boldsymbol{w}^* \\in \\mathbb{Q}^d$。如果有理数 $t=r/s$ 且 $−R\\leq r\\leq R, 0&lt;s \\leq S$ 以及 $\\gcd(s,N)=1$ 在 $\\mathbb{Z}_N$ 中表示为 $t’ = rs^{-1} \\bmod N$，则拉格朗日-高斯算法在 $2RS &lt;N$ 的情况下唯一地恢复 $r$ 和 $s$。</p>\n<p>由于 $\\boldsymbol{w}^* = A^{-1}\\boldsymbol{b} = \\frac{1}{\\mathrm{det}(A)} \\mathrm{adj}(A)\\boldsymbol{b} \\in \\mathbb{Q}^d$，为了使得选择的 $N$ 满足前面提到的条件，需要限制 $\\mathrm{det}(A)$ 和向量 $\\mathrm{adj}(A)\\boldsymbol{b}$ 的条目。令 $\\alpha = \\max {|A |<em>{\\infty},| \\boldsymbol{b} |</em>{\\infty} }$，利用Hadamard不等式，有 $0 &lt; \\mathrm{det}(A) \\leq \\alpha^d$（$A$ 是正定矩阵）和 $| \\mathrm{adj}(A)\\boldsymbol{b} |_{\\infty} \\leq d(d-1)^{\\frac{d-1}{2}} \\alpha^d$。</p>\n<p>对 $X$ 和 $\\boldsymbol{y}$ 使用与第二节相同的假设（即 $X$ 和 $\\boldsymbol{y}$ 的条目都是 $[-\\delta, \\delta]$ 中的实数，有最多 $\\ell$ 位小数），有 $\\alpha \\leq 10^{2\\ell}(n \\delta^2 + \\lambda)$。由此得出条件 $2RS &lt; N$ 在以下情况时满足：</p>\n<script type=\"math/tex; mode=display\">\n2d(d-1)^{\\frac{d-1}{2}} 10^{4\\ell d}(n\\delta^2 + \\lambda)^{2d} < N \\tag{4}</script><h2 id=\"复杂度\"><a href=\"#复杂度\" class=\"headerlink\" title=\"复杂度\"></a>复杂度</h2><p><a href=\"https://yuyingwai.cn/2020/06/17/论文笔记-SecureML-A-System-for-Scalable-Privacy-Preserving-Machine-Learning/\" target=\"_blank\" rel=\"noopener\">SecureML</a>仅使用相加的秘密共享和海狸三元组来设计假设数据集的任意分区的系统。就通信复杂度而言，SecureML在任意划分的情况下比本文的解决方案执行得更好。然而，如果训练数据集是水平划分的，并且 $n \\gg d$（例如 $n=Θ(d^{2.5})$）。例如，如果 $d=100, n=105$时，SecureML中的系统只有预处理阶段的200MB，而 $Π_{1,\\mathrm{hor}}+Π_2$ 的总成本小于120MB。</p>\n","site":{"data":{}},"excerpt":"<p><em>Irene Giacomelli, Somesh Jha, Marc Joye, C. David Page, and Kyonghwan Yoon</em></p>\n<p><a href=\"https://dblp.uni-trier.de/db/conf/acns/acns2018.html#GiacomelliJJPY18\" target=\"_blank\" rel=\"noopener\">ACNS 2018</a></p>\n<p><a href=\"https://link.springer.com/chapter/10.1007/978-3-319-93387-0_13\" target=\"_blank\" rel=\"noopener\">https://link.springer.com/chapter/10.1007/978-3-319-93387-0_13</a></p>","more":"<h1 id=\"摘要\"><a href=\"#摘要\" class=\"headerlink\" title=\"摘要\"></a>摘要</h1><p>具有L2范数正则化的线性回归(即岭回归)是一种重要的统计技术，它使用线性函数来模拟某些解释值和结果值之间的关系。在许多应用中(例如，个性化医疗中的预测建模)，这些值表示由不愿意共享它们的几个不同方拥有的敏感数据。在这种情况下，训练线性回归模型变得具有挑战性，并且需要特定的密码解决方案。尼古拉恩科等人优雅地解决了这个问题。在标准普尔(奥克兰)2013年。他们提出了一个双服务器系统，使用线性同态加密(LHE)和姚的两方协议(乱码电路)。在这项工作中，我们提出了一种新的系统，它可以只使用LHE(即不使用姚的协议)来训练脊线性回归模型。这极大地提高了整体性能(在计算和通信方面)，因为姚的协议是以前解决方案中的主要瓶颈。在人工生成数据集和真实数据集上验证了该系统的有效性。</p>\n<h2 id=\"本文的贡献\"><a href=\"#本文的贡献\" class=\"headerlink\" title=\"本文的贡献\"></a>本文的贡献</h2><p>本文提出了一种新的两服务台模型中的岭回归系统。</p>\n<ul>\n<li><p>对于第一阶段，作者扩展了Nikolaenko等人使用的方法，涉及使用标记同态加密技术加密任意划分的数据集，以支持通过LHE方案加密的密文对之间的乘法。通过这种方式，作者展示了仅基于LHE的解决方案可以处理比水平分区情况更复杂的场景。</p>\n</li>\n<li><p>对于第二阶段，作者通过设计一个只利用底层加密方案的线性同态性质求解 $A \\boldsymbol{w}=\\boldsymbol{b}$ 的加性同态两方协议来避免姚的协议。这可以提高整体性能，特别是显著降低通信开销。作为一个亮点，如果我们水平划分(分成10个大小相等的部分)1000万个实例和20个特征的数据集，我们的隐私保护回归方法运行在2分钟以内，产生1.3MB的通信开销。在[23]中提出的系统需要超过50min和270MB的交换数据来执行类似的计算。</p>\n</li>\n<li><p>最后，作者注意到基于梯度下降的解决方案使用迭代算法，并且存在估计迭代次数 $t$ 的问题。或者 $t$ 被固定为确保找到模型的良好近似的高值，这为协议带来了更高的复杂度；或者 $t$ 是基于数据集自适应地选择的，这在隐私保护设置中可能是不可行的；或者 $t$ 是基于数据集自适应地选择的，这在隐私保护设置中可能是不可行的。本文求解 $A \\boldsymbol{w}=\\boldsymbol{b}$ 的解决方案不存在这个问题。</p>\n</li>\n</ul>\n<h1 id=\"Background\"><a href=\"#Background\" class=\"headerlink\" title=\"Background\"></a>Background</h1><h2 id=\"线性回归\"><a href=\"#线性回归\" class=\"headerlink\" title=\"线性回归\"></a>线性回归</h2><p>见<a href=\"https://yuyingwai.cn/2020/08/09/论文笔记-Linear-Regression-on-Packed-Encrypted-Data-in-the-Two-Server-Model/\" target=\"_blank\" rel=\"noopener\">LoPED</a>中的2.1小节。</p>\n<h2 id=\"密码工具\"><a href=\"#密码工具\" class=\"headerlink\" title=\"密码工具\"></a>密码工具</h2><p>一般的加法同态算法只能计算一个密文和一个明文的乘积：</p>\n<script type=\"math/tex; mode=display\">\n\\mathsf{cMult}(a,c) = c \\odot c \\cdots \\odot c \\quad (a \\ \\mathrm{times})</script><p>而不能计算两个密文的乘积 $c \\times c’$。因此作者在这里使用了一种称为 <em>labeled-homomorphic encryption</em>（labHE）的同态加密技术：</p>\n<p>令 $(\\mathsf{Gen, Enc, Dec})$ 为一个具有安全参数 $\\kappa$ 和明文空间 $\\mathcal{M}$ 的LHE方案。假设乘法运算在 $\\mathcal{M}$ 中给出；例如 $(\\mathcal{M}, +, \\cdot)$ 是一个有限环。令 $F: {0,1 }^s \\times \\mathcal{L} \\rightarrow \\mathcal{M}$ 是一个有种子空间为 ${0,1}^s \\ (s = \\mathrm{poly}(\\kappa))$ 以及标记空间 $\\mathcal{L}$ 的伪随机函数。定义：</p>\n<ul>\n<li><p>$\\mathsf{labGen}(\\kappa)$：对输入 $\\kappa$，它运行 $\\mathsf{Gen}(\\kappa)$ 然后输出 $(sk, pk)$。</p>\n</li>\n<li><p>$\\mathsf{localGen}(pk)$：对于每个用户 $i$ 以及公钥作为输入，它在 ${0,1}^s$ 中选取随机种子 $\\sigma<em>i$ 然后计算 $pk_i = \\mathsf{Enc}</em>{pk}(\\underline{\\sigma_i})$，其中 $\\underline{\\sigma_i}$ 是作为 $\\mathcal{M}$ 中元素的 $\\sigma_i$ 的编码。它输出 $(\\sigma_i, pk_i)$。</p>\n</li>\n<li><p>$\\mathsf{labEnc}<em>{pk}(\\sigma_i, m, \\tau)$：对来自用户 $i$ 的一个带有标签 $\\tau \\in \\mathcal{L}$ 的消息 $m \\in \\mathcal{M}$，它计算 $b = F(\\sigma_i, \\tau)$ 然后输出标记的密文 $\\boldsymbol{c} = (a, c) \\in \\mathcal{M \\times C}$，其中 $a = m - b$ 在 $\\mathcal{M}$ 中而 $c = \\mathsf{Enc}</em>{pk}(b)$。</p>\n</li>\n<li><p>$\\mathsf{labMult}(\\boldsymbol{c, c’})$：输入两个标记的密文 $\\boldsymbol{c} = (a, c)$ 和 $\\boldsymbol{c’} = (a’, c’)$，它计算一个密文下的“乘积” $d = \\mathsf{labMult}(\\boldsymbol{c, c’})$ 为 $d = \\mathsf{Enc}<em>{pk}(a \\cdot a’) \\odot \\mathsf{cMult}(a, c’) \\odot \\mathsf{cMult}(a’, c)$。容易验证 $\\mathsf{Dec}</em>{sk}(d) = m \\cdot m’ - b \\cdot b’$：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{align}\nm \\cdot m' &= (a+b)(a'+b')\\\\\n&= a \\cdot a' + a \\cdot c' + a' \\cdot c + b \\cdot b'\n\\end{align}</script></li>\n<li><p>$\\mathsf{labDec}<em>{sk}(pk_i, pk_j, \\tilde{c})$：输入 $\\tilde{c}$，它首先从 $\\mathsf{Dec}</em>{sk}(pk<em>i)$ 恢复 $\\sigma_i$ 和 $\\sigma_j$。然后，它对所有 $t = 1,…,n$ 计算 $b_t = F(\\sigma_i, \\tau_t)$ 和 $b’_t = F(\\sigma_j, \\tau_t’)$。最后，它计算 $\\tilde{b} = \\sum^n</em>{t=1} b<em>t \\cdot b_t’$ 和 $\\tilde{m} = \\mathsf{Dec}</em>{sk}(\\tilde{c}) + \\tilde{b}$。容易验证 $\\tilde{m} = \\sum^n_{t=1} m_t \\cdot m_t’$。</p>\n</li>\n</ul>\n<h1 id=\"系统概览\"><a href=\"#系统概览\" class=\"headerlink\" title=\"系统概览\"></a>系统概览</h1><p><a href=\"https://yuyingwai.cn/2020/08/09/论文笔记-Linear-Regression-on-Packed-Encrypted-Data-in-the-Two-Server-Model/\" target=\"_blank\" rel=\"noopener\">LoPED</a>是基于本篇文章的，因此设定差不多。本文考虑这样的设置，其中训练数据集对于想要训练岭回归模型的实体不是明文可用的。相反，后者可以访问数据的加密副本，因此需要处理密钥的一方的帮助才能了解所需的模型。更准确地说，本文中的协议是为以下各方设计的：</p>\n<ul>\n<li><em>数据拥有者</em>：有 $m$ 个数据拥有者 $DO_1,…,DO_m$；每个 $DO_i$ 都有一个私有的数据集 $\\mathcal{D}_i$ ，并且愿意共享其加密后的版本。</li>\n<li><em>机器学习引擎</em>（MLE）：这是希望对通过合并本地数据集 $\\mathcal{D}_1,…,\\mathcal{D}_m$ 而获得的数据集 $\\mathcal{D}$ 运行线性回归算法，但只能访问它们的加密副本的一方。因此，MLE需要加密服务提供商的帮助。</li>\n<li><em>加密服务提供商</em>（CSP）负责初始化系统中使用的加密方案，并与MLE交互以帮助其完成其任务(计算线性回归模型)。CSP管理加密密钥，并且是唯一能够解密的实体。</li>\n</ul>\n<p>本文假设MLE和CSP没有串通，而且所有涉及的各方都是诚实但好奇的。此外，本文假设对于协议中涉及的每一对参与方，都存在一个私有的、经过身份验证的对等信道。特别是，任何两个参与者之间的通信都不能被窃听。</p>\n<p>本文的目标是确保MLE获得模型，而MLE和CSP都不会学习到模型本身所揭示的关于私有数据集 $\\mathcal{D}_i$ 的任何其他信息。即使在两个服务器(MLE或CSP)中的一个与一些数据所有者勾结的情况下，它们也不应该了解关于诚实的数据所有者持有的数据的额外信息。为了实现这一目标，本文设计了一个系统，它可以被视为由前面提到的 $m+2$ 方运行的多方协议，并由一系列步骤指定。该系统具有以下两阶段架构：</p>\n<p><strong>阶段1（聚合本地数据集）：</strong>CSP生成密钥对 $(sk,pk)$，保存 $sk$ 以及公开 $pk$；每个 $DO_i$ 用 $pk$ 加密自己的数据集 $\\mathcal{D}_i$ 并发送给MLE。MLE使用接收到的密文和同态的特性来获得 $A$ 和 $\\boldsymbol{b}$ 的密文。</p>\n<p><strong>阶段2（计算模型）：</strong>MLE盲化 $A$ 和 $\\boldsymbol{b}$ 并发送给CSP；后者解密对盲化后的数据解密并运行给定的算法。该算法的输出（“盲化模型”）是一个向量 $\\tilde{\\boldsymbol{w}}$，CSP把它发送给MLE，后者去盲化后获得 $\\boldsymbol{w}^*$。</p>\n<ul>\n<li>MLE选取一个随机可逆矩阵 $R \\in \\mathrm{GL}(d, \\mathcal{M})$ 和随机向量 $\\boldsymbol{r} \\in \\mathcal{M}$，然后使用线性同态加密的性质计算 $C’ = \\mathsf{Enc}<em>{pk}(AR)$ 和 $\\boldsymbol{d’} = \\mathsf{Enc}</em>{pk}(\\boldsymbol{b} + A \\boldsymbol{r})$。值 $C = AR$ 和 $\\boldsymbol{d} = \\boldsymbol{b} + A \\boldsymbol{r}$ 就是“盲化数据”。</li>\n<li>CSP解密 $C’$ 和 $\\boldsymbol{d’}$，然后计算 $\\tilde{\\boldsymbol{w}} = C^{-1} \\boldsymbol{d}$。向量 $\\tilde{\\boldsymbol{w}}$ 为“盲化模型”，发送回给MLE。</li>\n<li>MLE计算 $\\boldsymbol{w}^* = R \\tilde{\\boldsymbol{w}} - \\boldsymbol{r}$，容易验证 $R \\tilde{\\boldsymbol{w}} - \\boldsymbol{r} = R(AR)^{-1}(\\boldsymbol{b} + A \\boldsymbol{r}) - \\boldsymbol{r} = A^{-1} \\boldsymbol{b}$。</li>\n</ul>\n<h1 id=\"协议描述\"><a href=\"#协议描述\" class=\"headerlink\" title=\"协议描述\"></a>协议描述</h1><h2 id=\"阶段1：聚合数据集\"><a href=\"#阶段1：聚合数据集\" class=\"headerlink\" title=\"阶段1：聚合数据集\"></a>阶段1：聚合数据集</h2><p>两种情况，第一种情况为 $X$ 和 $\\boldsymbol{y}$ 的数据集被水平划分为 $m$ 个数据集，即每个 $DO$ 拥有：</p>\n<script type=\"math/tex; mode=display\">\n\\mathcal{D}_k = \\{(\\boldsymbol{x}_{n_{k-1}+1}, y_{n_{k-1}+1}),...,(\\boldsymbol{x}_{n_k}, y_{n_k}) \\} \\tag{2}</script><p>其中 $k = 1,…,m \\ (0 = n_0 &lt; n_1&lt;\\cdots&lt;n_m=m)$。这种情况下就是每个 $DO_i$ 对其数据集 $A$ 和 $\\boldsymbol{b}$ 的所有项加密发送给MLE，后者进行聚合：</p>\n<p><img src=\"http://images.yingwai.top/picgo/PPRRwoLHEp1.png\" alt=\"\"></p>\n<p>第二种情况为每个 $DO$ 拥有 $X$ 和 $\\boldsymbol{y}$ 中的某些元素：</p>\n<script type=\"math/tex; mode=display\">\n\\mathcal{D}_{k}=\\left\\{X[i, j]=\\boldsymbol{x}_{i}[j] \\mid(i, j) \\in D_{k}\\right\\} \\cup\\left\\{\\boldsymbol{y}[i]=y_{i} \\mid(i, 0) \\in D_{k}\\right\\} \\tag{3}</script><p>其中 $D_{k} \\subseteq{1, \\ldots, n} \\times{0,1, \\ldots, d}$。这种情况下，要计算矩阵 $A$ 和向量 $\\boldsymbol{b}$ 就要把来自两个用户的数据乘在一起（例如一方拥有 $X$ 而另一方拥有 $\\boldsymbol{y}$），此时可以用到前面的 $\\mathsf{labMult}$：</p>\n<p><img src=\"http://images.yingwai.top/picgo/PPRRwoLHEp2.png\" alt=\"\"></p>\n<h2 id=\"阶段2：计算模型\"><a href=\"#阶段2：计算模型\" class=\"headerlink\" title=\"阶段2：计算模型\"></a>阶段2：计算模型</h2><p>在阶段1的最后，MLE知道了 $A$ 和 $\\boldsymbol{b}$ 的密文。第3节中已经描述过大致的过程，即MLE先发送盲化后的数据给CSP，后者求解得到盲化后的模型后发送回给MLE，最后MLE去盲化得到模型 $\\boldsymbol{w}^*$：</p>\n<p><img src=\"http://images.yingwai.top/picgo/PPRRwoLHEp3.png\" alt=\"\"></p>\n<h2 id=\"参数的选择\"><a href=\"#参数的选择\" class=\"headerlink\" title=\"参数的选择\"></a>参数的选择</h2><p>在 $\\Pi_2$ 的最后一步使用了有理数重构从 $\\mathbb{Z}_N$ 中计算的 $A \\boldsymbol{w} = \\boldsymbol{b}$ 的解中恢复 $\\boldsymbol{w}^* \\in \\mathbb{Q}^d$。如果有理数 $t=r/s$ 且 $−R\\leq r\\leq R, 0&lt;s \\leq S$ 以及 $\\gcd(s,N)=1$ 在 $\\mathbb{Z}_N$ 中表示为 $t’ = rs^{-1} \\bmod N$，则拉格朗日-高斯算法在 $2RS &lt;N$ 的情况下唯一地恢复 $r$ 和 $s$。</p>\n<p>由于 $\\boldsymbol{w}^* = A^{-1}\\boldsymbol{b} = \\frac{1}{\\mathrm{det}(A)} \\mathrm{adj}(A)\\boldsymbol{b} \\in \\mathbb{Q}^d$，为了使得选择的 $N$ 满足前面提到的条件，需要限制 $\\mathrm{det}(A)$ 和向量 $\\mathrm{adj}(A)\\boldsymbol{b}$ 的条目。令 $\\alpha = \\max {|A |<em>{\\infty},| \\boldsymbol{b} |</em>{\\infty} }$，利用Hadamard不等式，有 $0 &lt; \\mathrm{det}(A) \\leq \\alpha^d$（$A$ 是正定矩阵）和 $| \\mathrm{adj}(A)\\boldsymbol{b} |_{\\infty} \\leq d(d-1)^{\\frac{d-1}{2}} \\alpha^d$。</p>\n<p>对 $X$ 和 $\\boldsymbol{y}$ 使用与第二节相同的假设（即 $X$ 和 $\\boldsymbol{y}$ 的条目都是 $[-\\delta, \\delta]$ 中的实数，有最多 $\\ell$ 位小数），有 $\\alpha \\leq 10^{2\\ell}(n \\delta^2 + \\lambda)$。由此得出条件 $2RS &lt; N$ 在以下情况时满足：</p>\n<script type=\"math/tex; mode=display\">\n2d(d-1)^{\\frac{d-1}{2}} 10^{4\\ell d}(n\\delta^2 + \\lambda)^{2d} < N \\tag{4}</script><h2 id=\"复杂度\"><a href=\"#复杂度\" class=\"headerlink\" title=\"复杂度\"></a>复杂度</h2><p><a href=\"https://yuyingwai.cn/2020/06/17/论文笔记-SecureML-A-System-for-Scalable-Privacy-Preserving-Machine-Learning/\" target=\"_blank\" rel=\"noopener\">SecureML</a>仅使用相加的秘密共享和海狸三元组来设计假设数据集的任意分区的系统。就通信复杂度而言，SecureML在任意划分的情况下比本文的解决方案执行得更好。然而，如果训练数据集是水平划分的，并且 $n \\gg d$（例如 $n=Θ(d^{2.5})$）。例如，如果 $d=100, n=105$时，SecureML中的系统只有预处理阶段的200MB，而 $Π_{1,\\mathrm{hor}}+Π_2$ 的总成本小于120MB。</p>"},{"title":"论文笔记 SecureML: A System for Scalable Privacy-Preserving Machine Learning","date":"2020-06-17T03:25:47.000Z","_content":"\n*Payman Mohassel,  Yupeng Zhang*\n\n[IEEE Symposium on Security and Privacy 2017](https://dblp.uni-trier.de/db/conf/sp/sp2017.html#MohasselZ17)\n\nhttps://eprint.iacr.org/2017/396.pdf\n\n<!--more-->\n\n# 文章贡献\n\n* **两方计算：**第一个提出在两方计算模型下处理机器学习模型问题；\n* **秘密分享：**第一个将秘密分享引入该问题，支持在两方上任意分布的数据；\n* **Secure SGD：**在两方下提出了训练模型的安全SGD算法；\n* **秘密截断：**分析了在秘密分享下如何进行定点数截断问题。\n\n\n\n# 计算模型\n\n本文考虑一个客户端集合 $\\mathcal{C}_1,...,\\mathcal{C}_m$ 想要使用它们的数据训练一个模型，客户端将数据 $x_i$ 以秘密分享的模式分发给两个非合谋的服务器 $\\mathcal{S}_0, \\mathcal{S}_1$（例如一方拥有随机数 $r_i$ 而另一方拥有 $x_i - r_i$），服务器交互式地计算函数 $f(x_i)$，得到预测标签 $y_i$。\n\n![](http://images.yingwai.top/picgo/smlf3.png)\n\n![](http://images.yingwai.top/picgo/smlppt1.png)\n\n\n\n# PPML\n\n本文给出了满足隐私保护的线性回归、逻辑回归以及神经网络的协议。\n\n\n\n## 线性回归\n\n$y = \\sum^d_{j=1} x_{ij} w_j = \\vec{x_i} \\cdot \\vec{w}$\n\n\n\n**损失函数：**\n\n$C(\\mathbf{w}) = \\frac{1}{n} \\sum C_i(\\mathbf{w})$，\n\n其中 $C_i(\\mathbf{w}) = \\frac{1}{2}(\\mathbf{x}_i \\cdot \\mathbf{w} - y_i)^2$。\n\n更新权重的公式为：\n$$\n\\begin{align}\nw_j : &= w_j - \\alpha \\frac{\\partial C_i(\\mathbf{w})}{\\partial w_j} \\\\\n&= w_j - \\alpha (\\mathbf{x}_i \\cdot \\mathbf{w} - y_i) x_{ij}\n\\end{align}\n$$\n可以看到只有加法和乘法的运算。\n\n数据是在两个服务器中加法共享的，计算两个数 $\\langle a \\rangle, \\langle b \\rangle$ 的和比较简单，两个服务器各自在本地将对应的份额相加即可；计算乘法则比较麻烦，需要借助乘法三元组 $(\\langle u \\rangle, \\langle v \\rangle, \\langle z \\rangle)$ 满足$z = uv \\bmod 2^l$：\n\n![](http://images.yingwai.top/picgo/smlppt2.png)\n\n接下来就可以得到上述算法的向量版本，以下是文章给出的具体协议：\n\n![](http://images.yingwai.top/picgo/smlf4.png)\n\n为了提高效率，使用了batch的方法来更新权重。\n\n\n\n## 逻辑回归\n\n$g(\\mathbf{x}_i) = f(\\mathbf{x}_i \\cdot \\mathbf{w}) = \\frac{1}{1+e^{-\\mathbf{x}_i \\cdot \\mathbf{w}}}$\n\n和线性回归相比，逻辑回归在线性回归的基础上增加了一个Sigmoid函数，其计算起来很困难，通常是使用多项式去拟合，但需要多项式次数较高且其并不收敛，导致在 $x$ 较大时准确率不高。\n\n因此作者提出了他们称为Secure-computation-friendly activation function：\n$$\nf(x) = \\left\\{ \\begin{array}{lcl}\n0, & \\mbox{if} & x < - \\frac{1}{2} \\\\\nx + \\frac{1}{2}, & \\mbox{if} & - \\frac{1}{2} \\leq x \\leq \\frac{1}{2} \\\\\n1, & \\mbox{if} & x > \\frac{1}{2}\n\\end{array}\\right.\n$$\n该函数的图像与Sigmoid函数类似：\n\n![](http://images.yingwai.top/picgo/smlf5.png)\n\n于是计算完矩阵-向量乘法后还需要计算上面的分段函数，因为要判断 $u+\\frac{1}{2}$ 和 $u- \\frac{1}{2}$ 的符号，这里算术共享就不是很适合，而Yao共享很适合，因此需要先把共享转换成Yao共享，在[ABY](https://yuyingwai.cn/2020/06/11/论文笔记-ABY-A-Framework-for-Efficient-Mixed-Protocol-Secure-Two-Party-Computation/)框架中有介绍。\n\n这里作者将函数 $f(u)$ 改写成了如下形式，方便乱码电路的计算：\n$$\nf(u) = (\\neg b_2) + (b_2 \\wedge (\\neg b_1))u\n$$\n其中 $b_1, b_2$ 分别为：\n$$\nb_1 = \\left\\{ \\begin{array}{ll}\n0, & \\mbox{if} \\ \\  u+\\frac{1}{2} \\geq 0 \\\\\n1, & \\mbox{otherwise}\n\\end{array}\\right.\n$$\n\n$$\nb_2 = \\left\\{ \\begin{array}{ll}\n0, & \\mbox{if} \\ \\  u-\\frac{1}{2} \\geq 0 \\\\\n1, & \\mbox{otherwise}\n\\end{array}\\right.\n$$\n\n于是构造电路以 $\\langle u \\rangle_0 + \\frac{1}{2}$ 和 $\\langle u \\rangle_1$ 作为输出，将它们相加并把结果的符号位 $b_1$ 输出，$b_2$ 同理，最后计算上面的 $f(u)$ 即可。下面是完整的协议：\n\n![](http://images.yingwai.top/picgo/smlf13.png)\n\n\n\n## 神经网络\n\n神经网络可以看作很多个与逻辑回归计算方式一致的神经元组成，用上面逻辑回归中的方法处理即可。","source":"_posts/论文笔记-SecureML-A-System-for-Scalable-Privacy-Preserving-Machine-Learning.md","raw":"---\ntitle: '论文笔记 SecureML: A System for Scalable Privacy-Preserving Machine Learning'\ndate: 2020-06-17 11:25:47\ncategories: Papers\ntags: [MPC, PPML, Neural Network, Logistic Regression, Linear Regression, Secret Sharing]\n---\n\n*Payman Mohassel,  Yupeng Zhang*\n\n[IEEE Symposium on Security and Privacy 2017](https://dblp.uni-trier.de/db/conf/sp/sp2017.html#MohasselZ17)\n\nhttps://eprint.iacr.org/2017/396.pdf\n\n<!--more-->\n\n# 文章贡献\n\n* **两方计算：**第一个提出在两方计算模型下处理机器学习模型问题；\n* **秘密分享：**第一个将秘密分享引入该问题，支持在两方上任意分布的数据；\n* **Secure SGD：**在两方下提出了训练模型的安全SGD算法；\n* **秘密截断：**分析了在秘密分享下如何进行定点数截断问题。\n\n\n\n# 计算模型\n\n本文考虑一个客户端集合 $\\mathcal{C}_1,...,\\mathcal{C}_m$ 想要使用它们的数据训练一个模型，客户端将数据 $x_i$ 以秘密分享的模式分发给两个非合谋的服务器 $\\mathcal{S}_0, \\mathcal{S}_1$（例如一方拥有随机数 $r_i$ 而另一方拥有 $x_i - r_i$），服务器交互式地计算函数 $f(x_i)$，得到预测标签 $y_i$。\n\n![](http://images.yingwai.top/picgo/smlf3.png)\n\n![](http://images.yingwai.top/picgo/smlppt1.png)\n\n\n\n# PPML\n\n本文给出了满足隐私保护的线性回归、逻辑回归以及神经网络的协议。\n\n\n\n## 线性回归\n\n$y = \\sum^d_{j=1} x_{ij} w_j = \\vec{x_i} \\cdot \\vec{w}$\n\n\n\n**损失函数：**\n\n$C(\\mathbf{w}) = \\frac{1}{n} \\sum C_i(\\mathbf{w})$，\n\n其中 $C_i(\\mathbf{w}) = \\frac{1}{2}(\\mathbf{x}_i \\cdot \\mathbf{w} - y_i)^2$。\n\n更新权重的公式为：\n$$\n\\begin{align}\nw_j : &= w_j - \\alpha \\frac{\\partial C_i(\\mathbf{w})}{\\partial w_j} \\\\\n&= w_j - \\alpha (\\mathbf{x}_i \\cdot \\mathbf{w} - y_i) x_{ij}\n\\end{align}\n$$\n可以看到只有加法和乘法的运算。\n\n数据是在两个服务器中加法共享的，计算两个数 $\\langle a \\rangle, \\langle b \\rangle$ 的和比较简单，两个服务器各自在本地将对应的份额相加即可；计算乘法则比较麻烦，需要借助乘法三元组 $(\\langle u \\rangle, \\langle v \\rangle, \\langle z \\rangle)$ 满足$z = uv \\bmod 2^l$：\n\n![](http://images.yingwai.top/picgo/smlppt2.png)\n\n接下来就可以得到上述算法的向量版本，以下是文章给出的具体协议：\n\n![](http://images.yingwai.top/picgo/smlf4.png)\n\n为了提高效率，使用了batch的方法来更新权重。\n\n\n\n## 逻辑回归\n\n$g(\\mathbf{x}_i) = f(\\mathbf{x}_i \\cdot \\mathbf{w}) = \\frac{1}{1+e^{-\\mathbf{x}_i \\cdot \\mathbf{w}}}$\n\n和线性回归相比，逻辑回归在线性回归的基础上增加了一个Sigmoid函数，其计算起来很困难，通常是使用多项式去拟合，但需要多项式次数较高且其并不收敛，导致在 $x$ 较大时准确率不高。\n\n因此作者提出了他们称为Secure-computation-friendly activation function：\n$$\nf(x) = \\left\\{ \\begin{array}{lcl}\n0, & \\mbox{if} & x < - \\frac{1}{2} \\\\\nx + \\frac{1}{2}, & \\mbox{if} & - \\frac{1}{2} \\leq x \\leq \\frac{1}{2} \\\\\n1, & \\mbox{if} & x > \\frac{1}{2}\n\\end{array}\\right.\n$$\n该函数的图像与Sigmoid函数类似：\n\n![](http://images.yingwai.top/picgo/smlf5.png)\n\n于是计算完矩阵-向量乘法后还需要计算上面的分段函数，因为要判断 $u+\\frac{1}{2}$ 和 $u- \\frac{1}{2}$ 的符号，这里算术共享就不是很适合，而Yao共享很适合，因此需要先把共享转换成Yao共享，在[ABY](https://yuyingwai.cn/2020/06/11/论文笔记-ABY-A-Framework-for-Efficient-Mixed-Protocol-Secure-Two-Party-Computation/)框架中有介绍。\n\n这里作者将函数 $f(u)$ 改写成了如下形式，方便乱码电路的计算：\n$$\nf(u) = (\\neg b_2) + (b_2 \\wedge (\\neg b_1))u\n$$\n其中 $b_1, b_2$ 分别为：\n$$\nb_1 = \\left\\{ \\begin{array}{ll}\n0, & \\mbox{if} \\ \\  u+\\frac{1}{2} \\geq 0 \\\\\n1, & \\mbox{otherwise}\n\\end{array}\\right.\n$$\n\n$$\nb_2 = \\left\\{ \\begin{array}{ll}\n0, & \\mbox{if} \\ \\  u-\\frac{1}{2} \\geq 0 \\\\\n1, & \\mbox{otherwise}\n\\end{array}\\right.\n$$\n\n于是构造电路以 $\\langle u \\rangle_0 + \\frac{1}{2}$ 和 $\\langle u \\rangle_1$ 作为输出，将它们相加并把结果的符号位 $b_1$ 输出，$b_2$ 同理，最后计算上面的 $f(u)$ 即可。下面是完整的协议：\n\n![](http://images.yingwai.top/picgo/smlf13.png)\n\n\n\n## 神经网络\n\n神经网络可以看作很多个与逻辑回归计算方式一致的神经元组成，用上面逻辑回归中的方法处理即可。","slug":"论文笔记-SecureML-A-System-for-Scalable-Privacy-Preserving-Machine-Learning","published":1,"updated":"2020-08-23T14:33:37.438Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cke79q4tu004s88psd81khzfn","content":"<p><em>Payman Mohassel,  Yupeng Zhang</em></p>\n<p><a href=\"https://dblp.uni-trier.de/db/conf/sp/sp2017.html#MohasselZ17\" target=\"_blank\" rel=\"noopener\">IEEE Symposium on Security and Privacy 2017</a></p>\n<p><a href=\"https://eprint.iacr.org/2017/396.pdf\" target=\"_blank\" rel=\"noopener\">https://eprint.iacr.org/2017/396.pdf</a></p>\n<a id=\"more\"></a>\n<h1 id=\"文章贡献\"><a href=\"#文章贡献\" class=\"headerlink\" title=\"文章贡献\"></a>文章贡献</h1><ul>\n<li><strong>两方计算：</strong>第一个提出在两方计算模型下处理机器学习模型问题；</li>\n<li><strong>秘密分享：</strong>第一个将秘密分享引入该问题，支持在两方上任意分布的数据；</li>\n<li><strong>Secure SGD：</strong>在两方下提出了训练模型的安全SGD算法；</li>\n<li><strong>秘密截断：</strong>分析了在秘密分享下如何进行定点数截断问题。</li>\n</ul>\n<h1 id=\"计算模型\"><a href=\"#计算模型\" class=\"headerlink\" title=\"计算模型\"></a>计算模型</h1><p>本文考虑一个客户端集合 $\\mathcal{C}_1,…,\\mathcal{C}_m$ 想要使用它们的数据训练一个模型，客户端将数据 $x_i$ 以秘密分享的模式分发给两个非合谋的服务器 $\\mathcal{S}_0, \\mathcal{S}_1$（例如一方拥有随机数 $r_i$ 而另一方拥有 $x_i - r_i$），服务器交互式地计算函数 $f(x_i)$，得到预测标签 $y_i$。</p>\n<p><img src=\"http://images.yingwai.top/picgo/smlf3.png\" alt=\"\"></p>\n<p><img src=\"http://images.yingwai.top/picgo/smlppt1.png\" alt=\"\"></p>\n<h1 id=\"PPML\"><a href=\"#PPML\" class=\"headerlink\" title=\"PPML\"></a>PPML</h1><p>本文给出了满足隐私保护的线性回归、逻辑回归以及神经网络的协议。</p>\n<h2 id=\"线性回归\"><a href=\"#线性回归\" class=\"headerlink\" title=\"线性回归\"></a>线性回归</h2><p>$y = \\sum^d<em>{j=1} x</em>{ij} w_j = \\vec{x_i} \\cdot \\vec{w}$</p>\n<p><strong>损失函数：</strong></p>\n<p>$C(\\mathbf{w}) = \\frac{1}{n} \\sum C_i(\\mathbf{w})$，</p>\n<p>其中 $C_i(\\mathbf{w}) = \\frac{1}{2}(\\mathbf{x}_i \\cdot \\mathbf{w} - y_i)^2$。</p>\n<p>更新权重的公式为：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{align}\nw_j : &= w_j - \\alpha \\frac{\\partial C_i(\\mathbf{w})}{\\partial w_j} \\\\\n&= w_j - \\alpha (\\mathbf{x}_i \\cdot \\mathbf{w} - y_i) x_{ij}\n\\end{align}</script><p>可以看到只有加法和乘法的运算。</p>\n<p>数据是在两个服务器中加法共享的，计算两个数 $\\langle a \\rangle, \\langle b \\rangle$ 的和比较简单，两个服务器各自在本地将对应的份额相加即可；计算乘法则比较麻烦，需要借助乘法三元组 $(\\langle u \\rangle, \\langle v \\rangle, \\langle z \\rangle)$ 满足$z = uv \\bmod 2^l$：</p>\n<p><img src=\"http://images.yingwai.top/picgo/smlppt2.png\" alt=\"\"></p>\n<p>接下来就可以得到上述算法的向量版本，以下是文章给出的具体协议：</p>\n<p><img src=\"http://images.yingwai.top/picgo/smlf4.png\" alt=\"\"></p>\n<p>为了提高效率，使用了batch的方法来更新权重。</p>\n<h2 id=\"逻辑回归\"><a href=\"#逻辑回归\" class=\"headerlink\" title=\"逻辑回归\"></a>逻辑回归</h2><p>$g(\\mathbf{x}_i) = f(\\mathbf{x}_i \\cdot \\mathbf{w}) = \\frac{1}{1+e^{-\\mathbf{x}_i \\cdot \\mathbf{w}}}$</p>\n<p>和线性回归相比，逻辑回归在线性回归的基础上增加了一个Sigmoid函数，其计算起来很困难，通常是使用多项式去拟合，但需要多项式次数较高且其并不收敛，导致在 $x$ 较大时准确率不高。</p>\n<p>因此作者提出了他们称为Secure-computation-friendly activation function：</p>\n<script type=\"math/tex; mode=display\">\nf(x) = \\left\\{ \\begin{array}{lcl}\n0, & \\mbox{if} & x < - \\frac{1}{2} \\\\\nx + \\frac{1}{2}, & \\mbox{if} & - \\frac{1}{2} \\leq x \\leq \\frac{1}{2} \\\\\n1, & \\mbox{if} & x > \\frac{1}{2}\n\\end{array}\\right.</script><p>该函数的图像与Sigmoid函数类似：</p>\n<p><img src=\"http://images.yingwai.top/picgo/smlf5.png\" alt=\"\"></p>\n<p>于是计算完矩阵-向量乘法后还需要计算上面的分段函数，因为要判断 $u+\\frac{1}{2}$ 和 $u- \\frac{1}{2}$ 的符号，这里算术共享就不是很适合，而Yao共享很适合，因此需要先把共享转换成Yao共享，在<a href=\"https://yuyingwai.cn/2020/06/11/论文笔记-ABY-A-Framework-for-Efficient-Mixed-Protocol-Secure-Two-Party-Computation/\" target=\"_blank\" rel=\"noopener\">ABY</a>框架中有介绍。</p>\n<p>这里作者将函数 $f(u)$ 改写成了如下形式，方便乱码电路的计算：</p>\n<script type=\"math/tex; mode=display\">\nf(u) = (\\neg b_2) + (b_2 \\wedge (\\neg b_1))u</script><p>其中 $b_1, b_2$ 分别为：</p>\n<script type=\"math/tex; mode=display\">\nb_1 = \\left\\{ \\begin{array}{ll}\n0, & \\mbox{if} \\ \\  u+\\frac{1}{2} \\geq 0 \\\\\n1, & \\mbox{otherwise}\n\\end{array}\\right.</script><script type=\"math/tex; mode=display\">\nb_2 = \\left\\{ \\begin{array}{ll}\n0, & \\mbox{if} \\ \\  u-\\frac{1}{2} \\geq 0 \\\\\n1, & \\mbox{otherwise}\n\\end{array}\\right.</script><p>于是构造电路以 $\\langle u \\rangle_0 + \\frac{1}{2}$ 和 $\\langle u \\rangle_1$ 作为输出，将它们相加并把结果的符号位 $b_1$ 输出，$b_2$ 同理，最后计算上面的 $f(u)$ 即可。下面是完整的协议：</p>\n<p><img src=\"http://images.yingwai.top/picgo/smlf13.png\" alt=\"\"></p>\n<h2 id=\"神经网络\"><a href=\"#神经网络\" class=\"headerlink\" title=\"神经网络\"></a>神经网络</h2><p>神经网络可以看作很多个与逻辑回归计算方式一致的神经元组成，用上面逻辑回归中的方法处理即可。</p>\n","site":{"data":{}},"excerpt":"<p><em>Payman Mohassel,  Yupeng Zhang</em></p>\n<p><a href=\"https://dblp.uni-trier.de/db/conf/sp/sp2017.html#MohasselZ17\" target=\"_blank\" rel=\"noopener\">IEEE Symposium on Security and Privacy 2017</a></p>\n<p><a href=\"https://eprint.iacr.org/2017/396.pdf\" target=\"_blank\" rel=\"noopener\">https://eprint.iacr.org/2017/396.pdf</a></p>","more":"<h1 id=\"文章贡献\"><a href=\"#文章贡献\" class=\"headerlink\" title=\"文章贡献\"></a>文章贡献</h1><ul>\n<li><strong>两方计算：</strong>第一个提出在两方计算模型下处理机器学习模型问题；</li>\n<li><strong>秘密分享：</strong>第一个将秘密分享引入该问题，支持在两方上任意分布的数据；</li>\n<li><strong>Secure SGD：</strong>在两方下提出了训练模型的安全SGD算法；</li>\n<li><strong>秘密截断：</strong>分析了在秘密分享下如何进行定点数截断问题。</li>\n</ul>\n<h1 id=\"计算模型\"><a href=\"#计算模型\" class=\"headerlink\" title=\"计算模型\"></a>计算模型</h1><p>本文考虑一个客户端集合 $\\mathcal{C}_1,…,\\mathcal{C}_m$ 想要使用它们的数据训练一个模型，客户端将数据 $x_i$ 以秘密分享的模式分发给两个非合谋的服务器 $\\mathcal{S}_0, \\mathcal{S}_1$（例如一方拥有随机数 $r_i$ 而另一方拥有 $x_i - r_i$），服务器交互式地计算函数 $f(x_i)$，得到预测标签 $y_i$。</p>\n<p><img src=\"http://images.yingwai.top/picgo/smlf3.png\" alt=\"\"></p>\n<p><img src=\"http://images.yingwai.top/picgo/smlppt1.png\" alt=\"\"></p>\n<h1 id=\"PPML\"><a href=\"#PPML\" class=\"headerlink\" title=\"PPML\"></a>PPML</h1><p>本文给出了满足隐私保护的线性回归、逻辑回归以及神经网络的协议。</p>\n<h2 id=\"线性回归\"><a href=\"#线性回归\" class=\"headerlink\" title=\"线性回归\"></a>线性回归</h2><p>$y = \\sum^d<em>{j=1} x</em>{ij} w_j = \\vec{x_i} \\cdot \\vec{w}$</p>\n<p><strong>损失函数：</strong></p>\n<p>$C(\\mathbf{w}) = \\frac{1}{n} \\sum C_i(\\mathbf{w})$，</p>\n<p>其中 $C_i(\\mathbf{w}) = \\frac{1}{2}(\\mathbf{x}_i \\cdot \\mathbf{w} - y_i)^2$。</p>\n<p>更新权重的公式为：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{align}\nw_j : &= w_j - \\alpha \\frac{\\partial C_i(\\mathbf{w})}{\\partial w_j} \\\\\n&= w_j - \\alpha (\\mathbf{x}_i \\cdot \\mathbf{w} - y_i) x_{ij}\n\\end{align}</script><p>可以看到只有加法和乘法的运算。</p>\n<p>数据是在两个服务器中加法共享的，计算两个数 $\\langle a \\rangle, \\langle b \\rangle$ 的和比较简单，两个服务器各自在本地将对应的份额相加即可；计算乘法则比较麻烦，需要借助乘法三元组 $(\\langle u \\rangle, \\langle v \\rangle, \\langle z \\rangle)$ 满足$z = uv \\bmod 2^l$：</p>\n<p><img src=\"http://images.yingwai.top/picgo/smlppt2.png\" alt=\"\"></p>\n<p>接下来就可以得到上述算法的向量版本，以下是文章给出的具体协议：</p>\n<p><img src=\"http://images.yingwai.top/picgo/smlf4.png\" alt=\"\"></p>\n<p>为了提高效率，使用了batch的方法来更新权重。</p>\n<h2 id=\"逻辑回归\"><a href=\"#逻辑回归\" class=\"headerlink\" title=\"逻辑回归\"></a>逻辑回归</h2><p>$g(\\mathbf{x}_i) = f(\\mathbf{x}_i \\cdot \\mathbf{w}) = \\frac{1}{1+e^{-\\mathbf{x}_i \\cdot \\mathbf{w}}}$</p>\n<p>和线性回归相比，逻辑回归在线性回归的基础上增加了一个Sigmoid函数，其计算起来很困难，通常是使用多项式去拟合，但需要多项式次数较高且其并不收敛，导致在 $x$ 较大时准确率不高。</p>\n<p>因此作者提出了他们称为Secure-computation-friendly activation function：</p>\n<script type=\"math/tex; mode=display\">\nf(x) = \\left\\{ \\begin{array}{lcl}\n0, & \\mbox{if} & x < - \\frac{1}{2} \\\\\nx + \\frac{1}{2}, & \\mbox{if} & - \\frac{1}{2} \\leq x \\leq \\frac{1}{2} \\\\\n1, & \\mbox{if} & x > \\frac{1}{2}\n\\end{array}\\right.</script><p>该函数的图像与Sigmoid函数类似：</p>\n<p><img src=\"http://images.yingwai.top/picgo/smlf5.png\" alt=\"\"></p>\n<p>于是计算完矩阵-向量乘法后还需要计算上面的分段函数，因为要判断 $u+\\frac{1}{2}$ 和 $u- \\frac{1}{2}$ 的符号，这里算术共享就不是很适合，而Yao共享很适合，因此需要先把共享转换成Yao共享，在<a href=\"https://yuyingwai.cn/2020/06/11/论文笔记-ABY-A-Framework-for-Efficient-Mixed-Protocol-Secure-Two-Party-Computation/\" target=\"_blank\" rel=\"noopener\">ABY</a>框架中有介绍。</p>\n<p>这里作者将函数 $f(u)$ 改写成了如下形式，方便乱码电路的计算：</p>\n<script type=\"math/tex; mode=display\">\nf(u) = (\\neg b_2) + (b_2 \\wedge (\\neg b_1))u</script><p>其中 $b_1, b_2$ 分别为：</p>\n<script type=\"math/tex; mode=display\">\nb_1 = \\left\\{ \\begin{array}{ll}\n0, & \\mbox{if} \\ \\  u+\\frac{1}{2} \\geq 0 \\\\\n1, & \\mbox{otherwise}\n\\end{array}\\right.</script><script type=\"math/tex; mode=display\">\nb_2 = \\left\\{ \\begin{array}{ll}\n0, & \\mbox{if} \\ \\  u-\\frac{1}{2} \\geq 0 \\\\\n1, & \\mbox{otherwise}\n\\end{array}\\right.</script><p>于是构造电路以 $\\langle u \\rangle_0 + \\frac{1}{2}$ 和 $\\langle u \\rangle_1$ 作为输出，将它们相加并把结果的符号位 $b_1$ 输出，$b_2$ 同理，最后计算上面的 $f(u)$ 即可。下面是完整的协议：</p>\n<p><img src=\"http://images.yingwai.top/picgo/smlf13.png\" alt=\"\"></p>\n<h2 id=\"神经网络\"><a href=\"#神经网络\" class=\"headerlink\" title=\"神经网络\"></a>神经网络</h2><p>神经网络可以看作很多个与逻辑回归计算方式一致的神经元组成，用上面逻辑回归中的方法处理即可。</p>"},{"title":"LeetCode刷题","date":"2020-05-25T12:48:42.000Z","_content":"\n记录一下每日刷题 $\\surd$\n\n<!--more-->\n\n[TOC]\n\n# 4. 寻找两个正序数组的中位数\n\nhttps://leetcode-cn.com/problems/median-of-two-sorted-arrays/\n\n## 题目描述\n\n给定两个大小为 m 和 n 的正序（从小到大）数组 `nums1` 和 `nums2`。\n\n请你找出这两个正序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。\n\n你可以假设 `nums1` 和 `nums2` 不会同时为空。\n\n \n\n示例 1:\n\n```\nnums1 = [1, 3]\nnums2 = [2]\n\n则中位数是 2.0\n```\n\n示例 2:\n\n```\nnums1 = [1, 2]\nnums2 = [3, 4]\n\n则中位数是 (2 + 3)/2 = 2.5\n```\n\n\n\n## 思路\n\n题目要求时间复杂度为 O(log(m + n))，知道要用二分查找，但是具体方法想不出来，只能看了一篇题解中的[找第 k 小的数的方法](https://leetcode-cn.com/problems/median-of-two-sorted-arrays/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-w-2/)。\n\n主要思想是：\n\n* 比较两个数组的第 `k/2` 个数字（向下取整），哪个小则可以直接排除那个数组的前 `k/2` 个数字（因为两个数组都是有序的）；\n* 上一步已经排除了 `k/2` 个数，因此 `k = k - k/2`，再次比较两个数组（其中一个数组为排除了 `k/2` 个数后的新数组）的第 `k/2` 个数字，直到 `k = 1` 或其中一个数组中的元素被全部排除了：\n  1. 若 `k = 1` 则返回当前两个数组的第一个元素中较小的那一个；\n  2. 若其中一个数组被全部排除，则返回另一个数组中的第 `k` 个元素。\n\n\n\n## 代码\n\n```python\nclass Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n        n, m = len(nums1), len(nums2)\n        left = (n + m + 1) // 2\n        right = (n + m + 2) // 2\n        return (self.recur(left, nums1, 0, n-1, nums2, 0, m-1) + self.recur(right, nums1, 0, n-1, nums2, 0, m-1)) * 0.5\n\n    def recur(self, k, arr1, s1, e1, arr2, s2, e2):\n        l1 = e1 - s1 + 1\n        l2 = e2 - s2 + 1\n        if l1 > l2:\n            return self.recur(k, arr2, s2, e2, arr1, s1, e1)\n        if l1 == 0:\n            return arr2[s2+k-1]\n        if k == 1:\n            return min(arr1[s1], arr2[s2])\n        p1 = s1 + min(k//2, l1) - 1\n        p2 = s2 + min(k//2, l2) - 1\n        if arr1[p1] < arr2[p2]:\n            return self.recur(k-min(k//2, l1), arr1, p1+1, e1, arr2, s2, e2)\n        else:\n            return self.recur(k-min(k//2, l2), arr1, s1, e1, arr2, p2+1, e2)\n```\n\n\n\n# 6. Z字形变换\n\nhttps://leetcode-cn.com/problems/zigzag-conversion/\n\n## 题目描述\n\n将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。\n\n比如输入字符串为 `\"LEETCODEISHIRING\"` 行数为 3 时，排列如下：\n\n```\nL   C   I   R\nE T O E S I I G\nE   D   H   N\n```\n\n之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：`\"LCIRETOESIIGEDHN\"`。\n\n请你实现这个将字符串进行指定行数变换的函数：\n\n```\nstring convert(string s, int numRows);\n```\n\n示例 1:\n\n```\n输入: s = \"LEETCODEISHIRING\", numRows = 3\n输出: \"LCIRETOESIIGEDHN\"\n```\n\n示例 2:\n\n```\n输入: s = \"LEETCODEISHIRING\", numRows = 4\n输出: \"LDREOEIIECIHNTSG\"\n解释:\n\nL     D     R\nE   O E   I I\nE C   I H   N\nT     S     G\n```\n\n\n\n## 思路\n\n用一个二维列表 `tmp` 存储 Z 字形字符串中每一行的元素，最后将 `tmp` 中的字符串逐行拼接即得到结果，具体步骤如下：\n\n* 从头到尾遍历`s`，`cnt` 表示当前字符的下标，`curRow` 表示当前字符 `s[cnt]` 在 Z 字形字符串中所在的行数，`step` 表示当前的方向（因为 Z 字形中字符都是往上往下这样循环）；\n* 将 `s[cnt]` 加入 `tmp[curRow]`，然后 `cnt` 自增 1，`curRow` 自增 `step`。当 `curRow` 为 `0` 或 `numRows` 时，转换方向，`step *= -1` 。\n\n\n\n## 代码\n\n```python\nclass Solution:\n    def convert(self, s: str, numRows: int) -> str:\n        if numRows == 1: return s\n        tmp = [\"\" for _ in range(numRows)]\n        cnt = curRow = 0\n        step = -1\n        while cnt < len(s):\n            tmp[curRow] += s[cnt]\n            cnt += 1\n            if curRow == numRows - 1 or curRow == 0:\n                step *= -1\n            curRow += step\n        return ''.join(tmp)\n```\n\n\n\n# 14. 最长公共前缀\n\nhttps://leetcode-cn.com/problems/longest-common-prefix/\n\n## 题目描述\n\n编写一个函数来查找字符串数组中的最长公共前缀。\n\n如果不存在公共前缀，返回空字符串 `\"\"`。\n\n示例 1:\n\n```\n输入: [\"flower\",\"flow\",\"flight\"]\n输出: \"fl\"\n```\n\n示例 2:\n\n```\n输入: [\"dog\",\"racecar\",\"car\"]\n输出: \"\"\n解释: 输入不存在公共前缀。\n```\n\n\n说明:\n\n所有输入只包含小写字母 `a-z` 。\n\n\n\n## 思路\n\nPython中的`max()`和`min()`可以比较字符串，按照ASCII值逐位比较：比如`cba`、`cbab`、`cbd`中最大为`cbd`，最小为`cba`。因此只要比较最大最小的两个字符串即可找到最大公共前缀。\n\n\n\n## 代码\n\n```python\nclass Solution:\n    def longestCommonPrefix(self, strs: List[str]) -> str:\n        if not strs: return \"\"\n        str1 = min(strs)\n        str2 = max(strs)\n        for i,x in enumerate(str1):\n            if x != str2[i]:\n                return str2[:i]\n        return str1\n```\n\n\n\n# 21. 合并两个有序链表\n\nhttps://leetcode-cn.com/problems/merge-two-sorted-lists/\n\n## 题目描述\n\n将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 \n\n \n\n示例：\n\n```\n输入：1->2->4, 1->3->4\n输出：1->1->2->3->4->4\n```\n\n\n\n## 思路\n\n因为链表有序，可以用两个指针分别遍历两个链表，将两个指针指向的节点中值较小的节点加入到新链表中，然后该指针往后挪，直到遍历完两个链表。\n\n时间复杂度为 O(M + N)，M 和 N 分别为两个链表的长度。\n\n\n\n## 代码\n\n```python\nclass Solution:\n    def mergeTwoLists(self, l1: ListNode, l2: ListNode) -> ListNode:\n        if not l1 and not l2: return None\n        p1, p2 = l1, l2\n        pre = None\n        while p1 and p2:\n            if p2.val < p1.val:\n                if not pre:\n                    root = p2\n                    pre = root\n                else:\n                    pre.next = p2\n                    pre = p2\n                p2 = p2.next\n            else:\n                if not pre:\n                    root = p1\n                    pre = root\n                else:\n                    pre.next = p1\n                    pre = p1\n                p1 = p1.next\n        if p1:\n            if not pre:\n                return p1\n            pre.next = p1\n        else:\n            if not pre:\n                return p2\n            pre.next = p2\n        return root\n```\n\n\n\n\n\n# 32. 最长有效括号\n\nhttps://leetcode-cn.com/problems/longest-valid-parentheses/\n\n## 题目描述\n\n给定一个只包含 `'('` 和 `')'` 的字符串，找出最长的包含有效括号的子串的长度。\n\n示例 1:\n\n```\n输入: \"(()\"\n输出: 2\n解释: 最长有效括号子串为 \"()\"\n```\n\n\n示例 2:\n\n```\n输入: \")()())\"\n输出: 4\n解释: 最长有效括号子串为 \"()()\"\n```\n\n\n\n## 思路\n\n动态规划：用 $dp[i]$ 表示字符串中以第 $i$ 个字符结尾的字符串的最大有效子串长度。根据题意，$s[i]$ 为 `'('` 时 $dp[i]=0$，有效的子串结尾肯定是 `')'`，可列出动态方程：\n\n当 $s[i]$ 为 `')'` 且 $s[i-1]$ 为 `'('` 时，也就是 \"$......()$\"，\n$$\ndp[i] = dp[i-2] + 2\n$$\n当 $s[i]$ 为 `')'` 且 $s[i-1]$ 为 `')'` 时，也就是 \"$......))$\"，如果倒数第二个 `')'` 是一个有效字符串 $sub_s$ 的一部分，且 $s[i-\\mbox{len}(sub_s)-1]$ 为 `'('` 。此时的最长有效子串的长度即为 $sub_s$ 加上 $2$ 再加上 $dp[i-\\mbox{len}(sub_s)-2]$：\n$$\ndp[i] = dp[i-1] + 2 + dp[i-dp[i-1]-2]\n$$\n最后的结果为 $dp$ 数组中的最大值。\n\n上面两条方程都要注意判断下标 $i-2$ 和 $i-dp[i-1]-2$ 的值，不要小于 $0$。\n\n\n\n## 代码\n\n```python\nclass Solution:\n    def longestValidParentheses(self, s: str) -> int:\n        if len(s) <= 1:\n            return 0\n        dp = [0]\n        for i in range(1, len(s)):\n            if s[i] == ')':\n                if s[i-1] == '(':\n                    dp.append(dp[max(i-2, 0)] + 2)\n                elif s[i-1] == ')' and i-dp[i-1]-1 >= 0 and s[i-dp[i-1]-1] == '(':\n                    dp.append(dp[i-1] + 2 + dp[max(i-dp[i-1]-2, 0)])\n                else:\n                    dp.append(0)\n            else:\n                dp.append(0)\n        return max(dp)\n```\n\n\n\n# 35. 搜索插入位置\n\nhttps://leetcode-cn.com/problems/search-insert-position/\n\n## 题目描述\n\n给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。\n\n你可以假设数组中无重复元素。\n\n示例 1:\n\n```\n输入: [1,3,5,6], 5\n输出: 2\n```\n\n示例 2:\n\n```\n输入: [1,3,5,6], 2\n输出: 1\n```\n\n示例 3:\n\n```\n输入: [1,3,5,6], 7\n输出: 4\n```\n\n示例 4:\n\n```\n输入: [1,3,5,6], 0\n输出: 0\n```\n\n\n\n## 思路\n\n二分查找，每次排除当前数组中一半的元素。\n\n注意递归边界为 `left >= right`，`target` 在 `nums` 不存在有两种情况：\n\n* 当 `left > right` 时，数组 `nums` 中不存在与 `target` 相等的元素，此时 `nums[left]` 为 `nums` 中第一个大于 `target` 的元素，`left` 即为 `target` 应该插入的位置；\n* 当 `left == right` 时，此时 `left` 和 `right` 应该都指向 `nums` 中最后一个元素（因为 `mid` 总是向下取整，这种情况下 `left` 每次都 `+1`，直到指向最后一个元素），此时需要额外判断 `target` 与最后一个元素的大小，`target` 大则将其插入到数组末尾。\n\n\n\n## 代码\n\n```python\nclass Solution:\n    def searchInsert(self, nums: List[int], target: int) -> int:\n        return self.getInsertIndex(nums, 0, len(nums)-1, target)\n\n    def getInsertIndex(self, nums, left, right, target):\n        if left >= right:\n            if target > nums[left]:\n                return left + 1\n            return left\n        mid = (left + right) // 2\n        if target == nums[mid]:\n            return mid\n        if target < nums[mid]:\n            return self.getInsertIndex(nums, left, mid-1, target)\n        else:\n            return self.getInsertIndex(nums, mid+1, right, target)\n```\n\n\n\n# 94. 二叉树的中序遍历\n\nhttps://leetcode-cn.com/problems/binary-tree-inorder-traversal/\n\n## 题目描述\n\n给定一个二叉树，返回它的中序 遍历。\n\n示例:\n\n```\n输入: [1,null,2,3]\n   1\n    \\\n     2\n    /\n   3\n\n输出: [1,3,2]\n```\n\n进阶: 递归算法很简单，你可以通过迭代算法完成吗？\n\n\n\n## 思路\n\n这里可以用两种方法，递归和迭代，前者比较简单就不说了，主要讲后者。\n\n迭代算法中需要用到一个栈，每到一个节点先将其入栈，遍历其左子树，然后访问该节点，访问完后该节点就可以出栈了，最后遍历其右子树。\n\n\n\n## 代码\n\n数据结构：\n\n```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n```\n\n递归：\n\n```python\nclass Solution:\n    def inorderTraversal(self, root: TreeNode) -> List[int]:\n        ans = []\n\n        def helper(root):\n            if root:\n                helper(root.left)\n                ans.append(root.val)\n                helper(root.right)\n            return\n\n        helper(root)\n        return ans\n```\n\n迭代：\n\n```python\nclass Solution:\n    def inorderTraversal(self, root: TreeNode) -> List[int]:\n        if not root:\n            return []\n        ans, v = [], []\n        cur = root\n        while cur or v:\n            while cur:\n                v.append(cur)\n                cur = cur.left\n            cur = v.pop()\n            ans.append(cur.val)\n            cur = cur.right\n\n        return ans\n```\n\n\n\n# 96. 不同的二叉搜索树\n\nhttps://leetcode-cn.com/problems/unique-binary-search-trees/\n\n## 题目描述\n\n给定一个整数 n，求以 1 ... n 为节点组成的二叉搜索树有多少种？\n\n示例:\n\n```\n输入: 3\n输出: 5\n解释:\n给定 n = 3, 一共有 5 种不同结构的二叉搜索树:\n\n   1         3     3      2      1\n    \\       /     /      / \\      \\\n     3     2     1      1   3      2\n    /     /       \\                 \\\n   2     1         2                 3\n```\n\n\n\n## 思路\n\n动态规划：\n\n* 用 `dp[n]` 表示以 1 ... n 为节点组成的二叉搜索树的数量，`f[i]` 表示 i 为根节点的二叉搜索树的数量；\n* 结果即为以各个节点作为根节点的数量总和：`dp[n] = f[1] + f[2] + ... + f[n]`；\n*  当 i 为根节点时，其左子树的节点数为 i-1，右子树的节点数为 n-i，因此有：`f[i] = f[i-1] * f[n-i]`；\n* `dp[n] = dp[0]*dp[n-1] + dp[1]*dp[n-2] + ... + dp[n-1]*dp[0]`。\n\n当 n 为1或0时，只有一种情况，即 `dp[0] = dp[1] = 1`。\n\n\n\n还有一种方法是递归，也是利用上面的公式。\n\n\n\n## 代码\n\n动态规划：\n\n```python\nclass Solution:\n    def numTrees(self, n: int) -> int:\n        dp = [0] * (n + 1)\n        dp[0] = dp[1] = 1\n        for i in range(2, n+1):\n            for j in range(1, i+1):\n                dp[i] += dp[j-1] * dp[i-j]\n        return dp[n]\n```\n\n递归：\n\n```python\nclass Solution:\n    def numTrees(self, n: int) -> int:\n        memo = [0] * (n + 1)\n\n        def helper(n):\n            if n == 1 or n == 0: return 1\n            if memo[n] > 0:\n                return memo[n]\n            for i in range(0, n):\n                memo[n] += helper(i) * helper(n-i-1)\n            return memo[n]\n\n        return helper(n)\n```\n\n\n\n# 97. 交错字符串\n\nhttps://leetcode-cn.com/problems/interleaving-string/\n\n## 题目描述\n\n给定三个字符串 s1, s2, s3, 验证 s3 是否是由 s1 和 s2 交错组成的。\n\n示例 1:\n\n```\n输入: s1 = \"aabcc\", s2 = \"dbbca\", s3 = \"aadbbcbcac\"\n输出: true\n```\n\n示例 2:\n\n```\n输入: s1 = \"aabcc\", s2 = \"dbbca\", s3 = \"aadbbbaccc\"\n输出: false\n```\n\n\n\n## 思路\n\n动态规划，用 `dp[i][j]` 表示 `s1` 的前 `i` 个字符和 `s2` 的前 `j` 个字符是否能交错组成 `s3` 的前 `i+j` 个字符。若 `s1[i]==s3[i+j]`，那么 `dp[i][j]` 是否为真则取决于 `s1` 的前 `i-1`（`s2` 的前 `j-1`）个字符和 `s2` 的前 `j` `s1` 的前 `i`）个字符是否能交错组成 `s3` 的前 `i+j-1` 个字符，即 `dp[i-1][j]`（`dp[i][j-1]`）是否为真。\n\n可得状态转移方程：\n\n* `dp[i][j] = (dp[i-1][j] and s1[i-1]==s3[i+j-1]) or (dp[i][j-1] and s2[j-1]==s3[i+j-1])`；\n* 边界条件为`dp[0][0] = True`。\n\n当 `s1` 和 `s2` 长度之和不等于 `s3` 长度时，直接输出 `False`。\n\n时间复杂度为 O(MN)。\n\n\n\n## 代码\n\n```python\nclass Solution:\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\n        n, m = len(s1), len(s2)\n        if n + m != len(s3):\n            return False\n        dp = [[False] * (m + 1) for _ in range(n + 1)]\n        dp[0][0] = True\n        for i in range(n + 1):\n            for j in range(m + 1):\n                if i > 0:\n                    dp[i][j] = dp[i][j] or (dp[i-1][j] and s1[i-1]==s3[i+j-1])\n                if j > 0:\n                    dp[i][j] = dp[i][j] or (dp[i][j-1] and s2[j-1]==s3[i+j-1])\n        return dp[n][m]\n```\n\n\n\n# 100. 相同的树\n\nhttps://leetcode-cn.com/problems/same-tree/\n\n## 题目描述\n\n给定两个二叉树，编写一个函数来检验它们是否相同。\n\n如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。\n\n示例 1:\n\n    输入:       1         1\n              / \\       / \\\n             2   3     2   3\n    \n            [1,2,3],   [1,2,3]\n            \n    输出: true\n\n\n示例 2:\n\n    输入:      1          1\n              /           \\\n             2             2\n    \n            [1,2],     [1,null,2]\n            \n    输出: false\n\n\n示例 3:\n\n    输入:       1         1\n              / \\       / \\\n             2   1     1   2\n    \n            [1,2,1],   [1,1,2]\n            \n    输出: false\n\n\n\n## 思路\n\n就是二叉树的遍历，用递归判断两棵树对应节点是否存在以及值是否相等即可。\n\n\n\n## 代码\n\n```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\n        \n        def helper(p, q):\n            if not p and not q: return True\n            if p and not q or not p and q: return False\n            if p.val != q.val: return False\n            return helper(p.left, q.left) and helper(p.right, q.right)\n\n        return helper(p, q)\n```\n\n\n\n# 101. 对称二叉树\n\nhttps://leetcode-cn.com/problems/symmetric-tree/\n\n## 题目描述\n\n给定一个二叉树，检查它是否是镜像对称的。\n\n \n\n例如，二叉树 [1,2,2,3,4,4,3] 是对称的。\n\n        1\n       / \\\n      2   2\n     / \\ / \\\n    3  4 4  3\n\n\n\n\n但是下面这个 `[1,2,2,null,3,null,3]` 则不是镜像对称的:\n\n        1\n       / \\\n      2   2\n       \\   \\\n       3    3\n\n\n\n\n进阶：\n\n你可以运用递归和迭代两种方法解决这个问题吗？\n\n\n\n## 思路\n\n可以通过判断根节点的两棵子树 $p,q$ 是否是镜像的。遍历的方式与第100题类似，只是这次两者不再按相同的顺序遍历，而是按镜像的方式：\n\n* $p$ 遍历其左子树时，$q$ 遍历其右子树；\n* $p$ 遍历其右子树时，$q$ 遍历其左子树。\n\n\n\n## 代码\n\n```python\nclass Solution:\n    def isSymmetric(self, root: TreeNode) -> bool:\n        def helper(p, q):\n            if not p and not q: return True\n            if p and not q or not p and q: return False\n            if p.val != q.val: return False\n            return helper(p.left, q.right) and helper(p.right, q.left)\n        if root and root.left and root.right:\n            return helper(root.left, root.right)\n        elif root and not root.left and not root.right or not root:\n            return True\n        else:\n            return False\n```\n\n\n\n# 102. 二叉树的层序遍历\n\nhttps://leetcode-cn.com/problems/binary-tree-level-order-traversal/\n\n## 题目描述\n\n给你一个二叉树，请你返回其按 **层序遍历** 得到的节点值。 （即逐层地，从左到右访问所有节点）。\n\n \n\n示例：\n二叉树：`[3,9,20,null,null,15,7]`,\n\n        3\n       / \\\n      9  20\n        /  \\\n       15   7\n\n返回其层次遍历结果：\n\n```\n[\n  [3],\n  [9,20],\n  [15,7]\n]\n```\n\n\n\n## 思路\n\n最简单的方法是用递归，按前序遍历二叉树中的节点，记录访问节点的层数，每层用一个列表 `ans[d]` ( `d` 表示当前节点所在层的深度)保存节点值。\n\n另一种思路是使用BFS，使用一个队列 `queue` 存放待访问的节点，每到一层都用 `s` 存当前层节点的个数，每访问到一个节点就将其值存入答案列表中对应的位置，并将其左右子节点存入队列。\n\n\n\n## 代码\n\n递归，前序遍历：\n\n```python\nclass Solution:\n    def levelOrder(self, root: TreeNode) -> List[List[int]]:\n        if not root: return []\n        ans = []\n        \n        def helper(node, d):\n            if not node: return\n            if len(ans) == d:\n                ans.append([])\n            ans[d].append(node.val)\n            helper(node.left, d+1)\n            helper(node.right, d+1)\n            return\n\n        helper(root, 0)\n        return ans\n```\n\n\n\nBFS：\n\n```python\nclass Solution:\n    def levelOrder(self, root: TreeNode) -> List[List[int]]:\n        queue = collections.deque()\n        queue.append(root)\n        ans = []\n        while queue:\n            s = len(queue)\n            d = []\n            for _ in range(s):\n                node = queue.popleft()\n                if not node:\n                    continue\n                d.append(node.val)\n                queue.append(node.left)\n                queue.append(node.right)\n            if d:\n                ans.append(d)\n\n        return ans\n```\n\n\n\n# 107. 二叉树的层次遍历 II\n\nhttps://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/\n\n## 题目描述\n\n给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）\n\n例如：\n给定二叉树 `[3,9,20,null,null,15,7]`,\n\n        3\n       / \\\n      9  20\n        /  \\\n       15   7\n\n返回其自底向上的层次遍历为：\n\n```\n[\n  [15,7],\n  [9,20],\n  [3]\n]\n```\n\n\n\n## 思路\n\n与层次遍历一样，只是输出的时候倒序输出即可，也是有两种方法：递归前序遍历和BFS。\n\n\n\n## 代码\n\n前序遍历，递归：\n\n```python\nclass Solution:\n    def levelOrderBottom(self, root: TreeNode) -> List[List[int]]:\n        ans = []\n        self.helper(root, 0, ans)\n        return ans[::-1]\n\n    def helper(self, node, depth, ans):\n        if not node:\n            return\n        if len(ans) == depth:\n            ans.append([])\n        ans[depth].append(node.val)\n        self.helper(node.left, depth+1, ans)\n        self.helper(node.right, depth+1, ans)\n        return\n```\n\n\n\nBFS：\n\n```python\nclass Solution:\n    def levelOrderBottom(self, root: TreeNode) -> List[List[int]]:\n        queue = collections.deque()\n        queue.append(root)\n        ans = []\n        while queue:\n            size = len(queue)\n            t = []\n            for _ in range(size):\n                p = queue.popleft()\n                if not p:\n                    continue\n                t.append(p.val)\n                queue.append(p.left)\n                queue.append(p.right)\n            if t:\n                ans.append(t)\n        return ans[::-1]\n```\n\n\n\n# 110. 平衡二叉树\n\nhttps://leetcode-cn.com/problems/balanced-binary-tree/\n\n## 题目描述\n\n给定一个二叉树，判断它是否是高度平衡的二叉树。\n\n本题中，一棵高度平衡二叉树定义为：\n\n*一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1。*\n\n示例 1:\n\n给定二叉树 `[3,9,20,null,null,15,7]`\n\n        3\n       / \\\n      9  20\n        /  \\\n       15   7\n\n\n返回 `true` 。\n\n示例 2:\n\n给定二叉树 `[1,2,2,3,3,null,null,4,4]`\n\n           1\n          / \\\n         2   2\n        / \\\n       3   3\n      / \\\n     4   4\n\n\n返回 `false` 。\n\n\n\n## 思路\n\n有两种解法，分别是自顶向下和自底向上。\n\n自顶向下(暴力法)比较容易想到，首先计算根节点左右子树的深度，然后比较它们的差是否小于2，然后计算根节点的左右子节点的左右子树的深度，以此类推。\n\n自底向上则是在计算节点的深度时就判断其左右子树的深度大小，若大于2则直接返回，效率要比自顶向下高很多。\n\n\n\n## 代码\n\n自顶向下：\n\n```python\nclass Solution:\n    def isBalanced(self, root: TreeNode) -> bool:\n        if not root: return True\n        return abs(self.helper(root.left) - self.helper(root.right)) < 2 and \\\n            self.isBalanced(root.left) and self.isBalanced(root.right)\n\n    def helper(self, node):\n        if not node: return 0\n        return max(self.helper(node.left), self.helper(node.right))+1\n```\n\n\n\n自底向上：\n\n```python\nclass Solution:\n    def isBalanced(self, root: TreeNode) -> bool:\n        return self.helper(root) != -1\n\n    def helper(self, node):\n        if not node: return 0\n        left = self.helper(node.left)\n        if left == -1: return -1\n        right = self.helper(node.right)\n        if right == -1: return -1\n        return max(left, right)+1 if abs(left - right) < 2 else -1\n```\n\n\n\n# 112. 路径总和\n\nhttps://leetcode-cn.com/problems/path-sum/\n\n## 题目描述\n\n给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。\n\n说明: 叶子节点是指没有子节点的节点。\n\n示例: \n给定如下二叉树，以及目标和 `sum = 22`，\n\n              5\n             / \\\n            4   8\n           /   / \\\n          11  13  4\n         /  \\      \\\n        7    2      1\n\n返回 `true`, 因为存在目标和为 22 的根节点到叶子节点的路径 `5->4->11->2`。\n\n\n\n## 思路\n\n递归，前序遍历二叉树，统计路径总和，到叶子节点时判断路径总和与目标和 `sum`  是否相等。\n\n\n\n## 代码\n\n```python\nclass Solution:\n    def hasPathSum(self, root: TreeNode, sum: int) -> bool:\n        if not root: return False\n\n        def helper(node, s):\n            if not node: return False\n            t = node.val + s\n            if not node.left and not node.right:\n                if t == sum:\n                    return True\n                else:\n                    return False\n            else: return helper(node.left, t) or helper(node.right, t)\n\n        return helper(root, 0)\n```\n\n\n\n# 120. 三角形最小路径和\n\nhttps://leetcode-cn.com/problems/triangle/\n\n## 题目描述\n\n给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。\n\n**相邻的结点** 在这里指的是 `下标` 与 `上一层结点下标` 相同或者等于 `上一层结点下标 + 1` 的两个结点。\n\n \n\n例如，给定三角形：\n\n```\n[\n     [2],\n    [3,4],\n   [6,5,7],\n  [4,1,8,3]\n]\n```\n\n自顶向下的最小路径和为 `11`（即，2 + 3 + 5 + 1 = 11）。\n\n \n\n说明：\n\n如果你可以只使用 O(n) 的额外空间（n 为三角形的总行数）来解决这个问题，那么你的算法会很加分。\n\n\n\n## 思路\n\n动态规划：\n\n* `dp[i][j]` 表示第 `i` 行第 `j` 列节点到最底层的最小路径和，自底向上计算。\n* `dp[i][j] = triangle[i][j] + min(dp[i+1][j], dp[i+1][j+1])`.\n\n计算完后 `dp[0][0]` 为最终答案。\n\n\n\n## 代码\n\n```python\nclass Solution:\n    def minimumTotal(self, triangle: List[List[int]]) -> int:\n        dp = triangle[:]\n        for i in range(len(triangle)-2, -1, -1):\n            for j in range(i+1):\n                dp[i][j] = triangle[i][j] + min(dp[i+1][j], dp[i+1][j+1])\n        return dp[0][0]\n```\n\n\n\n# 121. 买卖股票的最佳时机\n\nhttps://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/\n\n## 题目描述\n\n给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。\n\n如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。\n\n注意：你不能在买入股票前卖出股票。\n\n \n\n示例 1:\n\n```\n输入: [7,1,5,3,6,4]\n输出: 5\n解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。\n     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。\n```\n\n示例 2:\n\n```\n输入: [7,6,4,3,1]\n输出: 0\n解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。\n```\n\n\n\n## 思路\n\n因为有时间因素，因此不能简单地用最大值减去最小值。可以用维护两个变量`minp`和`maxp`，其中`minp`记录到当前为止的最小价格，`maxp`记录当前为止的最大差价。通过对数组的一遍扫描，每扫描到一个值就与`minp`作比较、计算当前值与`minp`的差价，若大于`maxp`则更新。\n\n\n\n## 代码\n\n```python\nclass Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        maxp = 0\n        if len(prices) > 0:\n            minp = prices[0]\n            for price in prices:\n                if price < minp:\n                    minp = price\n                if price - minp > maxp:\n                    maxp = price - minp\n        return maxp\n```\n\n\n\n# 152. 乘积最大子数组\n\nhttps://leetcode-cn.com/problems/maximum-product-subarray/\n\n## 题目描述\n\n给你一个整数数组 `nums` ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。\n\n示例 1:\n\n```\n输入: [2,3,-2,4]\n输出: 6\n解释: 子数组 [2,3] 有最大乘积 6。\n```\n\n示例 2:\n\n```\n输入: [-2,0,-1]\n输出: 0\n解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。\n```\n\n\n\n## 思路\n\n可以用动态规划。因为负负得正，所以当前的数为负的话，与前一个数的最小值相乘有可能得到比最大值更大的数。因此需要维护两个变量：当前的最大值和最小值。\n\n动态方程如下：\n$$\n\\begin{aligned}\nmaxDP[i+1] &= \\max(dmax[i+1] \\cdot nums[i], \\  nums[i],\\  dmin[i] \\cdot nums[i])\\\\\nminDP[i+1] &= \\min(dmax[i+1] \\cdot nums[i],\\  nums[i],\\  dmin[i] \\cdot nums[i])\\\\\nDP[i+1] &= \\max(DP[i],\\ maxDP[i+1])\n\\end{aligned}\n$$\n当`nums[i]`为0时，`dmax`和`dmin`都为0，于是需要从`nums[i+1]`重新开始。\n\n\n\n## 代码\n\n```python\nclass Solution:\n    def maxProduct(self, nums: List[int]) -> int:\n        if len(nums)==0:\n            return 0\n        elif len(nums)==1:\n            return nums[0]\n        m = dmax = dmin = nums[0]\n        for i in range(1, len(nums)):\n            tmp = dmax\n            dmax = max(max(dmax*nums[i], nums[i]), dmin*nums[i])\n            dmin = min(min(tmp*nums[i], nums[i]), dmin*nums[i])\n            m = max(dmax, m)\n        return m\n```\n\n\n\n# 167. 两数之和 II - 输入有序数组\n\nhttps://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/\n\n## 题目描述\n\n给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。\n\n函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。\n\n说明:\n\n* 返回的下标值（index1 和 index2）不是从零开始的。\n* 你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。\n\n示例:\n\n```\n输入: bers = [2, 7, 11, 15], target = 9\n输出: [1,2]\n解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。\n```\n\n\n\n## 思路\n\n遍历数组，将访问过的元素的索引存储在哈希表 `d` 中，`d[val]` 存储的是值为 `val` 的元素的索引。\n\n* 每访问到一个元素，计算其与目标数的差值 `k = target - val`；\n* 在 `d` 中查找 `k`，若 `k` 存在则直接返回 `[d[k], val的index]`（后访问的 `index` 肯定比先访问的大）；\n* 若 `k` 不存在则将 `val` 的 `index` 存储在哈希表中。\n\n时间复杂度 $O(N)$，遍历了一次数组；空间复杂度 $O(N)$，用到了一个哈希表存储数组中的元素的索引值。\n\n\n\n## 代码\n\n```python\nclass Solution:\n    def twoSum(self, numbers: List[int], target: int) -> List[int]:\n        n = len(numbers)\n        d = dict()\n        for i in range(n):\n            k = target - numbers[i]\n            if k in d:\n                return [d[k], i+1]\n            d[numbers[i]] = i + 1\n```\n\n\n\n# 169. 多数元素\n\nhttps://leetcode-cn.com/problems/majority-element/\n\n## 题目描述\n\n给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数大于 `⌊ n/2 ⌋` 的元素。\n\n你可以假设数组是非空的，并且给定的数组总是存在多数元素。\n\n \n\n示例 1:\n\n```\n输入: [3,2,3]\n输出: 3\n```\n\n\n示例 2:\n\n```\n输入: [2,2,1,1,1,2,2]\n输出: 2\n```\n\n\n\n## 思路\n\n这里可以使用摩尔投票法：\n\n候选人`k`初始化为数组第一个元素`nums[0]`，票数`cnt`初始化为1。从第二个元素`nums[1]`开始遍历，遇到与候选人相同的数则把票数加1，遇到不同的则把票数减1，如果票数减完之后为0，则更换当前数`nums[i]`为候选人并把票数重设为1。\n\n因为多数元素的个数肯定比其它元素的个数之和多，因此其票数在最后肯定是`>= 1`的。\n\n\n\n## 代码\n\n```python\nclass Solution:\n    def majorityElement(self, nums: List[int]) -> int:\n        if len(nums) < 0:\n            return 0\n        cnt = 1\n        k = nums[0]\n        for i in range(1, len(nums)):\n            if nums[i] == k:\n                cnt += 1\n            else:\n                cnt -= 1\n                if cnt == 0:\n                    cnt = 1\n                    k = nums[i]\n        return k\n```\n\n\n\n# 174. 地下城游戏\n\nhttps://leetcode-cn.com/problems/dungeon-game/\n\n## 题目描述\n\n一些恶魔抓住了公主（**P**）并将她关在了地下城的右下角。地下城是由 M x N 个房间组成的二维网格。我们英勇的骑士（**K**）最初被安置在左上角的房间里，他必须穿过地下城并通过对抗恶魔来拯救公主。\n\n骑士的初始健康点数为一个正整数。如果他的健康点数在某一时刻降至 0 或以下，他会立即死亡。\n\n有些房间由恶魔守卫，因此骑士在进入这些房间时会失去健康点数（若房间里的值为负整数，则表示骑士将损失健康点数）；其他房间要么是空的（房间里的值为 0），要么包含增加骑士健康点数的魔法球（若房间里的值为正整数，则表示骑士将增加健康点数）。\n\n为了尽快到达公主，骑士决定每次只向右或向下移动一步。\n\n \n\n**编写一个函数来计算确保骑士能够拯救到公主所需的最低初始健康点数。**\n\n例如，考虑到如下布局的地下城，如果骑士遵循最佳路径 `右 -> 右 -> 下 -> 下`，则骑士的初始健康点数至少为 **7**。\n\n![](http://images.yingwai.top/picgo/174f1.png)\n\n\n说明:\n\n* 骑士的健康点数没有上限。\n\n* 任何房间都可能对骑士的健康点数造成威胁，也可能增加骑士的健康点数，包括骑士进入的左上角房间以及公主被监禁的右下角房间。\n\n\n\n## 思路\n\n反向动态规划，从右下往左上遍历列表，用 `dp[i][j]` 来表示从房间 `(i, j)` 到达终点的最低初始健康点数，则可以得到\n\n* 此房间到终点的 `dp` 值为：此房间右边和下边的房间的 `dp` 值中较小的那一个，加上此房间需要消耗的生命值 `dungeon[i][j]` (注意初始值不能小于 **1**)；\n* `dp[i][j] = max(min(dp[i+1][j], dp[i][j+1]) - dungeon[i][j], 1)`.\n\n对于最后一行或一列中，除终点以外的元素 `dp[i][j]` 要用到的 `dp[i+1][j]` 和 `dp[i][j+1]`，将它们赋值为无穷大；而对于终点 `dp[m-1][n-1]`，将 `dp[m][n-1]` 和 `dp[m-1][n]` 赋值为 1。\n\n\n\n## 代码\n\n```python\nclass Solution:\n    def calculateMinimumHP(self, dungeon: List[List[int]]) -> int:\n        m, n = len(dungeon), len(dungeon[0])\n        BIG = float(\"inf\")\n        dp = [[BIG] * (n + 1) for _ in range(m + 1)]\n        dp[m-1][n] = dp[m][n-1] = 1\n        for i in range(m-1, -1, -1):\n            for j in range(n-1, -1, -1):\n                dp[i][j] = max(min(dp[i+1][j], dp[i][j+1]) - dungeon[i][j], 1)\n        return dp[0][0]\n```\n\n\n\n# 198. 打家劫舍\n\nhttps://leetcode-cn.com/problems/house-robber/\n\n## 题目描述\n\n你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。\n\n给定一个代表每个房屋存放金额的非负整数数组，计算你不触动警报装置的情况下，一夜之内能够偷窃到的最高金额。\n\n示例 1:\n\n```\n输入: [1,2,3,1]\n输出: 4\n解释: 偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。\n     偷窃到的最高金额 = 1 + 3 = 4 。\n```\n\n示例 2:\n\n```\n输入: [2,7,9,3,1]\n输出: 12\n解释: 偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。\n     偷窃到的最高金额 = 2 + 9 + 1 = 12 。\n```\n\n\n\n## 思路\n\n动态规划，用 $\\rm dp[i]$ 表示前 $\\rm i$ 个房间能偷到的最大值，根据题目条件有以下动态方程：\n$$\n\\rm dp[i] = \\max (dp[i-1], dp[i-2] + nums[i])\n$$\n\n\n## 代码\n\n```python\nclass Solution:\n    def rob(self, nums: List[int]) -> int:\n        if len(nums) <= 0:\n            return 0\n        elif len(nums) == 1:\n            return nums[0]\n        dp = []\n        dp.append(nums[0])\n        dp.append(max(nums[0], nums[1]))\n        for i in range(2, len(nums)):\n            dp.append(max(dp[i-1], dp[i-2] + nums[i]))\n        return dp[len(nums)-1]\n```\n\n\n\n# 257. 二叉树的所有路径\n\nhttps://leetcode-cn.com/problems/binary-tree-paths/\n\n## 题目描述\n\n给定一个二叉树，返回所有从根节点到叶子节点的路径。\n\n说明: 叶子节点是指没有子节点的节点。\n\n示例:\n\n```\n输入:\n\n   1\n /   \\\n2     3\n \\\n  5\n\n输出: [\"1->2->5\", \"1->3\"]\n\n解释: 所有根节点到叶子节点的路径为: 1->2->5, 1->3\n```\n\n\n\n## 思路\n\n递归，用一个字符串 `s` 记录当前的路径，访问到叶子节点时将其加入最终结果的列表 `ans` 中。访问到叶子节点或空节点时返回。\n\n\n\n## 代码\n\n```python\nclass Solution:\n    def binaryTreePaths(self, root: TreeNode) -> List[str]:\n        ans = []\n        s = \"\"\n        self.helper(root, ans, s, 1)\n        return ans\n\n    def helper(self, node, ans, s, depth):\n        if not node:\n            return\n        s = s + \"->\" + str(node.val) if depth > 1 else s + str(node.val)\n        if not node.left and not node.right:\n            ans.append(s)\n            return\n        self.helper(node.left, ans, s, depth+1)\n        self.helper(node.right, ans, s, depth+1)\n        return\n```\n\n\n\n# 287. 寻找重复数\n\nhttps://leetcode-cn.com/problems/find-the-duplicate-number/\n\n## 题目描述\n\n给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。\n\n示例 1:\n\n```\n输入: [1,3,4,2,2]\n输出: 2\n```\n\n\n示例 2:\n\n```\n输入: [3,1,3,4,2]\n输出: 3\n```\n\n说明：\n\n1. 不能更改原数组（假设数组是只读的）。\n2. 只能使用额外的 $O(1)$ 的空间。\n3. 时间复杂度小于 $O(n^2)$ 。\n4. 数组中只有一个重复的数字，但它可能不止重复出现一次。\n\n\n\n## 思路\n\n由于题目限制了空间，所以打表法之类的方法就无法使用。可以用二分法：\n\n对于给定题目条件的数组 `nums`，设`mid`为 1 到 n 的中位数。扫描数组，若数组中小于等于`mid`的数的数量严格大于`mid`，则可以确定重复的数就在 1 到`mid`之间，反之则在`mid`到 n 之间。\n\n\n\n## 代码\n\n```python\nclass Solution:\n    def findDuplicate(self, nums: List[int]) -> int:\n        size = len(nums)\n        left = 1\n        right = size - 1\n        while left < right:\n            cnt = 0\n            mid = left + (right - left) // 2\n            for num in nums:\n                if num <= mid:\n                    cnt += 1\n            if cnt > mid:\n                right = mid\n            else:\n                left = mid + 1\n        return left\n```\n\n\n\n# 300. 最长上升子序列\n\nhttps://leetcode-cn.com/problems/longest-increasing-subsequence/\n\n## 题目描述\n\n给定一个无序的整数数组，找到其中最长上升子序列的长度。\n\n示例:\n\n```\n输入: [10,9,2,5,3,7,101,18]\n输出: 4 \n解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。\n```\n\n\n说明:\n\n* 可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。\n* 你算法的时间复杂度应该为 $O(n^2)$。\n\n进阶: 你能将算法的时间复杂度降低到 $O(n \\log{n})$ 吗?\n\n\n\n## 思路\n\n$O(n \\log{n})$ 还没想到，这里介绍 $O(n^2)$ 的动态规划方法：\n\n用 $\\rm dp[i]$ 表示以第 $\\rm i$ 个元素结尾的最长上升子序列的长度，则可以得到以下的状态转移方程：\n$$\n\\rm dp[i] = \\max(dp[i], dp[j] + 1),\\ nums[j] < nums[i],\\  j < i.\n$$\n扫描完整个数组后，$\\rm dp$ 数组中的最大值即为结果。\n\n\n\n## 代码\n\n```python\nclass Solution:\n    def lengthOfLIS(self, nums: List[int]) -> int:\n        if len(nums) <= 0:\n            return 0\n        dp = []     # 存以第i个元素结尾的最长上升子序列的长度\n        for i in range(len(nums)):\n            dp.append(1)\n            for j in range(i):\n                if nums[j] < nums[i]:\n                    dp[i] = max(dp[i], dp[j]+1)\n        return max(dp)\n```\n\n\n\n# 309. 最佳买卖股票时机含冷冻期\n\nhttps://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/\n\n## 题目描述\n\n给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。\n\n设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:\n\n* 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。\n* 卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。\n\n示例:\n\n```\n输入: [1,2,3,0,2]\n输出: 3 \n解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]\n```\n\n\n\n## 思路\n\n动态规划，用两个数组来存储状态：\n\n1. `hold[i]` 表示在第 `i` 天结束时持有股票、此时的最大收益，有两种情况：\n   * 昨天持有股票，今天休息；\n   * 前天卖出，今天买入；\n   * `hold[i] = max(hold[i-1], unhold[i-2] - prices[i])`。\n2. `unhold[i]` 表示在第 `i` 天结束时未持有股票、此时的最大收益，也有两种情况：\n   * 昨天也没持有股票，今天休息；\n   * 昨天持有，今天卖出；\n   * `unhold[i] = max(unhold[i-1], hold[i-1] + prices[i])`。\n\n最终结果是 `unhold[n-1]`。\n\n初始情况：\n\n* 第 `0` 天持有股票即在当天买入股票，`hold[0] = -prices[0]`；\n* 第 `1` 天持有股票有前一天买入或是当天买入两种情况，`hold[1] = max(-prices[0], -prices[1])`；\n* 第 `0` 天未持有股票即当天休息，`unhold[0] = 0`。\n\n\n\n## 代码\n\n```python\nclass Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        if len(prices) < 2: return 0\n        hold, unhold = [], []\n        hold.append(-prices[0])\n        unhold.append(0)\n        for i in range(1, len(prices)):\n            if i == 1:\n                hold.append(max(-prices[0], -prices[1]))\n            else:\n                hold.append(max(hold[i-1], unhold[i-2] - prices[i]))\n            unhold.append(max(unhold[i-1], hold[i-1] + prices[i]))        \n        return unhold[len(prices) - 1]\n```\n\n\n\n# 312. 戳气球\n\nhttps://leetcode-cn.com/problems/burst-balloons/\n\n## 题目描述\n\n有 `n` 个气球，编号为 `0` 到 `n-1`，每个气球上都标有一个数字，这些数字存在数组 `nums` 中。\n\n现在要求你戳破所有的气球。如果你戳破气球 `i` ，就可以获得 `nums[left] * nums[i] * nums[right]` 个硬币。 这里的 `left` 和 `right` 代表和 `i` 相邻的两个气球的序号。注意当你戳破了气球 `i` 后，气球 `left` 和气球 `right` 就变成了相邻的气球。\n\n求所能获得硬币的最大数量。\n\n说明:\n\n* 你可以假设 `nums[-1] = nums[n] = 1`，但注意它们不是真实存在的所以并不能被戳破。\n* 0 ≤ `n` ≤ 500, 0 ≤ `nums[i]` ≤ 100\n\n示例:\n\n```\n输入: [3,1,5,8]\n输出: 167 \n解释: nums = [3,1,5,8] --> [3,5,8] -->   [3,8]   -->  [8]  --> []\n     coins =  3*1*5      +  3*5*8    +  1*3*8      + 1*8*1   = 167\n```\n\n\n\n## 思路\n\n动态规划，用 `dp[i][j]` 表示戳破气球 `i` 和气球 `j` 之间所有气球所能获得硬币的最大数量：\n\n* 当气球 `i` 和 `j` 相邻时，`dp[i][j]` 为0；\n* 令 `k` 为气球 `i` 和气球 `j` 之间最后戳破的气球序号，对于每个 `i` 和 `j`（`i` 小于 `j`），遍历所有的 `k`，取其中的最大值赋值给 `dp[i][j]`，可得以下状态转移方程：\n* `dp[i][j] = max(dp[i][j], dp[i][k] + dp[k][j] + nums[i]*nums[k]*nums[j])`.\n\n注意要令 `nums` 的两个边界赋值为1。\n\n时间复杂度为 $O(N^3)$。\n\n\n\n## 代码\n\n```python\nclass Solution:\n    def maxCoins(self, nums: List[int]) -> int:\n        points = [1] + nums + [1]\n        n = len(nums)\n        dp = [[0] * (n+2) for _ in range(n+2)]\n        for i in range(n, -1, -1):\n            for j in range(i+1, n+2):\n                for k in range(i+1, j):\n                    dp[i][j] = max(dp[i][j], dp[i][k] + dp[k][j] + points[k]*points[i]*points[j])\n        return dp[0][-1]\n```\n\n\n\n# 315. 计算右侧小于当前元素的个数\n\nhttps://leetcode-cn.com/problems/count-of-smaller-numbers-after-self/\n\n## 题目描述\n\n给定一个整数数组 nums，按要求返回一个新数组 counts。数组 counts 有该性质： `counts[i]` 的值是  `nums[i]` 右侧小于 `nums[i]` 的元素的数量。\n\n示例:\n\n```\n输入: [5,2,6,1]\n输出: [2,1,1,0] \n解释:\n5 的右侧有 2 个更小的元素 (2 和 1).\n2 的右侧仅有 1 个更小的元素 (1).\n6 的右侧有 1 个更小的元素 (1).\n1 的右侧有 0 个更小的元素.\n```\n\n\n\n## 思路\n\n二分查找，从后向前遍历 `nums`，使用一个辅助数组 `sorted_nums` 保存 `nums[i]` 右侧的元素的升序排列，`counts[i]` 的值即为 `nums[i]` 插入 `sorted_nums` 后的索引：\n\n1. 在 `sorted_nums` 中查找第一个小于等于 `nums[i] ` 的元素的索引，此索引即为`nums` 中 `nums[i]` 右侧小于该元素的元素数量；\n2. 将其添加到 `ans` 数组中；\n3. 将 `nums[i]` 插入到 `sorted_nums` 中的对应位置，继续遍历，直到遍历完整个数组。\n\n最后 `ans` 的倒序即为答案。\n\n\n\n## 代码\n\n```python\nclass Solution:\n    def countSmaller(self, nums: List[int]) -> List[int]:\n        sorted_nums, ans = [], []\n        for i in reversed(range(len(nums))): \n            t = self.findIndex(nums[i], sorted_nums)\n            sorted_nums.insert(t, nums[i])\n            ans.append(t)\n        return ans[::-1]\n    \n    def findIndex(self, n, sorted_nums):\n        if len(sorted_nums) == 0:\n            return 0\n        left, right = 0, len(sorted_nums)-1\n        mid = 0\n        while left < right:\n            mid = left + right >> 1\n            if n > sorted_nums[mid]:\n                left = mid + 1\n            else:\n                right = mid\n        if n > sorted_nums[left]:\n            left += 1\n        return left\n```\n\n\n\n# 322. 零钱兑换\n\nhttps://leetcode-cn.com/problems/coin-change/\n\n## 题目描述\n\n给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 `-1`。\n\n \n\n示例 1:\n\n```\n输入: coins = [1, 2, 5], amount = 11\n输出: 3 \n解释: 11 = 5 + 5 + 1\n```\n\n示例 2:\n\n```\n输入: coins = [2], amount = 3\n输出: -1\n```\n\n\n说明:\n你可以认为每种硬币的数量是无限的。\n\n\n\n## 思路\n\n首先想到了贪心，但会复杂一点，迟点再研究一下，这里用了动态规划。根据题意，要求 `amount` 的最少硬币数，可以先对 `coins` 中的每一个面额 `coin` 进行遍历，求子问题 $dp(amount-coin)$ 的最小值。\n\n可以列出状态转移方程\n$$\ndp(n) = \\left\\{ \\begin{array}{lcl}\n -1, & n < 0\\\\\n 0, & n = 0\\\\\n \\min\\{dp(n-coin)+1|coin \\in coins\\}, & n > 0\n\\end{array}\\right.\n$$\n\n\n\n## 代码\n\n```python\nclass Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        memo = dict()\n        \n        def dp(n):\n            if n in memo:\n                return memo[n]\n            if n == 0:\n                return 0\n            if n < 0:\n                return -1\n            ans = float(\"inf\")\n            for coin in coins:\n                subproblem = dp(n - coin)\n                if subproblem == -1:\n                    continue\n                ans = min(ans, subproblem + 1)\n            memo[n] = ans if ans!=float(inf) else -1\n            return memo[n]\n        \n        return dp(amount)\n```\n\n\n\n# 350. 两个数组的交集 II\n\nhttps://leetcode-cn.com/problems/intersection-of-two-arrays-ii/\n\n## 题目描述\n\n给定两个数组，编写一个函数来计算它们的交集。\n\n示例 1:\n\n```\n输入: nums1 = [1,2,2,1], nums2 = [2,2]\n输出: [2,2]\n```\n\n示例 2:\n\n```\n输入: nums1 = [4,9,5], nums2 = [9,4,9,8,4]\n输出: [4,9]\n```\n\n说明：\n\n* 输出结果中每个元素出现的次数，应与元素在两个数组中出现的次数一致。\n* 我们可以不考虑输出结果的顺序。\n\n进阶:\n\n* 如果给定的数组已经排好序呢？你将如何优化你的算法？\n* 如果 nums1 的大小比 nums2 小很多，哪种方法更优？\n* 如果 nums2 的元素存储在磁盘上，磁盘内存是有限的，并且你不能一次加载所有的元素到内存中，你该怎么办？\n\n\n\n## 思路\n\n两种方法：\n\n* 遍历 `nums1`，用一个字典存储 `d` 其中元素的个数，然后遍历 `nums2` 若扫描到的元素 `nums2[i]` 在字典中存在且 `d[nums2[i]] > 0`，则将该元素加入 `ans` 并将 `d[nums2[i]]` 自减 1。\n* 先对两个数组进行排序，然后用两个指针 `i, j` 分别指向排序完的数组的头元素。从头元素开始扫描，当 `nums1[i] > nums2[j]` 时 `j` 往后移，反之 `i` 往后移，两个元素相等时将其加入 `ans`，当遍历完其中一个数组后结束循环。\n\n\n\n## 代码\n\n哈希表：\n\n```python\nclass Solution:\n    def intersect(self, nums1: List[int], nums2: List[int]) -> List[int]:\n        d = dict()\n        ans = []\n        for num in nums1:\n            if num in d:\n                d[num] += 1\n            else:\n                d[num] = 1\n        for num in nums2:\n            if num in d and d[num] > 0:\n                ans.append(num)\n                d[num] -= 1\n        return ans\n```\n\n\n\n排序方法：\n\n```python\nclass Solution:\n    def intersect(self, nums1: List[int], nums2: List[int]) -> List[int]:\n        nums1.sort()\n        nums2.sort()\n        i = j = 0\n        ans = []\n        while i < len(nums1) and j < len(nums2):\n            if nums1[i] == nums2[j]:\n                ans.append(nums1[i])\n                i += 1\n                j += 1\n            elif nums1[i] > nums2[j]:\n                j += 1\n            else:\n                i += 1\n        return ans\n```\n\n\n\n# 394. 字符串解码\n\nhttps://leetcode-cn.com/problems/decode-string/\n\n## 题目描述\n\n给定一个经过编码的字符串，返回它解码后的字符串。\n\n编码规则为: `k[encoded_string]`，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。\n\n你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。\n\n此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 `3a` 或 `2[4]` 的输入。\n\n示例:\n\n```\ns = \"3[a]2[bc]\", 返回 \"aaabcbc\".\ns = \"3[a2[c]]\", 返回 \"accaccacc\".\ns = \"2[abc]3[cd]ef\", 返回 \"abcabccdcdcdef\".\n```\n\n\n\n## 思路\n\n这里可以使用栈，对字符串按顺序扫描：\n\n1. 将右括号以外的字符全部入栈，直到扫描到右括号；\n2. 扫描到右括号则开始退栈，保存在一个字符串`ss`中，直到遇到左括号；\n3. 根据题目的条件，在左括号前面的一定是数字，此时就可以统计当前字符串出现的次数`t`，把`ss`复制`t`次重新入栈；\n4. 最后把栈中所有元素拼接在一起即可。\n\n\n\n## 代码\n\n```python\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        if len(s) <= 0:\n            return \"\"\n        ans = \"\"\n        tmps = []   # 栈\n        i = 1\n        tmps.append(s[0])\n        ss, t = \"\", \"\"\t# 分别存当前字符串和当前的次数\n        while i < len(s):\n            w = s[i]\n            if w == ']':\t# 扫描到右括号则开始退栈，直到遇到左括号\n                while tmps[-1] != '[':\n                    ss = tmps.pop() + ss\n                tmps.pop()      # 将左括号退栈\n                while len(tmps) > 0 and tmps[-1].isdigit():\t\t# 统计次数\n                    t = tmps.pop() + t\n                tmps.append(ss*int(t))\n                ss, t = \"\", \"\"\n            else:\n                tmps.append(w)\n            i += 1\n        for tmp in tmps:\n            ans = ans + tmp\n        return ans\n```\n\n\n\n# 409. 最长回文串\n\nhttps://leetcode-cn.com/problems/longest-palindrome/\n\n## 题目描述\n\n给定一个包含大写字母和小写字母的字符串，找到通过这些字母构造成的最长的回文串。\n\n在构造过程中，请注意区分大小写。比如 `\"Aa\"` 不能当做一个回文字符串。\n\n注意:\n假设字符串的长度不会超过 1010。\n\n示例 1:\n\n```\n输入:\n\"abccccdd\"\n\n输出:\n7\n\n解释:\n我们可以构造的最长的回文串是\"dccaccd\", 它的长度是 7。\n```\n\n\n\n## 思路\n\n由题意可知回文串中奇数的字母只能出现在中间，即只能选取一个来构造回文串。因此可以先统计每个字母在字符串中出现的个数存在字典中，然后遍历字典，将数量为偶数的直接累加；数量为奇数的则判断前面是否已出现了奇数，若不是则直接累加，若是则只选取偶数数量的当前字母，即把当前数量 $-1$ 再累加。\n\n\n\n## 代码\n\n```python\nclass Solution:\n    def longestPalindrome(self, s: str) -> int:\n        d = dict()\n        ans = 0\n        flag = 0    # 判断前面有无加奇数\n        for w in s:\n            if w in d:\n                d[w] += 1\n            else:\n                d[w] = 1\n        for value in d.values():\n            if value%2==0:\n                ans += value\n            elif flag:\n                ans += value - 1\n            else:\n                ans += value\n                flag = 1\n        return ans\n```\n\n\n\n# 563. 二叉树的坡度\n\nhttps://leetcode-cn.com/problems/binary-tree-tilt/\n\n## 题目描述\n\n给定一个二叉树，计算整个树的坡度。\n\n一个树的节点的坡度定义即为，该节点左子树的结点之和和右子树结点之和的差的绝对值。空结点的的坡度是0。\n\n整个树的坡度就是其所有节点的坡度之和。\n\n \n\n示例：\n\n```\n输入：\n         1\n       /   \\\n      2     3\n输出：1\n解释：\n结点 2 的坡度: 0\n结点 3 的坡度: 0\n结点 1 的坡度: |2-3| = 1\n树的坡度 : 0 + 0 + 1 = 1\n```\n\n\n\n\n提示：\n\n任何子树的结点的和不会超过 32 位整数的范围。\n坡度的值不会超过 32 位整数的范围。\n\n\n\n## 思路\n\n递归，后序遍历二叉树，用一个变量 `tilt` 存储累计坡度，访问节点时更新 `tilt = tilt + |(左子树节点之和 - 右子树节点之和)|`，然后返回以当前节点为根节点的二叉树节点之和。\n\n递归边界为访问到空节点，返回 0。\n\n\n\n## 代码\n\n```python\nclass Solution:\n    def findTilt(self, root: TreeNode) -> int:\n        tilt = [0]\n        self.recur(root, tilt)\n        return tilt[0]\n\n    def recur(self, node, tilt):\n        if not node:\n            return 0\n        left = self.recur(node.left, tilt)\n        right = self.recur(node.right, tilt)\n        tilt[0] += abs(left - right)\n        return left + right + node.val\n```\n\n\n\n# 623. 在二叉树中增加一行\n\nhttps://leetcode-cn.com/problems/add-one-row-to-tree/\n\n## 题目描述\n\n给定一个二叉树，根节点为第1层，深度为 1。在其第 `d` 层追加一行值为 `v` 的节点。\n\n添加规则：给定一个深度值 `d` （正整数），针对深度为 `d-1` 层的每一非空节点 `N`，为 `N` 创建两个值为 `v` 的左子树和右子树。\n\n将 `N` 原先的左子树，连接为新节点 `v` 的左子树；将 `N` 原先的右子树，连接为新节点 `v` 的右子树。\n\n如果 `d` 的值为 1，深度 d - 1 不存在，则创建一个新的根节点 `v`，原先的整棵树将作为 `v` 的左子树。\n\n示例 1:\n\n```\n输入: \n二叉树如下所示:\n       4\n     /   \\\n    2     6\n   / \\   / \n  3   1 5   \n\nv = 1\n\nd = 2\n\n输出: \n       4\n      / \\\n     1   1\n    /     \\\n   2       6\n  / \\     / \n 3   1   5  \n```\n\n示例 2:\n\n```\n输入: \n二叉树如下所示:\n      4\n     /   \n    2    \n   / \\   \n  3   1    \n\nv = 1\n\nd = 3\n\n输出: \n      4\n     /   \n    2\n   / \\    \n  1   1\n /     \\  \n3       1\n```\n\n\n注意:\n\n输入的深度值 d 的范围是：[1，二叉树最大深度 + 1]。\n输入的二叉树至少有一个节点。\n\n\n\n## 思路\n\n深度优先搜索(递归)，在访问到深度为 `d-1` 的节点则在它们下面增加子节点然后返回。\n\n注意 `d = 1` 的特殊情况和访问到空节点的情况。\n\n\n\n## 代码\n\n```python\nclass Solution:\n    def addOneRow(self, root: TreeNode, v: int, d: int) -> TreeNode:\n        if d == 1:\n            newnode = TreeNode(v)\n            newnode.left = root\n            root = newnode\n        else:\n            self.helper(root, d, v, 1)\n        return root\n    \n    def helper(self, node, d, v, depth):\n        if not node: return\n        if depth == d - 1:\n            lnode, rnode = node.left, node.right\n            n1, n2 = TreeNode(v), TreeNode(v)\n            n1.left, n2.right = lnode, rnode\n            node.left, node.right = n1, n2\n            return\n        self.helper(node.left, d, v, depth + 1)\n        self.helper(node.right, d, v, depth + 1)\n        return\n```\n\n\n\n# 637. 二叉树的层平均值\n\nhttps://leetcode-cn.com/problems/average-of-levels-in-binary-tree/\n\n## 题目描述\n\n给定一个非空二叉树, 返回一个由每层节点平均值组成的数组。\n\n \n\n示例 1：\n\n```\n输入：\n    3\n   / \\\n  9  20\n    /  \\\n   15   7\n输出：[3, 14.5, 11]\n解释：\n第 0 层的平均值是 3 ,  第1层是 14.5 , 第2层是 11 。因此返回 [3, 14.5, 11] 。\n```\n\n\n\n提示：\n\n节点值的范围在32位有符号整数范围内。\n\n\n\n## 思路\n\nBFS，套模板，逐层计算均值即可。\n\n\n\n## 代码\n\n```python\nclass Solution:\n    def averageOfLevels(self, root: TreeNode) -> List[float]:\n        queue = collections.deque()\n        queue.append(root)\n        ans = []\n        if root:\n            while queue:\n                size = len(queue)\n                s = 0\n                for _ in range(size):\n                    node = queue.popleft()\n                    s += node.val\n                    if node.left:\n                        queue.append(node.left)\n                    if node.right:\n                        queue.append(node.right)\n                if size:\n                    ans.append(s/size)\n        return ans\n```\n\n\n\n# 785. 判断二分图\n\nhttps://leetcode-cn.com/problems/is-graph-bipartite/\n\n## 题目描述\n\n给定一个无向图 `graph`，当这个图为二分图时返回 `true`。\n\n如果我们能将一个图的节点集合分割成两个独立的子集A和B，并使图中的每一条边的两个节点一个来自A集合，一个来自B集合，我们就将这个图称为二分图。\n\ngraph将会以邻接表方式给出，`graph[i]` 表示图中与节点 `i` 相连的所有节点。每个节点都是一个在 `0` 到 `graph.length-1` 之间的整数。这图中没有自环和平行边： `graph[i]` 中不存在 `i`，并且 `graph[i]` 中没有重复的值。\n\n```\n示例 1:\n输入: [[1,3], [0,2], [1,3], [0,2]]\n输出: true\n解释: \n无向图如下:\n0----1\n|    |\n|    |\n3----2\n我们可以将节点分成两组: {0, 2} 和 {1, 3}。\n```\n\n```\n示例 2:\n输入: [[1,2,3], [0,2], [0,1,3], [0,2]]\n输出: false\n解释: \n无向图如下:\n0----1\n| \\  |\n|  \\ |\n3----2\n我们不能将节点分割成两个独立的子集。\n```\n\n\n\n注意:\n\n* `graph` 的长度范围为 `[1, 100]`。\n* `graph[i]` 中的元素的范围为 `[0, graph.length - 1]`。\n* `graph[i]` 不会包含 `i` 或者有重复的值。\n* 图是无向的: 如果 `j` 在 `graph[i]` 里边, 那么 `i` 也会在 `graph[j]` 里边。\n\n\n\n## 思路\n\nBFS，遍历所有节点，用 `visited` 数组标记节点是否已经被访问（初始值为 `0`）：\n\n* 对当前未访问的节点 `i`，\n  1. 将 `visited[i]` 标记为 `1`；\n  2. 把 `i` 的相邻节点 `j` 标记为 `-1`，然后继续对 `j` 的相邻节点标记为 `-visited[j]`，直到所有连接在一起的节点都被访问；\n  3. 如果上一步在标记时，`i` 的某个相邻节点 `j` 的标记值 `visited[j] = visited[i]`，则说明无法将图中节点分割，返回 `false`。\n\n\n\n## 代码\n\n```python\nclass Solution:\n    def isBipartite(self, graph: List[List[int]]) -> bool:\n        visited = [0] * len(graph)\n        queue = collections.deque()\n        for i in range(len(graph)):\n            if visited[i] != 0:\n                continue              \n            visited[i] = 1\n            queue.append(i)\n            while queue:\n                cur = queue.popleft()\n                for node in graph[cur]:\n                    if visited[node] == 0:\n                        visited[node] = -visited[cur]\n                        queue.append(node)\n                    elif visited[node] == visited[cur]:\n                        return False\n        return True\n```\n\n\n\n# 974. 和可被 K 整除的子数组\n\nhttps://leetcode-cn.com/problems/subarray-sums-divisible-by-k/\n\n## 题目描述\n\n给定一个整数数组 A，返回其中元素之和可被 K 整除的（连续、非空）子数组的数目。\n\n \n\n示例：\n\n```\n输入：A = [4,5,0,-2,-3,1], K = 5\n输出：7\n解释：\n有 7 个子数组满足其元素之和可被 K = 5 整除：\n[4, 5, 0, -2, -3, 1], [5], [5, 0], [5, 0, -2, -3], [0], [0, -2, -3], [-2, -3]\n```\n\n\n\n\n提示：\n\n1. `1 <= A.length <= 30000`\n2. `-10000 <= A[i] <= 10000`\n3. `2 <= K <= 10000`\n\n\n\n## 思路\n\n一个前缀和的问题。设 $\\rm presum[i]$是数组 $\\rm A$ 第 $\\rm i$ 个元素的前缀和，那么 $\\rm A[i]$ 就可以表示为 $\\rm presum[i] - presum[i-1]$，子数组 $\\rm A[k]$ 到 $\\rm A[i]$ 的和就是 $\\rm presum[i] - presum[k-1]$。\n\n题目要求的是满足 $\\rm presum[i] - presum[k-1] \\bmod K = 0$ 的子数组 $\\rm [A[k],...,A[i]]$ 的个数，根据同余定理，可以把问题转换为求同余的 $\\rm presum[i]$ 的个数。每扫描到数组中的一个数，就检查哈希表中有没有同余的数组，若有则计算同余的数量，若无把当前模 $\\rm K$ 的余数保存在哈希表中，一次遍历即可解决问题。\n\n\n\n## 代码\n\n```python\nclass Solution:\n    def subarraysDivByK(self, A: List[int], K: int) -> int:\n        if len(A)==0 or K==0:\n            return 0\n        d = {0:1}\n        presum, cnt = 0, 0\n        for a in A:\n            presum += a\n            m = presum % K\n            s = d.get(m, 0)\n            cnt += s\n            d[m] = s + 1\n        return cnt\n```\n\n\n\n# 994. 腐烂的橘子\n\nhttps://leetcode-cn.com/problems/rotting-oranges/\n\n## 题目描述\n\n在给定的网格中，每个单元格可以有以下三个值之一：\n\n值 `0` 代表空单元格；\n值 `1` 代表新鲜橘子；\n值 `2` 代表腐烂的橘子。\n每分钟，任何与腐烂的橘子（在 4 个正方向上）相邻的新鲜橘子都会腐烂。\n\n返回直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 `-1`。\n\n \n\n示例 1：\n\n![](http://images.yingwai.top/picgo/oranges.png)\n\n```\n输入：[[2,1,1],[1,1,0],[0,1,1]]\n输出：4\n```\n\n\n\n示例 2：\n\n```\n输入：[[2,1,1],[0,1,1],[1,0,1]]\n输出：-1\n解释：左下角的橘子（第 2 行， 第 0 列）永远不会腐烂，因为腐烂只会发生在 4 个正向上。\n```\n\n示例 3：\n\n```\n输入：[[0,2]]\n输出：0\n解释：因为 0 分钟时已经没有新鲜橘子了，所以答案就是 0 。\n```\n\n\n提示：\n\n1. `1 <= grid.length <= 10`\n2. `1 <= grid[0].length <= 10`\n3. `grid[i][j]`仅为`0`、`1`或`2`\n\n\n\n## 思路\n\n广度优先搜索，一圈一圈往外腐蚀。\n\n\n\n## 代码\n\n```python\nclass Solution:\n    def orangesRotting(self, grid: List[List[int]]) -> int:\n        dx = [-1, 1, 0, 0]\n        dy = [0, 0, -1, 1]\n        rotlist = list()    # 腐烂橘子的队列\n        minute = 0\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j] == 2:\n                    rotlist.append([i, j])\n\n        while rotlist:  # BFS循环\n            newrotlist = list()\n            for rotorange in rotlist:   # 当前腐烂橘子的坐标\n                x0 = rotorange[0]\n                y0 = rotorange[1]\n\n                for i in range(4):  # 四个相邻方向的橘子腐烂\n                    x = x0 + dx[i]\n                    y = y0 + dy[i]\n                    if 0<=x<len(grid) and 0<=y<len(grid[0]) and grid[x][y]==1:\n                        grid[x][y] = 2\n                        newrotlist.append([x, y])\n\n            if not newrotlist:\n                break\n\n            minute += 1\n            rotlist = newrotlist[:]     # 更新腐烂队列\n\n        for row in grid:\n                for i in row:\n                    if i == 1:  # 还有新鲜的\n                        return -1\n\n        return minute\n```\n\n\n\n# 1305. 两棵二叉搜索树中的所有元素\n\nhttps://leetcode-cn.com/problems/all-elements-in-two-binary-search-trees/\n\n## 题目描述\n\n给你 root1 和 root2 这两棵二叉搜索树。\n\n请你返回一个列表，其中包含 两棵树 中的所有整数并按 升序 排序。\n\n \n\n示例 1：\n\n![](http://images.yingwai.top/picgo/lc1305f1.png)\n\n```\n输入：root1 = [2,1,4], root2 = [1,0,3]\n输出：[0,1,1,2,3,4]\n```\n\n示例 2：\n\n```\n输入：root1 = [0,-10,10], root2 = [5,1,7,0,2]\n输出：[-10,0,0,1,2,5,7,10]\n```\n\n示例 3：\n\n```\n输入：root1 = [], root2 = [5,1,7,0,2]\n输出：[0,1,2,5,7]\n```\n\n示例 4：\n\n```\n输入：root1 = [0,-10,10], root2 = []\n输出：[-10,0,10]\n```\n\n示例 5：\n\n![](http://images.yingwai.top/picgo/lc1305f2.png)\n\n```\n输入：root1 = [1,null,8], root2 = [8,1]\n输出：[1,1,8,8]\n```\n\n\n\n\n提示：\n\n* 每棵树最多有 `5000` 个节点。\n* 每个节点的值在 `[-10^5, 10^5]` 之间。\n\n\n\n## 思路\n\n利用二叉搜索树性质，中序遍历得到每棵树的节点值的升序排列，然后再使用归并排序得到最终的结果数组。\n\n* 时间复杂度 $O(M + N)$，中序遍历和归并排序都是 $O(M + N)$，其中 $M,N$ 分别为两棵树的节点个数；\n* 空间复杂度 $O(M+N)$，用到两个额外的数组来存储每棵树的升序排列。\n\n\n\n## 代码\n\n```python\nclass Solution:\n    def getAllElements(self, root1: TreeNode, root2: TreeNode) -> List[int]:\n        t1, t2 = [], []\n        ans = []\n        self.helper(root1, t1)\n        self.helper(root2, t2)\n        i, j = 0, 0\n        while i < len(t1) or j < len(t2):\n            if i < len(t1) and (j == len(t2) or t1[i] < t2[j]):\n                ans.append(t1[i])\n                i += 1\n            else:\n                ans.append(t2[j])\n                j += 1\n        return ans\n        \n    def helper(self, node, t):\n        if not node: return\n        self.helper(node.left, t)\n        t.append(node.val)\n        self.helper(node.right, t)\n        return\n```\n\n\n\n# 面试题 16.11. 跳水板\n\nhttps://leetcode-cn.com/problems/diving-board-lcci/\n\n## 题目描述\n\n你正在使用一堆木板建造跳水板。有两种类型的木板，其中长度较短的木板长度为`shorter`，长度较长的木板长度为`longer`。你必须正好使用`k`块木板。编写一个方法，生成跳水板所有可能的长度。\n\n返回的长度需要从小到大排列。\n\n示例：\n\n```\n输入：\nshorter = 1\nlonger = 2\nk = 3\n输出： {3,4,5,6}\n```\n\n提示：\n\n* 0 < shorter <= longer\n* 0 <= k <= 100000\n\n\n\n## 思路\n\n因为每次都必须要正好使用 `k` 块木板，所以有以下公式\n$$\nans[i] = shorter\\times i + longer \\times (k-i)\n$$\n其中 $0 \\leq i \\leq k$。\n\n在 $longer > shorter$ 的情况下，为什么每种组合下建造的跳水板长度都是不一样的？考虑以下两种不同的组合：第一种组合，有 $i$ 块短木板，则跳水板的长度是 $shorter \\times i + longer \\times (k−i)$；第二种组合，有 $j$ 块短木板，则跳水板的长度是 $shorter \\times j+longer \\times (k−j)$。其中 $0 \\leq i<j \\leq k$。则两种不同的组合下的跳水板长度之差为：\n$$\n(shorter \\times j+longer \\times (k−j)) - (shorter \\times i + longer \\times (k−i)) = (longer - shorter) \\times (i - j)\n$$\n因为 $longer > shorter$ 且 $i<j$，因此上式 $<0$。\n\n然后要考虑到极端情况：\n\n* $k = 0$：直接输出空列表。\n* $longer = shorter$：输出列表中只有一个元素 $ans = [shorter(longer) \\times k]$。\n\n\n\n## 代码\n\n```python\nclass Solution:\n    def divingBoard(self, shorter: int, longer: int, k: int) -> List[int]:\n        ans = []\n        if k > 0:\n            s, l = k, 0\n            if shorter == longer:\n                ans.append(shorter*s)\n            else:\n                while l <= k:\n                    ans.append(shorter*s + longer*l)\n                    s -= 1\n                    l += 1\n        return ans\n```\n\n\n\n# 面试题 17. 12. BiNode\n\nhttps://leetcode-cn.com/problems/binode-lcci/\n\n## 题目描述\n\n二叉树数据结构 `TreeNode` 可用来表示单向链表（其中 `left` 置空，`right` 为下一个链表节点）。实现一个方法，把二叉搜索树转换为单向链表，要求依然符合二叉搜索树的性质，转换操作应是原址的，也就是在原始的二叉搜索树上直接修改。\n\n返回转换后的单向链表的头节点。\n\n注意：本题相对原题稍作改动\n\n \n\n示例：\n\n```\n输入： [4,2,5,1,3,null,6,0]\n输出： [0,null,1,null,2,null,3,null,4,null,5,null,6]\n```\n\n提示：\n\n* 节点数量不会超过 100000。\n\n\n\n## 思路\n\n中序遍历，用 `pre` 记录上一个处理的节点，访问到一个新的节点 `p` 时，将 `pre.right` 指向 `p` 并把 `p.left` 置空。\n\n注意要将第一个处理的节点作为根节点。\n\n\n\n## 代码\n\n```python\nclass Solution:\n    def convertBiNode(self, root: TreeNode) -> TreeNode:\n        if not root:\n            return\n        s = []\n        p, pre = root, None\n        while s or p:\n            while p:\n                s.append(p)\n                p = p.left\n            p = s.pop()\n            if not pre:\n                root = p\n                root.left = None\n            else:\n                pre.right = p\n                p.left = None\n            pre = p\n            p = p.right\n        return root\n```\n\n\n\n# 面试题 17.13. 恢复空格\n\nhttps://leetcode-cn.com/problems/re-space-lcci/\n\n## 题目描述\n\n哦，不！你不小心把一个长篇文章中的空格、标点都删掉了，并且大写也弄成了小写。像句子`\"I reset the computer. It still didn’t boot!\"`已经变成了`\"iresetthecomputeritstilldidntboot\"`。在处理标点符号和大小写之前，你得先把它断成词语。当然了，你有一本厚厚的词典`dictionary`，不过，有些词没在词典里。假设文章用`sentence`表示，设计一个算法，把文章断开，要求未识别的字符最少，返回未识别的字符数。\n\n注意：本题相对原题稍作改动，只需返回未识别的字符数\n\n \n\n示例：\n\n```\n输入：\ndictionary = [\"looked\",\"just\",\"like\",\"her\",\"brother\"]\nsentence = \"jesslookedjustliketimherbrother\"\n输出： 7\n解释： 断句后为\"jess looked just like tim her brother\"，共7个未识别字符。\n```\n\n提示：\n\n* `0 <= len(sentence) <= 1000`\n* `dictionary`中总字符数不超过 `150000`。\n* 你可以认为`dictionary`和`sentence`中只包含小写字母。\n\n\n\n## 思路\n\n动态规划，用 $dp[i]$ 表示`sentence`中以第 $index$ 个字符结尾的字符串中未识别的字符数，其中 $i = index + 1$（这里令 $dp[0]=0$，因为可能出现前 $k$ 个字符组成一个词，这样做利于判断）。对于每个 $index$，都对`dictionary`进行一次遍历，用 $len$ 表示`dictionary`中每个词的长度，则可以得到动态方程：\n\n每扫描到一个 $i$，都先把 $dp[i]$ 初始化为 $i$，然后有\n\n当`sentence`中第 $index - len + 1$ 到 第 $index$ 个字符在`dictionary`中时，\n$$\ndp[i] = \\min (dp[i],dp[i-len])\n$$\n其它情况，\n$$\ndp[i] = (dp[i], dp[i-1]+1)\n$$\n最后 $dp$ 数组中的最后一个元素即为结果。\n\n\n\n## 代码\n\n```python\nclass Solution:\n    def respace(self, dictionary: List[str], sentence: str) -> int:\n        dp = []\n        dp.append(0)\n        for i in range(1, len(sentence)+1):\n            index = i - 1\n            t = i\n            for word in dictionary:\n                l = len(word)\n                if index + 1 - l >= 0 and sentence[index-l+1:index+1] in dictionary:\n                    t = min(t, dp[i-l])\n                    if i - l == 0:\n                        break\n                t = min(t, dp[i-1]+1)\n            dp.append(t)\n        return dp[len(sentence)]\n```\n\n","source":"_posts/LeetCode刷题.md","raw":"---\ntitle: LeetCode刷题\ndate: 2020-05-25 20:48:42\ncategories: Coding\ntags: LeetCode\n---\n\n记录一下每日刷题 $\\surd$\n\n<!--more-->\n\n[TOC]\n\n# 4. 寻找两个正序数组的中位数\n\nhttps://leetcode-cn.com/problems/median-of-two-sorted-arrays/\n\n## 题目描述\n\n给定两个大小为 m 和 n 的正序（从小到大）数组 `nums1` 和 `nums2`。\n\n请你找出这两个正序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。\n\n你可以假设 `nums1` 和 `nums2` 不会同时为空。\n\n \n\n示例 1:\n\n```\nnums1 = [1, 3]\nnums2 = [2]\n\n则中位数是 2.0\n```\n\n示例 2:\n\n```\nnums1 = [1, 2]\nnums2 = [3, 4]\n\n则中位数是 (2 + 3)/2 = 2.5\n```\n\n\n\n## 思路\n\n题目要求时间复杂度为 O(log(m + n))，知道要用二分查找，但是具体方法想不出来，只能看了一篇题解中的[找第 k 小的数的方法](https://leetcode-cn.com/problems/median-of-two-sorted-arrays/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-w-2/)。\n\n主要思想是：\n\n* 比较两个数组的第 `k/2` 个数字（向下取整），哪个小则可以直接排除那个数组的前 `k/2` 个数字（因为两个数组都是有序的）；\n* 上一步已经排除了 `k/2` 个数，因此 `k = k - k/2`，再次比较两个数组（其中一个数组为排除了 `k/2` 个数后的新数组）的第 `k/2` 个数字，直到 `k = 1` 或其中一个数组中的元素被全部排除了：\n  1. 若 `k = 1` 则返回当前两个数组的第一个元素中较小的那一个；\n  2. 若其中一个数组被全部排除，则返回另一个数组中的第 `k` 个元素。\n\n\n\n## 代码\n\n```python\nclass Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n        n, m = len(nums1), len(nums2)\n        left = (n + m + 1) // 2\n        right = (n + m + 2) // 2\n        return (self.recur(left, nums1, 0, n-1, nums2, 0, m-1) + self.recur(right, nums1, 0, n-1, nums2, 0, m-1)) * 0.5\n\n    def recur(self, k, arr1, s1, e1, arr2, s2, e2):\n        l1 = e1 - s1 + 1\n        l2 = e2 - s2 + 1\n        if l1 > l2:\n            return self.recur(k, arr2, s2, e2, arr1, s1, e1)\n        if l1 == 0:\n            return arr2[s2+k-1]\n        if k == 1:\n            return min(arr1[s1], arr2[s2])\n        p1 = s1 + min(k//2, l1) - 1\n        p2 = s2 + min(k//2, l2) - 1\n        if arr1[p1] < arr2[p2]:\n            return self.recur(k-min(k//2, l1), arr1, p1+1, e1, arr2, s2, e2)\n        else:\n            return self.recur(k-min(k//2, l2), arr1, s1, e1, arr2, p2+1, e2)\n```\n\n\n\n# 6. Z字形变换\n\nhttps://leetcode-cn.com/problems/zigzag-conversion/\n\n## 题目描述\n\n将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。\n\n比如输入字符串为 `\"LEETCODEISHIRING\"` 行数为 3 时，排列如下：\n\n```\nL   C   I   R\nE T O E S I I G\nE   D   H   N\n```\n\n之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：`\"LCIRETOESIIGEDHN\"`。\n\n请你实现这个将字符串进行指定行数变换的函数：\n\n```\nstring convert(string s, int numRows);\n```\n\n示例 1:\n\n```\n输入: s = \"LEETCODEISHIRING\", numRows = 3\n输出: \"LCIRETOESIIGEDHN\"\n```\n\n示例 2:\n\n```\n输入: s = \"LEETCODEISHIRING\", numRows = 4\n输出: \"LDREOEIIECIHNTSG\"\n解释:\n\nL     D     R\nE   O E   I I\nE C   I H   N\nT     S     G\n```\n\n\n\n## 思路\n\n用一个二维列表 `tmp` 存储 Z 字形字符串中每一行的元素，最后将 `tmp` 中的字符串逐行拼接即得到结果，具体步骤如下：\n\n* 从头到尾遍历`s`，`cnt` 表示当前字符的下标，`curRow` 表示当前字符 `s[cnt]` 在 Z 字形字符串中所在的行数，`step` 表示当前的方向（因为 Z 字形中字符都是往上往下这样循环）；\n* 将 `s[cnt]` 加入 `tmp[curRow]`，然后 `cnt` 自增 1，`curRow` 自增 `step`。当 `curRow` 为 `0` 或 `numRows` 时，转换方向，`step *= -1` 。\n\n\n\n## 代码\n\n```python\nclass Solution:\n    def convert(self, s: str, numRows: int) -> str:\n        if numRows == 1: return s\n        tmp = [\"\" for _ in range(numRows)]\n        cnt = curRow = 0\n        step = -1\n        while cnt < len(s):\n            tmp[curRow] += s[cnt]\n            cnt += 1\n            if curRow == numRows - 1 or curRow == 0:\n                step *= -1\n            curRow += step\n        return ''.join(tmp)\n```\n\n\n\n# 14. 最长公共前缀\n\nhttps://leetcode-cn.com/problems/longest-common-prefix/\n\n## 题目描述\n\n编写一个函数来查找字符串数组中的最长公共前缀。\n\n如果不存在公共前缀，返回空字符串 `\"\"`。\n\n示例 1:\n\n```\n输入: [\"flower\",\"flow\",\"flight\"]\n输出: \"fl\"\n```\n\n示例 2:\n\n```\n输入: [\"dog\",\"racecar\",\"car\"]\n输出: \"\"\n解释: 输入不存在公共前缀。\n```\n\n\n说明:\n\n所有输入只包含小写字母 `a-z` 。\n\n\n\n## 思路\n\nPython中的`max()`和`min()`可以比较字符串，按照ASCII值逐位比较：比如`cba`、`cbab`、`cbd`中最大为`cbd`，最小为`cba`。因此只要比较最大最小的两个字符串即可找到最大公共前缀。\n\n\n\n## 代码\n\n```python\nclass Solution:\n    def longestCommonPrefix(self, strs: List[str]) -> str:\n        if not strs: return \"\"\n        str1 = min(strs)\n        str2 = max(strs)\n        for i,x in enumerate(str1):\n            if x != str2[i]:\n                return str2[:i]\n        return str1\n```\n\n\n\n# 21. 合并两个有序链表\n\nhttps://leetcode-cn.com/problems/merge-two-sorted-lists/\n\n## 题目描述\n\n将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 \n\n \n\n示例：\n\n```\n输入：1->2->4, 1->3->4\n输出：1->1->2->3->4->4\n```\n\n\n\n## 思路\n\n因为链表有序，可以用两个指针分别遍历两个链表，将两个指针指向的节点中值较小的节点加入到新链表中，然后该指针往后挪，直到遍历完两个链表。\n\n时间复杂度为 O(M + N)，M 和 N 分别为两个链表的长度。\n\n\n\n## 代码\n\n```python\nclass Solution:\n    def mergeTwoLists(self, l1: ListNode, l2: ListNode) -> ListNode:\n        if not l1 and not l2: return None\n        p1, p2 = l1, l2\n        pre = None\n        while p1 and p2:\n            if p2.val < p1.val:\n                if not pre:\n                    root = p2\n                    pre = root\n                else:\n                    pre.next = p2\n                    pre = p2\n                p2 = p2.next\n            else:\n                if not pre:\n                    root = p1\n                    pre = root\n                else:\n                    pre.next = p1\n                    pre = p1\n                p1 = p1.next\n        if p1:\n            if not pre:\n                return p1\n            pre.next = p1\n        else:\n            if not pre:\n                return p2\n            pre.next = p2\n        return root\n```\n\n\n\n\n\n# 32. 最长有效括号\n\nhttps://leetcode-cn.com/problems/longest-valid-parentheses/\n\n## 题目描述\n\n给定一个只包含 `'('` 和 `')'` 的字符串，找出最长的包含有效括号的子串的长度。\n\n示例 1:\n\n```\n输入: \"(()\"\n输出: 2\n解释: 最长有效括号子串为 \"()\"\n```\n\n\n示例 2:\n\n```\n输入: \")()())\"\n输出: 4\n解释: 最长有效括号子串为 \"()()\"\n```\n\n\n\n## 思路\n\n动态规划：用 $dp[i]$ 表示字符串中以第 $i$ 个字符结尾的字符串的最大有效子串长度。根据题意，$s[i]$ 为 `'('` 时 $dp[i]=0$，有效的子串结尾肯定是 `')'`，可列出动态方程：\n\n当 $s[i]$ 为 `')'` 且 $s[i-1]$ 为 `'('` 时，也就是 \"$......()$\"，\n$$\ndp[i] = dp[i-2] + 2\n$$\n当 $s[i]$ 为 `')'` 且 $s[i-1]$ 为 `')'` 时，也就是 \"$......))$\"，如果倒数第二个 `')'` 是一个有效字符串 $sub_s$ 的一部分，且 $s[i-\\mbox{len}(sub_s)-1]$ 为 `'('` 。此时的最长有效子串的长度即为 $sub_s$ 加上 $2$ 再加上 $dp[i-\\mbox{len}(sub_s)-2]$：\n$$\ndp[i] = dp[i-1] + 2 + dp[i-dp[i-1]-2]\n$$\n最后的结果为 $dp$ 数组中的最大值。\n\n上面两条方程都要注意判断下标 $i-2$ 和 $i-dp[i-1]-2$ 的值，不要小于 $0$。\n\n\n\n## 代码\n\n```python\nclass Solution:\n    def longestValidParentheses(self, s: str) -> int:\n        if len(s) <= 1:\n            return 0\n        dp = [0]\n        for i in range(1, len(s)):\n            if s[i] == ')':\n                if s[i-1] == '(':\n                    dp.append(dp[max(i-2, 0)] + 2)\n                elif s[i-1] == ')' and i-dp[i-1]-1 >= 0 and s[i-dp[i-1]-1] == '(':\n                    dp.append(dp[i-1] + 2 + dp[max(i-dp[i-1]-2, 0)])\n                else:\n                    dp.append(0)\n            else:\n                dp.append(0)\n        return max(dp)\n```\n\n\n\n# 35. 搜索插入位置\n\nhttps://leetcode-cn.com/problems/search-insert-position/\n\n## 题目描述\n\n给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。\n\n你可以假设数组中无重复元素。\n\n示例 1:\n\n```\n输入: [1,3,5,6], 5\n输出: 2\n```\n\n示例 2:\n\n```\n输入: [1,3,5,6], 2\n输出: 1\n```\n\n示例 3:\n\n```\n输入: [1,3,5,6], 7\n输出: 4\n```\n\n示例 4:\n\n```\n输入: [1,3,5,6], 0\n输出: 0\n```\n\n\n\n## 思路\n\n二分查找，每次排除当前数组中一半的元素。\n\n注意递归边界为 `left >= right`，`target` 在 `nums` 不存在有两种情况：\n\n* 当 `left > right` 时，数组 `nums` 中不存在与 `target` 相等的元素，此时 `nums[left]` 为 `nums` 中第一个大于 `target` 的元素，`left` 即为 `target` 应该插入的位置；\n* 当 `left == right` 时，此时 `left` 和 `right` 应该都指向 `nums` 中最后一个元素（因为 `mid` 总是向下取整，这种情况下 `left` 每次都 `+1`，直到指向最后一个元素），此时需要额外判断 `target` 与最后一个元素的大小，`target` 大则将其插入到数组末尾。\n\n\n\n## 代码\n\n```python\nclass Solution:\n    def searchInsert(self, nums: List[int], target: int) -> int:\n        return self.getInsertIndex(nums, 0, len(nums)-1, target)\n\n    def getInsertIndex(self, nums, left, right, target):\n        if left >= right:\n            if target > nums[left]:\n                return left + 1\n            return left\n        mid = (left + right) // 2\n        if target == nums[mid]:\n            return mid\n        if target < nums[mid]:\n            return self.getInsertIndex(nums, left, mid-1, target)\n        else:\n            return self.getInsertIndex(nums, mid+1, right, target)\n```\n\n\n\n# 94. 二叉树的中序遍历\n\nhttps://leetcode-cn.com/problems/binary-tree-inorder-traversal/\n\n## 题目描述\n\n给定一个二叉树，返回它的中序 遍历。\n\n示例:\n\n```\n输入: [1,null,2,3]\n   1\n    \\\n     2\n    /\n   3\n\n输出: [1,3,2]\n```\n\n进阶: 递归算法很简单，你可以通过迭代算法完成吗？\n\n\n\n## 思路\n\n这里可以用两种方法，递归和迭代，前者比较简单就不说了，主要讲后者。\n\n迭代算法中需要用到一个栈，每到一个节点先将其入栈，遍历其左子树，然后访问该节点，访问完后该节点就可以出栈了，最后遍历其右子树。\n\n\n\n## 代码\n\n数据结构：\n\n```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n```\n\n递归：\n\n```python\nclass Solution:\n    def inorderTraversal(self, root: TreeNode) -> List[int]:\n        ans = []\n\n        def helper(root):\n            if root:\n                helper(root.left)\n                ans.append(root.val)\n                helper(root.right)\n            return\n\n        helper(root)\n        return ans\n```\n\n迭代：\n\n```python\nclass Solution:\n    def inorderTraversal(self, root: TreeNode) -> List[int]:\n        if not root:\n            return []\n        ans, v = [], []\n        cur = root\n        while cur or v:\n            while cur:\n                v.append(cur)\n                cur = cur.left\n            cur = v.pop()\n            ans.append(cur.val)\n            cur = cur.right\n\n        return ans\n```\n\n\n\n# 96. 不同的二叉搜索树\n\nhttps://leetcode-cn.com/problems/unique-binary-search-trees/\n\n## 题目描述\n\n给定一个整数 n，求以 1 ... n 为节点组成的二叉搜索树有多少种？\n\n示例:\n\n```\n输入: 3\n输出: 5\n解释:\n给定 n = 3, 一共有 5 种不同结构的二叉搜索树:\n\n   1         3     3      2      1\n    \\       /     /      / \\      \\\n     3     2     1      1   3      2\n    /     /       \\                 \\\n   2     1         2                 3\n```\n\n\n\n## 思路\n\n动态规划：\n\n* 用 `dp[n]` 表示以 1 ... n 为节点组成的二叉搜索树的数量，`f[i]` 表示 i 为根节点的二叉搜索树的数量；\n* 结果即为以各个节点作为根节点的数量总和：`dp[n] = f[1] + f[2] + ... + f[n]`；\n*  当 i 为根节点时，其左子树的节点数为 i-1，右子树的节点数为 n-i，因此有：`f[i] = f[i-1] * f[n-i]`；\n* `dp[n] = dp[0]*dp[n-1] + dp[1]*dp[n-2] + ... + dp[n-1]*dp[0]`。\n\n当 n 为1或0时，只有一种情况，即 `dp[0] = dp[1] = 1`。\n\n\n\n还有一种方法是递归，也是利用上面的公式。\n\n\n\n## 代码\n\n动态规划：\n\n```python\nclass Solution:\n    def numTrees(self, n: int) -> int:\n        dp = [0] * (n + 1)\n        dp[0] = dp[1] = 1\n        for i in range(2, n+1):\n            for j in range(1, i+1):\n                dp[i] += dp[j-1] * dp[i-j]\n        return dp[n]\n```\n\n递归：\n\n```python\nclass Solution:\n    def numTrees(self, n: int) -> int:\n        memo = [0] * (n + 1)\n\n        def helper(n):\n            if n == 1 or n == 0: return 1\n            if memo[n] > 0:\n                return memo[n]\n            for i in range(0, n):\n                memo[n] += helper(i) * helper(n-i-1)\n            return memo[n]\n\n        return helper(n)\n```\n\n\n\n# 97. 交错字符串\n\nhttps://leetcode-cn.com/problems/interleaving-string/\n\n## 题目描述\n\n给定三个字符串 s1, s2, s3, 验证 s3 是否是由 s1 和 s2 交错组成的。\n\n示例 1:\n\n```\n输入: s1 = \"aabcc\", s2 = \"dbbca\", s3 = \"aadbbcbcac\"\n输出: true\n```\n\n示例 2:\n\n```\n输入: s1 = \"aabcc\", s2 = \"dbbca\", s3 = \"aadbbbaccc\"\n输出: false\n```\n\n\n\n## 思路\n\n动态规划，用 `dp[i][j]` 表示 `s1` 的前 `i` 个字符和 `s2` 的前 `j` 个字符是否能交错组成 `s3` 的前 `i+j` 个字符。若 `s1[i]==s3[i+j]`，那么 `dp[i][j]` 是否为真则取决于 `s1` 的前 `i-1`（`s2` 的前 `j-1`）个字符和 `s2` 的前 `j` `s1` 的前 `i`）个字符是否能交错组成 `s3` 的前 `i+j-1` 个字符，即 `dp[i-1][j]`（`dp[i][j-1]`）是否为真。\n\n可得状态转移方程：\n\n* `dp[i][j] = (dp[i-1][j] and s1[i-1]==s3[i+j-1]) or (dp[i][j-1] and s2[j-1]==s3[i+j-1])`；\n* 边界条件为`dp[0][0] = True`。\n\n当 `s1` 和 `s2` 长度之和不等于 `s3` 长度时，直接输出 `False`。\n\n时间复杂度为 O(MN)。\n\n\n\n## 代码\n\n```python\nclass Solution:\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\n        n, m = len(s1), len(s2)\n        if n + m != len(s3):\n            return False\n        dp = [[False] * (m + 1) for _ in range(n + 1)]\n        dp[0][0] = True\n        for i in range(n + 1):\n            for j in range(m + 1):\n                if i > 0:\n                    dp[i][j] = dp[i][j] or (dp[i-1][j] and s1[i-1]==s3[i+j-1])\n                if j > 0:\n                    dp[i][j] = dp[i][j] or (dp[i][j-1] and s2[j-1]==s3[i+j-1])\n        return dp[n][m]\n```\n\n\n\n# 100. 相同的树\n\nhttps://leetcode-cn.com/problems/same-tree/\n\n## 题目描述\n\n给定两个二叉树，编写一个函数来检验它们是否相同。\n\n如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。\n\n示例 1:\n\n    输入:       1         1\n              / \\       / \\\n             2   3     2   3\n    \n            [1,2,3],   [1,2,3]\n            \n    输出: true\n\n\n示例 2:\n\n    输入:      1          1\n              /           \\\n             2             2\n    \n            [1,2],     [1,null,2]\n            \n    输出: false\n\n\n示例 3:\n\n    输入:       1         1\n              / \\       / \\\n             2   1     1   2\n    \n            [1,2,1],   [1,1,2]\n            \n    输出: false\n\n\n\n## 思路\n\n就是二叉树的遍历，用递归判断两棵树对应节点是否存在以及值是否相等即可。\n\n\n\n## 代码\n\n```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\n        \n        def helper(p, q):\n            if not p and not q: return True\n            if p and not q or not p and q: return False\n            if p.val != q.val: return False\n            return helper(p.left, q.left) and helper(p.right, q.right)\n\n        return helper(p, q)\n```\n\n\n\n# 101. 对称二叉树\n\nhttps://leetcode-cn.com/problems/symmetric-tree/\n\n## 题目描述\n\n给定一个二叉树，检查它是否是镜像对称的。\n\n \n\n例如，二叉树 [1,2,2,3,4,4,3] 是对称的。\n\n        1\n       / \\\n      2   2\n     / \\ / \\\n    3  4 4  3\n\n\n\n\n但是下面这个 `[1,2,2,null,3,null,3]` 则不是镜像对称的:\n\n        1\n       / \\\n      2   2\n       \\   \\\n       3    3\n\n\n\n\n进阶：\n\n你可以运用递归和迭代两种方法解决这个问题吗？\n\n\n\n## 思路\n\n可以通过判断根节点的两棵子树 $p,q$ 是否是镜像的。遍历的方式与第100题类似，只是这次两者不再按相同的顺序遍历，而是按镜像的方式：\n\n* $p$ 遍历其左子树时，$q$ 遍历其右子树；\n* $p$ 遍历其右子树时，$q$ 遍历其左子树。\n\n\n\n## 代码\n\n```python\nclass Solution:\n    def isSymmetric(self, root: TreeNode) -> bool:\n        def helper(p, q):\n            if not p and not q: return True\n            if p and not q or not p and q: return False\n            if p.val != q.val: return False\n            return helper(p.left, q.right) and helper(p.right, q.left)\n        if root and root.left and root.right:\n            return helper(root.left, root.right)\n        elif root and not root.left and not root.right or not root:\n            return True\n        else:\n            return False\n```\n\n\n\n# 102. 二叉树的层序遍历\n\nhttps://leetcode-cn.com/problems/binary-tree-level-order-traversal/\n\n## 题目描述\n\n给你一个二叉树，请你返回其按 **层序遍历** 得到的节点值。 （即逐层地，从左到右访问所有节点）。\n\n \n\n示例：\n二叉树：`[3,9,20,null,null,15,7]`,\n\n        3\n       / \\\n      9  20\n        /  \\\n       15   7\n\n返回其层次遍历结果：\n\n```\n[\n  [3],\n  [9,20],\n  [15,7]\n]\n```\n\n\n\n## 思路\n\n最简单的方法是用递归，按前序遍历二叉树中的节点，记录访问节点的层数，每层用一个列表 `ans[d]` ( `d` 表示当前节点所在层的深度)保存节点值。\n\n另一种思路是使用BFS，使用一个队列 `queue` 存放待访问的节点，每到一层都用 `s` 存当前层节点的个数，每访问到一个节点就将其值存入答案列表中对应的位置，并将其左右子节点存入队列。\n\n\n\n## 代码\n\n递归，前序遍历：\n\n```python\nclass Solution:\n    def levelOrder(self, root: TreeNode) -> List[List[int]]:\n        if not root: return []\n        ans = []\n        \n        def helper(node, d):\n            if not node: return\n            if len(ans) == d:\n                ans.append([])\n            ans[d].append(node.val)\n            helper(node.left, d+1)\n            helper(node.right, d+1)\n            return\n\n        helper(root, 0)\n        return ans\n```\n\n\n\nBFS：\n\n```python\nclass Solution:\n    def levelOrder(self, root: TreeNode) -> List[List[int]]:\n        queue = collections.deque()\n        queue.append(root)\n        ans = []\n        while queue:\n            s = len(queue)\n            d = []\n            for _ in range(s):\n                node = queue.popleft()\n                if not node:\n                    continue\n                d.append(node.val)\n                queue.append(node.left)\n                queue.append(node.right)\n            if d:\n                ans.append(d)\n\n        return ans\n```\n\n\n\n# 107. 二叉树的层次遍历 II\n\nhttps://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/\n\n## 题目描述\n\n给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）\n\n例如：\n给定二叉树 `[3,9,20,null,null,15,7]`,\n\n        3\n       / \\\n      9  20\n        /  \\\n       15   7\n\n返回其自底向上的层次遍历为：\n\n```\n[\n  [15,7],\n  [9,20],\n  [3]\n]\n```\n\n\n\n## 思路\n\n与层次遍历一样，只是输出的时候倒序输出即可，也是有两种方法：递归前序遍历和BFS。\n\n\n\n## 代码\n\n前序遍历，递归：\n\n```python\nclass Solution:\n    def levelOrderBottom(self, root: TreeNode) -> List[List[int]]:\n        ans = []\n        self.helper(root, 0, ans)\n        return ans[::-1]\n\n    def helper(self, node, depth, ans):\n        if not node:\n            return\n        if len(ans) == depth:\n            ans.append([])\n        ans[depth].append(node.val)\n        self.helper(node.left, depth+1, ans)\n        self.helper(node.right, depth+1, ans)\n        return\n```\n\n\n\nBFS：\n\n```python\nclass Solution:\n    def levelOrderBottom(self, root: TreeNode) -> List[List[int]]:\n        queue = collections.deque()\n        queue.append(root)\n        ans = []\n        while queue:\n            size = len(queue)\n            t = []\n            for _ in range(size):\n                p = queue.popleft()\n                if not p:\n                    continue\n                t.append(p.val)\n                queue.append(p.left)\n                queue.append(p.right)\n            if t:\n                ans.append(t)\n        return ans[::-1]\n```\n\n\n\n# 110. 平衡二叉树\n\nhttps://leetcode-cn.com/problems/balanced-binary-tree/\n\n## 题目描述\n\n给定一个二叉树，判断它是否是高度平衡的二叉树。\n\n本题中，一棵高度平衡二叉树定义为：\n\n*一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1。*\n\n示例 1:\n\n给定二叉树 `[3,9,20,null,null,15,7]`\n\n        3\n       / \\\n      9  20\n        /  \\\n       15   7\n\n\n返回 `true` 。\n\n示例 2:\n\n给定二叉树 `[1,2,2,3,3,null,null,4,4]`\n\n           1\n          / \\\n         2   2\n        / \\\n       3   3\n      / \\\n     4   4\n\n\n返回 `false` 。\n\n\n\n## 思路\n\n有两种解法，分别是自顶向下和自底向上。\n\n自顶向下(暴力法)比较容易想到，首先计算根节点左右子树的深度，然后比较它们的差是否小于2，然后计算根节点的左右子节点的左右子树的深度，以此类推。\n\n自底向上则是在计算节点的深度时就判断其左右子树的深度大小，若大于2则直接返回，效率要比自顶向下高很多。\n\n\n\n## 代码\n\n自顶向下：\n\n```python\nclass Solution:\n    def isBalanced(self, root: TreeNode) -> bool:\n        if not root: return True\n        return abs(self.helper(root.left) - self.helper(root.right)) < 2 and \\\n            self.isBalanced(root.left) and self.isBalanced(root.right)\n\n    def helper(self, node):\n        if not node: return 0\n        return max(self.helper(node.left), self.helper(node.right))+1\n```\n\n\n\n自底向上：\n\n```python\nclass Solution:\n    def isBalanced(self, root: TreeNode) -> bool:\n        return self.helper(root) != -1\n\n    def helper(self, node):\n        if not node: return 0\n        left = self.helper(node.left)\n        if left == -1: return -1\n        right = self.helper(node.right)\n        if right == -1: return -1\n        return max(left, right)+1 if abs(left - right) < 2 else -1\n```\n\n\n\n# 112. 路径总和\n\nhttps://leetcode-cn.com/problems/path-sum/\n\n## 题目描述\n\n给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。\n\n说明: 叶子节点是指没有子节点的节点。\n\n示例: \n给定如下二叉树，以及目标和 `sum = 22`，\n\n              5\n             / \\\n            4   8\n           /   / \\\n          11  13  4\n         /  \\      \\\n        7    2      1\n\n返回 `true`, 因为存在目标和为 22 的根节点到叶子节点的路径 `5->4->11->2`。\n\n\n\n## 思路\n\n递归，前序遍历二叉树，统计路径总和，到叶子节点时判断路径总和与目标和 `sum`  是否相等。\n\n\n\n## 代码\n\n```python\nclass Solution:\n    def hasPathSum(self, root: TreeNode, sum: int) -> bool:\n        if not root: return False\n\n        def helper(node, s):\n            if not node: return False\n            t = node.val + s\n            if not node.left and not node.right:\n                if t == sum:\n                    return True\n                else:\n                    return False\n            else: return helper(node.left, t) or helper(node.right, t)\n\n        return helper(root, 0)\n```\n\n\n\n# 120. 三角形最小路径和\n\nhttps://leetcode-cn.com/problems/triangle/\n\n## 题目描述\n\n给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。\n\n**相邻的结点** 在这里指的是 `下标` 与 `上一层结点下标` 相同或者等于 `上一层结点下标 + 1` 的两个结点。\n\n \n\n例如，给定三角形：\n\n```\n[\n     [2],\n    [3,4],\n   [6,5,7],\n  [4,1,8,3]\n]\n```\n\n自顶向下的最小路径和为 `11`（即，2 + 3 + 5 + 1 = 11）。\n\n \n\n说明：\n\n如果你可以只使用 O(n) 的额外空间（n 为三角形的总行数）来解决这个问题，那么你的算法会很加分。\n\n\n\n## 思路\n\n动态规划：\n\n* `dp[i][j]` 表示第 `i` 行第 `j` 列节点到最底层的最小路径和，自底向上计算。\n* `dp[i][j] = triangle[i][j] + min(dp[i+1][j], dp[i+1][j+1])`.\n\n计算完后 `dp[0][0]` 为最终答案。\n\n\n\n## 代码\n\n```python\nclass Solution:\n    def minimumTotal(self, triangle: List[List[int]]) -> int:\n        dp = triangle[:]\n        for i in range(len(triangle)-2, -1, -1):\n            for j in range(i+1):\n                dp[i][j] = triangle[i][j] + min(dp[i+1][j], dp[i+1][j+1])\n        return dp[0][0]\n```\n\n\n\n# 121. 买卖股票的最佳时机\n\nhttps://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/\n\n## 题目描述\n\n给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。\n\n如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。\n\n注意：你不能在买入股票前卖出股票。\n\n \n\n示例 1:\n\n```\n输入: [7,1,5,3,6,4]\n输出: 5\n解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。\n     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。\n```\n\n示例 2:\n\n```\n输入: [7,6,4,3,1]\n输出: 0\n解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。\n```\n\n\n\n## 思路\n\n因为有时间因素，因此不能简单地用最大值减去最小值。可以用维护两个变量`minp`和`maxp`，其中`minp`记录到当前为止的最小价格，`maxp`记录当前为止的最大差价。通过对数组的一遍扫描，每扫描到一个值就与`minp`作比较、计算当前值与`minp`的差价，若大于`maxp`则更新。\n\n\n\n## 代码\n\n```python\nclass Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        maxp = 0\n        if len(prices) > 0:\n            minp = prices[0]\n            for price in prices:\n                if price < minp:\n                    minp = price\n                if price - minp > maxp:\n                    maxp = price - minp\n        return maxp\n```\n\n\n\n# 152. 乘积最大子数组\n\nhttps://leetcode-cn.com/problems/maximum-product-subarray/\n\n## 题目描述\n\n给你一个整数数组 `nums` ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。\n\n示例 1:\n\n```\n输入: [2,3,-2,4]\n输出: 6\n解释: 子数组 [2,3] 有最大乘积 6。\n```\n\n示例 2:\n\n```\n输入: [-2,0,-1]\n输出: 0\n解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。\n```\n\n\n\n## 思路\n\n可以用动态规划。因为负负得正，所以当前的数为负的话，与前一个数的最小值相乘有可能得到比最大值更大的数。因此需要维护两个变量：当前的最大值和最小值。\n\n动态方程如下：\n$$\n\\begin{aligned}\nmaxDP[i+1] &= \\max(dmax[i+1] \\cdot nums[i], \\  nums[i],\\  dmin[i] \\cdot nums[i])\\\\\nminDP[i+1] &= \\min(dmax[i+1] \\cdot nums[i],\\  nums[i],\\  dmin[i] \\cdot nums[i])\\\\\nDP[i+1] &= \\max(DP[i],\\ maxDP[i+1])\n\\end{aligned}\n$$\n当`nums[i]`为0时，`dmax`和`dmin`都为0，于是需要从`nums[i+1]`重新开始。\n\n\n\n## 代码\n\n```python\nclass Solution:\n    def maxProduct(self, nums: List[int]) -> int:\n        if len(nums)==0:\n            return 0\n        elif len(nums)==1:\n            return nums[0]\n        m = dmax = dmin = nums[0]\n        for i in range(1, len(nums)):\n            tmp = dmax\n            dmax = max(max(dmax*nums[i], nums[i]), dmin*nums[i])\n            dmin = min(min(tmp*nums[i], nums[i]), dmin*nums[i])\n            m = max(dmax, m)\n        return m\n```\n\n\n\n# 167. 两数之和 II - 输入有序数组\n\nhttps://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/\n\n## 题目描述\n\n给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。\n\n函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。\n\n说明:\n\n* 返回的下标值（index1 和 index2）不是从零开始的。\n* 你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。\n\n示例:\n\n```\n输入: bers = [2, 7, 11, 15], target = 9\n输出: [1,2]\n解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。\n```\n\n\n\n## 思路\n\n遍历数组，将访问过的元素的索引存储在哈希表 `d` 中，`d[val]` 存储的是值为 `val` 的元素的索引。\n\n* 每访问到一个元素，计算其与目标数的差值 `k = target - val`；\n* 在 `d` 中查找 `k`，若 `k` 存在则直接返回 `[d[k], val的index]`（后访问的 `index` 肯定比先访问的大）；\n* 若 `k` 不存在则将 `val` 的 `index` 存储在哈希表中。\n\n时间复杂度 $O(N)$，遍历了一次数组；空间复杂度 $O(N)$，用到了一个哈希表存储数组中的元素的索引值。\n\n\n\n## 代码\n\n```python\nclass Solution:\n    def twoSum(self, numbers: List[int], target: int) -> List[int]:\n        n = len(numbers)\n        d = dict()\n        for i in range(n):\n            k = target - numbers[i]\n            if k in d:\n                return [d[k], i+1]\n            d[numbers[i]] = i + 1\n```\n\n\n\n# 169. 多数元素\n\nhttps://leetcode-cn.com/problems/majority-element/\n\n## 题目描述\n\n给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数大于 `⌊ n/2 ⌋` 的元素。\n\n你可以假设数组是非空的，并且给定的数组总是存在多数元素。\n\n \n\n示例 1:\n\n```\n输入: [3,2,3]\n输出: 3\n```\n\n\n示例 2:\n\n```\n输入: [2,2,1,1,1,2,2]\n输出: 2\n```\n\n\n\n## 思路\n\n这里可以使用摩尔投票法：\n\n候选人`k`初始化为数组第一个元素`nums[0]`，票数`cnt`初始化为1。从第二个元素`nums[1]`开始遍历，遇到与候选人相同的数则把票数加1，遇到不同的则把票数减1，如果票数减完之后为0，则更换当前数`nums[i]`为候选人并把票数重设为1。\n\n因为多数元素的个数肯定比其它元素的个数之和多，因此其票数在最后肯定是`>= 1`的。\n\n\n\n## 代码\n\n```python\nclass Solution:\n    def majorityElement(self, nums: List[int]) -> int:\n        if len(nums) < 0:\n            return 0\n        cnt = 1\n        k = nums[0]\n        for i in range(1, len(nums)):\n            if nums[i] == k:\n                cnt += 1\n            else:\n                cnt -= 1\n                if cnt == 0:\n                    cnt = 1\n                    k = nums[i]\n        return k\n```\n\n\n\n# 174. 地下城游戏\n\nhttps://leetcode-cn.com/problems/dungeon-game/\n\n## 题目描述\n\n一些恶魔抓住了公主（**P**）并将她关在了地下城的右下角。地下城是由 M x N 个房间组成的二维网格。我们英勇的骑士（**K**）最初被安置在左上角的房间里，他必须穿过地下城并通过对抗恶魔来拯救公主。\n\n骑士的初始健康点数为一个正整数。如果他的健康点数在某一时刻降至 0 或以下，他会立即死亡。\n\n有些房间由恶魔守卫，因此骑士在进入这些房间时会失去健康点数（若房间里的值为负整数，则表示骑士将损失健康点数）；其他房间要么是空的（房间里的值为 0），要么包含增加骑士健康点数的魔法球（若房间里的值为正整数，则表示骑士将增加健康点数）。\n\n为了尽快到达公主，骑士决定每次只向右或向下移动一步。\n\n \n\n**编写一个函数来计算确保骑士能够拯救到公主所需的最低初始健康点数。**\n\n例如，考虑到如下布局的地下城，如果骑士遵循最佳路径 `右 -> 右 -> 下 -> 下`，则骑士的初始健康点数至少为 **7**。\n\n![](http://images.yingwai.top/picgo/174f1.png)\n\n\n说明:\n\n* 骑士的健康点数没有上限。\n\n* 任何房间都可能对骑士的健康点数造成威胁，也可能增加骑士的健康点数，包括骑士进入的左上角房间以及公主被监禁的右下角房间。\n\n\n\n## 思路\n\n反向动态规划，从右下往左上遍历列表，用 `dp[i][j]` 来表示从房间 `(i, j)` 到达终点的最低初始健康点数，则可以得到\n\n* 此房间到终点的 `dp` 值为：此房间右边和下边的房间的 `dp` 值中较小的那一个，加上此房间需要消耗的生命值 `dungeon[i][j]` (注意初始值不能小于 **1**)；\n* `dp[i][j] = max(min(dp[i+1][j], dp[i][j+1]) - dungeon[i][j], 1)`.\n\n对于最后一行或一列中，除终点以外的元素 `dp[i][j]` 要用到的 `dp[i+1][j]` 和 `dp[i][j+1]`，将它们赋值为无穷大；而对于终点 `dp[m-1][n-1]`，将 `dp[m][n-1]` 和 `dp[m-1][n]` 赋值为 1。\n\n\n\n## 代码\n\n```python\nclass Solution:\n    def calculateMinimumHP(self, dungeon: List[List[int]]) -> int:\n        m, n = len(dungeon), len(dungeon[0])\n        BIG = float(\"inf\")\n        dp = [[BIG] * (n + 1) for _ in range(m + 1)]\n        dp[m-1][n] = dp[m][n-1] = 1\n        for i in range(m-1, -1, -1):\n            for j in range(n-1, -1, -1):\n                dp[i][j] = max(min(dp[i+1][j], dp[i][j+1]) - dungeon[i][j], 1)\n        return dp[0][0]\n```\n\n\n\n# 198. 打家劫舍\n\nhttps://leetcode-cn.com/problems/house-robber/\n\n## 题目描述\n\n你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。\n\n给定一个代表每个房屋存放金额的非负整数数组，计算你不触动警报装置的情况下，一夜之内能够偷窃到的最高金额。\n\n示例 1:\n\n```\n输入: [1,2,3,1]\n输出: 4\n解释: 偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。\n     偷窃到的最高金额 = 1 + 3 = 4 。\n```\n\n示例 2:\n\n```\n输入: [2,7,9,3,1]\n输出: 12\n解释: 偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。\n     偷窃到的最高金额 = 2 + 9 + 1 = 12 。\n```\n\n\n\n## 思路\n\n动态规划，用 $\\rm dp[i]$ 表示前 $\\rm i$ 个房间能偷到的最大值，根据题目条件有以下动态方程：\n$$\n\\rm dp[i] = \\max (dp[i-1], dp[i-2] + nums[i])\n$$\n\n\n## 代码\n\n```python\nclass Solution:\n    def rob(self, nums: List[int]) -> int:\n        if len(nums) <= 0:\n            return 0\n        elif len(nums) == 1:\n            return nums[0]\n        dp = []\n        dp.append(nums[0])\n        dp.append(max(nums[0], nums[1]))\n        for i in range(2, len(nums)):\n            dp.append(max(dp[i-1], dp[i-2] + nums[i]))\n        return dp[len(nums)-1]\n```\n\n\n\n# 257. 二叉树的所有路径\n\nhttps://leetcode-cn.com/problems/binary-tree-paths/\n\n## 题目描述\n\n给定一个二叉树，返回所有从根节点到叶子节点的路径。\n\n说明: 叶子节点是指没有子节点的节点。\n\n示例:\n\n```\n输入:\n\n   1\n /   \\\n2     3\n \\\n  5\n\n输出: [\"1->2->5\", \"1->3\"]\n\n解释: 所有根节点到叶子节点的路径为: 1->2->5, 1->3\n```\n\n\n\n## 思路\n\n递归，用一个字符串 `s` 记录当前的路径，访问到叶子节点时将其加入最终结果的列表 `ans` 中。访问到叶子节点或空节点时返回。\n\n\n\n## 代码\n\n```python\nclass Solution:\n    def binaryTreePaths(self, root: TreeNode) -> List[str]:\n        ans = []\n        s = \"\"\n        self.helper(root, ans, s, 1)\n        return ans\n\n    def helper(self, node, ans, s, depth):\n        if not node:\n            return\n        s = s + \"->\" + str(node.val) if depth > 1 else s + str(node.val)\n        if not node.left and not node.right:\n            ans.append(s)\n            return\n        self.helper(node.left, ans, s, depth+1)\n        self.helper(node.right, ans, s, depth+1)\n        return\n```\n\n\n\n# 287. 寻找重复数\n\nhttps://leetcode-cn.com/problems/find-the-duplicate-number/\n\n## 题目描述\n\n给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。\n\n示例 1:\n\n```\n输入: [1,3,4,2,2]\n输出: 2\n```\n\n\n示例 2:\n\n```\n输入: [3,1,3,4,2]\n输出: 3\n```\n\n说明：\n\n1. 不能更改原数组（假设数组是只读的）。\n2. 只能使用额外的 $O(1)$ 的空间。\n3. 时间复杂度小于 $O(n^2)$ 。\n4. 数组中只有一个重复的数字，但它可能不止重复出现一次。\n\n\n\n## 思路\n\n由于题目限制了空间，所以打表法之类的方法就无法使用。可以用二分法：\n\n对于给定题目条件的数组 `nums`，设`mid`为 1 到 n 的中位数。扫描数组，若数组中小于等于`mid`的数的数量严格大于`mid`，则可以确定重复的数就在 1 到`mid`之间，反之则在`mid`到 n 之间。\n\n\n\n## 代码\n\n```python\nclass Solution:\n    def findDuplicate(self, nums: List[int]) -> int:\n        size = len(nums)\n        left = 1\n        right = size - 1\n        while left < right:\n            cnt = 0\n            mid = left + (right - left) // 2\n            for num in nums:\n                if num <= mid:\n                    cnt += 1\n            if cnt > mid:\n                right = mid\n            else:\n                left = mid + 1\n        return left\n```\n\n\n\n# 300. 最长上升子序列\n\nhttps://leetcode-cn.com/problems/longest-increasing-subsequence/\n\n## 题目描述\n\n给定一个无序的整数数组，找到其中最长上升子序列的长度。\n\n示例:\n\n```\n输入: [10,9,2,5,3,7,101,18]\n输出: 4 \n解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。\n```\n\n\n说明:\n\n* 可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。\n* 你算法的时间复杂度应该为 $O(n^2)$。\n\n进阶: 你能将算法的时间复杂度降低到 $O(n \\log{n})$ 吗?\n\n\n\n## 思路\n\n$O(n \\log{n})$ 还没想到，这里介绍 $O(n^2)$ 的动态规划方法：\n\n用 $\\rm dp[i]$ 表示以第 $\\rm i$ 个元素结尾的最长上升子序列的长度，则可以得到以下的状态转移方程：\n$$\n\\rm dp[i] = \\max(dp[i], dp[j] + 1),\\ nums[j] < nums[i],\\  j < i.\n$$\n扫描完整个数组后，$\\rm dp$ 数组中的最大值即为结果。\n\n\n\n## 代码\n\n```python\nclass Solution:\n    def lengthOfLIS(self, nums: List[int]) -> int:\n        if len(nums) <= 0:\n            return 0\n        dp = []     # 存以第i个元素结尾的最长上升子序列的长度\n        for i in range(len(nums)):\n            dp.append(1)\n            for j in range(i):\n                if nums[j] < nums[i]:\n                    dp[i] = max(dp[i], dp[j]+1)\n        return max(dp)\n```\n\n\n\n# 309. 最佳买卖股票时机含冷冻期\n\nhttps://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/\n\n## 题目描述\n\n给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。\n\n设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:\n\n* 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。\n* 卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。\n\n示例:\n\n```\n输入: [1,2,3,0,2]\n输出: 3 \n解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]\n```\n\n\n\n## 思路\n\n动态规划，用两个数组来存储状态：\n\n1. `hold[i]` 表示在第 `i` 天结束时持有股票、此时的最大收益，有两种情况：\n   * 昨天持有股票，今天休息；\n   * 前天卖出，今天买入；\n   * `hold[i] = max(hold[i-1], unhold[i-2] - prices[i])`。\n2. `unhold[i]` 表示在第 `i` 天结束时未持有股票、此时的最大收益，也有两种情况：\n   * 昨天也没持有股票，今天休息；\n   * 昨天持有，今天卖出；\n   * `unhold[i] = max(unhold[i-1], hold[i-1] + prices[i])`。\n\n最终结果是 `unhold[n-1]`。\n\n初始情况：\n\n* 第 `0` 天持有股票即在当天买入股票，`hold[0] = -prices[0]`；\n* 第 `1` 天持有股票有前一天买入或是当天买入两种情况，`hold[1] = max(-prices[0], -prices[1])`；\n* 第 `0` 天未持有股票即当天休息，`unhold[0] = 0`。\n\n\n\n## 代码\n\n```python\nclass Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        if len(prices) < 2: return 0\n        hold, unhold = [], []\n        hold.append(-prices[0])\n        unhold.append(0)\n        for i in range(1, len(prices)):\n            if i == 1:\n                hold.append(max(-prices[0], -prices[1]))\n            else:\n                hold.append(max(hold[i-1], unhold[i-2] - prices[i]))\n            unhold.append(max(unhold[i-1], hold[i-1] + prices[i]))        \n        return unhold[len(prices) - 1]\n```\n\n\n\n# 312. 戳气球\n\nhttps://leetcode-cn.com/problems/burst-balloons/\n\n## 题目描述\n\n有 `n` 个气球，编号为 `0` 到 `n-1`，每个气球上都标有一个数字，这些数字存在数组 `nums` 中。\n\n现在要求你戳破所有的气球。如果你戳破气球 `i` ，就可以获得 `nums[left] * nums[i] * nums[right]` 个硬币。 这里的 `left` 和 `right` 代表和 `i` 相邻的两个气球的序号。注意当你戳破了气球 `i` 后，气球 `left` 和气球 `right` 就变成了相邻的气球。\n\n求所能获得硬币的最大数量。\n\n说明:\n\n* 你可以假设 `nums[-1] = nums[n] = 1`，但注意它们不是真实存在的所以并不能被戳破。\n* 0 ≤ `n` ≤ 500, 0 ≤ `nums[i]` ≤ 100\n\n示例:\n\n```\n输入: [3,1,5,8]\n输出: 167 \n解释: nums = [3,1,5,8] --> [3,5,8] -->   [3,8]   -->  [8]  --> []\n     coins =  3*1*5      +  3*5*8    +  1*3*8      + 1*8*1   = 167\n```\n\n\n\n## 思路\n\n动态规划，用 `dp[i][j]` 表示戳破气球 `i` 和气球 `j` 之间所有气球所能获得硬币的最大数量：\n\n* 当气球 `i` 和 `j` 相邻时，`dp[i][j]` 为0；\n* 令 `k` 为气球 `i` 和气球 `j` 之间最后戳破的气球序号，对于每个 `i` 和 `j`（`i` 小于 `j`），遍历所有的 `k`，取其中的最大值赋值给 `dp[i][j]`，可得以下状态转移方程：\n* `dp[i][j] = max(dp[i][j], dp[i][k] + dp[k][j] + nums[i]*nums[k]*nums[j])`.\n\n注意要令 `nums` 的两个边界赋值为1。\n\n时间复杂度为 $O(N^3)$。\n\n\n\n## 代码\n\n```python\nclass Solution:\n    def maxCoins(self, nums: List[int]) -> int:\n        points = [1] + nums + [1]\n        n = len(nums)\n        dp = [[0] * (n+2) for _ in range(n+2)]\n        for i in range(n, -1, -1):\n            for j in range(i+1, n+2):\n                for k in range(i+1, j):\n                    dp[i][j] = max(dp[i][j], dp[i][k] + dp[k][j] + points[k]*points[i]*points[j])\n        return dp[0][-1]\n```\n\n\n\n# 315. 计算右侧小于当前元素的个数\n\nhttps://leetcode-cn.com/problems/count-of-smaller-numbers-after-self/\n\n## 题目描述\n\n给定一个整数数组 nums，按要求返回一个新数组 counts。数组 counts 有该性质： `counts[i]` 的值是  `nums[i]` 右侧小于 `nums[i]` 的元素的数量。\n\n示例:\n\n```\n输入: [5,2,6,1]\n输出: [2,1,1,0] \n解释:\n5 的右侧有 2 个更小的元素 (2 和 1).\n2 的右侧仅有 1 个更小的元素 (1).\n6 的右侧有 1 个更小的元素 (1).\n1 的右侧有 0 个更小的元素.\n```\n\n\n\n## 思路\n\n二分查找，从后向前遍历 `nums`，使用一个辅助数组 `sorted_nums` 保存 `nums[i]` 右侧的元素的升序排列，`counts[i]` 的值即为 `nums[i]` 插入 `sorted_nums` 后的索引：\n\n1. 在 `sorted_nums` 中查找第一个小于等于 `nums[i] ` 的元素的索引，此索引即为`nums` 中 `nums[i]` 右侧小于该元素的元素数量；\n2. 将其添加到 `ans` 数组中；\n3. 将 `nums[i]` 插入到 `sorted_nums` 中的对应位置，继续遍历，直到遍历完整个数组。\n\n最后 `ans` 的倒序即为答案。\n\n\n\n## 代码\n\n```python\nclass Solution:\n    def countSmaller(self, nums: List[int]) -> List[int]:\n        sorted_nums, ans = [], []\n        for i in reversed(range(len(nums))): \n            t = self.findIndex(nums[i], sorted_nums)\n            sorted_nums.insert(t, nums[i])\n            ans.append(t)\n        return ans[::-1]\n    \n    def findIndex(self, n, sorted_nums):\n        if len(sorted_nums) == 0:\n            return 0\n        left, right = 0, len(sorted_nums)-1\n        mid = 0\n        while left < right:\n            mid = left + right >> 1\n            if n > sorted_nums[mid]:\n                left = mid + 1\n            else:\n                right = mid\n        if n > sorted_nums[left]:\n            left += 1\n        return left\n```\n\n\n\n# 322. 零钱兑换\n\nhttps://leetcode-cn.com/problems/coin-change/\n\n## 题目描述\n\n给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 `-1`。\n\n \n\n示例 1:\n\n```\n输入: coins = [1, 2, 5], amount = 11\n输出: 3 \n解释: 11 = 5 + 5 + 1\n```\n\n示例 2:\n\n```\n输入: coins = [2], amount = 3\n输出: -1\n```\n\n\n说明:\n你可以认为每种硬币的数量是无限的。\n\n\n\n## 思路\n\n首先想到了贪心，但会复杂一点，迟点再研究一下，这里用了动态规划。根据题意，要求 `amount` 的最少硬币数，可以先对 `coins` 中的每一个面额 `coin` 进行遍历，求子问题 $dp(amount-coin)$ 的最小值。\n\n可以列出状态转移方程\n$$\ndp(n) = \\left\\{ \\begin{array}{lcl}\n -1, & n < 0\\\\\n 0, & n = 0\\\\\n \\min\\{dp(n-coin)+1|coin \\in coins\\}, & n > 0\n\\end{array}\\right.\n$$\n\n\n\n## 代码\n\n```python\nclass Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        memo = dict()\n        \n        def dp(n):\n            if n in memo:\n                return memo[n]\n            if n == 0:\n                return 0\n            if n < 0:\n                return -1\n            ans = float(\"inf\")\n            for coin in coins:\n                subproblem = dp(n - coin)\n                if subproblem == -1:\n                    continue\n                ans = min(ans, subproblem + 1)\n            memo[n] = ans if ans!=float(inf) else -1\n            return memo[n]\n        \n        return dp(amount)\n```\n\n\n\n# 350. 两个数组的交集 II\n\nhttps://leetcode-cn.com/problems/intersection-of-two-arrays-ii/\n\n## 题目描述\n\n给定两个数组，编写一个函数来计算它们的交集。\n\n示例 1:\n\n```\n输入: nums1 = [1,2,2,1], nums2 = [2,2]\n输出: [2,2]\n```\n\n示例 2:\n\n```\n输入: nums1 = [4,9,5], nums2 = [9,4,9,8,4]\n输出: [4,9]\n```\n\n说明：\n\n* 输出结果中每个元素出现的次数，应与元素在两个数组中出现的次数一致。\n* 我们可以不考虑输出结果的顺序。\n\n进阶:\n\n* 如果给定的数组已经排好序呢？你将如何优化你的算法？\n* 如果 nums1 的大小比 nums2 小很多，哪种方法更优？\n* 如果 nums2 的元素存储在磁盘上，磁盘内存是有限的，并且你不能一次加载所有的元素到内存中，你该怎么办？\n\n\n\n## 思路\n\n两种方法：\n\n* 遍历 `nums1`，用一个字典存储 `d` 其中元素的个数，然后遍历 `nums2` 若扫描到的元素 `nums2[i]` 在字典中存在且 `d[nums2[i]] > 0`，则将该元素加入 `ans` 并将 `d[nums2[i]]` 自减 1。\n* 先对两个数组进行排序，然后用两个指针 `i, j` 分别指向排序完的数组的头元素。从头元素开始扫描，当 `nums1[i] > nums2[j]` 时 `j` 往后移，反之 `i` 往后移，两个元素相等时将其加入 `ans`，当遍历完其中一个数组后结束循环。\n\n\n\n## 代码\n\n哈希表：\n\n```python\nclass Solution:\n    def intersect(self, nums1: List[int], nums2: List[int]) -> List[int]:\n        d = dict()\n        ans = []\n        for num in nums1:\n            if num in d:\n                d[num] += 1\n            else:\n                d[num] = 1\n        for num in nums2:\n            if num in d and d[num] > 0:\n                ans.append(num)\n                d[num] -= 1\n        return ans\n```\n\n\n\n排序方法：\n\n```python\nclass Solution:\n    def intersect(self, nums1: List[int], nums2: List[int]) -> List[int]:\n        nums1.sort()\n        nums2.sort()\n        i = j = 0\n        ans = []\n        while i < len(nums1) and j < len(nums2):\n            if nums1[i] == nums2[j]:\n                ans.append(nums1[i])\n                i += 1\n                j += 1\n            elif nums1[i] > nums2[j]:\n                j += 1\n            else:\n                i += 1\n        return ans\n```\n\n\n\n# 394. 字符串解码\n\nhttps://leetcode-cn.com/problems/decode-string/\n\n## 题目描述\n\n给定一个经过编码的字符串，返回它解码后的字符串。\n\n编码规则为: `k[encoded_string]`，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。\n\n你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。\n\n此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 `3a` 或 `2[4]` 的输入。\n\n示例:\n\n```\ns = \"3[a]2[bc]\", 返回 \"aaabcbc\".\ns = \"3[a2[c]]\", 返回 \"accaccacc\".\ns = \"2[abc]3[cd]ef\", 返回 \"abcabccdcdcdef\".\n```\n\n\n\n## 思路\n\n这里可以使用栈，对字符串按顺序扫描：\n\n1. 将右括号以外的字符全部入栈，直到扫描到右括号；\n2. 扫描到右括号则开始退栈，保存在一个字符串`ss`中，直到遇到左括号；\n3. 根据题目的条件，在左括号前面的一定是数字，此时就可以统计当前字符串出现的次数`t`，把`ss`复制`t`次重新入栈；\n4. 最后把栈中所有元素拼接在一起即可。\n\n\n\n## 代码\n\n```python\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        if len(s) <= 0:\n            return \"\"\n        ans = \"\"\n        tmps = []   # 栈\n        i = 1\n        tmps.append(s[0])\n        ss, t = \"\", \"\"\t# 分别存当前字符串和当前的次数\n        while i < len(s):\n            w = s[i]\n            if w == ']':\t# 扫描到右括号则开始退栈，直到遇到左括号\n                while tmps[-1] != '[':\n                    ss = tmps.pop() + ss\n                tmps.pop()      # 将左括号退栈\n                while len(tmps) > 0 and tmps[-1].isdigit():\t\t# 统计次数\n                    t = tmps.pop() + t\n                tmps.append(ss*int(t))\n                ss, t = \"\", \"\"\n            else:\n                tmps.append(w)\n            i += 1\n        for tmp in tmps:\n            ans = ans + tmp\n        return ans\n```\n\n\n\n# 409. 最长回文串\n\nhttps://leetcode-cn.com/problems/longest-palindrome/\n\n## 题目描述\n\n给定一个包含大写字母和小写字母的字符串，找到通过这些字母构造成的最长的回文串。\n\n在构造过程中，请注意区分大小写。比如 `\"Aa\"` 不能当做一个回文字符串。\n\n注意:\n假设字符串的长度不会超过 1010。\n\n示例 1:\n\n```\n输入:\n\"abccccdd\"\n\n输出:\n7\n\n解释:\n我们可以构造的最长的回文串是\"dccaccd\", 它的长度是 7。\n```\n\n\n\n## 思路\n\n由题意可知回文串中奇数的字母只能出现在中间，即只能选取一个来构造回文串。因此可以先统计每个字母在字符串中出现的个数存在字典中，然后遍历字典，将数量为偶数的直接累加；数量为奇数的则判断前面是否已出现了奇数，若不是则直接累加，若是则只选取偶数数量的当前字母，即把当前数量 $-1$ 再累加。\n\n\n\n## 代码\n\n```python\nclass Solution:\n    def longestPalindrome(self, s: str) -> int:\n        d = dict()\n        ans = 0\n        flag = 0    # 判断前面有无加奇数\n        for w in s:\n            if w in d:\n                d[w] += 1\n            else:\n                d[w] = 1\n        for value in d.values():\n            if value%2==0:\n                ans += value\n            elif flag:\n                ans += value - 1\n            else:\n                ans += value\n                flag = 1\n        return ans\n```\n\n\n\n# 563. 二叉树的坡度\n\nhttps://leetcode-cn.com/problems/binary-tree-tilt/\n\n## 题目描述\n\n给定一个二叉树，计算整个树的坡度。\n\n一个树的节点的坡度定义即为，该节点左子树的结点之和和右子树结点之和的差的绝对值。空结点的的坡度是0。\n\n整个树的坡度就是其所有节点的坡度之和。\n\n \n\n示例：\n\n```\n输入：\n         1\n       /   \\\n      2     3\n输出：1\n解释：\n结点 2 的坡度: 0\n结点 3 的坡度: 0\n结点 1 的坡度: |2-3| = 1\n树的坡度 : 0 + 0 + 1 = 1\n```\n\n\n\n\n提示：\n\n任何子树的结点的和不会超过 32 位整数的范围。\n坡度的值不会超过 32 位整数的范围。\n\n\n\n## 思路\n\n递归，后序遍历二叉树，用一个变量 `tilt` 存储累计坡度，访问节点时更新 `tilt = tilt + |(左子树节点之和 - 右子树节点之和)|`，然后返回以当前节点为根节点的二叉树节点之和。\n\n递归边界为访问到空节点，返回 0。\n\n\n\n## 代码\n\n```python\nclass Solution:\n    def findTilt(self, root: TreeNode) -> int:\n        tilt = [0]\n        self.recur(root, tilt)\n        return tilt[0]\n\n    def recur(self, node, tilt):\n        if not node:\n            return 0\n        left = self.recur(node.left, tilt)\n        right = self.recur(node.right, tilt)\n        tilt[0] += abs(left - right)\n        return left + right + node.val\n```\n\n\n\n# 623. 在二叉树中增加一行\n\nhttps://leetcode-cn.com/problems/add-one-row-to-tree/\n\n## 题目描述\n\n给定一个二叉树，根节点为第1层，深度为 1。在其第 `d` 层追加一行值为 `v` 的节点。\n\n添加规则：给定一个深度值 `d` （正整数），针对深度为 `d-1` 层的每一非空节点 `N`，为 `N` 创建两个值为 `v` 的左子树和右子树。\n\n将 `N` 原先的左子树，连接为新节点 `v` 的左子树；将 `N` 原先的右子树，连接为新节点 `v` 的右子树。\n\n如果 `d` 的值为 1，深度 d - 1 不存在，则创建一个新的根节点 `v`，原先的整棵树将作为 `v` 的左子树。\n\n示例 1:\n\n```\n输入: \n二叉树如下所示:\n       4\n     /   \\\n    2     6\n   / \\   / \n  3   1 5   \n\nv = 1\n\nd = 2\n\n输出: \n       4\n      / \\\n     1   1\n    /     \\\n   2       6\n  / \\     / \n 3   1   5  \n```\n\n示例 2:\n\n```\n输入: \n二叉树如下所示:\n      4\n     /   \n    2    \n   / \\   \n  3   1    \n\nv = 1\n\nd = 3\n\n输出: \n      4\n     /   \n    2\n   / \\    \n  1   1\n /     \\  \n3       1\n```\n\n\n注意:\n\n输入的深度值 d 的范围是：[1，二叉树最大深度 + 1]。\n输入的二叉树至少有一个节点。\n\n\n\n## 思路\n\n深度优先搜索(递归)，在访问到深度为 `d-1` 的节点则在它们下面增加子节点然后返回。\n\n注意 `d = 1` 的特殊情况和访问到空节点的情况。\n\n\n\n## 代码\n\n```python\nclass Solution:\n    def addOneRow(self, root: TreeNode, v: int, d: int) -> TreeNode:\n        if d == 1:\n            newnode = TreeNode(v)\n            newnode.left = root\n            root = newnode\n        else:\n            self.helper(root, d, v, 1)\n        return root\n    \n    def helper(self, node, d, v, depth):\n        if not node: return\n        if depth == d - 1:\n            lnode, rnode = node.left, node.right\n            n1, n2 = TreeNode(v), TreeNode(v)\n            n1.left, n2.right = lnode, rnode\n            node.left, node.right = n1, n2\n            return\n        self.helper(node.left, d, v, depth + 1)\n        self.helper(node.right, d, v, depth + 1)\n        return\n```\n\n\n\n# 637. 二叉树的层平均值\n\nhttps://leetcode-cn.com/problems/average-of-levels-in-binary-tree/\n\n## 题目描述\n\n给定一个非空二叉树, 返回一个由每层节点平均值组成的数组。\n\n \n\n示例 1：\n\n```\n输入：\n    3\n   / \\\n  9  20\n    /  \\\n   15   7\n输出：[3, 14.5, 11]\n解释：\n第 0 层的平均值是 3 ,  第1层是 14.5 , 第2层是 11 。因此返回 [3, 14.5, 11] 。\n```\n\n\n\n提示：\n\n节点值的范围在32位有符号整数范围内。\n\n\n\n## 思路\n\nBFS，套模板，逐层计算均值即可。\n\n\n\n## 代码\n\n```python\nclass Solution:\n    def averageOfLevels(self, root: TreeNode) -> List[float]:\n        queue = collections.deque()\n        queue.append(root)\n        ans = []\n        if root:\n            while queue:\n                size = len(queue)\n                s = 0\n                for _ in range(size):\n                    node = queue.popleft()\n                    s += node.val\n                    if node.left:\n                        queue.append(node.left)\n                    if node.right:\n                        queue.append(node.right)\n                if size:\n                    ans.append(s/size)\n        return ans\n```\n\n\n\n# 785. 判断二分图\n\nhttps://leetcode-cn.com/problems/is-graph-bipartite/\n\n## 题目描述\n\n给定一个无向图 `graph`，当这个图为二分图时返回 `true`。\n\n如果我们能将一个图的节点集合分割成两个独立的子集A和B，并使图中的每一条边的两个节点一个来自A集合，一个来自B集合，我们就将这个图称为二分图。\n\ngraph将会以邻接表方式给出，`graph[i]` 表示图中与节点 `i` 相连的所有节点。每个节点都是一个在 `0` 到 `graph.length-1` 之间的整数。这图中没有自环和平行边： `graph[i]` 中不存在 `i`，并且 `graph[i]` 中没有重复的值。\n\n```\n示例 1:\n输入: [[1,3], [0,2], [1,3], [0,2]]\n输出: true\n解释: \n无向图如下:\n0----1\n|    |\n|    |\n3----2\n我们可以将节点分成两组: {0, 2} 和 {1, 3}。\n```\n\n```\n示例 2:\n输入: [[1,2,3], [0,2], [0,1,3], [0,2]]\n输出: false\n解释: \n无向图如下:\n0----1\n| \\  |\n|  \\ |\n3----2\n我们不能将节点分割成两个独立的子集。\n```\n\n\n\n注意:\n\n* `graph` 的长度范围为 `[1, 100]`。\n* `graph[i]` 中的元素的范围为 `[0, graph.length - 1]`。\n* `graph[i]` 不会包含 `i` 或者有重复的值。\n* 图是无向的: 如果 `j` 在 `graph[i]` 里边, 那么 `i` 也会在 `graph[j]` 里边。\n\n\n\n## 思路\n\nBFS，遍历所有节点，用 `visited` 数组标记节点是否已经被访问（初始值为 `0`）：\n\n* 对当前未访问的节点 `i`，\n  1. 将 `visited[i]` 标记为 `1`；\n  2. 把 `i` 的相邻节点 `j` 标记为 `-1`，然后继续对 `j` 的相邻节点标记为 `-visited[j]`，直到所有连接在一起的节点都被访问；\n  3. 如果上一步在标记时，`i` 的某个相邻节点 `j` 的标记值 `visited[j] = visited[i]`，则说明无法将图中节点分割，返回 `false`。\n\n\n\n## 代码\n\n```python\nclass Solution:\n    def isBipartite(self, graph: List[List[int]]) -> bool:\n        visited = [0] * len(graph)\n        queue = collections.deque()\n        for i in range(len(graph)):\n            if visited[i] != 0:\n                continue              \n            visited[i] = 1\n            queue.append(i)\n            while queue:\n                cur = queue.popleft()\n                for node in graph[cur]:\n                    if visited[node] == 0:\n                        visited[node] = -visited[cur]\n                        queue.append(node)\n                    elif visited[node] == visited[cur]:\n                        return False\n        return True\n```\n\n\n\n# 974. 和可被 K 整除的子数组\n\nhttps://leetcode-cn.com/problems/subarray-sums-divisible-by-k/\n\n## 题目描述\n\n给定一个整数数组 A，返回其中元素之和可被 K 整除的（连续、非空）子数组的数目。\n\n \n\n示例：\n\n```\n输入：A = [4,5,0,-2,-3,1], K = 5\n输出：7\n解释：\n有 7 个子数组满足其元素之和可被 K = 5 整除：\n[4, 5, 0, -2, -3, 1], [5], [5, 0], [5, 0, -2, -3], [0], [0, -2, -3], [-2, -3]\n```\n\n\n\n\n提示：\n\n1. `1 <= A.length <= 30000`\n2. `-10000 <= A[i] <= 10000`\n3. `2 <= K <= 10000`\n\n\n\n## 思路\n\n一个前缀和的问题。设 $\\rm presum[i]$是数组 $\\rm A$ 第 $\\rm i$ 个元素的前缀和，那么 $\\rm A[i]$ 就可以表示为 $\\rm presum[i] - presum[i-1]$，子数组 $\\rm A[k]$ 到 $\\rm A[i]$ 的和就是 $\\rm presum[i] - presum[k-1]$。\n\n题目要求的是满足 $\\rm presum[i] - presum[k-1] \\bmod K = 0$ 的子数组 $\\rm [A[k],...,A[i]]$ 的个数，根据同余定理，可以把问题转换为求同余的 $\\rm presum[i]$ 的个数。每扫描到数组中的一个数，就检查哈希表中有没有同余的数组，若有则计算同余的数量，若无把当前模 $\\rm K$ 的余数保存在哈希表中，一次遍历即可解决问题。\n\n\n\n## 代码\n\n```python\nclass Solution:\n    def subarraysDivByK(self, A: List[int], K: int) -> int:\n        if len(A)==0 or K==0:\n            return 0\n        d = {0:1}\n        presum, cnt = 0, 0\n        for a in A:\n            presum += a\n            m = presum % K\n            s = d.get(m, 0)\n            cnt += s\n            d[m] = s + 1\n        return cnt\n```\n\n\n\n# 994. 腐烂的橘子\n\nhttps://leetcode-cn.com/problems/rotting-oranges/\n\n## 题目描述\n\n在给定的网格中，每个单元格可以有以下三个值之一：\n\n值 `0` 代表空单元格；\n值 `1` 代表新鲜橘子；\n值 `2` 代表腐烂的橘子。\n每分钟，任何与腐烂的橘子（在 4 个正方向上）相邻的新鲜橘子都会腐烂。\n\n返回直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 `-1`。\n\n \n\n示例 1：\n\n![](http://images.yingwai.top/picgo/oranges.png)\n\n```\n输入：[[2,1,1],[1,1,0],[0,1,1]]\n输出：4\n```\n\n\n\n示例 2：\n\n```\n输入：[[2,1,1],[0,1,1],[1,0,1]]\n输出：-1\n解释：左下角的橘子（第 2 行， 第 0 列）永远不会腐烂，因为腐烂只会发生在 4 个正向上。\n```\n\n示例 3：\n\n```\n输入：[[0,2]]\n输出：0\n解释：因为 0 分钟时已经没有新鲜橘子了，所以答案就是 0 。\n```\n\n\n提示：\n\n1. `1 <= grid.length <= 10`\n2. `1 <= grid[0].length <= 10`\n3. `grid[i][j]`仅为`0`、`1`或`2`\n\n\n\n## 思路\n\n广度优先搜索，一圈一圈往外腐蚀。\n\n\n\n## 代码\n\n```python\nclass Solution:\n    def orangesRotting(self, grid: List[List[int]]) -> int:\n        dx = [-1, 1, 0, 0]\n        dy = [0, 0, -1, 1]\n        rotlist = list()    # 腐烂橘子的队列\n        minute = 0\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j] == 2:\n                    rotlist.append([i, j])\n\n        while rotlist:  # BFS循环\n            newrotlist = list()\n            for rotorange in rotlist:   # 当前腐烂橘子的坐标\n                x0 = rotorange[0]\n                y0 = rotorange[1]\n\n                for i in range(4):  # 四个相邻方向的橘子腐烂\n                    x = x0 + dx[i]\n                    y = y0 + dy[i]\n                    if 0<=x<len(grid) and 0<=y<len(grid[0]) and grid[x][y]==1:\n                        grid[x][y] = 2\n                        newrotlist.append([x, y])\n\n            if not newrotlist:\n                break\n\n            minute += 1\n            rotlist = newrotlist[:]     # 更新腐烂队列\n\n        for row in grid:\n                for i in row:\n                    if i == 1:  # 还有新鲜的\n                        return -1\n\n        return minute\n```\n\n\n\n# 1305. 两棵二叉搜索树中的所有元素\n\nhttps://leetcode-cn.com/problems/all-elements-in-two-binary-search-trees/\n\n## 题目描述\n\n给你 root1 和 root2 这两棵二叉搜索树。\n\n请你返回一个列表，其中包含 两棵树 中的所有整数并按 升序 排序。\n\n \n\n示例 1：\n\n![](http://images.yingwai.top/picgo/lc1305f1.png)\n\n```\n输入：root1 = [2,1,4], root2 = [1,0,3]\n输出：[0,1,1,2,3,4]\n```\n\n示例 2：\n\n```\n输入：root1 = [0,-10,10], root2 = [5,1,7,0,2]\n输出：[-10,0,0,1,2,5,7,10]\n```\n\n示例 3：\n\n```\n输入：root1 = [], root2 = [5,1,7,0,2]\n输出：[0,1,2,5,7]\n```\n\n示例 4：\n\n```\n输入：root1 = [0,-10,10], root2 = []\n输出：[-10,0,10]\n```\n\n示例 5：\n\n![](http://images.yingwai.top/picgo/lc1305f2.png)\n\n```\n输入：root1 = [1,null,8], root2 = [8,1]\n输出：[1,1,8,8]\n```\n\n\n\n\n提示：\n\n* 每棵树最多有 `5000` 个节点。\n* 每个节点的值在 `[-10^5, 10^5]` 之间。\n\n\n\n## 思路\n\n利用二叉搜索树性质，中序遍历得到每棵树的节点值的升序排列，然后再使用归并排序得到最终的结果数组。\n\n* 时间复杂度 $O(M + N)$，中序遍历和归并排序都是 $O(M + N)$，其中 $M,N$ 分别为两棵树的节点个数；\n* 空间复杂度 $O(M+N)$，用到两个额外的数组来存储每棵树的升序排列。\n\n\n\n## 代码\n\n```python\nclass Solution:\n    def getAllElements(self, root1: TreeNode, root2: TreeNode) -> List[int]:\n        t1, t2 = [], []\n        ans = []\n        self.helper(root1, t1)\n        self.helper(root2, t2)\n        i, j = 0, 0\n        while i < len(t1) or j < len(t2):\n            if i < len(t1) and (j == len(t2) or t1[i] < t2[j]):\n                ans.append(t1[i])\n                i += 1\n            else:\n                ans.append(t2[j])\n                j += 1\n        return ans\n        \n    def helper(self, node, t):\n        if not node: return\n        self.helper(node.left, t)\n        t.append(node.val)\n        self.helper(node.right, t)\n        return\n```\n\n\n\n# 面试题 16.11. 跳水板\n\nhttps://leetcode-cn.com/problems/diving-board-lcci/\n\n## 题目描述\n\n你正在使用一堆木板建造跳水板。有两种类型的木板，其中长度较短的木板长度为`shorter`，长度较长的木板长度为`longer`。你必须正好使用`k`块木板。编写一个方法，生成跳水板所有可能的长度。\n\n返回的长度需要从小到大排列。\n\n示例：\n\n```\n输入：\nshorter = 1\nlonger = 2\nk = 3\n输出： {3,4,5,6}\n```\n\n提示：\n\n* 0 < shorter <= longer\n* 0 <= k <= 100000\n\n\n\n## 思路\n\n因为每次都必须要正好使用 `k` 块木板，所以有以下公式\n$$\nans[i] = shorter\\times i + longer \\times (k-i)\n$$\n其中 $0 \\leq i \\leq k$。\n\n在 $longer > shorter$ 的情况下，为什么每种组合下建造的跳水板长度都是不一样的？考虑以下两种不同的组合：第一种组合，有 $i$ 块短木板，则跳水板的长度是 $shorter \\times i + longer \\times (k−i)$；第二种组合，有 $j$ 块短木板，则跳水板的长度是 $shorter \\times j+longer \\times (k−j)$。其中 $0 \\leq i<j \\leq k$。则两种不同的组合下的跳水板长度之差为：\n$$\n(shorter \\times j+longer \\times (k−j)) - (shorter \\times i + longer \\times (k−i)) = (longer - shorter) \\times (i - j)\n$$\n因为 $longer > shorter$ 且 $i<j$，因此上式 $<0$。\n\n然后要考虑到极端情况：\n\n* $k = 0$：直接输出空列表。\n* $longer = shorter$：输出列表中只有一个元素 $ans = [shorter(longer) \\times k]$。\n\n\n\n## 代码\n\n```python\nclass Solution:\n    def divingBoard(self, shorter: int, longer: int, k: int) -> List[int]:\n        ans = []\n        if k > 0:\n            s, l = k, 0\n            if shorter == longer:\n                ans.append(shorter*s)\n            else:\n                while l <= k:\n                    ans.append(shorter*s + longer*l)\n                    s -= 1\n                    l += 1\n        return ans\n```\n\n\n\n# 面试题 17. 12. BiNode\n\nhttps://leetcode-cn.com/problems/binode-lcci/\n\n## 题目描述\n\n二叉树数据结构 `TreeNode` 可用来表示单向链表（其中 `left` 置空，`right` 为下一个链表节点）。实现一个方法，把二叉搜索树转换为单向链表，要求依然符合二叉搜索树的性质，转换操作应是原址的，也就是在原始的二叉搜索树上直接修改。\n\n返回转换后的单向链表的头节点。\n\n注意：本题相对原题稍作改动\n\n \n\n示例：\n\n```\n输入： [4,2,5,1,3,null,6,0]\n输出： [0,null,1,null,2,null,3,null,4,null,5,null,6]\n```\n\n提示：\n\n* 节点数量不会超过 100000。\n\n\n\n## 思路\n\n中序遍历，用 `pre` 记录上一个处理的节点，访问到一个新的节点 `p` 时，将 `pre.right` 指向 `p` 并把 `p.left` 置空。\n\n注意要将第一个处理的节点作为根节点。\n\n\n\n## 代码\n\n```python\nclass Solution:\n    def convertBiNode(self, root: TreeNode) -> TreeNode:\n        if not root:\n            return\n        s = []\n        p, pre = root, None\n        while s or p:\n            while p:\n                s.append(p)\n                p = p.left\n            p = s.pop()\n            if not pre:\n                root = p\n                root.left = None\n            else:\n                pre.right = p\n                p.left = None\n            pre = p\n            p = p.right\n        return root\n```\n\n\n\n# 面试题 17.13. 恢复空格\n\nhttps://leetcode-cn.com/problems/re-space-lcci/\n\n## 题目描述\n\n哦，不！你不小心把一个长篇文章中的空格、标点都删掉了，并且大写也弄成了小写。像句子`\"I reset the computer. It still didn’t boot!\"`已经变成了`\"iresetthecomputeritstilldidntboot\"`。在处理标点符号和大小写之前，你得先把它断成词语。当然了，你有一本厚厚的词典`dictionary`，不过，有些词没在词典里。假设文章用`sentence`表示，设计一个算法，把文章断开，要求未识别的字符最少，返回未识别的字符数。\n\n注意：本题相对原题稍作改动，只需返回未识别的字符数\n\n \n\n示例：\n\n```\n输入：\ndictionary = [\"looked\",\"just\",\"like\",\"her\",\"brother\"]\nsentence = \"jesslookedjustliketimherbrother\"\n输出： 7\n解释： 断句后为\"jess looked just like tim her brother\"，共7个未识别字符。\n```\n\n提示：\n\n* `0 <= len(sentence) <= 1000`\n* `dictionary`中总字符数不超过 `150000`。\n* 你可以认为`dictionary`和`sentence`中只包含小写字母。\n\n\n\n## 思路\n\n动态规划，用 $dp[i]$ 表示`sentence`中以第 $index$ 个字符结尾的字符串中未识别的字符数，其中 $i = index + 1$（这里令 $dp[0]=0$，因为可能出现前 $k$ 个字符组成一个词，这样做利于判断）。对于每个 $index$，都对`dictionary`进行一次遍历，用 $len$ 表示`dictionary`中每个词的长度，则可以得到动态方程：\n\n每扫描到一个 $i$，都先把 $dp[i]$ 初始化为 $i$，然后有\n\n当`sentence`中第 $index - len + 1$ 到 第 $index$ 个字符在`dictionary`中时，\n$$\ndp[i] = \\min (dp[i],dp[i-len])\n$$\n其它情况，\n$$\ndp[i] = (dp[i], dp[i-1]+1)\n$$\n最后 $dp$ 数组中的最后一个元素即为结果。\n\n\n\n## 代码\n\n```python\nclass Solution:\n    def respace(self, dictionary: List[str], sentence: str) -> int:\n        dp = []\n        dp.append(0)\n        for i in range(1, len(sentence)+1):\n            index = i - 1\n            t = i\n            for word in dictionary:\n                l = len(word)\n                if index + 1 - l >= 0 and sentence[index-l+1:index+1] in dictionary:\n                    t = min(t, dp[i-l])\n                    if i - l == 0:\n                        break\n                t = min(t, dp[i-1]+1)\n            dp.append(t)\n        return dp[len(sentence)]\n```\n\n","slug":"LeetCode刷题","published":1,"updated":"2020-08-23T14:33:37.430Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cke79q4tv004w88psb6v2hppz","content":"<p>记录一下每日刷题 $\\surd$</p>\n<a id=\"more\"></a>\n<p>[TOC]</p>\n<h1 id=\"4-寻找两个正序数组的中位数\"><a href=\"#4-寻找两个正序数组的中位数\" class=\"headerlink\" title=\"4. 寻找两个正序数组的中位数\"></a>4. 寻找两个正序数组的中位数</h1><p><a href=\"https://leetcode-cn.com/problems/median-of-two-sorted-arrays/\" target=\"_blank\" rel=\"noopener\">https://leetcode-cn.com/problems/median-of-two-sorted-arrays/</a></p>\n<h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>给定两个大小为 m 和 n 的正序（从小到大）数组 <code>nums1</code> 和 <code>nums2</code>。</p>\n<p>请你找出这两个正序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。</p>\n<p>你可以假设 <code>nums1</code> 和 <code>nums2</code> 不会同时为空。</p>\n<p>示例 1:</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nums1 = [<span class=\"number\">1</span>, <span class=\"number\">3</span>]</span><br><span class=\"line\">nums2 = [<span class=\"number\">2</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">则中位数是 <span class=\"number\">2.0</span></span><br></pre></td></tr></table></figure>\n<p>示例 2:</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nums1 = [<span class=\"number\">1</span>, <span class=\"number\">2</span>]</span><br><span class=\"line\">nums2 = [<span class=\"number\">3</span>, <span class=\"number\">4</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">则中位数是 (<span class=\"number\">2</span> + <span class=\"number\">3</span>)/<span class=\"number\">2</span> = <span class=\"number\">2.5</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>题目要求时间复杂度为 O(log(m + n))，知道要用二分查找，但是具体方法想不出来，只能看了一篇题解中的<a href=\"https://leetcode-cn.com/problems/median-of-two-sorted-arrays/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-w-2/\" target=\"_blank\" rel=\"noopener\">找第 k 小的数的方法</a>。</p>\n<p>主要思想是：</p>\n<ul>\n<li>比较两个数组的第 <code>k/2</code> 个数字（向下取整），哪个小则可以直接排除那个数组的前 <code>k/2</code> 个数字（因为两个数组都是有序的）；</li>\n<li>上一步已经排除了 <code>k/2</code> 个数，因此 <code>k = k - k/2</code>，再次比较两个数组（其中一个数组为排除了 <code>k/2</code> 个数后的新数组）的第 <code>k/2</code> 个数字，直到 <code>k = 1</code> 或其中一个数组中的元素被全部排除了：<ol>\n<li>若 <code>k = 1</code> 则返回当前两个数组的第一个元素中较小的那一个；</li>\n<li>若其中一个数组被全部排除，则返回另一个数组中的第 <code>k</code> 个元素。</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">findMedianSortedArrays</span><span class=\"params\">(self, nums1: List[int], nums2: List[int])</span> -&gt; float:</span></span><br><span class=\"line\">        n, m = len(nums1), len(nums2)</span><br><span class=\"line\">        left = (n + m + <span class=\"number\">1</span>) // <span class=\"number\">2</span></span><br><span class=\"line\">        right = (n + m + <span class=\"number\">2</span>) // <span class=\"number\">2</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> (self.recur(left, nums1, <span class=\"number\">0</span>, n<span class=\"number\">-1</span>, nums2, <span class=\"number\">0</span>, m<span class=\"number\">-1</span>) + self.recur(right, nums1, <span class=\"number\">0</span>, n<span class=\"number\">-1</span>, nums2, <span class=\"number\">0</span>, m<span class=\"number\">-1</span>)) * <span class=\"number\">0.5</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">recur</span><span class=\"params\">(self, k, arr1, s1, e1, arr2, s2, e2)</span>:</span></span><br><span class=\"line\">        l1 = e1 - s1 + <span class=\"number\">1</span></span><br><span class=\"line\">        l2 = e2 - s2 + <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> l1 &gt; l2:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> self.recur(k, arr2, s2, e2, arr1, s1, e1)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> l1 == <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> arr2[s2+k<span class=\"number\">-1</span>]</span><br><span class=\"line\">        <span class=\"keyword\">if</span> k == <span class=\"number\">1</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> min(arr1[s1], arr2[s2])</span><br><span class=\"line\">        p1 = s1 + min(k//<span class=\"number\">2</span>, l1) - <span class=\"number\">1</span></span><br><span class=\"line\">        p2 = s2 + min(k//<span class=\"number\">2</span>, l2) - <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> arr1[p1] &lt; arr2[p2]:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> self.recur(k-min(k//<span class=\"number\">2</span>, l1), arr1, p1+<span class=\"number\">1</span>, e1, arr2, s2, e2)</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> self.recur(k-min(k//<span class=\"number\">2</span>, l2), arr1, s1, e1, arr2, p2+<span class=\"number\">1</span>, e2)</span><br></pre></td></tr></table></figure>\n<h1 id=\"6-Z字形变换\"><a href=\"#6-Z字形变换\" class=\"headerlink\" title=\"6. Z字形变换\"></a>6. Z字形变换</h1><p><a href=\"https://leetcode-cn.com/problems/zigzag-conversion/\" target=\"_blank\" rel=\"noopener\">https://leetcode-cn.com/problems/zigzag-conversion/</a></p>\n<h2 id=\"题目描述-1\"><a href=\"#题目描述-1\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。</p>\n<p>比如输入字符串为 <code>&quot;LEETCODEISHIRING&quot;</code> 行数为 3 时，排列如下：</p>\n<figure class=\"highlight julia\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">L   C   <span class=\"literal\">I</span>   R</span><br><span class=\"line\">E T O E S <span class=\"literal\">I</span> <span class=\"literal\">I</span> G</span><br><span class=\"line\">E   D   H   N</span><br></pre></td></tr></table></figure>\n<p>之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：<code>&quot;LCIRETOESIIGEDHN&quot;</code>。</p>\n<p>请你实现这个将字符串进行指定行数变换的函数：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">convert</span><span class=\"params\">(<span class=\"built_in\">string</span> s, <span class=\"keyword\">int</span> numRows)</span></span>;</span><br></pre></td></tr></table></figure>\n<p>示例 1:</p>\n<figure class=\"highlight nix\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: <span class=\"attr\">s</span> = <span class=\"string\">\"LEETCODEISHIRING\"</span>, <span class=\"attr\">numRows</span> = <span class=\"number\">3</span></span><br><span class=\"line\">输出: <span class=\"string\">\"LCIRETOESIIGEDHN\"</span></span><br></pre></td></tr></table></figure>\n<p>示例 2:</p>\n<figure class=\"highlight julia\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: s = <span class=\"string\">\"LEETCODEISHIRING\"</span>, numRows = <span class=\"number\">4</span></span><br><span class=\"line\">输出: <span class=\"string\">\"LDREOEIIECIHNTSG\"</span></span><br><span class=\"line\">解释:</span><br><span class=\"line\"></span><br><span class=\"line\">L     D     R</span><br><span class=\"line\">E   O E   <span class=\"literal\">I</span> <span class=\"literal\">I</span></span><br><span class=\"line\">E C   <span class=\"literal\">I</span> H   N</span><br><span class=\"line\">T     S     G</span><br></pre></td></tr></table></figure>\n<h2 id=\"思路-1\"><a href=\"#思路-1\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>用一个二维列表 <code>tmp</code> 存储 Z 字形字符串中每一行的元素，最后将 <code>tmp</code> 中的字符串逐行拼接即得到结果，具体步骤如下：</p>\n<ul>\n<li>从头到尾遍历<code>s</code>，<code>cnt</code> 表示当前字符的下标，<code>curRow</code> 表示当前字符 <code>s[cnt]</code> 在 Z 字形字符串中所在的行数，<code>step</code> 表示当前的方向（因为 Z 字形中字符都是往上往下这样循环）；</li>\n<li>将 <code>s[cnt]</code> 加入 <code>tmp[curRow]</code>，然后 <code>cnt</code> 自增 1，<code>curRow</code> 自增 <code>step</code>。当 <code>curRow</code> 为 <code>0</code> 或 <code>numRows</code> 时，转换方向，<code>step *= -1</code> 。</li>\n</ul>\n<h2 id=\"代码-1\"><a href=\"#代码-1\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">convert</span><span class=\"params\">(self, s: str, numRows: int)</span> -&gt; str:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> numRows == <span class=\"number\">1</span>: <span class=\"keyword\">return</span> s</span><br><span class=\"line\">        tmp = [<span class=\"string\">\"\"</span> <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(numRows)]</span><br><span class=\"line\">        cnt = curRow = <span class=\"number\">0</span></span><br><span class=\"line\">        step = <span class=\"number\">-1</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> cnt &lt; len(s):</span><br><span class=\"line\">            tmp[curRow] += s[cnt]</span><br><span class=\"line\">            cnt += <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> curRow == numRows - <span class=\"number\">1</span> <span class=\"keyword\">or</span> curRow == <span class=\"number\">0</span>:</span><br><span class=\"line\">                step *= <span class=\"number\">-1</span></span><br><span class=\"line\">            curRow += step</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">''</span>.join(tmp)</span><br></pre></td></tr></table></figure>\n<h1 id=\"14-最长公共前缀\"><a href=\"#14-最长公共前缀\" class=\"headerlink\" title=\"14. 最长公共前缀\"></a>14. 最长公共前缀</h1><p><a href=\"https://leetcode-cn.com/problems/longest-common-prefix/\" target=\"_blank\" rel=\"noopener\">https://leetcode-cn.com/problems/longest-common-prefix/</a></p>\n<h2 id=\"题目描述-2\"><a href=\"#题目描述-2\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>编写一个函数来查找字符串数组中的最长公共前缀。</p>\n<p>如果不存在公共前缀，返回空字符串 <code>&quot;&quot;</code>。</p>\n<p>示例 1:</p>\n<figure class=\"highlight prolog\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: [<span class=\"string\">\"flower\"</span>,<span class=\"string\">\"flow\"</span>,<span class=\"string\">\"flight\"</span>]</span><br><span class=\"line\">输出: <span class=\"string\">\"fl\"</span></span><br></pre></td></tr></table></figure>\n<p>示例 2:</p>\n<figure class=\"highlight prolog\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: [<span class=\"string\">\"dog\"</span>,<span class=\"string\">\"racecar\"</span>,<span class=\"string\">\"car\"</span>]</span><br><span class=\"line\">输出: <span class=\"string\">\"\"</span></span><br><span class=\"line\">解释: 输入不存在公共前缀。</span><br></pre></td></tr></table></figure>\n<p>说明:</p>\n<p>所有输入只包含小写字母 <code>a-z</code> 。</p>\n<h2 id=\"思路-2\"><a href=\"#思路-2\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>Python中的<code>max()</code>和<code>min()</code>可以比较字符串，按照ASCII值逐位比较：比如<code>cba</code>、<code>cbab</code>、<code>cbd</code>中最大为<code>cbd</code>，最小为<code>cba</code>。因此只要比较最大最小的两个字符串即可找到最大公共前缀。</p>\n<h2 id=\"代码-2\"><a href=\"#代码-2\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">longestCommonPrefix</span><span class=\"params\">(self, strs: List[str])</span> -&gt; str:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> strs: <span class=\"keyword\">return</span> <span class=\"string\">\"\"</span></span><br><span class=\"line\">        str1 = min(strs)</span><br><span class=\"line\">        str2 = max(strs)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i,x <span class=\"keyword\">in</span> enumerate(str1):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> x != str2[i]:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> str2[:i]</span><br><span class=\"line\">        <span class=\"keyword\">return</span> str1</span><br></pre></td></tr></table></figure>\n<h1 id=\"21-合并两个有序链表\"><a href=\"#21-合并两个有序链表\" class=\"headerlink\" title=\"21. 合并两个有序链表\"></a>21. 合并两个有序链表</h1><p><a href=\"https://leetcode-cn.com/problems/merge-two-sorted-lists/\" target=\"_blank\" rel=\"noopener\">https://leetcode-cn.com/problems/merge-two-sorted-lists/</a></p>\n<h2 id=\"题目描述-3\"><a href=\"#题目描述-3\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p>\n<p>示例：</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：<span class=\"number\">1</span>-&gt;<span class=\"number\">2</span>-&gt;<span class=\"number\">4</span>, <span class=\"number\">1</span>-&gt;<span class=\"number\">3</span>-&gt;<span class=\"number\">4</span></span><br><span class=\"line\">输出：<span class=\"number\">1</span>-&gt;<span class=\"number\">1</span>-&gt;<span class=\"number\">2</span>-&gt;<span class=\"number\">3</span>-&gt;<span class=\"number\">4</span>-&gt;<span class=\"number\">4</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"思路-3\"><a href=\"#思路-3\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>因为链表有序，可以用两个指针分别遍历两个链表，将两个指针指向的节点中值较小的节点加入到新链表中，然后该指针往后挪，直到遍历完两个链表。</p>\n<p>时间复杂度为 O(M + N)，M 和 N 分别为两个链表的长度。</p>\n<h2 id=\"代码-3\"><a href=\"#代码-3\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">mergeTwoLists</span><span class=\"params\">(self, l1: ListNode, l2: ListNode)</span> -&gt; ListNode:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> l1 <span class=\"keyword\">and</span> <span class=\"keyword\">not</span> l2: <span class=\"keyword\">return</span> <span class=\"literal\">None</span></span><br><span class=\"line\">        p1, p2 = l1, l2</span><br><span class=\"line\">        pre = <span class=\"literal\">None</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> p1 <span class=\"keyword\">and</span> p2:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> p2.val &lt; p1.val:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> pre:</span><br><span class=\"line\">                    root = p2</span><br><span class=\"line\">                    pre = root</span><br><span class=\"line\">                <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                    pre.next = p2</span><br><span class=\"line\">                    pre = p2</span><br><span class=\"line\">                p2 = p2.next</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> pre:</span><br><span class=\"line\">                    root = p1</span><br><span class=\"line\">                    pre = root</span><br><span class=\"line\">                <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                    pre.next = p1</span><br><span class=\"line\">                    pre = p1</span><br><span class=\"line\">                p1 = p1.next</span><br><span class=\"line\">        <span class=\"keyword\">if</span> p1:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> pre:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> p1</span><br><span class=\"line\">            pre.next = p1</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> pre:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> p2</span><br><span class=\"line\">            pre.next = p2</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root</span><br></pre></td></tr></table></figure>\n<h1 id=\"32-最长有效括号\"><a href=\"#32-最长有效括号\" class=\"headerlink\" title=\"32. 最长有效括号\"></a>32. 最长有效括号</h1><p><a href=\"https://leetcode-cn.com/problems/longest-valid-parentheses/\" target=\"_blank\" rel=\"noopener\">https://leetcode-cn.com/problems/longest-valid-parentheses/</a></p>\n<h2 id=\"题目描述-4\"><a href=\"#题目描述-4\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>给定一个只包含 <code>&#39;(&#39;</code> 和 <code>&#39;)&#39;</code> 的字符串，找出最长的包含有效括号的子串的长度。</p>\n<p>示例 1:</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">输入: \"(()\"</span></span><br><span class=\"line\"><span class=\"section\">输出: 2</span></span><br><span class=\"line\"><span class=\"section\">解释: 最长有效括号子串为 \"()\"</span></span><br></pre></td></tr></table></figure>\n<p>示例 2:</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">输入: \")()())\"</span></span><br><span class=\"line\"><span class=\"section\">输出: 4</span></span><br><span class=\"line\"><span class=\"section\">解释: 最长有效括号子串为 \"()()\"</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"思路-4\"><a href=\"#思路-4\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>动态规划：用 $dp[i]$ 表示字符串中以第 $i$ 个字符结尾的字符串的最大有效子串长度。根据题意，$s[i]$ 为 <code>&#39;(&#39;</code> 时 $dp[i]=0$，有效的子串结尾肯定是 <code>&#39;)&#39;</code>，可列出动态方程：</p>\n<p>当 $s[i]$ 为 <code>&#39;)&#39;</code> 且 $s[i-1]$ 为 <code>&#39;(&#39;</code> 时，也就是 “$……()$”，</p>\n<script type=\"math/tex; mode=display\">\ndp[i] = dp[i-2] + 2</script><p>当 $s[i]$ 为 <code>&#39;)&#39;</code> 且 $s[i-1]$ 为 <code>&#39;)&#39;</code> 时，也就是 “$……))$”，如果倒数第二个 <code>&#39;)&#39;</code> 是一个有效字符串 $sub_s$ 的一部分，且 $s[i-\\mbox{len}(sub_s)-1]$ 为 <code>&#39;(&#39;</code> 。此时的最长有效子串的长度即为 $sub_s$ 加上 $2$ 再加上 $dp[i-\\mbox{len}(sub_s)-2]$：</p>\n<script type=\"math/tex; mode=display\">\ndp[i] = dp[i-1] + 2 + dp[i-dp[i-1]-2]</script><p>最后的结果为 $dp$ 数组中的最大值。</p>\n<p>上面两条方程都要注意判断下标 $i-2$ 和 $i-dp[i-1]-2$ 的值，不要小于 $0$。</p>\n<h2 id=\"代码-4\"><a href=\"#代码-4\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">longestValidParentheses</span><span class=\"params\">(self, s: str)</span> -&gt; int:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> len(s) &lt;= <span class=\"number\">1</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">        dp = [<span class=\"number\">0</span>]</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, len(s)):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> s[i] == <span class=\"string\">')'</span>:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> s[i<span class=\"number\">-1</span>] == <span class=\"string\">'('</span>:</span><br><span class=\"line\">                    dp.append(dp[max(i<span class=\"number\">-2</span>, <span class=\"number\">0</span>)] + <span class=\"number\">2</span>)</span><br><span class=\"line\">                <span class=\"keyword\">elif</span> s[i<span class=\"number\">-1</span>] == <span class=\"string\">')'</span> <span class=\"keyword\">and</span> i-dp[i<span class=\"number\">-1</span>]<span class=\"number\">-1</span> &gt;= <span class=\"number\">0</span> <span class=\"keyword\">and</span> s[i-dp[i<span class=\"number\">-1</span>]<span class=\"number\">-1</span>] == <span class=\"string\">'('</span>:</span><br><span class=\"line\">                    dp.append(dp[i<span class=\"number\">-1</span>] + <span class=\"number\">2</span> + dp[max(i-dp[i<span class=\"number\">-1</span>]<span class=\"number\">-2</span>, <span class=\"number\">0</span>)])</span><br><span class=\"line\">                <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                    dp.append(<span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                dp.append(<span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> max(dp)</span><br></pre></td></tr></table></figure>\n<h1 id=\"35-搜索插入位置\"><a href=\"#35-搜索插入位置\" class=\"headerlink\" title=\"35. 搜索插入位置\"></a>35. 搜索插入位置</h1><p><a href=\"https://leetcode-cn.com/problems/search-insert-position/\" target=\"_blank\" rel=\"noopener\">https://leetcode-cn.com/problems/search-insert-position/</a></p>\n<h2 id=\"题目描述-5\"><a href=\"#题目描述-5\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p>\n<p>你可以假设数组中无重复元素。</p>\n<p>示例 1:</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: [<span class=\"number\">1</span>,<span class=\"number\">3</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>], <span class=\"number\">5</span></span><br><span class=\"line\">输出: <span class=\"number\">2</span></span><br></pre></td></tr></table></figure>\n<p>示例 2:</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: [<span class=\"number\">1</span>,<span class=\"number\">3</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>], <span class=\"number\">2</span></span><br><span class=\"line\">输出: <span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n<p>示例 3:</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: [<span class=\"number\">1</span>,<span class=\"number\">3</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>], <span class=\"number\">7</span></span><br><span class=\"line\">输出: <span class=\"number\">4</span></span><br></pre></td></tr></table></figure>\n<p>示例 4:</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: [<span class=\"number\">1</span>,<span class=\"number\">3</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>], <span class=\"number\">0</span></span><br><span class=\"line\">输出: <span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"思路-5\"><a href=\"#思路-5\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>二分查找，每次排除当前数组中一半的元素。</p>\n<p>注意递归边界为 <code>left &gt;= right</code>，<code>target</code> 在 <code>nums</code> 不存在有两种情况：</p>\n<ul>\n<li>当 <code>left &gt; right</code> 时，数组 <code>nums</code> 中不存在与 <code>target</code> 相等的元素，此时 <code>nums[left]</code> 为 <code>nums</code> 中第一个大于 <code>target</code> 的元素，<code>left</code> 即为 <code>target</code> 应该插入的位置；</li>\n<li>当 <code>left == right</code> 时，此时 <code>left</code> 和 <code>right</code> 应该都指向 <code>nums</code> 中最后一个元素（因为 <code>mid</code> 总是向下取整，这种情况下 <code>left</code> 每次都 <code>+1</code>，直到指向最后一个元素），此时需要额外判断 <code>target</code> 与最后一个元素的大小，<code>target</code> 大则将其插入到数组末尾。</li>\n</ul>\n<h2 id=\"代码-5\"><a href=\"#代码-5\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">searchInsert</span><span class=\"params\">(self, nums: List[int], target: int)</span> -&gt; int:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.getInsertIndex(nums, <span class=\"number\">0</span>, len(nums)<span class=\"number\">-1</span>, target)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">getInsertIndex</span><span class=\"params\">(self, nums, left, right, target)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> left &gt;= right:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> target &gt; nums[left]:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> left + <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> left</span><br><span class=\"line\">        mid = (left + right) // <span class=\"number\">2</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> target == nums[mid]:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> mid</span><br><span class=\"line\">        <span class=\"keyword\">if</span> target &lt; nums[mid]:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> self.getInsertIndex(nums, left, mid<span class=\"number\">-1</span>, target)</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> self.getInsertIndex(nums, mid+<span class=\"number\">1</span>, right, target)</span><br></pre></td></tr></table></figure>\n<h1 id=\"94-二叉树的中序遍历\"><a href=\"#94-二叉树的中序遍历\" class=\"headerlink\" title=\"94. 二叉树的中序遍历\"></a>94. 二叉树的中序遍历</h1><p><a href=\"https://leetcode-cn.com/problems/binary-tree-inorder-traversal/\" target=\"_blank\" rel=\"noopener\">https://leetcode-cn.com/problems/binary-tree-inorder-traversal/</a></p>\n<h2 id=\"题目描述-6\"><a href=\"#题目描述-6\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>给定一个二叉树，返回它的中序 遍历。</p>\n<p>示例:</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: [<span class=\"number\">1</span>,<span class=\"literal\">null</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]</span><br><span class=\"line\">   <span class=\"number\">1</span></span><br><span class=\"line\">    \\</span><br><span class=\"line\">     <span class=\"number\">2</span></span><br><span class=\"line\">    /</span><br><span class=\"line\">   <span class=\"number\">3</span></span><br><span class=\"line\"></span><br><span class=\"line\">输出: [<span class=\"number\">1</span>,<span class=\"number\">3</span>,<span class=\"number\">2</span>]</span><br></pre></td></tr></table></figure>\n<p>进阶: 递归算法很简单，你可以通过迭代算法完成吗？</p>\n<h2 id=\"思路-6\"><a href=\"#思路-6\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>这里可以用两种方法，递归和迭代，前者比较简单就不说了，主要讲后者。</p>\n<p>迭代算法中需要用到一个栈，每到一个节点先将其入栈，遍历其左子树，然后访问该节点，访问完后该节点就可以出栈了，最后遍历其右子树。</p>\n<h2 id=\"代码-6\"><a href=\"#代码-6\" class=\"headerlink\" title=\"代码\"></a>代码</h2><p>数据结构：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"># class TreeNode:</span></span><br><span class=\"line\"><span class=\"comment\">#     def __init__(self, x):</span></span><br><span class=\"line\"><span class=\"comment\">#         self.val = x</span></span><br><span class=\"line\"><span class=\"comment\">#         self.left = None</span></span><br><span class=\"line\"><span class=\"comment\">#         self.right = None</span></span><br></pre></td></tr></table></figure>\n<p>递归：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">inorderTraversal</span><span class=\"params\">(self, root: TreeNode)</span> -&gt; List[int]:</span></span><br><span class=\"line\">        ans = []</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">helper</span><span class=\"params\">(root)</span>:</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> root:</span><br><span class=\"line\">                helper(root.left)</span><br><span class=\"line\">                ans.append(root.val)</span><br><span class=\"line\">                helper(root.right)</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\"></span><br><span class=\"line\">        helper(root)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<p>迭代：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">inorderTraversal</span><span class=\"params\">(self, root: TreeNode)</span> -&gt; List[int]:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> root:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> []</span><br><span class=\"line\">        ans, v = [], []</span><br><span class=\"line\">        cur = root</span><br><span class=\"line\">        <span class=\"keyword\">while</span> cur <span class=\"keyword\">or</span> v:</span><br><span class=\"line\">            <span class=\"keyword\">while</span> cur:</span><br><span class=\"line\">                v.append(cur)</span><br><span class=\"line\">                cur = cur.left</span><br><span class=\"line\">            cur = v.pop()</span><br><span class=\"line\">            ans.append(cur.val)</span><br><span class=\"line\">            cur = cur.right</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<h1 id=\"96-不同的二叉搜索树\"><a href=\"#96-不同的二叉搜索树\" class=\"headerlink\" title=\"96. 不同的二叉搜索树\"></a>96. 不同的二叉搜索树</h1><p><a href=\"https://leetcode-cn.com/problems/unique-binary-search-trees/\" target=\"_blank\" rel=\"noopener\">https://leetcode-cn.com/problems/unique-binary-search-trees/</a></p>\n<h2 id=\"题目描述-7\"><a href=\"#题目描述-7\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>给定一个整数 n，求以 1 … n 为节点组成的二叉搜索树有多少种？</p>\n<p>示例:</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: <span class=\"number\">3</span></span><br><span class=\"line\">输出: <span class=\"number\">5</span></span><br><span class=\"line\">解释:</span><br><span class=\"line\">给定 n = <span class=\"number\">3</span>, 一共有 <span class=\"number\">5</span> 种不同结构的二叉搜索树:</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"number\">1</span>         <span class=\"number\">3</span>     <span class=\"number\">3</span>      <span class=\"number\">2</span>      <span class=\"number\">1</span></span><br><span class=\"line\">    \\       /     /      / \\      \\</span><br><span class=\"line\">     <span class=\"number\">3</span>     <span class=\"number\">2</span>     <span class=\"number\">1</span>      <span class=\"number\">1</span>   <span class=\"number\">3</span>      <span class=\"number\">2</span></span><br><span class=\"line\">    /     /       \\                 \\</span><br><span class=\"line\">   <span class=\"number\">2</span>     <span class=\"number\">1</span>         <span class=\"number\">2</span>                 <span class=\"number\">3</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"思路-7\"><a href=\"#思路-7\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>动态规划：</p>\n<ul>\n<li>用 <code>dp[n]</code> 表示以 1 … n 为节点组成的二叉搜索树的数量，<code>f[i]</code> 表示 i 为根节点的二叉搜索树的数量；</li>\n<li>结果即为以各个节点作为根节点的数量总和：<code>dp[n] = f[1] + f[2] + ... + f[n]</code>；</li>\n<li>当 i 为根节点时，其左子树的节点数为 i-1，右子树的节点数为 n-i，因此有：<code>f[i] = f[i-1] * f[n-i]</code>；</li>\n<li><code>dp[n] = dp[0]*dp[n-1] + dp[1]*dp[n-2] + ... + dp[n-1]*dp[0]</code>。</li>\n</ul>\n<p>当 n 为1或0时，只有一种情况，即 <code>dp[0] = dp[1] = 1</code>。</p>\n<p>还有一种方法是递归，也是利用上面的公式。</p>\n<h2 id=\"代码-7\"><a href=\"#代码-7\" class=\"headerlink\" title=\"代码\"></a>代码</h2><p>动态规划：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">numTrees</span><span class=\"params\">(self, n: int)</span> -&gt; int:</span></span><br><span class=\"line\">        dp = [<span class=\"number\">0</span>] * (n + <span class=\"number\">1</span>)</span><br><span class=\"line\">        dp[<span class=\"number\">0</span>] = dp[<span class=\"number\">1</span>] = <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">2</span>, n+<span class=\"number\">1</span>):</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, i+<span class=\"number\">1</span>):</span><br><span class=\"line\">                dp[i] += dp[j<span class=\"number\">-1</span>] * dp[i-j]</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[n]</span><br></pre></td></tr></table></figure>\n<p>递归：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">numTrees</span><span class=\"params\">(self, n: int)</span> -&gt; int:</span></span><br><span class=\"line\">        memo = [<span class=\"number\">0</span>] * (n + <span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">helper</span><span class=\"params\">(n)</span>:</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> n == <span class=\"number\">1</span> <span class=\"keyword\">or</span> n == <span class=\"number\">0</span>: <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> memo[n] &gt; <span class=\"number\">0</span>:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> memo[n]</span><br><span class=\"line\">            <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">0</span>, n):</span><br><span class=\"line\">                memo[n] += helper(i) * helper(n-i<span class=\"number\">-1</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> memo[n]</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> helper(n)</span><br></pre></td></tr></table></figure>\n<h1 id=\"97-交错字符串\"><a href=\"#97-交错字符串\" class=\"headerlink\" title=\"97. 交错字符串\"></a>97. 交错字符串</h1><p><a href=\"https://leetcode-cn.com/problems/interleaving-string/\" target=\"_blank\" rel=\"noopener\">https://leetcode-cn.com/problems/interleaving-string/</a></p>\n<h2 id=\"题目描述-8\"><a href=\"#题目描述-8\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>给定三个字符串 s1, s2, s3, 验证 s3 是否是由 s1 和 s2 交错组成的。</p>\n<p>示例 1:</p>\n<figure class=\"highlight nix\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: <span class=\"attr\">s1</span> = <span class=\"string\">\"aabcc\"</span>, <span class=\"attr\">s2</span> = <span class=\"string\">\"dbbca\"</span>, <span class=\"attr\">s3</span> = <span class=\"string\">\"aadbbcbcac\"</span></span><br><span class=\"line\">输出: <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n<p>示例 2:</p>\n<figure class=\"highlight nix\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: <span class=\"attr\">s1</span> = <span class=\"string\">\"aabcc\"</span>, <span class=\"attr\">s2</span> = <span class=\"string\">\"dbbca\"</span>, <span class=\"attr\">s3</span> = <span class=\"string\">\"aadbbbaccc\"</span></span><br><span class=\"line\">输出: <span class=\"literal\">false</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"思路-8\"><a href=\"#思路-8\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>动态规划，用 <code>dp[i][j]</code> 表示 <code>s1</code> 的前 <code>i</code> 个字符和 <code>s2</code> 的前 <code>j</code> 个字符是否能交错组成 <code>s3</code> 的前 <code>i+j</code> 个字符。若 <code>s1[i]==s3[i+j]</code>，那么 <code>dp[i][j]</code> 是否为真则取决于 <code>s1</code> 的前 <code>i-1</code>（<code>s2</code> 的前 <code>j-1</code>）个字符和 <code>s2</code> 的前 <code>j</code> <code>s1</code> 的前 <code>i</code>）个字符是否能交错组成 <code>s3</code> 的前 <code>i+j-1</code> 个字符，即 <code>dp[i-1][j]</code>（<code>dp[i][j-1]</code>）是否为真。</p>\n<p>可得状态转移方程：</p>\n<ul>\n<li><code>dp[i][j] = (dp[i-1][j] and s1[i-1]==s3[i+j-1]) or (dp[i][j-1] and s2[j-1]==s3[i+j-1])</code>；</li>\n<li>边界条件为<code>dp[0][0] = True</code>。</li>\n</ul>\n<p>当 <code>s1</code> 和 <code>s2</code> 长度之和不等于 <code>s3</code> 长度时，直接输出 <code>False</code>。</p>\n<p>时间复杂度为 O(MN)。</p>\n<h2 id=\"代码-8\"><a href=\"#代码-8\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isInterleave</span><span class=\"params\">(self, s1: str, s2: str, s3: str)</span> -&gt; bool:</span></span><br><span class=\"line\">        n, m = len(s1), len(s2)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> n + m != len(s3):</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">        dp = [[<span class=\"literal\">False</span>] * (m + <span class=\"number\">1</span>) <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(n + <span class=\"number\">1</span>)]</span><br><span class=\"line\">        dp[<span class=\"number\">0</span>][<span class=\"number\">0</span>] = <span class=\"literal\">True</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n + <span class=\"number\">1</span>):</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(m + <span class=\"number\">1</span>):</span><br><span class=\"line\">                <span class=\"keyword\">if</span> i &gt; <span class=\"number\">0</span>:</span><br><span class=\"line\">                    dp[i][j] = dp[i][j] <span class=\"keyword\">or</span> (dp[i<span class=\"number\">-1</span>][j] <span class=\"keyword\">and</span> s1[i<span class=\"number\">-1</span>]==s3[i+j<span class=\"number\">-1</span>])</span><br><span class=\"line\">                <span class=\"keyword\">if</span> j &gt; <span class=\"number\">0</span>:</span><br><span class=\"line\">                    dp[i][j] = dp[i][j] <span class=\"keyword\">or</span> (dp[i][j<span class=\"number\">-1</span>] <span class=\"keyword\">and</span> s2[j<span class=\"number\">-1</span>]==s3[i+j<span class=\"number\">-1</span>])</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[n][m]</span><br></pre></td></tr></table></figure>\n<h1 id=\"100-相同的树\"><a href=\"#100-相同的树\" class=\"headerlink\" title=\"100. 相同的树\"></a>100. 相同的树</h1><p><a href=\"https://leetcode-cn.com/problems/same-tree/\" target=\"_blank\" rel=\"noopener\">https://leetcode-cn.com/problems/same-tree/</a></p>\n<h2 id=\"题目描述-9\"><a href=\"#题目描述-9\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>给定两个二叉树，编写一个函数来检验它们是否相同。</p>\n<p>如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。</p>\n<p>示例 1:</p>\n<pre><code>输入:       1         1\n          / \\       / \\\n         2   3     2   3\n\n        [1,2,3],   [1,2,3]\n\n输出: true\n</code></pre><p>示例 2:</p>\n<pre><code>输入:      1          1\n          /           \\\n         2             2\n\n        [1,2],     [1,null,2]\n\n输出: false\n</code></pre><p>示例 3:</p>\n<pre><code>输入:       1         1\n          / \\       / \\\n         2   1     1   2\n\n        [1,2,1],   [1,1,2]\n\n输出: false\n</code></pre><h2 id=\"思路-9\"><a href=\"#思路-9\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>就是二叉树的遍历，用递归判断两棵树对应节点是否存在以及值是否相等即可。</p>\n<h2 id=\"代码-9\"><a href=\"#代码-9\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"># class TreeNode:</span></span><br><span class=\"line\"><span class=\"comment\">#     def __init__(self, x):</span></span><br><span class=\"line\"><span class=\"comment\">#         self.val = x</span></span><br><span class=\"line\"><span class=\"comment\">#         self.left = None</span></span><br><span class=\"line\"><span class=\"comment\">#         self.right = None</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isSameTree</span><span class=\"params\">(self, p: TreeNode, q: TreeNode)</span> -&gt; bool:</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">helper</span><span class=\"params\">(p, q)</span>:</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> p <span class=\"keyword\">and</span> <span class=\"keyword\">not</span> q: <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> p <span class=\"keyword\">and</span> <span class=\"keyword\">not</span> q <span class=\"keyword\">or</span> <span class=\"keyword\">not</span> p <span class=\"keyword\">and</span> q: <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> p.val != q.val: <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> helper(p.left, q.left) <span class=\"keyword\">and</span> helper(p.right, q.right)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> helper(p, q)</span><br></pre></td></tr></table></figure>\n<h1 id=\"101-对称二叉树\"><a href=\"#101-对称二叉树\" class=\"headerlink\" title=\"101. 对称二叉树\"></a>101. 对称二叉树</h1><p><a href=\"https://leetcode-cn.com/problems/symmetric-tree/\" target=\"_blank\" rel=\"noopener\">https://leetcode-cn.com/problems/symmetric-tree/</a></p>\n<h2 id=\"题目描述-10\"><a href=\"#题目描述-10\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>给定一个二叉树，检查它是否是镜像对称的。</p>\n<p>例如，二叉树 [1,2,2,3,4,4,3] 是对称的。</p>\n<pre><code>    1\n   / \\\n  2   2\n / \\ / \\\n3  4 4  3\n</code></pre><p>但是下面这个 <code>[1,2,2,null,3,null,3]</code> 则不是镜像对称的:</p>\n<pre><code>    1\n   / \\\n  2   2\n   \\   \\\n   3    3\n</code></pre><p>进阶：</p>\n<p>你可以运用递归和迭代两种方法解决这个问题吗？</p>\n<h2 id=\"思路-10\"><a href=\"#思路-10\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>可以通过判断根节点的两棵子树 $p,q$ 是否是镜像的。遍历的方式与第100题类似，只是这次两者不再按相同的顺序遍历，而是按镜像的方式：</p>\n<ul>\n<li>$p$ 遍历其左子树时，$q$ 遍历其右子树；</li>\n<li>$p$ 遍历其右子树时，$q$ 遍历其左子树。</li>\n</ul>\n<h2 id=\"代码-10\"><a href=\"#代码-10\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isSymmetric</span><span class=\"params\">(self, root: TreeNode)</span> -&gt; bool:</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">helper</span><span class=\"params\">(p, q)</span>:</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> p <span class=\"keyword\">and</span> <span class=\"keyword\">not</span> q: <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> p <span class=\"keyword\">and</span> <span class=\"keyword\">not</span> q <span class=\"keyword\">or</span> <span class=\"keyword\">not</span> p <span class=\"keyword\">and</span> q: <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> p.val != q.val: <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> helper(p.left, q.right) <span class=\"keyword\">and</span> helper(p.right, q.left)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> root <span class=\"keyword\">and</span> root.left <span class=\"keyword\">and</span> root.right:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> helper(root.left, root.right)</span><br><span class=\"line\">        <span class=\"keyword\">elif</span> root <span class=\"keyword\">and</span> <span class=\"keyword\">not</span> root.left <span class=\"keyword\">and</span> <span class=\"keyword\">not</span> root.right <span class=\"keyword\">or</span> <span class=\"keyword\">not</span> root:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"102-二叉树的层序遍历\"><a href=\"#102-二叉树的层序遍历\" class=\"headerlink\" title=\"102. 二叉树的层序遍历\"></a>102. 二叉树的层序遍历</h1><p><a href=\"https://leetcode-cn.com/problems/binary-tree-level-order-traversal/\" target=\"_blank\" rel=\"noopener\">https://leetcode-cn.com/problems/binary-tree-level-order-traversal/</a></p>\n<h2 id=\"题目描述-11\"><a href=\"#题目描述-11\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>给你一个二叉树，请你返回其按 <strong>层序遍历</strong> 得到的节点值。 （即逐层地，从左到右访问所有节点）。</p>\n<p>示例：<br>二叉树：<code>[3,9,20,null,null,15,7]</code>,</p>\n<pre><code>    3\n   / \\\n  9  20\n    /  \\\n   15   7\n</code></pre><p>返回其层次遍历结果：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[</span><br><span class=\"line\">  [<span class=\"number\">3</span>],</span><br><span class=\"line\">  [<span class=\"number\">9</span>,<span class=\"number\">20</span>],</span><br><span class=\"line\">  [<span class=\"number\">15</span>,<span class=\"number\">7</span>]</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n<h2 id=\"思路-11\"><a href=\"#思路-11\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>最简单的方法是用递归，按前序遍历二叉树中的节点，记录访问节点的层数，每层用一个列表 <code>ans[d]</code> ( <code>d</code> 表示当前节点所在层的深度)保存节点值。</p>\n<p>另一种思路是使用BFS，使用一个队列 <code>queue</code> 存放待访问的节点，每到一层都用 <code>s</code> 存当前层节点的个数，每访问到一个节点就将其值存入答案列表中对应的位置，并将其左右子节点存入队列。</p>\n<h2 id=\"代码-11\"><a href=\"#代码-11\" class=\"headerlink\" title=\"代码\"></a>代码</h2><p>递归，前序遍历：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">levelOrder</span><span class=\"params\">(self, root: TreeNode)</span> -&gt; List[List[int]]:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> root: <span class=\"keyword\">return</span> []</span><br><span class=\"line\">        ans = []</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">helper</span><span class=\"params\">(node, d)</span>:</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> node: <span class=\"keyword\">return</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> len(ans) == d:</span><br><span class=\"line\">                ans.append([])</span><br><span class=\"line\">            ans[d].append(node.val)</span><br><span class=\"line\">            helper(node.left, d+<span class=\"number\">1</span>)</span><br><span class=\"line\">            helper(node.right, d+<span class=\"number\">1</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\"></span><br><span class=\"line\">        helper(root, <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<p>BFS：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">levelOrder</span><span class=\"params\">(self, root: TreeNode)</span> -&gt; List[List[int]]:</span></span><br><span class=\"line\">        queue = collections.deque()</span><br><span class=\"line\">        queue.append(root)</span><br><span class=\"line\">        ans = []</span><br><span class=\"line\">        <span class=\"keyword\">while</span> queue:</span><br><span class=\"line\">            s = len(queue)</span><br><span class=\"line\">            d = []</span><br><span class=\"line\">            <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(s):</span><br><span class=\"line\">                node = queue.popleft()</span><br><span class=\"line\">                <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> node:</span><br><span class=\"line\">                    <span class=\"keyword\">continue</span></span><br><span class=\"line\">                d.append(node.val)</span><br><span class=\"line\">                queue.append(node.left)</span><br><span class=\"line\">                queue.append(node.right)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> d:</span><br><span class=\"line\">                ans.append(d)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<h1 id=\"107-二叉树的层次遍历-II\"><a href=\"#107-二叉树的层次遍历-II\" class=\"headerlink\" title=\"107. 二叉树的层次遍历 II\"></a>107. 二叉树的层次遍历 II</h1><p><a href=\"https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/\" target=\"_blank\" rel=\"noopener\">https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/</a></p>\n<h2 id=\"题目描述-12\"><a href=\"#题目描述-12\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）</p>\n<p>例如：<br>给定二叉树 <code>[3,9,20,null,null,15,7]</code>,</p>\n<pre><code>    3\n   / \\\n  9  20\n    /  \\\n   15   7\n</code></pre><p>返回其自底向上的层次遍历为：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[</span><br><span class=\"line\">  [<span class=\"number\">15</span>,<span class=\"number\">7</span>],</span><br><span class=\"line\">  [<span class=\"number\">9</span>,<span class=\"number\">20</span>],</span><br><span class=\"line\">  [<span class=\"number\">3</span>]</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n<h2 id=\"思路-12\"><a href=\"#思路-12\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>与层次遍历一样，只是输出的时候倒序输出即可，也是有两种方法：递归前序遍历和BFS。</p>\n<h2 id=\"代码-12\"><a href=\"#代码-12\" class=\"headerlink\" title=\"代码\"></a>代码</h2><p>前序遍历，递归：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">levelOrderBottom</span><span class=\"params\">(self, root: TreeNode)</span> -&gt; List[List[int]]:</span></span><br><span class=\"line\">        ans = []</span><br><span class=\"line\">        self.helper(root, <span class=\"number\">0</span>, ans)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans[::<span class=\"number\">-1</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">helper</span><span class=\"params\">(self, node, depth, ans)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> node:</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> len(ans) == depth:</span><br><span class=\"line\">            ans.append([])</span><br><span class=\"line\">        ans[depth].append(node.val)</span><br><span class=\"line\">        self.helper(node.left, depth+<span class=\"number\">1</span>, ans)</span><br><span class=\"line\">        self.helper(node.right, depth+<span class=\"number\">1</span>, ans)</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br></pre></td></tr></table></figure>\n<p>BFS：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">levelOrderBottom</span><span class=\"params\">(self, root: TreeNode)</span> -&gt; List[List[int]]:</span></span><br><span class=\"line\">        queue = collections.deque()</span><br><span class=\"line\">        queue.append(root)</span><br><span class=\"line\">        ans = []</span><br><span class=\"line\">        <span class=\"keyword\">while</span> queue:</span><br><span class=\"line\">            size = len(queue)</span><br><span class=\"line\">            t = []</span><br><span class=\"line\">            <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(size):</span><br><span class=\"line\">                p = queue.popleft()</span><br><span class=\"line\">                <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> p:</span><br><span class=\"line\">                    <span class=\"keyword\">continue</span></span><br><span class=\"line\">                t.append(p.val)</span><br><span class=\"line\">                queue.append(p.left)</span><br><span class=\"line\">                queue.append(p.right)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> t:</span><br><span class=\"line\">                ans.append(t)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans[::<span class=\"number\">-1</span>]</span><br></pre></td></tr></table></figure>\n<h1 id=\"110-平衡二叉树\"><a href=\"#110-平衡二叉树\" class=\"headerlink\" title=\"110. 平衡二叉树\"></a>110. 平衡二叉树</h1><p><a href=\"https://leetcode-cn.com/problems/balanced-binary-tree/\" target=\"_blank\" rel=\"noopener\">https://leetcode-cn.com/problems/balanced-binary-tree/</a></p>\n<h2 id=\"题目描述-13\"><a href=\"#题目描述-13\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>给定一个二叉树，判断它是否是高度平衡的二叉树。</p>\n<p>本题中，一棵高度平衡二叉树定义为：</p>\n<p><em>一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1。</em></p>\n<p>示例 1:</p>\n<p>给定二叉树 <code>[3,9,20,null,null,15,7]</code></p>\n<pre><code>    3\n   / \\\n  9  20\n    /  \\\n   15   7\n</code></pre><p>返回 <code>true</code> 。</p>\n<p>示例 2:</p>\n<p>给定二叉树 <code>[1,2,2,3,3,null,null,4,4]</code></p>\n<pre><code>       1\n      / \\\n     2   2\n    / \\\n   3   3\n  / \\\n 4   4\n</code></pre><p>返回 <code>false</code> 。</p>\n<h2 id=\"思路-13\"><a href=\"#思路-13\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>有两种解法，分别是自顶向下和自底向上。</p>\n<p>自顶向下(暴力法)比较容易想到，首先计算根节点左右子树的深度，然后比较它们的差是否小于2，然后计算根节点的左右子节点的左右子树的深度，以此类推。</p>\n<p>自底向上则是在计算节点的深度时就判断其左右子树的深度大小，若大于2则直接返回，效率要比自顶向下高很多。</p>\n<h2 id=\"代码-13\"><a href=\"#代码-13\" class=\"headerlink\" title=\"代码\"></a>代码</h2><p>自顶向下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isBalanced</span><span class=\"params\">(self, root: TreeNode)</span> -&gt; bool:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> root: <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> abs(self.helper(root.left) - self.helper(root.right)) &lt; <span class=\"number\">2</span> <span class=\"keyword\">and</span> \\</span><br><span class=\"line\">            self.isBalanced(root.left) <span class=\"keyword\">and</span> self.isBalanced(root.right)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">helper</span><span class=\"params\">(self, node)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> node: <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> max(self.helper(node.left), self.helper(node.right))+<span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n<p>自底向上：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isBalanced</span><span class=\"params\">(self, root: TreeNode)</span> -&gt; bool:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.helper(root) != <span class=\"number\">-1</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">helper</span><span class=\"params\">(self, node)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> node: <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">        left = self.helper(node.left)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> left == <span class=\"number\">-1</span>: <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">        right = self.helper(node.right)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> right == <span class=\"number\">-1</span>: <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> max(left, right)+<span class=\"number\">1</span> <span class=\"keyword\">if</span> abs(left - right) &lt; <span class=\"number\">2</span> <span class=\"keyword\">else</span> <span class=\"number\">-1</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"112-路径总和\"><a href=\"#112-路径总和\" class=\"headerlink\" title=\"112. 路径总和\"></a>112. 路径总和</h1><p><a href=\"https://leetcode-cn.com/problems/path-sum/\" target=\"_blank\" rel=\"noopener\">https://leetcode-cn.com/problems/path-sum/</a></p>\n<h2 id=\"题目描述-14\"><a href=\"#题目描述-14\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。</p>\n<p>说明: 叶子节点是指没有子节点的节点。</p>\n<p>示例:<br>给定如下二叉树，以及目标和 <code>sum = 22</code>，</p>\n<pre><code>          5\n         / \\\n        4   8\n       /   / \\\n      11  13  4\n     /  \\      \\\n    7    2      1\n</code></pre><p>返回 <code>true</code>, 因为存在目标和为 22 的根节点到叶子节点的路径 <code>5-&gt;4-&gt;11-&gt;2</code>。</p>\n<h2 id=\"思路-14\"><a href=\"#思路-14\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>递归，前序遍历二叉树，统计路径总和，到叶子节点时判断路径总和与目标和 <code>sum</code>  是否相等。</p>\n<h2 id=\"代码-14\"><a href=\"#代码-14\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">hasPathSum</span><span class=\"params\">(self, root: TreeNode, sum: int)</span> -&gt; bool:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> root: <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">helper</span><span class=\"params\">(node, s)</span>:</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> node: <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">            t = node.val + s</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> node.left <span class=\"keyword\">and</span> <span class=\"keyword\">not</span> node.right:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> t == sum:</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\">                <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>: <span class=\"keyword\">return</span> helper(node.left, t) <span class=\"keyword\">or</span> helper(node.right, t)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> helper(root, <span class=\"number\">0</span>)</span><br></pre></td></tr></table></figure>\n<h1 id=\"120-三角形最小路径和\"><a href=\"#120-三角形最小路径和\" class=\"headerlink\" title=\"120. 三角形最小路径和\"></a>120. 三角形最小路径和</h1><p><a href=\"https://leetcode-cn.com/problems/triangle/\" target=\"_blank\" rel=\"noopener\">https://leetcode-cn.com/problems/triangle/</a></p>\n<h2 id=\"题目描述-15\"><a href=\"#题目描述-15\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。</p>\n<p><strong>相邻的结点</strong> 在这里指的是 <code>下标</code> 与 <code>上一层结点下标</code> 相同或者等于 <code>上一层结点下标 + 1</code> 的两个结点。</p>\n<p>例如，给定三角形：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[</span><br><span class=\"line\">     [<span class=\"number\">2</span>],</span><br><span class=\"line\">    [<span class=\"number\">3</span>,<span class=\"number\">4</span>],</span><br><span class=\"line\">   [<span class=\"number\">6</span>,<span class=\"number\">5</span>,<span class=\"number\">7</span>],</span><br><span class=\"line\">  [<span class=\"number\">4</span>,<span class=\"number\">1</span>,<span class=\"number\">8</span>,<span class=\"number\">3</span>]</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n<p>自顶向下的最小路径和为 <code>11</code>（即，2 + 3 + 5 + 1 = 11）。</p>\n<p>说明：</p>\n<p>如果你可以只使用 O(n) 的额外空间（n 为三角形的总行数）来解决这个问题，那么你的算法会很加分。</p>\n<h2 id=\"思路-15\"><a href=\"#思路-15\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>动态规划：</p>\n<ul>\n<li><code>dp[i][j]</code> 表示第 <code>i</code> 行第 <code>j</code> 列节点到最底层的最小路径和，自底向上计算。</li>\n<li><code>dp[i][j] = triangle[i][j] + min(dp[i+1][j], dp[i+1][j+1])</code>.</li>\n</ul>\n<p>计算完后 <code>dp[0][0]</code> 为最终答案。</p>\n<h2 id=\"代码-15\"><a href=\"#代码-15\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">minimumTotal</span><span class=\"params\">(self, triangle: List[List[int]])</span> -&gt; int:</span></span><br><span class=\"line\">        dp = triangle[:]</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(triangle)<span class=\"number\">-2</span>, <span class=\"number\">-1</span>, <span class=\"number\">-1</span>):</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(i+<span class=\"number\">1</span>):</span><br><span class=\"line\">                dp[i][j] = triangle[i][j] + min(dp[i+<span class=\"number\">1</span>][j], dp[i+<span class=\"number\">1</span>][j+<span class=\"number\">1</span>])</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[<span class=\"number\">0</span>][<span class=\"number\">0</span>]</span><br></pre></td></tr></table></figure>\n<h1 id=\"121-买卖股票的最佳时机\"><a href=\"#121-买卖股票的最佳时机\" class=\"headerlink\" title=\"121. 买卖股票的最佳时机\"></a>121. 买卖股票的最佳时机</h1><p><a href=\"https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/\" target=\"_blank\" rel=\"noopener\">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/</a></p>\n<h2 id=\"题目描述-16\"><a href=\"#题目描述-16\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p>\n<p>如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。</p>\n<p>注意：你不能在买入股票前卖出股票。</p>\n<p>示例 1:</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: [<span class=\"number\">7</span>,<span class=\"number\">1</span>,<span class=\"number\">5</span>,<span class=\"number\">3</span>,<span class=\"number\">6</span>,<span class=\"number\">4</span>]</span><br><span class=\"line\">输出: <span class=\"number\">5</span></span><br><span class=\"line\">解释: 在第 <span class=\"number\">2</span> 天（股票价格 = <span class=\"number\">1</span>）的时候买入，在第 <span class=\"number\">5</span> 天（股票价格 = <span class=\"number\">6</span>）的时候卖出，最大利润 = <span class=\"number\">6</span><span class=\"number\">-1</span> = <span class=\"number\">5</span> 。</span><br><span class=\"line\">     注意利润不能是 <span class=\"number\">7</span><span class=\"number\">-1</span> = <span class=\"number\">6</span>, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。</span><br></pre></td></tr></table></figure>\n<p>示例 2:</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: [<span class=\"number\">7</span>,<span class=\"number\">6</span>,<span class=\"number\">4</span>,<span class=\"number\">3</span>,<span class=\"number\">1</span>]</span><br><span class=\"line\">输出: <span class=\"number\">0</span></span><br><span class=\"line\">解释: 在这种情况下, 没有交易完成, 所以最大利润为 <span class=\"number\">0</span>。</span><br></pre></td></tr></table></figure>\n<h2 id=\"思路-16\"><a href=\"#思路-16\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>因为有时间因素，因此不能简单地用最大值减去最小值。可以用维护两个变量<code>minp</code>和<code>maxp</code>，其中<code>minp</code>记录到当前为止的最小价格，<code>maxp</code>记录当前为止的最大差价。通过对数组的一遍扫描，每扫描到一个值就与<code>minp</code>作比较、计算当前值与<code>minp</code>的差价，若大于<code>maxp</code>则更新。</p>\n<h2 id=\"代码-16\"><a href=\"#代码-16\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">maxProfit</span><span class=\"params\">(self, prices: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">        maxp = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> len(prices) &gt; <span class=\"number\">0</span>:</span><br><span class=\"line\">            minp = prices[<span class=\"number\">0</span>]</span><br><span class=\"line\">            <span class=\"keyword\">for</span> price <span class=\"keyword\">in</span> prices:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> price &lt; minp:</span><br><span class=\"line\">                    minp = price</span><br><span class=\"line\">                <span class=\"keyword\">if</span> price - minp &gt; maxp:</span><br><span class=\"line\">                    maxp = price - minp</span><br><span class=\"line\">        <span class=\"keyword\">return</span> maxp</span><br></pre></td></tr></table></figure>\n<h1 id=\"152-乘积最大子数组\"><a href=\"#152-乘积最大子数组\" class=\"headerlink\" title=\"152. 乘积最大子数组\"></a>152. 乘积最大子数组</h1><p><a href=\"https://leetcode-cn.com/problems/maximum-product-subarray/\" target=\"_blank\" rel=\"noopener\">https://leetcode-cn.com/problems/maximum-product-subarray/</a></p>\n<h2 id=\"题目描述-17\"><a href=\"#题目描述-17\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>给你一个整数数组 <code>nums</code> ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。</p>\n<p>示例 1:</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: [<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">-2</span>,<span class=\"number\">4</span>]</span><br><span class=\"line\">输出: <span class=\"number\">6</span></span><br><span class=\"line\">解释: 子数组 [<span class=\"number\">2</span>,<span class=\"number\">3</span>] 有最大乘积 <span class=\"number\">6</span>。</span><br></pre></td></tr></table></figure>\n<p>示例 2:</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: [<span class=\"number\">-2</span>,<span class=\"number\">0</span>,<span class=\"number\">-1</span>]</span><br><span class=\"line\">输出: <span class=\"number\">0</span></span><br><span class=\"line\">解释: 结果不能为 <span class=\"number\">2</span>, 因为 [<span class=\"number\">-2</span>,<span class=\"number\">-1</span>] 不是子数组。</span><br></pre></td></tr></table></figure>\n<h2 id=\"思路-17\"><a href=\"#思路-17\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>可以用动态规划。因为负负得正，所以当前的数为负的话，与前一个数的最小值相乘有可能得到比最大值更大的数。因此需要维护两个变量：当前的最大值和最小值。</p>\n<p>动态方程如下：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{aligned}\nmaxDP[i+1] &= \\max(dmax[i+1] \\cdot nums[i], \\  nums[i],\\  dmin[i] \\cdot nums[i])\\\\\nminDP[i+1] &= \\min(dmax[i+1] \\cdot nums[i],\\  nums[i],\\  dmin[i] \\cdot nums[i])\\\\\nDP[i+1] &= \\max(DP[i],\\ maxDP[i+1])\n\\end{aligned}</script><p>当<code>nums[i]</code>为0时，<code>dmax</code>和<code>dmin</code>都为0，于是需要从<code>nums[i+1]</code>重新开始。</p>\n<h2 id=\"代码-17\"><a href=\"#代码-17\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">maxProduct</span><span class=\"params\">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> len(nums)==<span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">elif</span> len(nums)==<span class=\"number\">1</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> nums[<span class=\"number\">0</span>]</span><br><span class=\"line\">        m = dmax = dmin = nums[<span class=\"number\">0</span>]</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, len(nums)):</span><br><span class=\"line\">            tmp = dmax</span><br><span class=\"line\">            dmax = max(max(dmax*nums[i], nums[i]), dmin*nums[i])</span><br><span class=\"line\">            dmin = min(min(tmp*nums[i], nums[i]), dmin*nums[i])</span><br><span class=\"line\">            m = max(dmax, m)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> m</span><br></pre></td></tr></table></figure>\n<h1 id=\"167-两数之和-II-输入有序数组\"><a href=\"#167-两数之和-II-输入有序数组\" class=\"headerlink\" title=\"167. 两数之和 II - 输入有序数组\"></a>167. 两数之和 II - 输入有序数组</h1><p><a href=\"https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/\" target=\"_blank\" rel=\"noopener\">https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/</a></p>\n<h2 id=\"题目描述-18\"><a href=\"#题目描述-18\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。</p>\n<p>函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。</p>\n<p>说明:</p>\n<ul>\n<li>返回的下标值（index1 和 index2）不是从零开始的。</li>\n<li>你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。</li>\n</ul>\n<p>示例:</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: bers = [<span class=\"number\">2</span>, <span class=\"number\">7</span>, <span class=\"number\">11</span>, <span class=\"number\">15</span>], target = <span class=\"number\">9</span></span><br><span class=\"line\">输出: [<span class=\"number\">1</span>,<span class=\"number\">2</span>]</span><br><span class=\"line\">解释: <span class=\"number\">2</span> 与 <span class=\"number\">7</span> 之和等于目标数 <span class=\"number\">9</span> 。因此 index1 = <span class=\"number\">1</span>, index2 = <span class=\"number\">2</span> 。</span><br></pre></td></tr></table></figure>\n<h2 id=\"思路-18\"><a href=\"#思路-18\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>遍历数组，将访问过的元素的索引存储在哈希表 <code>d</code> 中，<code>d[val]</code> 存储的是值为 <code>val</code> 的元素的索引。</p>\n<ul>\n<li>每访问到一个元素，计算其与目标数的差值 <code>k = target - val</code>；</li>\n<li>在 <code>d</code> 中查找 <code>k</code>，若 <code>k</code> 存在则直接返回 <code>[d[k], val的index]</code>（后访问的 <code>index</code> 肯定比先访问的大）；</li>\n<li>若 <code>k</code> 不存在则将 <code>val</code> 的 <code>index</code> 存储在哈希表中。</li>\n</ul>\n<p>时间复杂度 $O(N)$，遍历了一次数组；空间复杂度 $O(N)$，用到了一个哈希表存储数组中的元素的索引值。</p>\n<h2 id=\"代码-18\"><a href=\"#代码-18\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">twoSum</span><span class=\"params\">(self, numbers: List[int], target: int)</span> -&gt; List[int]:</span></span><br><span class=\"line\">        n = len(numbers)</span><br><span class=\"line\">        d = dict()</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">            k = target - numbers[i]</span><br><span class=\"line\">            <span class=\"keyword\">if</span> k <span class=\"keyword\">in</span> d:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> [d[k], i+<span class=\"number\">1</span>]</span><br><span class=\"line\">            d[numbers[i]] = i + <span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"169-多数元素\"><a href=\"#169-多数元素\" class=\"headerlink\" title=\"169. 多数元素\"></a>169. 多数元素</h1><p><a href=\"https://leetcode-cn.com/problems/majority-element/\" target=\"_blank\" rel=\"noopener\">https://leetcode-cn.com/problems/majority-element/</a></p>\n<h2 id=\"题目描述-19\"><a href=\"#题目描述-19\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数大于 <code>⌊ n/2 ⌋</code> 的元素。</p>\n<p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p>\n<p>示例 1:</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: [<span class=\"number\">3</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]</span><br><span class=\"line\">输出: <span class=\"number\">3</span></span><br></pre></td></tr></table></figure>\n<p>示例 2:</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: [<span class=\"number\">2</span>,<span class=\"number\">2</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">2</span>]</span><br><span class=\"line\">输出: <span class=\"number\">2</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"思路-19\"><a href=\"#思路-19\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>这里可以使用摩尔投票法：</p>\n<p>候选人<code>k</code>初始化为数组第一个元素<code>nums[0]</code>，票数<code>cnt</code>初始化为1。从第二个元素<code>nums[1]</code>开始遍历，遇到与候选人相同的数则把票数加1，遇到不同的则把票数减1，如果票数减完之后为0，则更换当前数<code>nums[i]</code>为候选人并把票数重设为1。</p>\n<p>因为多数元素的个数肯定比其它元素的个数之和多，因此其票数在最后肯定是<code>&gt;= 1</code>的。</p>\n<h2 id=\"代码-19\"><a href=\"#代码-19\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">majorityElement</span><span class=\"params\">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> len(nums) &lt; <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">        cnt = <span class=\"number\">1</span></span><br><span class=\"line\">        k = nums[<span class=\"number\">0</span>]</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, len(nums)):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> nums[i] == k:</span><br><span class=\"line\">                cnt += <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                cnt -= <span class=\"number\">1</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> cnt == <span class=\"number\">0</span>:</span><br><span class=\"line\">                    cnt = <span class=\"number\">1</span></span><br><span class=\"line\">                    k = nums[i]</span><br><span class=\"line\">        <span class=\"keyword\">return</span> k</span><br></pre></td></tr></table></figure>\n<h1 id=\"174-地下城游戏\"><a href=\"#174-地下城游戏\" class=\"headerlink\" title=\"174. 地下城游戏\"></a>174. 地下城游戏</h1><p><a href=\"https://leetcode-cn.com/problems/dungeon-game/\" target=\"_blank\" rel=\"noopener\">https://leetcode-cn.com/problems/dungeon-game/</a></p>\n<h2 id=\"题目描述-20\"><a href=\"#题目描述-20\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>一些恶魔抓住了公主（<strong>P</strong>）并将她关在了地下城的右下角。地下城是由 M x N 个房间组成的二维网格。我们英勇的骑士（<strong>K</strong>）最初被安置在左上角的房间里，他必须穿过地下城并通过对抗恶魔来拯救公主。</p>\n<p>骑士的初始健康点数为一个正整数。如果他的健康点数在某一时刻降至 0 或以下，他会立即死亡。</p>\n<p>有些房间由恶魔守卫，因此骑士在进入这些房间时会失去健康点数（若房间里的值为负整数，则表示骑士将损失健康点数）；其他房间要么是空的（房间里的值为 0），要么包含增加骑士健康点数的魔法球（若房间里的值为正整数，则表示骑士将增加健康点数）。</p>\n<p>为了尽快到达公主，骑士决定每次只向右或向下移动一步。</p>\n<p><strong>编写一个函数来计算确保骑士能够拯救到公主所需的最低初始健康点数。</strong></p>\n<p>例如，考虑到如下布局的地下城，如果骑士遵循最佳路径 <code>右 -&gt; 右 -&gt; 下 -&gt; 下</code>，则骑士的初始健康点数至少为 <strong>7</strong>。</p>\n<p><img src=\"http://images.yingwai.top/picgo/174f1.png\" alt=\"\"></p>\n<p>说明:</p>\n<ul>\n<li><p>骑士的健康点数没有上限。</p>\n</li>\n<li><p>任何房间都可能对骑士的健康点数造成威胁，也可能增加骑士的健康点数，包括骑士进入的左上角房间以及公主被监禁的右下角房间。</p>\n</li>\n</ul>\n<h2 id=\"思路-20\"><a href=\"#思路-20\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>反向动态规划，从右下往左上遍历列表，用 <code>dp[i][j]</code> 来表示从房间 <code>(i, j)</code> 到达终点的最低初始健康点数，则可以得到</p>\n<ul>\n<li>此房间到终点的 <code>dp</code> 值为：此房间右边和下边的房间的 <code>dp</code> 值中较小的那一个，加上此房间需要消耗的生命值 <code>dungeon[i][j]</code> (注意初始值不能小于 <strong>1</strong>)；</li>\n<li><code>dp[i][j] = max(min(dp[i+1][j], dp[i][j+1]) - dungeon[i][j], 1)</code>.</li>\n</ul>\n<p>对于最后一行或一列中，除终点以外的元素 <code>dp[i][j]</code> 要用到的 <code>dp[i+1][j]</code> 和 <code>dp[i][j+1]</code>，将它们赋值为无穷大；而对于终点 <code>dp[m-1][n-1]</code>，将 <code>dp[m][n-1]</code> 和 <code>dp[m-1][n]</code> 赋值为 1。</p>\n<h2 id=\"代码-20\"><a href=\"#代码-20\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">calculateMinimumHP</span><span class=\"params\">(self, dungeon: List[List[int]])</span> -&gt; int:</span></span><br><span class=\"line\">        m, n = len(dungeon), len(dungeon[<span class=\"number\">0</span>])</span><br><span class=\"line\">        BIG = float(<span class=\"string\">\"inf\"</span>)</span><br><span class=\"line\">        dp = [[BIG] * (n + <span class=\"number\">1</span>) <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(m + <span class=\"number\">1</span>)]</span><br><span class=\"line\">        dp[m<span class=\"number\">-1</span>][n] = dp[m][n<span class=\"number\">-1</span>] = <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(m<span class=\"number\">-1</span>, <span class=\"number\">-1</span>, <span class=\"number\">-1</span>):</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(n<span class=\"number\">-1</span>, <span class=\"number\">-1</span>, <span class=\"number\">-1</span>):</span><br><span class=\"line\">                dp[i][j] = max(min(dp[i+<span class=\"number\">1</span>][j], dp[i][j+<span class=\"number\">1</span>]) - dungeon[i][j], <span class=\"number\">1</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[<span class=\"number\">0</span>][<span class=\"number\">0</span>]</span><br></pre></td></tr></table></figure>\n<h1 id=\"198-打家劫舍\"><a href=\"#198-打家劫舍\" class=\"headerlink\" title=\"198. 打家劫舍\"></a>198. 打家劫舍</h1><p><a href=\"https://leetcode-cn.com/problems/house-robber/\" target=\"_blank\" rel=\"noopener\">https://leetcode-cn.com/problems/house-robber/</a></p>\n<h2 id=\"题目描述-21\"><a href=\"#题目描述-21\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p>\n<p>给定一个代表每个房屋存放金额的非负整数数组，计算你不触动警报装置的情况下，一夜之内能够偷窃到的最高金额。</p>\n<p>示例 1:</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">1</span>]</span><br><span class=\"line\">输出: <span class=\"number\">4</span></span><br><span class=\"line\">解释: 偷窃 <span class=\"number\">1</span> 号房屋 (金额 = <span class=\"number\">1</span>) ，然后偷窃 <span class=\"number\">3</span> 号房屋 (金额 = <span class=\"number\">3</span>)。</span><br><span class=\"line\">     偷窃到的最高金额 = <span class=\"number\">1</span> + <span class=\"number\">3</span> = <span class=\"number\">4</span> 。</span><br></pre></td></tr></table></figure>\n<p>示例 2:</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: [<span class=\"number\">2</span>,<span class=\"number\">7</span>,<span class=\"number\">9</span>,<span class=\"number\">3</span>,<span class=\"number\">1</span>]</span><br><span class=\"line\">输出: <span class=\"number\">12</span></span><br><span class=\"line\">解释: 偷窃 <span class=\"number\">1</span> 号房屋 (金额 = <span class=\"number\">2</span>), 偷窃 <span class=\"number\">3</span> 号房屋 (金额 = <span class=\"number\">9</span>)，接着偷窃 <span class=\"number\">5</span> 号房屋 (金额 = <span class=\"number\">1</span>)。</span><br><span class=\"line\">     偷窃到的最高金额 = <span class=\"number\">2</span> + <span class=\"number\">9</span> + <span class=\"number\">1</span> = <span class=\"number\">12</span> 。</span><br></pre></td></tr></table></figure>\n<h2 id=\"思路-21\"><a href=\"#思路-21\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>动态规划，用 $\\rm dp[i]$ 表示前 $\\rm i$ 个房间能偷到的最大值，根据题目条件有以下动态方程：</p>\n<script type=\"math/tex; mode=display\">\n\\rm dp[i] = \\max (dp[i-1], dp[i-2] + nums[i])</script><h2 id=\"代码-21\"><a href=\"#代码-21\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">rob</span><span class=\"params\">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> len(nums) &lt;= <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">elif</span> len(nums) == <span class=\"number\">1</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> nums[<span class=\"number\">0</span>]</span><br><span class=\"line\">        dp = []</span><br><span class=\"line\">        dp.append(nums[<span class=\"number\">0</span>])</span><br><span class=\"line\">        dp.append(max(nums[<span class=\"number\">0</span>], nums[<span class=\"number\">1</span>]))</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">2</span>, len(nums)):</span><br><span class=\"line\">            dp.append(max(dp[i<span class=\"number\">-1</span>], dp[i<span class=\"number\">-2</span>] + nums[i]))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[len(nums)<span class=\"number\">-1</span>]</span><br></pre></td></tr></table></figure>\n<h1 id=\"257-二叉树的所有路径\"><a href=\"#257-二叉树的所有路径\" class=\"headerlink\" title=\"257. 二叉树的所有路径\"></a>257. 二叉树的所有路径</h1><p><a href=\"https://leetcode-cn.com/problems/binary-tree-paths/\" target=\"_blank\" rel=\"noopener\">https://leetcode-cn.com/problems/binary-tree-paths/</a></p>\n<h2 id=\"题目描述-22\"><a href=\"#题目描述-22\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>给定一个二叉树，返回所有从根节点到叶子节点的路径。</p>\n<p>说明: 叶子节点是指没有子节点的节点。</p>\n<p>示例:</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入:</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"number\">1</span></span><br><span class=\"line\"> /   \\</span><br><span class=\"line\"><span class=\"number\">2</span>     <span class=\"number\">3</span></span><br><span class=\"line\"> \\</span><br><span class=\"line\">  <span class=\"number\">5</span></span><br><span class=\"line\"></span><br><span class=\"line\">输出: [<span class=\"string\">\"1-&gt;2-&gt;5\"</span>, <span class=\"string\">\"1-&gt;3\"</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">解释: 所有根节点到叶子节点的路径为: <span class=\"number\">1</span>-&gt;<span class=\"number\">2</span>-&gt;<span class=\"number\">5</span>, <span class=\"number\">1</span>-&gt;<span class=\"number\">3</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"思路-22\"><a href=\"#思路-22\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>递归，用一个字符串 <code>s</code> 记录当前的路径，访问到叶子节点时将其加入最终结果的列表 <code>ans</code> 中。访问到叶子节点或空节点时返回。</p>\n<h2 id=\"代码-22\"><a href=\"#代码-22\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">binaryTreePaths</span><span class=\"params\">(self, root: TreeNode)</span> -&gt; List[str]:</span></span><br><span class=\"line\">        ans = []</span><br><span class=\"line\">        s = <span class=\"string\">\"\"</span></span><br><span class=\"line\">        self.helper(root, ans, s, <span class=\"number\">1</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">helper</span><span class=\"params\">(self, node, ans, s, depth)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> node:</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">        s = s + <span class=\"string\">\"-&gt;\"</span> + str(node.val) <span class=\"keyword\">if</span> depth &gt; <span class=\"number\">1</span> <span class=\"keyword\">else</span> s + str(node.val)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> node.left <span class=\"keyword\">and</span> <span class=\"keyword\">not</span> node.right:</span><br><span class=\"line\">            ans.append(s)</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">        self.helper(node.left, ans, s, depth+<span class=\"number\">1</span>)</span><br><span class=\"line\">        self.helper(node.right, ans, s, depth+<span class=\"number\">1</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"287-寻找重复数\"><a href=\"#287-寻找重复数\" class=\"headerlink\" title=\"287. 寻找重复数\"></a>287. 寻找重复数</h1><p><a href=\"https://leetcode-cn.com/problems/find-the-duplicate-number/\" target=\"_blank\" rel=\"noopener\">https://leetcode-cn.com/problems/find-the-duplicate-number/</a></p>\n<h2 id=\"题目描述-23\"><a href=\"#题目描述-23\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。</p>\n<p>示例 1:</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: [<span class=\"number\">1</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">2</span>,<span class=\"number\">2</span>]</span><br><span class=\"line\">输出: <span class=\"number\">2</span></span><br></pre></td></tr></table></figure>\n<p>示例 2:</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: [<span class=\"number\">3</span>,<span class=\"number\">1</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">2</span>]</span><br><span class=\"line\">输出: <span class=\"number\">3</span></span><br></pre></td></tr></table></figure>\n<p>说明：</p>\n<ol>\n<li>不能更改原数组（假设数组是只读的）。</li>\n<li>只能使用额外的 $O(1)$ 的空间。</li>\n<li>时间复杂度小于 $O(n^2)$ 。</li>\n<li>数组中只有一个重复的数字，但它可能不止重复出现一次。</li>\n</ol>\n<h2 id=\"思路-23\"><a href=\"#思路-23\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>由于题目限制了空间，所以打表法之类的方法就无法使用。可以用二分法：</p>\n<p>对于给定题目条件的数组 <code>nums</code>，设<code>mid</code>为 1 到 n 的中位数。扫描数组，若数组中小于等于<code>mid</code>的数的数量严格大于<code>mid</code>，则可以确定重复的数就在 1 到<code>mid</code>之间，反之则在<code>mid</code>到 n 之间。</p>\n<h2 id=\"代码-23\"><a href=\"#代码-23\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">findDuplicate</span><span class=\"params\">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">        size = len(nums)</span><br><span class=\"line\">        left = <span class=\"number\">1</span></span><br><span class=\"line\">        right = size - <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> left &lt; right:</span><br><span class=\"line\">            cnt = <span class=\"number\">0</span></span><br><span class=\"line\">            mid = left + (right - left) // <span class=\"number\">2</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> num <span class=\"keyword\">in</span> nums:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> num &lt;= mid:</span><br><span class=\"line\">                    cnt += <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> cnt &gt; mid:</span><br><span class=\"line\">                right = mid</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                left = mid + <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> left</span><br></pre></td></tr></table></figure>\n<h1 id=\"300-最长上升子序列\"><a href=\"#300-最长上升子序列\" class=\"headerlink\" title=\"300. 最长上升子序列\"></a>300. 最长上升子序列</h1><p><a href=\"https://leetcode-cn.com/problems/longest-increasing-subsequence/\" target=\"_blank\" rel=\"noopener\">https://leetcode-cn.com/problems/longest-increasing-subsequence/</a></p>\n<h2 id=\"题目描述-24\"><a href=\"#题目描述-24\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>给定一个无序的整数数组，找到其中最长上升子序列的长度。</p>\n<p>示例:</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: [<span class=\"number\">10</span>,<span class=\"number\">9</span>,<span class=\"number\">2</span>,<span class=\"number\">5</span>,<span class=\"number\">3</span>,<span class=\"number\">7</span>,<span class=\"number\">101</span>,<span class=\"number\">18</span>]</span><br><span class=\"line\">输出: <span class=\"number\">4</span> </span><br><span class=\"line\">解释: 最长的上升子序列是 [<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">7</span>,<span class=\"number\">101</span>]，它的长度是 <span class=\"number\">4</span>。</span><br></pre></td></tr></table></figure>\n<p>说明:</p>\n<ul>\n<li>可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。</li>\n<li>你算法的时间复杂度应该为 $O(n^2)$。</li>\n</ul>\n<p>进阶: 你能将算法的时间复杂度降低到 $O(n \\log{n})$ 吗?</p>\n<h2 id=\"思路-24\"><a href=\"#思路-24\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>$O(n \\log{n})$ 还没想到，这里介绍 $O(n^2)$ 的动态规划方法：</p>\n<p>用 $\\rm dp[i]$ 表示以第 $\\rm i$ 个元素结尾的最长上升子序列的长度，则可以得到以下的状态转移方程：</p>\n<script type=\"math/tex; mode=display\">\n\\rm dp[i] = \\max(dp[i], dp[j] + 1),\\ nums[j] < nums[i],\\  j < i.</script><p>扫描完整个数组后，$\\rm dp$ 数组中的最大值即为结果。</p>\n<h2 id=\"代码-24\"><a href=\"#代码-24\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">lengthOfLIS</span><span class=\"params\">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> len(nums) &lt;= <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">        dp = []     <span class=\"comment\"># 存以第i个元素结尾的最长上升子序列的长度</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(nums)):</span><br><span class=\"line\">            dp.append(<span class=\"number\">1</span>)</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(i):</span><br><span class=\"line\">                <span class=\"keyword\">if</span> nums[j] &lt; nums[i]:</span><br><span class=\"line\">                    dp[i] = max(dp[i], dp[j]+<span class=\"number\">1</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> max(dp)</span><br></pre></td></tr></table></figure>\n<h1 id=\"309-最佳买卖股票时机含冷冻期\"><a href=\"#309-最佳买卖股票时机含冷冻期\" class=\"headerlink\" title=\"309. 最佳买卖股票时机含冷冻期\"></a>309. 最佳买卖股票时机含冷冻期</h1><p><a href=\"https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/\" target=\"_blank\" rel=\"noopener\">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/</a></p>\n<h2 id=\"题目描述-25\"><a href=\"#题目描述-25\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。</p>\n<p>设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:</p>\n<ul>\n<li>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</li>\n<li>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。</li>\n</ul>\n<p>示例:</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">0</span>,<span class=\"number\">2</span>]</span><br><span class=\"line\">输出: <span class=\"number\">3</span> </span><br><span class=\"line\">解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]</span><br></pre></td></tr></table></figure>\n<h2 id=\"思路-25\"><a href=\"#思路-25\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>动态规划，用两个数组来存储状态：</p>\n<ol>\n<li><code>hold[i]</code> 表示在第 <code>i</code> 天结束时持有股票、此时的最大收益，有两种情况：<ul>\n<li>昨天持有股票，今天休息；</li>\n<li>前天卖出，今天买入；</li>\n<li><code>hold[i] = max(hold[i-1], unhold[i-2] - prices[i])</code>。</li>\n</ul>\n</li>\n<li><code>unhold[i]</code> 表示在第 <code>i</code> 天结束时未持有股票、此时的最大收益，也有两种情况：<ul>\n<li>昨天也没持有股票，今天休息；</li>\n<li>昨天持有，今天卖出；</li>\n<li><code>unhold[i] = max(unhold[i-1], hold[i-1] + prices[i])</code>。</li>\n</ul>\n</li>\n</ol>\n<p>最终结果是 <code>unhold[n-1]</code>。</p>\n<p>初始情况：</p>\n<ul>\n<li>第 <code>0</code> 天持有股票即在当天买入股票，<code>hold[0] = -prices[0]</code>；</li>\n<li>第 <code>1</code> 天持有股票有前一天买入或是当天买入两种情况，<code>hold[1] = max(-prices[0], -prices[1])</code>；</li>\n<li>第 <code>0</code> 天未持有股票即当天休息，<code>unhold[0] = 0</code>。</li>\n</ul>\n<h2 id=\"代码-25\"><a href=\"#代码-25\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">maxProfit</span><span class=\"params\">(self, prices: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> len(prices) &lt; <span class=\"number\">2</span>: <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">        hold, unhold = [], []</span><br><span class=\"line\">        hold.append(-prices[<span class=\"number\">0</span>])</span><br><span class=\"line\">        unhold.append(<span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, len(prices)):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> i == <span class=\"number\">1</span>:</span><br><span class=\"line\">                hold.append(max(-prices[<span class=\"number\">0</span>], -prices[<span class=\"number\">1</span>]))</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                hold.append(max(hold[i<span class=\"number\">-1</span>], unhold[i<span class=\"number\">-2</span>] - prices[i]))</span><br><span class=\"line\">            unhold.append(max(unhold[i<span class=\"number\">-1</span>], hold[i<span class=\"number\">-1</span>] + prices[i]))        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> unhold[len(prices) - <span class=\"number\">1</span>]</span><br></pre></td></tr></table></figure>\n<h1 id=\"312-戳气球\"><a href=\"#312-戳气球\" class=\"headerlink\" title=\"312. 戳气球\"></a>312. 戳气球</h1><p><a href=\"https://leetcode-cn.com/problems/burst-balloons/\" target=\"_blank\" rel=\"noopener\">https://leetcode-cn.com/problems/burst-balloons/</a></p>\n<h2 id=\"题目描述-26\"><a href=\"#题目描述-26\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>有 <code>n</code> 个气球，编号为 <code>0</code> 到 <code>n-1</code>，每个气球上都标有一个数字，这些数字存在数组 <code>nums</code> 中。</p>\n<p>现在要求你戳破所有的气球。如果你戳破气球 <code>i</code> ，就可以获得 <code>nums[left] * nums[i] * nums[right]</code> 个硬币。 这里的 <code>left</code> 和 <code>right</code> 代表和 <code>i</code> 相邻的两个气球的序号。注意当你戳破了气球 <code>i</code> 后，气球 <code>left</code> 和气球 <code>right</code> 就变成了相邻的气球。</p>\n<p>求所能获得硬币的最大数量。</p>\n<p>说明:</p>\n<ul>\n<li>你可以假设 <code>nums[-1] = nums[n] = 1</code>，但注意它们不是真实存在的所以并不能被戳破。</li>\n<li>0 ≤ <code>n</code> ≤ 500, 0 ≤ <code>nums[i]</code> ≤ 100</li>\n</ul>\n<p>示例:</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: [<span class=\"number\">3</span>,<span class=\"number\">1</span>,<span class=\"number\">5</span>,<span class=\"number\">8</span>]</span><br><span class=\"line\">输出: <span class=\"number\">167</span> </span><br><span class=\"line\">解释: nums = [<span class=\"number\">3</span>,<span class=\"number\">1</span>,<span class=\"number\">5</span>,<span class=\"number\">8</span>] --&gt; [<span class=\"number\">3</span>,<span class=\"number\">5</span>,<span class=\"number\">8</span>] --&gt;   [<span class=\"number\">3</span>,<span class=\"number\">8</span>]   --&gt;  [<span class=\"number\">8</span>]  --&gt; []</span><br><span class=\"line\">     coins =  <span class=\"number\">3</span>*<span class=\"number\">1</span>*<span class=\"number\">5</span>      +  <span class=\"number\">3</span>*<span class=\"number\">5</span>*<span class=\"number\">8</span>    +  <span class=\"number\">1</span>*<span class=\"number\">3</span>*<span class=\"number\">8</span>      + <span class=\"number\">1</span>*<span class=\"number\">8</span>*<span class=\"number\">1</span>   = <span class=\"number\">167</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"思路-26\"><a href=\"#思路-26\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>动态规划，用 <code>dp[i][j]</code> 表示戳破气球 <code>i</code> 和气球 <code>j</code> 之间所有气球所能获得硬币的最大数量：</p>\n<ul>\n<li>当气球 <code>i</code> 和 <code>j</code> 相邻时，<code>dp[i][j]</code> 为0；</li>\n<li>令 <code>k</code> 为气球 <code>i</code> 和气球 <code>j</code> 之间最后戳破的气球序号，对于每个 <code>i</code> 和 <code>j</code>（<code>i</code> 小于 <code>j</code>），遍历所有的 <code>k</code>，取其中的最大值赋值给 <code>dp[i][j]</code>，可得以下状态转移方程：</li>\n<li><code>dp[i][j] = max(dp[i][j], dp[i][k] + dp[k][j] + nums[i]*nums[k]*nums[j])</code>.</li>\n</ul>\n<p>注意要令 <code>nums</code> 的两个边界赋值为1。</p>\n<p>时间复杂度为 $O(N^3)$。</p>\n<h2 id=\"代码-26\"><a href=\"#代码-26\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">maxCoins</span><span class=\"params\">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">        points = [<span class=\"number\">1</span>] + nums + [<span class=\"number\">1</span>]</span><br><span class=\"line\">        n = len(nums)</span><br><span class=\"line\">        dp = [[<span class=\"number\">0</span>] * (n+<span class=\"number\">2</span>) <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(n+<span class=\"number\">2</span>)]</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n, <span class=\"number\">-1</span>, <span class=\"number\">-1</span>):</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(i+<span class=\"number\">1</span>, n+<span class=\"number\">2</span>):</span><br><span class=\"line\">                <span class=\"keyword\">for</span> k <span class=\"keyword\">in</span> range(i+<span class=\"number\">1</span>, j):</span><br><span class=\"line\">                    dp[i][j] = max(dp[i][j], dp[i][k] + dp[k][j] + points[k]*points[i]*points[j])</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[<span class=\"number\">0</span>][<span class=\"number\">-1</span>]</span><br></pre></td></tr></table></figure>\n<h1 id=\"315-计算右侧小于当前元素的个数\"><a href=\"#315-计算右侧小于当前元素的个数\" class=\"headerlink\" title=\"315. 计算右侧小于当前元素的个数\"></a>315. 计算右侧小于当前元素的个数</h1><p><a href=\"https://leetcode-cn.com/problems/count-of-smaller-numbers-after-self/\" target=\"_blank\" rel=\"noopener\">https://leetcode-cn.com/problems/count-of-smaller-numbers-after-self/</a></p>\n<h2 id=\"题目描述-27\"><a href=\"#题目描述-27\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>给定一个整数数组 nums，按要求返回一个新数组 counts。数组 counts 有该性质： <code>counts[i]</code> 的值是  <code>nums[i]</code> 右侧小于 <code>nums[i]</code> 的元素的数量。</p>\n<p>示例:</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: [<span class=\"number\">5</span>,<span class=\"number\">2</span>,<span class=\"number\">6</span>,<span class=\"number\">1</span>]</span><br><span class=\"line\">输出: [<span class=\"number\">2</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">0</span>] </span><br><span class=\"line\">解释:</span><br><span class=\"line\"><span class=\"number\">5</span> 的右侧有 <span class=\"number\">2</span> 个更小的元素 (<span class=\"number\">2</span> 和 <span class=\"number\">1</span>).</span><br><span class=\"line\"><span class=\"number\">2</span> 的右侧仅有 <span class=\"number\">1</span> 个更小的元素 (<span class=\"number\">1</span>).</span><br><span class=\"line\"><span class=\"number\">6</span> 的右侧有 <span class=\"number\">1</span> 个更小的元素 (<span class=\"number\">1</span>).</span><br><span class=\"line\"><span class=\"number\">1</span> 的右侧有 <span class=\"number\">0</span> 个更小的元素.</span><br></pre></td></tr></table></figure>\n<h2 id=\"思路-27\"><a href=\"#思路-27\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>二分查找，从后向前遍历 <code>nums</code>，使用一个辅助数组 <code>sorted_nums</code> 保存 <code>nums[i]</code> 右侧的元素的升序排列，<code>counts[i]</code> 的值即为 <code>nums[i]</code> 插入 <code>sorted_nums</code> 后的索引：</p>\n<ol>\n<li>在 <code>sorted_nums</code> 中查找第一个小于等于 <code>nums[i]</code> 的元素的索引，此索引即为<code>nums</code> 中 <code>nums[i]</code> 右侧小于该元素的元素数量；</li>\n<li>将其添加到 <code>ans</code> 数组中；</li>\n<li>将 <code>nums[i]</code> 插入到 <code>sorted_nums</code> 中的对应位置，继续遍历，直到遍历完整个数组。</li>\n</ol>\n<p>最后 <code>ans</code> 的倒序即为答案。</p>\n<h2 id=\"代码-27\"><a href=\"#代码-27\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">countSmaller</span><span class=\"params\">(self, nums: List[int])</span> -&gt; List[int]:</span></span><br><span class=\"line\">        sorted_nums, ans = [], []</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> reversed(range(len(nums))): </span><br><span class=\"line\">            t = self.findIndex(nums[i], sorted_nums)</span><br><span class=\"line\">            sorted_nums.insert(t, nums[i])</span><br><span class=\"line\">            ans.append(t)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans[::<span class=\"number\">-1</span>]</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">findIndex</span><span class=\"params\">(self, n, sorted_nums)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> len(sorted_nums) == <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">        left, right = <span class=\"number\">0</span>, len(sorted_nums)<span class=\"number\">-1</span></span><br><span class=\"line\">        mid = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> left &lt; right:</span><br><span class=\"line\">            mid = left + right &gt;&gt; <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> n &gt; sorted_nums[mid]:</span><br><span class=\"line\">                left = mid + <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                right = mid</span><br><span class=\"line\">        <span class=\"keyword\">if</span> n &gt; sorted_nums[left]:</span><br><span class=\"line\">            left += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> left</span><br></pre></td></tr></table></figure>\n<h1 id=\"322-零钱兑换\"><a href=\"#322-零钱兑换\" class=\"headerlink\" title=\"322. 零钱兑换\"></a>322. 零钱兑换</h1><p><a href=\"https://leetcode-cn.com/problems/coin-change/\" target=\"_blank\" rel=\"noopener\">https://leetcode-cn.com/problems/coin-change/</a></p>\n<h2 id=\"题目描述-28\"><a href=\"#题目描述-28\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 <code>-1</code>。</p>\n<p>示例 1:</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: coins = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">5</span>], amount = <span class=\"number\">11</span></span><br><span class=\"line\">输出: <span class=\"number\">3</span> </span><br><span class=\"line\">解释: <span class=\"number\">11</span> = <span class=\"number\">5</span> + <span class=\"number\">5</span> + <span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n<p>示例 2:</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: coins = [<span class=\"number\">2</span>], amount = <span class=\"number\">3</span></span><br><span class=\"line\">输出: <span class=\"number\">-1</span></span><br></pre></td></tr></table></figure>\n<p>说明:<br>你可以认为每种硬币的数量是无限的。</p>\n<h2 id=\"思路-28\"><a href=\"#思路-28\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>首先想到了贪心，但会复杂一点，迟点再研究一下，这里用了动态规划。根据题意，要求 <code>amount</code> 的最少硬币数，可以先对 <code>coins</code> 中的每一个面额 <code>coin</code> 进行遍历，求子问题 $dp(amount-coin)$ 的最小值。</p>\n<p>可以列出状态转移方程</p>\n<script type=\"math/tex; mode=display\">\ndp(n) = \\left\\{ \\begin{array}{lcl}\n -1, & n < 0\\\\\n 0, & n = 0\\\\\n \\min\\{dp(n-coin)+1|coin \\in coins\\}, & n > 0\n\\end{array}\\right.</script><h2 id=\"代码-28\"><a href=\"#代码-28\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">coinChange</span><span class=\"params\">(self, coins: List[int], amount: int)</span> -&gt; int:</span></span><br><span class=\"line\">        memo = dict()</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dp</span><span class=\"params\">(n)</span>:</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> n <span class=\"keyword\">in</span> memo:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> memo[n]</span><br><span class=\"line\">            <span class=\"keyword\">if</span> n == <span class=\"number\">0</span>:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> n &lt; <span class=\"number\">0</span>:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">            ans = float(<span class=\"string\">\"inf\"</span>)</span><br><span class=\"line\">            <span class=\"keyword\">for</span> coin <span class=\"keyword\">in</span> coins:</span><br><span class=\"line\">                subproblem = dp(n - coin)</span><br><span class=\"line\">                <span class=\"keyword\">if</span> subproblem == <span class=\"number\">-1</span>:</span><br><span class=\"line\">                    <span class=\"keyword\">continue</span></span><br><span class=\"line\">                ans = min(ans, subproblem + <span class=\"number\">1</span>)</span><br><span class=\"line\">            memo[n] = ans <span class=\"keyword\">if</span> ans!=float(inf) <span class=\"keyword\">else</span> <span class=\"number\">-1</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> memo[n]</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp(amount)</span><br></pre></td></tr></table></figure>\n<h1 id=\"350-两个数组的交集-II\"><a href=\"#350-两个数组的交集-II\" class=\"headerlink\" title=\"350. 两个数组的交集 II\"></a>350. 两个数组的交集 II</h1><p><a href=\"https://leetcode-cn.com/problems/intersection-of-two-arrays-ii/\" target=\"_blank\" rel=\"noopener\">https://leetcode-cn.com/problems/intersection-of-two-arrays-ii/</a></p>\n<h2 id=\"题目描述-29\"><a href=\"#题目描述-29\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>给定两个数组，编写一个函数来计算它们的交集。</p>\n<p>示例 1:</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: nums1 = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">2</span>,<span class=\"number\">1</span>], nums2 = [<span class=\"number\">2</span>,<span class=\"number\">2</span>]</span><br><span class=\"line\">输出: [<span class=\"number\">2</span>,<span class=\"number\">2</span>]</span><br></pre></td></tr></table></figure>\n<p>示例 2:</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: nums1 = [<span class=\"number\">4</span>,<span class=\"number\">9</span>,<span class=\"number\">5</span>], nums2 = [<span class=\"number\">9</span>,<span class=\"number\">4</span>,<span class=\"number\">9</span>,<span class=\"number\">8</span>,<span class=\"number\">4</span>]</span><br><span class=\"line\">输出: [<span class=\"number\">4</span>,<span class=\"number\">9</span>]</span><br></pre></td></tr></table></figure>\n<p>说明：</p>\n<ul>\n<li>输出结果中每个元素出现的次数，应与元素在两个数组中出现的次数一致。</li>\n<li>我们可以不考虑输出结果的顺序。</li>\n</ul>\n<p>进阶:</p>\n<ul>\n<li>如果给定的数组已经排好序呢？你将如何优化你的算法？</li>\n<li>如果 nums1 的大小比 nums2 小很多，哪种方法更优？</li>\n<li>如果 nums2 的元素存储在磁盘上，磁盘内存是有限的，并且你不能一次加载所有的元素到内存中，你该怎么办？</li>\n</ul>\n<h2 id=\"思路-29\"><a href=\"#思路-29\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>两种方法：</p>\n<ul>\n<li>遍历 <code>nums1</code>，用一个字典存储 <code>d</code> 其中元素的个数，然后遍历 <code>nums2</code> 若扫描到的元素 <code>nums2[i]</code> 在字典中存在且 <code>d[nums2[i]] &gt; 0</code>，则将该元素加入 <code>ans</code> 并将 <code>d[nums2[i]]</code> 自减 1。</li>\n<li>先对两个数组进行排序，然后用两个指针 <code>i, j</code> 分别指向排序完的数组的头元素。从头元素开始扫描，当 <code>nums1[i] &gt; nums2[j]</code> 时 <code>j</code> 往后移，反之 <code>i</code> 往后移，两个元素相等时将其加入 <code>ans</code>，当遍历完其中一个数组后结束循环。</li>\n</ul>\n<h2 id=\"代码-29\"><a href=\"#代码-29\" class=\"headerlink\" title=\"代码\"></a>代码</h2><p>哈希表：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">intersect</span><span class=\"params\">(self, nums1: List[int], nums2: List[int])</span> -&gt; List[int]:</span></span><br><span class=\"line\">        d = dict()</span><br><span class=\"line\">        ans = []</span><br><span class=\"line\">        <span class=\"keyword\">for</span> num <span class=\"keyword\">in</span> nums1:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> num <span class=\"keyword\">in</span> d:</span><br><span class=\"line\">                d[num] += <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                d[num] = <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> num <span class=\"keyword\">in</span> nums2:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> num <span class=\"keyword\">in</span> d <span class=\"keyword\">and</span> d[num] &gt; <span class=\"number\">0</span>:</span><br><span class=\"line\">                ans.append(num)</span><br><span class=\"line\">                d[num] -= <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<p>排序方法：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">intersect</span><span class=\"params\">(self, nums1: List[int], nums2: List[int])</span> -&gt; List[int]:</span></span><br><span class=\"line\">        nums1.sort()</span><br><span class=\"line\">        nums2.sort()</span><br><span class=\"line\">        i = j = <span class=\"number\">0</span></span><br><span class=\"line\">        ans = []</span><br><span class=\"line\">        <span class=\"keyword\">while</span> i &lt; len(nums1) <span class=\"keyword\">and</span> j &lt; len(nums2):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> nums1[i] == nums2[j]:</span><br><span class=\"line\">                ans.append(nums1[i])</span><br><span class=\"line\">                i += <span class=\"number\">1</span></span><br><span class=\"line\">                j += <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">elif</span> nums1[i] &gt; nums2[j]:</span><br><span class=\"line\">                j += <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                i += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<h1 id=\"394-字符串解码\"><a href=\"#394-字符串解码\" class=\"headerlink\" title=\"394. 字符串解码\"></a>394. 字符串解码</h1><p><a href=\"https://leetcode-cn.com/problems/decode-string/\" target=\"_blank\" rel=\"noopener\">https://leetcode-cn.com/problems/decode-string/</a></p>\n<h2 id=\"题目描述-30\"><a href=\"#题目描述-30\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>给定一个经过编码的字符串，返回它解码后的字符串。</p>\n<p>编码规则为: <code>k[encoded_string]</code>，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。</p>\n<p>你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。</p>\n<p>此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 <code>3a</code> 或 <code>2[4]</code> 的输入。</p>\n<p>示例:</p>\n<figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">s</span> = <span class=\"string\">\"3[a]2[bc]\"</span>, 返回 <span class=\"string\">\"aaabcbc\"</span>.</span><br><span class=\"line\"><span class=\"attribute\">s</span> = <span class=\"string\">\"3[a2[c]]\"</span>, 返回 <span class=\"string\">\"accaccacc\"</span>.</span><br><span class=\"line\"><span class=\"attribute\">s</span> = <span class=\"string\">\"2[abc]3[cd]ef\"</span>, 返回 <span class=\"string\">\"abcabccdcdcdef\"</span>.</span><br></pre></td></tr></table></figure>\n<h2 id=\"思路-30\"><a href=\"#思路-30\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>这里可以使用栈，对字符串按顺序扫描：</p>\n<ol>\n<li>将右括号以外的字符全部入栈，直到扫描到右括号；</li>\n<li>扫描到右括号则开始退栈，保存在一个字符串<code>ss</code>中，直到遇到左括号；</li>\n<li>根据题目的条件，在左括号前面的一定是数字，此时就可以统计当前字符串出现的次数<code>t</code>，把<code>ss</code>复制<code>t</code>次重新入栈；</li>\n<li>最后把栈中所有元素拼接在一起即可。</li>\n</ol>\n<h2 id=\"代码-30\"><a href=\"#代码-30\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">decodeString</span><span class=\"params\">(self, s: str)</span> -&gt; str:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> len(s) &lt;= <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">\"\"</span></span><br><span class=\"line\">        ans = <span class=\"string\">\"\"</span></span><br><span class=\"line\">        tmps = []   <span class=\"comment\"># 栈</span></span><br><span class=\"line\">        i = <span class=\"number\">1</span></span><br><span class=\"line\">        tmps.append(s[<span class=\"number\">0</span>])</span><br><span class=\"line\">        ss, t = <span class=\"string\">\"\"</span>, <span class=\"string\">\"\"</span>\t<span class=\"comment\"># 分别存当前字符串和当前的次数</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> i &lt; len(s):</span><br><span class=\"line\">            w = s[i]</span><br><span class=\"line\">            <span class=\"keyword\">if</span> w == <span class=\"string\">']'</span>:\t<span class=\"comment\"># 扫描到右括号则开始退栈，直到遇到左括号</span></span><br><span class=\"line\">                <span class=\"keyword\">while</span> tmps[<span class=\"number\">-1</span>] != <span class=\"string\">'['</span>:</span><br><span class=\"line\">                    ss = tmps.pop() + ss</span><br><span class=\"line\">                tmps.pop()      <span class=\"comment\"># 将左括号退栈</span></span><br><span class=\"line\">                <span class=\"keyword\">while</span> len(tmps) &gt; <span class=\"number\">0</span> <span class=\"keyword\">and</span> tmps[<span class=\"number\">-1</span>].isdigit():\t\t<span class=\"comment\"># 统计次数</span></span><br><span class=\"line\">                    t = tmps.pop() + t</span><br><span class=\"line\">                tmps.append(ss*int(t))</span><br><span class=\"line\">                ss, t = <span class=\"string\">\"\"</span>, <span class=\"string\">\"\"</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                tmps.append(w)</span><br><span class=\"line\">            i += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> tmp <span class=\"keyword\">in</span> tmps:</span><br><span class=\"line\">            ans = ans + tmp</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<h1 id=\"409-最长回文串\"><a href=\"#409-最长回文串\" class=\"headerlink\" title=\"409. 最长回文串\"></a>409. 最长回文串</h1><p><a href=\"https://leetcode-cn.com/problems/longest-palindrome/\" target=\"_blank\" rel=\"noopener\">https://leetcode-cn.com/problems/longest-palindrome/</a></p>\n<h2 id=\"题目描述-31\"><a href=\"#题目描述-31\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>给定一个包含大写字母和小写字母的字符串，找到通过这些字母构造成的最长的回文串。</p>\n<p>在构造过程中，请注意区分大小写。比如 <code>&quot;Aa&quot;</code> 不能当做一个回文字符串。</p>\n<p>注意:<br>假设字符串的长度不会超过 1010。</p>\n<p>示例 1:</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">输入:</span></span><br><span class=\"line\"><span class=\"string\">\"abccccdd\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">输出:</span></span><br><span class=\"line\">7</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">解释:</span></span><br><span class=\"line\">我们可以构造的最长的回文串是<span class=\"string\">\"dccaccd\"</span>, 它的长度是 7。</span><br></pre></td></tr></table></figure>\n<h2 id=\"思路-31\"><a href=\"#思路-31\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>由题意可知回文串中奇数的字母只能出现在中间，即只能选取一个来构造回文串。因此可以先统计每个字母在字符串中出现的个数存在字典中，然后遍历字典，将数量为偶数的直接累加；数量为奇数的则判断前面是否已出现了奇数，若不是则直接累加，若是则只选取偶数数量的当前字母，即把当前数量 $-1$ 再累加。</p>\n<h2 id=\"代码-31\"><a href=\"#代码-31\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">longestPalindrome</span><span class=\"params\">(self, s: str)</span> -&gt; int:</span></span><br><span class=\"line\">        d = dict()</span><br><span class=\"line\">        ans = <span class=\"number\">0</span></span><br><span class=\"line\">        flag = <span class=\"number\">0</span>    <span class=\"comment\"># 判断前面有无加奇数</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> w <span class=\"keyword\">in</span> s:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> w <span class=\"keyword\">in</span> d:</span><br><span class=\"line\">                d[w] += <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                d[w] = <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> value <span class=\"keyword\">in</span> d.values():</span><br><span class=\"line\">            <span class=\"keyword\">if</span> value%<span class=\"number\">2</span>==<span class=\"number\">0</span>:</span><br><span class=\"line\">                ans += value</span><br><span class=\"line\">            <span class=\"keyword\">elif</span> flag:</span><br><span class=\"line\">                ans += value - <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                ans += value</span><br><span class=\"line\">                flag = <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<h1 id=\"563-二叉树的坡度\"><a href=\"#563-二叉树的坡度\" class=\"headerlink\" title=\"563. 二叉树的坡度\"></a>563. 二叉树的坡度</h1><p><a href=\"https://leetcode-cn.com/problems/binary-tree-tilt/\" target=\"_blank\" rel=\"noopener\">https://leetcode-cn.com/problems/binary-tree-tilt/</a></p>\n<h2 id=\"题目描述-32\"><a href=\"#题目描述-32\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>给定一个二叉树，计算整个树的坡度。</p>\n<p>一个树的节点的坡度定义即为，该节点左子树的结点之和和右子树结点之和的差的绝对值。空结点的的坡度是0。</p>\n<p>整个树的坡度就是其所有节点的坡度之和。</p>\n<p>示例：</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：</span><br><span class=\"line\">         <span class=\"number\">1</span></span><br><span class=\"line\">       /   \\</span><br><span class=\"line\">      <span class=\"number\">2</span>     <span class=\"number\">3</span></span><br><span class=\"line\">输出：<span class=\"number\">1</span></span><br><span class=\"line\">解释：</span><br><span class=\"line\">结点 <span class=\"number\">2</span> 的坡度: <span class=\"number\">0</span></span><br><span class=\"line\">结点 <span class=\"number\">3</span> 的坡度: <span class=\"number\">0</span></span><br><span class=\"line\">结点 <span class=\"number\">1</span> 的坡度: |<span class=\"number\">2</span><span class=\"number\">-3</span>| = <span class=\"number\">1</span></span><br><span class=\"line\">树的坡度 : <span class=\"number\">0</span> + <span class=\"number\">0</span> + <span class=\"number\">1</span> = <span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n<p>提示：</p>\n<p>任何子树的结点的和不会超过 32 位整数的范围。<br>坡度的值不会超过 32 位整数的范围。</p>\n<h2 id=\"思路-32\"><a href=\"#思路-32\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>递归，后序遍历二叉树，用一个变量 <code>tilt</code> 存储累计坡度，访问节点时更新 <code>tilt = tilt + |(左子树节点之和 - 右子树节点之和)|</code>，然后返回以当前节点为根节点的二叉树节点之和。</p>\n<p>递归边界为访问到空节点，返回 0。</p>\n<h2 id=\"代码-32\"><a href=\"#代码-32\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">findTilt</span><span class=\"params\">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class=\"line\">        tilt = [<span class=\"number\">0</span>]</span><br><span class=\"line\">        self.recur(root, tilt)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> tilt[<span class=\"number\">0</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">recur</span><span class=\"params\">(self, node, tilt)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> node:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">        left = self.recur(node.left, tilt)</span><br><span class=\"line\">        right = self.recur(node.right, tilt)</span><br><span class=\"line\">        tilt[<span class=\"number\">0</span>] += abs(left - right)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> left + right + node.val</span><br></pre></td></tr></table></figure>\n<h1 id=\"623-在二叉树中增加一行\"><a href=\"#623-在二叉树中增加一行\" class=\"headerlink\" title=\"623. 在二叉树中增加一行\"></a>623. 在二叉树中增加一行</h1><p><a href=\"https://leetcode-cn.com/problems/add-one-row-to-tree/\" target=\"_blank\" rel=\"noopener\">https://leetcode-cn.com/problems/add-one-row-to-tree/</a></p>\n<h2 id=\"题目描述-33\"><a href=\"#题目描述-33\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>给定一个二叉树，根节点为第1层，深度为 1。在其第 <code>d</code> 层追加一行值为 <code>v</code> 的节点。</p>\n<p>添加规则：给定一个深度值 <code>d</code> （正整数），针对深度为 <code>d-1</code> 层的每一非空节点 <code>N</code>，为 <code>N</code> 创建两个值为 <code>v</code> 的左子树和右子树。</p>\n<p>将 <code>N</code> 原先的左子树，连接为新节点 <code>v</code> 的左子树；将 <code>N</code> 原先的右子树，连接为新节点 <code>v</code> 的右子树。</p>\n<p>如果 <code>d</code> 的值为 1，深度 d - 1 不存在，则创建一个新的根节点 <code>v</code>，原先的整棵树将作为 <code>v</code> 的左子树。</p>\n<p>示例 1:</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: </span><br><span class=\"line\">二叉树如下所示:</span><br><span class=\"line\">       <span class=\"number\">4</span></span><br><span class=\"line\">     /   \\</span><br><span class=\"line\">    <span class=\"number\">2</span>     <span class=\"number\">6</span></span><br><span class=\"line\">   / \\   / </span><br><span class=\"line\">  <span class=\"number\">3</span>   <span class=\"number\">1</span> <span class=\"number\">5</span>   </span><br><span class=\"line\"></span><br><span class=\"line\">v = <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">d = <span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\">输出: </span><br><span class=\"line\">       <span class=\"number\">4</span></span><br><span class=\"line\">      / \\</span><br><span class=\"line\">     <span class=\"number\">1</span>   <span class=\"number\">1</span></span><br><span class=\"line\">    /     \\</span><br><span class=\"line\">   <span class=\"number\">2</span>       <span class=\"number\">6</span></span><br><span class=\"line\">  / \\     / </span><br><span class=\"line\"> <span class=\"number\">3</span>   <span class=\"number\">1</span>   <span class=\"number\">5</span></span><br></pre></td></tr></table></figure>\n<p>示例 2:</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: </span><br><span class=\"line\">二叉树如下所示:</span><br><span class=\"line\">      <span class=\"number\">4</span></span><br><span class=\"line\">     /   </span><br><span class=\"line\">    <span class=\"number\">2</span>    </span><br><span class=\"line\">   / \\   </span><br><span class=\"line\">  <span class=\"number\">3</span>   <span class=\"number\">1</span>    </span><br><span class=\"line\"></span><br><span class=\"line\">v = <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">d = <span class=\"number\">3</span></span><br><span class=\"line\"></span><br><span class=\"line\">输出: </span><br><span class=\"line\">      <span class=\"number\">4</span></span><br><span class=\"line\">     /   </span><br><span class=\"line\">    <span class=\"number\">2</span></span><br><span class=\"line\">   / \\    </span><br><span class=\"line\">  <span class=\"number\">1</span>   <span class=\"number\">1</span></span><br><span class=\"line\"> /     \\  </span><br><span class=\"line\"><span class=\"number\">3</span>       <span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n<p>注意:</p>\n<p>输入的深度值 d 的范围是：[1，二叉树最大深度 + 1]。<br>输入的二叉树至少有一个节点。</p>\n<h2 id=\"思路-33\"><a href=\"#思路-33\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>深度优先搜索(递归)，在访问到深度为 <code>d-1</code> 的节点则在它们下面增加子节点然后返回。</p>\n<p>注意 <code>d = 1</code> 的特殊情况和访问到空节点的情况。</p>\n<h2 id=\"代码-33\"><a href=\"#代码-33\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">addOneRow</span><span class=\"params\">(self, root: TreeNode, v: int, d: int)</span> -&gt; TreeNode:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> d == <span class=\"number\">1</span>:</span><br><span class=\"line\">            newnode = TreeNode(v)</span><br><span class=\"line\">            newnode.left = root</span><br><span class=\"line\">            root = newnode</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            self.helper(root, d, v, <span class=\"number\">1</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">helper</span><span class=\"params\">(self, node, d, v, depth)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> node: <span class=\"keyword\">return</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> depth == d - <span class=\"number\">1</span>:</span><br><span class=\"line\">            lnode, rnode = node.left, node.right</span><br><span class=\"line\">            n1, n2 = TreeNode(v), TreeNode(v)</span><br><span class=\"line\">            n1.left, n2.right = lnode, rnode</span><br><span class=\"line\">            node.left, node.right = n1, n2</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">        self.helper(node.left, d, v, depth + <span class=\"number\">1</span>)</span><br><span class=\"line\">        self.helper(node.right, d, v, depth + <span class=\"number\">1</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"637-二叉树的层平均值\"><a href=\"#637-二叉树的层平均值\" class=\"headerlink\" title=\"637. 二叉树的层平均值\"></a>637. 二叉树的层平均值</h1><p><a href=\"https://leetcode-cn.com/problems/average-of-levels-in-binary-tree/\" target=\"_blank\" rel=\"noopener\">https://leetcode-cn.com/problems/average-of-levels-in-binary-tree/</a></p>\n<h2 id=\"题目描述-34\"><a href=\"#题目描述-34\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>给定一个非空二叉树, 返回一个由每层节点平均值组成的数组。</p>\n<p>示例 1：</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：</span><br><span class=\"line\">    <span class=\"number\">3</span></span><br><span class=\"line\">   / \\</span><br><span class=\"line\">  <span class=\"number\">9</span>  <span class=\"number\">20</span></span><br><span class=\"line\">    /  \\</span><br><span class=\"line\">   <span class=\"number\">15</span>   <span class=\"number\">7</span></span><br><span class=\"line\">输出：[<span class=\"number\">3</span>, <span class=\"number\">14.5</span>, <span class=\"number\">11</span>]</span><br><span class=\"line\">解释：</span><br><span class=\"line\">第 <span class=\"number\">0</span> 层的平均值是 <span class=\"number\">3</span> ,  第<span class=\"number\">1</span>层是 <span class=\"number\">14.5</span> , 第<span class=\"number\">2</span>层是 <span class=\"number\">11</span> 。因此返回 [<span class=\"number\">3</span>, <span class=\"number\">14.5</span>, <span class=\"number\">11</span>] 。</span><br></pre></td></tr></table></figure>\n<p>提示：</p>\n<p>节点值的范围在32位有符号整数范围内。</p>\n<h2 id=\"思路-34\"><a href=\"#思路-34\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>BFS，套模板，逐层计算均值即可。</p>\n<h2 id=\"代码-34\"><a href=\"#代码-34\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">averageOfLevels</span><span class=\"params\">(self, root: TreeNode)</span> -&gt; List[float]:</span></span><br><span class=\"line\">        queue = collections.deque()</span><br><span class=\"line\">        queue.append(root)</span><br><span class=\"line\">        ans = []</span><br><span class=\"line\">        <span class=\"keyword\">if</span> root:</span><br><span class=\"line\">            <span class=\"keyword\">while</span> queue:</span><br><span class=\"line\">                size = len(queue)</span><br><span class=\"line\">                s = <span class=\"number\">0</span></span><br><span class=\"line\">                <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(size):</span><br><span class=\"line\">                    node = queue.popleft()</span><br><span class=\"line\">                    s += node.val</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> node.left:</span><br><span class=\"line\">                        queue.append(node.left)</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> node.right:</span><br><span class=\"line\">                        queue.append(node.right)</span><br><span class=\"line\">                <span class=\"keyword\">if</span> size:</span><br><span class=\"line\">                    ans.append(s/size)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<h1 id=\"785-判断二分图\"><a href=\"#785-判断二分图\" class=\"headerlink\" title=\"785. 判断二分图\"></a>785. 判断二分图</h1><p><a href=\"https://leetcode-cn.com/problems/is-graph-bipartite/\" target=\"_blank\" rel=\"noopener\">https://leetcode-cn.com/problems/is-graph-bipartite/</a></p>\n<h2 id=\"题目描述-35\"><a href=\"#题目描述-35\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>给定一个无向图 <code>graph</code>，当这个图为二分图时返回 <code>true</code>。</p>\n<p>如果我们能将一个图的节点集合分割成两个独立的子集A和B，并使图中的每一条边的两个节点一个来自A集合，一个来自B集合，我们就将这个图称为二分图。</p>\n<p>graph将会以邻接表方式给出，<code>graph[i]</code> 表示图中与节点 <code>i</code> 相连的所有节点。每个节点都是一个在 <code>0</code> 到 <code>graph.length-1</code> 之间的整数。这图中没有自环和平行边： <code>graph[i]</code> 中不存在 <code>i</code>，并且 <code>graph[i]</code> 中没有重复的值。</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">示例 <span class=\"number\">1</span>:</span><br><span class=\"line\">输入: [[<span class=\"number\">1</span>,<span class=\"number\">3</span>], [<span class=\"number\">0</span>,<span class=\"number\">2</span>], [<span class=\"number\">1</span>,<span class=\"number\">3</span>], [<span class=\"number\">0</span>,<span class=\"number\">2</span>]]</span><br><span class=\"line\">输出: <span class=\"literal\">true</span></span><br><span class=\"line\">解释: </span><br><span class=\"line\">无向图如下:</span><br><span class=\"line\"><span class=\"number\">0</span>---<span class=\"number\">-1</span></span><br><span class=\"line\">|    |</span><br><span class=\"line\">|    |</span><br><span class=\"line\"><span class=\"number\">3</span>---<span class=\"number\">-2</span></span><br><span class=\"line\">我们可以将节点分成两组: &#123;<span class=\"number\">0</span>, <span class=\"number\">2</span>&#125; 和 &#123;<span class=\"number\">1</span>, <span class=\"number\">3</span>&#125;。</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">示例 <span class=\"number\">2</span>:</span><br><span class=\"line\">输入: [[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>], [<span class=\"number\">0</span>,<span class=\"number\">2</span>], [<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">3</span>], [<span class=\"number\">0</span>,<span class=\"number\">2</span>]]</span><br><span class=\"line\">输出: <span class=\"literal\">false</span></span><br><span class=\"line\">解释: </span><br><span class=\"line\">无向图如下:</span><br><span class=\"line\"><span class=\"number\">0</span>---<span class=\"number\">-1</span></span><br><span class=\"line\">| \\  |</span><br><span class=\"line\">|  \\ |</span><br><span class=\"line\"><span class=\"number\">3</span>---<span class=\"number\">-2</span></span><br><span class=\"line\">我们不能将节点分割成两个独立的子集。</span><br></pre></td></tr></table></figure>\n<p>注意:</p>\n<ul>\n<li><code>graph</code> 的长度范围为 <code>[1, 100]</code>。</li>\n<li><code>graph[i]</code> 中的元素的范围为 <code>[0, graph.length - 1]</code>。</li>\n<li><code>graph[i]</code> 不会包含 <code>i</code> 或者有重复的值。</li>\n<li>图是无向的: 如果 <code>j</code> 在 <code>graph[i]</code> 里边, 那么 <code>i</code> 也会在 <code>graph[j]</code> 里边。</li>\n</ul>\n<h2 id=\"思路-35\"><a href=\"#思路-35\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>BFS，遍历所有节点，用 <code>visited</code> 数组标记节点是否已经被访问（初始值为 <code>0</code>）：</p>\n<ul>\n<li>对当前未访问的节点 <code>i</code>，<ol>\n<li>将 <code>visited[i]</code> 标记为 <code>1</code>；</li>\n<li>把 <code>i</code> 的相邻节点 <code>j</code> 标记为 <code>-1</code>，然后继续对 <code>j</code> 的相邻节点标记为 <code>-visited[j]</code>，直到所有连接在一起的节点都被访问；</li>\n<li>如果上一步在标记时，<code>i</code> 的某个相邻节点 <code>j</code> 的标记值 <code>visited[j] = visited[i]</code>，则说明无法将图中节点分割，返回 <code>false</code>。</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"代码-35\"><a href=\"#代码-35\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isBipartite</span><span class=\"params\">(self, graph: List[List[int]])</span> -&gt; bool:</span></span><br><span class=\"line\">        visited = [<span class=\"number\">0</span>] * len(graph)</span><br><span class=\"line\">        queue = collections.deque()</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(graph)):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> visited[i] != <span class=\"number\">0</span>:</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>              </span><br><span class=\"line\">            visited[i] = <span class=\"number\">1</span></span><br><span class=\"line\">            queue.append(i)</span><br><span class=\"line\">            <span class=\"keyword\">while</span> queue:</span><br><span class=\"line\">                cur = queue.popleft()</span><br><span class=\"line\">                <span class=\"keyword\">for</span> node <span class=\"keyword\">in</span> graph[cur]:</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> visited[node] == <span class=\"number\">0</span>:</span><br><span class=\"line\">                        visited[node] = -visited[cur]</span><br><span class=\"line\">                        queue.append(node)</span><br><span class=\"line\">                    <span class=\"keyword\">elif</span> visited[node] == visited[cur]:</span><br><span class=\"line\">                        <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"974-和可被-K-整除的子数组\"><a href=\"#974-和可被-K-整除的子数组\" class=\"headerlink\" title=\"974. 和可被 K 整除的子数组\"></a>974. 和可被 K 整除的子数组</h1><p><a href=\"https://leetcode-cn.com/problems/subarray-sums-divisible-by-k/\" target=\"_blank\" rel=\"noopener\">https://leetcode-cn.com/problems/subarray-sums-divisible-by-k/</a></p>\n<h2 id=\"题目描述-36\"><a href=\"#题目描述-36\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>给定一个整数数组 A，返回其中元素之和可被 K 整除的（连续、非空）子数组的数目。</p>\n<p>示例：</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：A = [<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">0</span>,<span class=\"number\">-2</span>,<span class=\"number\">-3</span>,<span class=\"number\">1</span>], K = <span class=\"number\">5</span></span><br><span class=\"line\">输出：<span class=\"number\">7</span></span><br><span class=\"line\">解释：</span><br><span class=\"line\">有 <span class=\"number\">7</span> 个子数组满足其元素之和可被 K = <span class=\"number\">5</span> 整除：</span><br><span class=\"line\">[<span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">0</span>, <span class=\"number\">-2</span>, <span class=\"number\">-3</span>, <span class=\"number\">1</span>], [<span class=\"number\">5</span>], [<span class=\"number\">5</span>, <span class=\"number\">0</span>], [<span class=\"number\">5</span>, <span class=\"number\">0</span>, <span class=\"number\">-2</span>, <span class=\"number\">-3</span>], [<span class=\"number\">0</span>], [<span class=\"number\">0</span>, <span class=\"number\">-2</span>, <span class=\"number\">-3</span>], [<span class=\"number\">-2</span>, <span class=\"number\">-3</span>]</span><br></pre></td></tr></table></figure>\n<p>提示：</p>\n<ol>\n<li><code>1 &lt;= A.length &lt;= 30000</code></li>\n<li><code>-10000 &lt;= A[i] &lt;= 10000</code></li>\n<li><code>2 &lt;= K &lt;= 10000</code></li>\n</ol>\n<h2 id=\"思路-36\"><a href=\"#思路-36\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>一个前缀和的问题。设 $\\rm presum[i]$是数组 $\\rm A$ 第 $\\rm i$ 个元素的前缀和，那么 $\\rm A[i]$ 就可以表示为 $\\rm presum[i] - presum[i-1]$，子数组 $\\rm A[k]$ 到 $\\rm A[i]$ 的和就是 $\\rm presum[i] - presum[k-1]$。</p>\n<p>题目要求的是满足 $\\rm presum[i] - presum[k-1] \\bmod K = 0$ 的子数组 $\\rm [A[k],…,A[i]]$ 的个数，根据同余定理，可以把问题转换为求同余的 $\\rm presum[i]$ 的个数。每扫描到数组中的一个数，就检查哈希表中有没有同余的数组，若有则计算同余的数量，若无把当前模 $\\rm K$ 的余数保存在哈希表中，一次遍历即可解决问题。</p>\n<h2 id=\"代码-36\"><a href=\"#代码-36\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">subarraysDivByK</span><span class=\"params\">(self, A: List[int], K: int)</span> -&gt; int:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> len(A)==<span class=\"number\">0</span> <span class=\"keyword\">or</span> K==<span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">        d = &#123;<span class=\"number\">0</span>:<span class=\"number\">1</span>&#125;</span><br><span class=\"line\">        presum, cnt = <span class=\"number\">0</span>, <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> a <span class=\"keyword\">in</span> A:</span><br><span class=\"line\">            presum += a</span><br><span class=\"line\">            m = presum % K</span><br><span class=\"line\">            s = d.get(m, <span class=\"number\">0</span>)</span><br><span class=\"line\">            cnt += s</span><br><span class=\"line\">            d[m] = s + <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> cnt</span><br></pre></td></tr></table></figure>\n<h1 id=\"994-腐烂的橘子\"><a href=\"#994-腐烂的橘子\" class=\"headerlink\" title=\"994. 腐烂的橘子\"></a>994. 腐烂的橘子</h1><p><a href=\"https://leetcode-cn.com/problems/rotting-oranges/\" target=\"_blank\" rel=\"noopener\">https://leetcode-cn.com/problems/rotting-oranges/</a></p>\n<h2 id=\"题目描述-37\"><a href=\"#题目描述-37\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>在给定的网格中，每个单元格可以有以下三个值之一：</p>\n<p>值 <code>0</code> 代表空单元格；<br>值 <code>1</code> 代表新鲜橘子；<br>值 <code>2</code> 代表腐烂的橘子。<br>每分钟，任何与腐烂的橘子（在 4 个正方向上）相邻的新鲜橘子都会腐烂。</p>\n<p>返回直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 <code>-1</code>。</p>\n<p>示例 1：</p>\n<p><img src=\"http://images.yingwai.top/picgo/oranges.png\" alt=\"\"></p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：[[<span class=\"number\">2</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>],[<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">0</span>],[<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>]]</span><br><span class=\"line\">输出：<span class=\"number\">4</span></span><br></pre></td></tr></table></figure>\n<p>示例 2：</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：[[<span class=\"number\">2</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>],[<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>],[<span class=\"number\">1</span>,<span class=\"number\">0</span>,<span class=\"number\">1</span>]]</span><br><span class=\"line\">输出：<span class=\"number\">-1</span></span><br><span class=\"line\">解释：左下角的橘子（第 <span class=\"number\">2</span> 行， 第 <span class=\"number\">0</span> 列）永远不会腐烂，因为腐烂只会发生在 <span class=\"number\">4</span> 个正向上。</span><br></pre></td></tr></table></figure>\n<p>示例 3：</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：[[<span class=\"number\">0</span>,<span class=\"number\">2</span>]]</span><br><span class=\"line\">输出：<span class=\"number\">0</span></span><br><span class=\"line\">解释：因为 <span class=\"number\">0</span> 分钟时已经没有新鲜橘子了，所以答案就是 <span class=\"number\">0</span> 。</span><br></pre></td></tr></table></figure>\n<p>提示：</p>\n<ol>\n<li><code>1 &lt;= grid.length &lt;= 10</code></li>\n<li><code>1 &lt;= grid[0].length &lt;= 10</code></li>\n<li><code>grid[i][j]</code>仅为<code>0</code>、<code>1</code>或<code>2</code></li>\n</ol>\n<h2 id=\"思路-37\"><a href=\"#思路-37\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>广度优先搜索，一圈一圈往外腐蚀。</p>\n<h2 id=\"代码-37\"><a href=\"#代码-37\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">orangesRotting</span><span class=\"params\">(self, grid: List[List[int]])</span> -&gt; int:</span></span><br><span class=\"line\">        dx = [<span class=\"number\">-1</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>]</span><br><span class=\"line\">        dy = [<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">-1</span>, <span class=\"number\">1</span>]</span><br><span class=\"line\">        rotlist = list()    <span class=\"comment\"># 腐烂橘子的队列</span></span><br><span class=\"line\">        minute = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(grid)):</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(len(grid[<span class=\"number\">0</span>])):</span><br><span class=\"line\">                <span class=\"keyword\">if</span> grid[i][j] == <span class=\"number\">2</span>:</span><br><span class=\"line\">                    rotlist.append([i, j])</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> rotlist:  <span class=\"comment\"># BFS循环</span></span><br><span class=\"line\">            newrotlist = list()</span><br><span class=\"line\">            <span class=\"keyword\">for</span> rotorange <span class=\"keyword\">in</span> rotlist:   <span class=\"comment\"># 当前腐烂橘子的坐标</span></span><br><span class=\"line\">                x0 = rotorange[<span class=\"number\">0</span>]</span><br><span class=\"line\">                y0 = rotorange[<span class=\"number\">1</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">4</span>):  <span class=\"comment\"># 四个相邻方向的橘子腐烂</span></span><br><span class=\"line\">                    x = x0 + dx[i]</span><br><span class=\"line\">                    y = y0 + dy[i]</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> <span class=\"number\">0</span>&lt;=x&lt;len(grid) <span class=\"keyword\">and</span> <span class=\"number\">0</span>&lt;=y&lt;len(grid[<span class=\"number\">0</span>]) <span class=\"keyword\">and</span> grid[x][y]==<span class=\"number\">1</span>:</span><br><span class=\"line\">                        grid[x][y] = <span class=\"number\">2</span></span><br><span class=\"line\">                        newrotlist.append([x, y])</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> newrotlist:</span><br><span class=\"line\">                <span class=\"keyword\">break</span></span><br><span class=\"line\"></span><br><span class=\"line\">            minute += <span class=\"number\">1</span></span><br><span class=\"line\">            rotlist = newrotlist[:]     <span class=\"comment\"># 更新腐烂队列</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> row <span class=\"keyword\">in</span> grid:</span><br><span class=\"line\">                <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> row:</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> i == <span class=\"number\">1</span>:  <span class=\"comment\"># 还有新鲜的</span></span><br><span class=\"line\">                        <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> minute</span><br></pre></td></tr></table></figure>\n<h1 id=\"1305-两棵二叉搜索树中的所有元素\"><a href=\"#1305-两棵二叉搜索树中的所有元素\" class=\"headerlink\" title=\"1305. 两棵二叉搜索树中的所有元素\"></a>1305. 两棵二叉搜索树中的所有元素</h1><p><a href=\"https://leetcode-cn.com/problems/all-elements-in-two-binary-search-trees/\" target=\"_blank\" rel=\"noopener\">https://leetcode-cn.com/problems/all-elements-in-two-binary-search-trees/</a></p>\n<h2 id=\"题目描述-38\"><a href=\"#题目描述-38\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>给你 root1 和 root2 这两棵二叉搜索树。</p>\n<p>请你返回一个列表，其中包含 两棵树 中的所有整数并按 升序 排序。</p>\n<p>示例 1：</p>\n<p><img src=\"http://images.yingwai.top/picgo/lc1305f1.png\" alt=\"\"></p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：root1 = [<span class=\"number\">2</span>,<span class=\"number\">1</span>,<span class=\"number\">4</span>], root2 = [<span class=\"number\">1</span>,<span class=\"number\">0</span>,<span class=\"number\">3</span>]</span><br><span class=\"line\">输出：[<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>]</span><br></pre></td></tr></table></figure>\n<p>示例 2：</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：root1 = [<span class=\"number\">0</span>,<span class=\"number\">-10</span>,<span class=\"number\">10</span>], root2 = [<span class=\"number\">5</span>,<span class=\"number\">1</span>,<span class=\"number\">7</span>,<span class=\"number\">0</span>,<span class=\"number\">2</span>]</span><br><span class=\"line\">输出：[<span class=\"number\">-10</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">5</span>,<span class=\"number\">7</span>,<span class=\"number\">10</span>]</span><br></pre></td></tr></table></figure>\n<p>示例 3：</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：root1 = [], root2 = [<span class=\"number\">5</span>,<span class=\"number\">1</span>,<span class=\"number\">7</span>,<span class=\"number\">0</span>,<span class=\"number\">2</span>]</span><br><span class=\"line\">输出：[<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">5</span>,<span class=\"number\">7</span>]</span><br></pre></td></tr></table></figure>\n<p>示例 4：</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：root1 = [<span class=\"number\">0</span>,<span class=\"number\">-10</span>,<span class=\"number\">10</span>], root2 = []</span><br><span class=\"line\">输出：[<span class=\"number\">-10</span>,<span class=\"number\">0</span>,<span class=\"number\">10</span>]</span><br></pre></td></tr></table></figure>\n<p>示例 5：</p>\n<p><img src=\"http://images.yingwai.top/picgo/lc1305f2.png\" alt=\"\"></p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：root1 = [<span class=\"number\">1</span>,<span class=\"literal\">null</span>,<span class=\"number\">8</span>], root2 = [<span class=\"number\">8</span>,<span class=\"number\">1</span>]</span><br><span class=\"line\">输出：[<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">8</span>,<span class=\"number\">8</span>]</span><br></pre></td></tr></table></figure>\n<p>提示：</p>\n<ul>\n<li>每棵树最多有 <code>5000</code> 个节点。</li>\n<li>每个节点的值在 <code>[-10^5, 10^5]</code> 之间。</li>\n</ul>\n<h2 id=\"思路-38\"><a href=\"#思路-38\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>利用二叉搜索树性质，中序遍历得到每棵树的节点值的升序排列，然后再使用归并排序得到最终的结果数组。</p>\n<ul>\n<li>时间复杂度 $O(M + N)$，中序遍历和归并排序都是 $O(M + N)$，其中 $M,N$ 分别为两棵树的节点个数；</li>\n<li>空间复杂度 $O(M+N)$，用到两个额外的数组来存储每棵树的升序排列。</li>\n</ul>\n<h2 id=\"代码-38\"><a href=\"#代码-38\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">getAllElements</span><span class=\"params\">(self, root1: TreeNode, root2: TreeNode)</span> -&gt; List[int]:</span></span><br><span class=\"line\">        t1, t2 = [], []</span><br><span class=\"line\">        ans = []</span><br><span class=\"line\">        self.helper(root1, t1)</span><br><span class=\"line\">        self.helper(root2, t2)</span><br><span class=\"line\">        i, j = <span class=\"number\">0</span>, <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> i &lt; len(t1) <span class=\"keyword\">or</span> j &lt; len(t2):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> i &lt; len(t1) <span class=\"keyword\">and</span> (j == len(t2) <span class=\"keyword\">or</span> t1[i] &lt; t2[j]):</span><br><span class=\"line\">                ans.append(t1[i])</span><br><span class=\"line\">                i += <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                ans.append(t2[j])</span><br><span class=\"line\">                j += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">helper</span><span class=\"params\">(self, node, t)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> node: <span class=\"keyword\">return</span></span><br><span class=\"line\">        self.helper(node.left, t)</span><br><span class=\"line\">        t.append(node.val)</span><br><span class=\"line\">        self.helper(node.right, t)</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"面试题-16-11-跳水板\"><a href=\"#面试题-16-11-跳水板\" class=\"headerlink\" title=\"面试题 16.11. 跳水板\"></a>面试题 16.11. 跳水板</h1><p><a href=\"https://leetcode-cn.com/problems/diving-board-lcci/\" target=\"_blank\" rel=\"noopener\">https://leetcode-cn.com/problems/diving-board-lcci/</a></p>\n<h2 id=\"题目描述-39\"><a href=\"#题目描述-39\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>你正在使用一堆木板建造跳水板。有两种类型的木板，其中长度较短的木板长度为<code>shorter</code>，长度较长的木板长度为<code>longer</code>。你必须正好使用<code>k</code>块木板。编写一个方法，生成跳水板所有可能的长度。</p>\n<p>返回的长度需要从小到大排列。</p>\n<p>示例：</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：</span><br><span class=\"line\">shorter = <span class=\"number\">1</span></span><br><span class=\"line\">longer = <span class=\"number\">2</span></span><br><span class=\"line\">k = <span class=\"number\">3</span></span><br><span class=\"line\">输出： &#123;<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>&#125;</span><br></pre></td></tr></table></figure>\n<p>提示：</p>\n<ul>\n<li>0 &lt; shorter &lt;= longer</li>\n<li>0 &lt;= k &lt;= 100000</li>\n</ul>\n<h2 id=\"思路-39\"><a href=\"#思路-39\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>因为每次都必须要正好使用 <code>k</code> 块木板，所以有以下公式</p>\n<script type=\"math/tex; mode=display\">\nans[i] = shorter\\times i + longer \\times (k-i)</script><p>其中 $0 \\leq i \\leq k$。</p>\n<p>在 $longer &gt; shorter$ 的情况下，为什么每种组合下建造的跳水板长度都是不一样的？考虑以下两种不同的组合：第一种组合，有 $i$ 块短木板，则跳水板的长度是 $shorter \\times i + longer \\times (k−i)$；第二种组合，有 $j$ 块短木板，则跳水板的长度是 $shorter \\times j+longer \\times (k−j)$。其中 $0 \\leq i&lt;j \\leq k$。则两种不同的组合下的跳水板长度之差为：</p>\n<script type=\"math/tex; mode=display\">\n(shorter \\times j+longer \\times (k−j)) - (shorter \\times i + longer \\times (k−i)) = (longer - shorter) \\times (i - j)</script><p>因为 $longer &gt; shorter$ 且 $i&lt;j$，因此上式 $&lt;0$。</p>\n<p>然后要考虑到极端情况：</p>\n<ul>\n<li>$k = 0$：直接输出空列表。</li>\n<li>$longer = shorter$：输出列表中只有一个元素 $ans = [shorter(longer) \\times k]$。</li>\n</ul>\n<h2 id=\"代码-39\"><a href=\"#代码-39\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">divingBoard</span><span class=\"params\">(self, shorter: int, longer: int, k: int)</span> -&gt; List[int]:</span></span><br><span class=\"line\">        ans = []</span><br><span class=\"line\">        <span class=\"keyword\">if</span> k &gt; <span class=\"number\">0</span>:</span><br><span class=\"line\">            s, l = k, <span class=\"number\">0</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> shorter == longer:</span><br><span class=\"line\">                ans.append(shorter*s)</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                <span class=\"keyword\">while</span> l &lt;= k:</span><br><span class=\"line\">                    ans.append(shorter*s + longer*l)</span><br><span class=\"line\">                    s -= <span class=\"number\">1</span></span><br><span class=\"line\">                    l += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<h1 id=\"面试题-17-12-BiNode\"><a href=\"#面试题-17-12-BiNode\" class=\"headerlink\" title=\"面试题 17. 12. BiNode\"></a>面试题 17. 12. BiNode</h1><p><a href=\"https://leetcode-cn.com/problems/binode-lcci/\" target=\"_blank\" rel=\"noopener\">https://leetcode-cn.com/problems/binode-lcci/</a></p>\n<h2 id=\"题目描述-40\"><a href=\"#题目描述-40\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>二叉树数据结构 <code>TreeNode</code> 可用来表示单向链表（其中 <code>left</code> 置空，<code>right</code> 为下一个链表节点）。实现一个方法，把二叉搜索树转换为单向链表，要求依然符合二叉搜索树的性质，转换操作应是原址的，也就是在原始的二叉搜索树上直接修改。</p>\n<p>返回转换后的单向链表的头节点。</p>\n<p>注意：本题相对原题稍作改动</p>\n<p>示例：</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入： [<span class=\"number\">4</span>,<span class=\"number\">2</span>,<span class=\"number\">5</span>,<span class=\"number\">1</span>,<span class=\"number\">3</span>,<span class=\"literal\">null</span>,<span class=\"number\">6</span>,<span class=\"number\">0</span>]</span><br><span class=\"line\">输出： [<span class=\"number\">0</span>,<span class=\"literal\">null</span>,<span class=\"number\">1</span>,<span class=\"literal\">null</span>,<span class=\"number\">2</span>,<span class=\"literal\">null</span>,<span class=\"number\">3</span>,<span class=\"literal\">null</span>,<span class=\"number\">4</span>,<span class=\"literal\">null</span>,<span class=\"number\">5</span>,<span class=\"literal\">null</span>,<span class=\"number\">6</span>]</span><br></pre></td></tr></table></figure>\n<p>提示：</p>\n<ul>\n<li>节点数量不会超过 100000。</li>\n</ul>\n<h2 id=\"思路-40\"><a href=\"#思路-40\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>中序遍历，用 <code>pre</code> 记录上一个处理的节点，访问到一个新的节点 <code>p</code> 时，将 <code>pre.right</code> 指向 <code>p</code> 并把 <code>p.left</code> 置空。</p>\n<p>注意要将第一个处理的节点作为根节点。</p>\n<h2 id=\"代码-40\"><a href=\"#代码-40\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">convertBiNode</span><span class=\"params\">(self, root: TreeNode)</span> -&gt; TreeNode:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> root:</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">        s = []</span><br><span class=\"line\">        p, pre = root, <span class=\"literal\">None</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> s <span class=\"keyword\">or</span> p:</span><br><span class=\"line\">            <span class=\"keyword\">while</span> p:</span><br><span class=\"line\">                s.append(p)</span><br><span class=\"line\">                p = p.left</span><br><span class=\"line\">            p = s.pop()</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> pre:</span><br><span class=\"line\">                root = p</span><br><span class=\"line\">                root.left = <span class=\"literal\">None</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                pre.right = p</span><br><span class=\"line\">                p.left = <span class=\"literal\">None</span></span><br><span class=\"line\">            pre = p</span><br><span class=\"line\">            p = p.right</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root</span><br></pre></td></tr></table></figure>\n<h1 id=\"面试题-17-13-恢复空格\"><a href=\"#面试题-17-13-恢复空格\" class=\"headerlink\" title=\"面试题 17.13. 恢复空格\"></a>面试题 17.13. 恢复空格</h1><p><a href=\"https://leetcode-cn.com/problems/re-space-lcci/\" target=\"_blank\" rel=\"noopener\">https://leetcode-cn.com/problems/re-space-lcci/</a></p>\n<h2 id=\"题目描述-41\"><a href=\"#题目描述-41\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>哦，不！你不小心把一个长篇文章中的空格、标点都删掉了，并且大写也弄成了小写。像句子<code>&quot;I reset the computer. It still didn’t boot!&quot;</code>已经变成了<code>&quot;iresetthecomputeritstilldidntboot&quot;</code>。在处理标点符号和大小写之前，你得先把它断成词语。当然了，你有一本厚厚的词典<code>dictionary</code>，不过，有些词没在词典里。假设文章用<code>sentence</code>表示，设计一个算法，把文章断开，要求未识别的字符最少，返回未识别的字符数。</p>\n<p>注意：本题相对原题稍作改动，只需返回未识别的字符数</p>\n<p>示例：</p>\n<figure class=\"highlight smalltalk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：</span><br><span class=\"line\">dictionary = [<span class=\"comment\">\"looked\"</span>,<span class=\"comment\">\"just\"</span>,<span class=\"comment\">\"like\"</span>,<span class=\"comment\">\"her\"</span>,<span class=\"comment\">\"brother\"</span>]</span><br><span class=\"line\">sentence = <span class=\"comment\">\"jesslookedjustliketimherbrother\"</span></span><br><span class=\"line\">输出： <span class=\"number\">7</span></span><br><span class=\"line\">解释： 断句后为<span class=\"comment\">\"jess looked just like tim her brother\"</span>，共<span class=\"number\">7</span>个未识别字符。</span><br></pre></td></tr></table></figure>\n<p>提示：</p>\n<ul>\n<li><code>0 &lt;= len(sentence) &lt;= 1000</code></li>\n<li><code>dictionary</code>中总字符数不超过 <code>150000</code>。</li>\n<li>你可以认为<code>dictionary</code>和<code>sentence</code>中只包含小写字母。</li>\n</ul>\n<h2 id=\"思路-41\"><a href=\"#思路-41\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>动态规划，用 $dp[i]$ 表示<code>sentence</code>中以第 $index$ 个字符结尾的字符串中未识别的字符数，其中 $i = index + 1$（这里令 $dp[0]=0$，因为可能出现前 $k$ 个字符组成一个词，这样做利于判断）。对于每个 $index$，都对<code>dictionary</code>进行一次遍历，用 $len$ 表示<code>dictionary</code>中每个词的长度，则可以得到动态方程：</p>\n<p>每扫描到一个 $i$，都先把 $dp[i]$ 初始化为 $i$，然后有</p>\n<p>当<code>sentence</code>中第 $index - len + 1$ 到 第 $index$ 个字符在<code>dictionary</code>中时，</p>\n<script type=\"math/tex; mode=display\">\ndp[i] = \\min (dp[i],dp[i-len])</script><p>其它情况，</p>\n<script type=\"math/tex; mode=display\">\ndp[i] = (dp[i], dp[i-1]+1)</script><p>最后 $dp$ 数组中的最后一个元素即为结果。</p>\n<h2 id=\"代码-41\"><a href=\"#代码-41\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">respace</span><span class=\"params\">(self, dictionary: List[str], sentence: str)</span> -&gt; int:</span></span><br><span class=\"line\">        dp = []</span><br><span class=\"line\">        dp.append(<span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, len(sentence)+<span class=\"number\">1</span>):</span><br><span class=\"line\">            index = i - <span class=\"number\">1</span></span><br><span class=\"line\">            t = i</span><br><span class=\"line\">            <span class=\"keyword\">for</span> word <span class=\"keyword\">in</span> dictionary:</span><br><span class=\"line\">                l = len(word)</span><br><span class=\"line\">                <span class=\"keyword\">if</span> index + <span class=\"number\">1</span> - l &gt;= <span class=\"number\">0</span> <span class=\"keyword\">and</span> sentence[index-l+<span class=\"number\">1</span>:index+<span class=\"number\">1</span>] <span class=\"keyword\">in</span> dictionary:</span><br><span class=\"line\">                    t = min(t, dp[i-l])</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> i - l == <span class=\"number\">0</span>:</span><br><span class=\"line\">                        <span class=\"keyword\">break</span></span><br><span class=\"line\">                t = min(t, dp[i<span class=\"number\">-1</span>]+<span class=\"number\">1</span>)</span><br><span class=\"line\">            dp.append(t)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[len(sentence)]</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p>记录一下每日刷题 $\\surd$</p>","more":"<p>[TOC]</p>\n<h1 id=\"4-寻找两个正序数组的中位数\"><a href=\"#4-寻找两个正序数组的中位数\" class=\"headerlink\" title=\"4. 寻找两个正序数组的中位数\"></a>4. 寻找两个正序数组的中位数</h1><p><a href=\"https://leetcode-cn.com/problems/median-of-two-sorted-arrays/\" target=\"_blank\" rel=\"noopener\">https://leetcode-cn.com/problems/median-of-two-sorted-arrays/</a></p>\n<h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>给定两个大小为 m 和 n 的正序（从小到大）数组 <code>nums1</code> 和 <code>nums2</code>。</p>\n<p>请你找出这两个正序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。</p>\n<p>你可以假设 <code>nums1</code> 和 <code>nums2</code> 不会同时为空。</p>\n<p>示例 1:</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nums1 = [<span class=\"number\">1</span>, <span class=\"number\">3</span>]</span><br><span class=\"line\">nums2 = [<span class=\"number\">2</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">则中位数是 <span class=\"number\">2.0</span></span><br></pre></td></tr></table></figure>\n<p>示例 2:</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nums1 = [<span class=\"number\">1</span>, <span class=\"number\">2</span>]</span><br><span class=\"line\">nums2 = [<span class=\"number\">3</span>, <span class=\"number\">4</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">则中位数是 (<span class=\"number\">2</span> + <span class=\"number\">3</span>)/<span class=\"number\">2</span> = <span class=\"number\">2.5</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>题目要求时间复杂度为 O(log(m + n))，知道要用二分查找，但是具体方法想不出来，只能看了一篇题解中的<a href=\"https://leetcode-cn.com/problems/median-of-two-sorted-arrays/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-w-2/\" target=\"_blank\" rel=\"noopener\">找第 k 小的数的方法</a>。</p>\n<p>主要思想是：</p>\n<ul>\n<li>比较两个数组的第 <code>k/2</code> 个数字（向下取整），哪个小则可以直接排除那个数组的前 <code>k/2</code> 个数字（因为两个数组都是有序的）；</li>\n<li>上一步已经排除了 <code>k/2</code> 个数，因此 <code>k = k - k/2</code>，再次比较两个数组（其中一个数组为排除了 <code>k/2</code> 个数后的新数组）的第 <code>k/2</code> 个数字，直到 <code>k = 1</code> 或其中一个数组中的元素被全部排除了：<ol>\n<li>若 <code>k = 1</code> 则返回当前两个数组的第一个元素中较小的那一个；</li>\n<li>若其中一个数组被全部排除，则返回另一个数组中的第 <code>k</code> 个元素。</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">findMedianSortedArrays</span><span class=\"params\">(self, nums1: List[int], nums2: List[int])</span> -&gt; float:</span></span><br><span class=\"line\">        n, m = len(nums1), len(nums2)</span><br><span class=\"line\">        left = (n + m + <span class=\"number\">1</span>) // <span class=\"number\">2</span></span><br><span class=\"line\">        right = (n + m + <span class=\"number\">2</span>) // <span class=\"number\">2</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> (self.recur(left, nums1, <span class=\"number\">0</span>, n<span class=\"number\">-1</span>, nums2, <span class=\"number\">0</span>, m<span class=\"number\">-1</span>) + self.recur(right, nums1, <span class=\"number\">0</span>, n<span class=\"number\">-1</span>, nums2, <span class=\"number\">0</span>, m<span class=\"number\">-1</span>)) * <span class=\"number\">0.5</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">recur</span><span class=\"params\">(self, k, arr1, s1, e1, arr2, s2, e2)</span>:</span></span><br><span class=\"line\">        l1 = e1 - s1 + <span class=\"number\">1</span></span><br><span class=\"line\">        l2 = e2 - s2 + <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> l1 &gt; l2:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> self.recur(k, arr2, s2, e2, arr1, s1, e1)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> l1 == <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> arr2[s2+k<span class=\"number\">-1</span>]</span><br><span class=\"line\">        <span class=\"keyword\">if</span> k == <span class=\"number\">1</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> min(arr1[s1], arr2[s2])</span><br><span class=\"line\">        p1 = s1 + min(k//<span class=\"number\">2</span>, l1) - <span class=\"number\">1</span></span><br><span class=\"line\">        p2 = s2 + min(k//<span class=\"number\">2</span>, l2) - <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> arr1[p1] &lt; arr2[p2]:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> self.recur(k-min(k//<span class=\"number\">2</span>, l1), arr1, p1+<span class=\"number\">1</span>, e1, arr2, s2, e2)</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> self.recur(k-min(k//<span class=\"number\">2</span>, l2), arr1, s1, e1, arr2, p2+<span class=\"number\">1</span>, e2)</span><br></pre></td></tr></table></figure>\n<h1 id=\"6-Z字形变换\"><a href=\"#6-Z字形变换\" class=\"headerlink\" title=\"6. Z字形变换\"></a>6. Z字形变换</h1><p><a href=\"https://leetcode-cn.com/problems/zigzag-conversion/\" target=\"_blank\" rel=\"noopener\">https://leetcode-cn.com/problems/zigzag-conversion/</a></p>\n<h2 id=\"题目描述-1\"><a href=\"#题目描述-1\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。</p>\n<p>比如输入字符串为 <code>&quot;LEETCODEISHIRING&quot;</code> 行数为 3 时，排列如下：</p>\n<figure class=\"highlight julia\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">L   C   <span class=\"literal\">I</span>   R</span><br><span class=\"line\">E T O E S <span class=\"literal\">I</span> <span class=\"literal\">I</span> G</span><br><span class=\"line\">E   D   H   N</span><br></pre></td></tr></table></figure>\n<p>之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：<code>&quot;LCIRETOESIIGEDHN&quot;</code>。</p>\n<p>请你实现这个将字符串进行指定行数变换的函数：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">convert</span><span class=\"params\">(<span class=\"built_in\">string</span> s, <span class=\"keyword\">int</span> numRows)</span></span>;</span><br></pre></td></tr></table></figure>\n<p>示例 1:</p>\n<figure class=\"highlight nix\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: <span class=\"attr\">s</span> = <span class=\"string\">\"LEETCODEISHIRING\"</span>, <span class=\"attr\">numRows</span> = <span class=\"number\">3</span></span><br><span class=\"line\">输出: <span class=\"string\">\"LCIRETOESIIGEDHN\"</span></span><br></pre></td></tr></table></figure>\n<p>示例 2:</p>\n<figure class=\"highlight julia\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: s = <span class=\"string\">\"LEETCODEISHIRING\"</span>, numRows = <span class=\"number\">4</span></span><br><span class=\"line\">输出: <span class=\"string\">\"LDREOEIIECIHNTSG\"</span></span><br><span class=\"line\">解释:</span><br><span class=\"line\"></span><br><span class=\"line\">L     D     R</span><br><span class=\"line\">E   O E   <span class=\"literal\">I</span> <span class=\"literal\">I</span></span><br><span class=\"line\">E C   <span class=\"literal\">I</span> H   N</span><br><span class=\"line\">T     S     G</span><br></pre></td></tr></table></figure>\n<h2 id=\"思路-1\"><a href=\"#思路-1\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>用一个二维列表 <code>tmp</code> 存储 Z 字形字符串中每一行的元素，最后将 <code>tmp</code> 中的字符串逐行拼接即得到结果，具体步骤如下：</p>\n<ul>\n<li>从头到尾遍历<code>s</code>，<code>cnt</code> 表示当前字符的下标，<code>curRow</code> 表示当前字符 <code>s[cnt]</code> 在 Z 字形字符串中所在的行数，<code>step</code> 表示当前的方向（因为 Z 字形中字符都是往上往下这样循环）；</li>\n<li>将 <code>s[cnt]</code> 加入 <code>tmp[curRow]</code>，然后 <code>cnt</code> 自增 1，<code>curRow</code> 自增 <code>step</code>。当 <code>curRow</code> 为 <code>0</code> 或 <code>numRows</code> 时，转换方向，<code>step *= -1</code> 。</li>\n</ul>\n<h2 id=\"代码-1\"><a href=\"#代码-1\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">convert</span><span class=\"params\">(self, s: str, numRows: int)</span> -&gt; str:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> numRows == <span class=\"number\">1</span>: <span class=\"keyword\">return</span> s</span><br><span class=\"line\">        tmp = [<span class=\"string\">\"\"</span> <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(numRows)]</span><br><span class=\"line\">        cnt = curRow = <span class=\"number\">0</span></span><br><span class=\"line\">        step = <span class=\"number\">-1</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> cnt &lt; len(s):</span><br><span class=\"line\">            tmp[curRow] += s[cnt]</span><br><span class=\"line\">            cnt += <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> curRow == numRows - <span class=\"number\">1</span> <span class=\"keyword\">or</span> curRow == <span class=\"number\">0</span>:</span><br><span class=\"line\">                step *= <span class=\"number\">-1</span></span><br><span class=\"line\">            curRow += step</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">''</span>.join(tmp)</span><br></pre></td></tr></table></figure>\n<h1 id=\"14-最长公共前缀\"><a href=\"#14-最长公共前缀\" class=\"headerlink\" title=\"14. 最长公共前缀\"></a>14. 最长公共前缀</h1><p><a href=\"https://leetcode-cn.com/problems/longest-common-prefix/\" target=\"_blank\" rel=\"noopener\">https://leetcode-cn.com/problems/longest-common-prefix/</a></p>\n<h2 id=\"题目描述-2\"><a href=\"#题目描述-2\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>编写一个函数来查找字符串数组中的最长公共前缀。</p>\n<p>如果不存在公共前缀，返回空字符串 <code>&quot;&quot;</code>。</p>\n<p>示例 1:</p>\n<figure class=\"highlight prolog\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: [<span class=\"string\">\"flower\"</span>,<span class=\"string\">\"flow\"</span>,<span class=\"string\">\"flight\"</span>]</span><br><span class=\"line\">输出: <span class=\"string\">\"fl\"</span></span><br></pre></td></tr></table></figure>\n<p>示例 2:</p>\n<figure class=\"highlight prolog\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: [<span class=\"string\">\"dog\"</span>,<span class=\"string\">\"racecar\"</span>,<span class=\"string\">\"car\"</span>]</span><br><span class=\"line\">输出: <span class=\"string\">\"\"</span></span><br><span class=\"line\">解释: 输入不存在公共前缀。</span><br></pre></td></tr></table></figure>\n<p>说明:</p>\n<p>所有输入只包含小写字母 <code>a-z</code> 。</p>\n<h2 id=\"思路-2\"><a href=\"#思路-2\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>Python中的<code>max()</code>和<code>min()</code>可以比较字符串，按照ASCII值逐位比较：比如<code>cba</code>、<code>cbab</code>、<code>cbd</code>中最大为<code>cbd</code>，最小为<code>cba</code>。因此只要比较最大最小的两个字符串即可找到最大公共前缀。</p>\n<h2 id=\"代码-2\"><a href=\"#代码-2\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">longestCommonPrefix</span><span class=\"params\">(self, strs: List[str])</span> -&gt; str:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> strs: <span class=\"keyword\">return</span> <span class=\"string\">\"\"</span></span><br><span class=\"line\">        str1 = min(strs)</span><br><span class=\"line\">        str2 = max(strs)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i,x <span class=\"keyword\">in</span> enumerate(str1):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> x != str2[i]:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> str2[:i]</span><br><span class=\"line\">        <span class=\"keyword\">return</span> str1</span><br></pre></td></tr></table></figure>\n<h1 id=\"21-合并两个有序链表\"><a href=\"#21-合并两个有序链表\" class=\"headerlink\" title=\"21. 合并两个有序链表\"></a>21. 合并两个有序链表</h1><p><a href=\"https://leetcode-cn.com/problems/merge-two-sorted-lists/\" target=\"_blank\" rel=\"noopener\">https://leetcode-cn.com/problems/merge-two-sorted-lists/</a></p>\n<h2 id=\"题目描述-3\"><a href=\"#题目描述-3\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p>\n<p>示例：</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：<span class=\"number\">1</span>-&gt;<span class=\"number\">2</span>-&gt;<span class=\"number\">4</span>, <span class=\"number\">1</span>-&gt;<span class=\"number\">3</span>-&gt;<span class=\"number\">4</span></span><br><span class=\"line\">输出：<span class=\"number\">1</span>-&gt;<span class=\"number\">1</span>-&gt;<span class=\"number\">2</span>-&gt;<span class=\"number\">3</span>-&gt;<span class=\"number\">4</span>-&gt;<span class=\"number\">4</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"思路-3\"><a href=\"#思路-3\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>因为链表有序，可以用两个指针分别遍历两个链表，将两个指针指向的节点中值较小的节点加入到新链表中，然后该指针往后挪，直到遍历完两个链表。</p>\n<p>时间复杂度为 O(M + N)，M 和 N 分别为两个链表的长度。</p>\n<h2 id=\"代码-3\"><a href=\"#代码-3\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">mergeTwoLists</span><span class=\"params\">(self, l1: ListNode, l2: ListNode)</span> -&gt; ListNode:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> l1 <span class=\"keyword\">and</span> <span class=\"keyword\">not</span> l2: <span class=\"keyword\">return</span> <span class=\"literal\">None</span></span><br><span class=\"line\">        p1, p2 = l1, l2</span><br><span class=\"line\">        pre = <span class=\"literal\">None</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> p1 <span class=\"keyword\">and</span> p2:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> p2.val &lt; p1.val:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> pre:</span><br><span class=\"line\">                    root = p2</span><br><span class=\"line\">                    pre = root</span><br><span class=\"line\">                <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                    pre.next = p2</span><br><span class=\"line\">                    pre = p2</span><br><span class=\"line\">                p2 = p2.next</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> pre:</span><br><span class=\"line\">                    root = p1</span><br><span class=\"line\">                    pre = root</span><br><span class=\"line\">                <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                    pre.next = p1</span><br><span class=\"line\">                    pre = p1</span><br><span class=\"line\">                p1 = p1.next</span><br><span class=\"line\">        <span class=\"keyword\">if</span> p1:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> pre:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> p1</span><br><span class=\"line\">            pre.next = p1</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> pre:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> p2</span><br><span class=\"line\">            pre.next = p2</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root</span><br></pre></td></tr></table></figure>\n<h1 id=\"32-最长有效括号\"><a href=\"#32-最长有效括号\" class=\"headerlink\" title=\"32. 最长有效括号\"></a>32. 最长有效括号</h1><p><a href=\"https://leetcode-cn.com/problems/longest-valid-parentheses/\" target=\"_blank\" rel=\"noopener\">https://leetcode-cn.com/problems/longest-valid-parentheses/</a></p>\n<h2 id=\"题目描述-4\"><a href=\"#题目描述-4\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>给定一个只包含 <code>&#39;(&#39;</code> 和 <code>&#39;)&#39;</code> 的字符串，找出最长的包含有效括号的子串的长度。</p>\n<p>示例 1:</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">输入: \"(()\"</span></span><br><span class=\"line\"><span class=\"section\">输出: 2</span></span><br><span class=\"line\"><span class=\"section\">解释: 最长有效括号子串为 \"()\"</span></span><br></pre></td></tr></table></figure>\n<p>示例 2:</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">输入: \")()())\"</span></span><br><span class=\"line\"><span class=\"section\">输出: 4</span></span><br><span class=\"line\"><span class=\"section\">解释: 最长有效括号子串为 \"()()\"</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"思路-4\"><a href=\"#思路-4\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>动态规划：用 $dp[i]$ 表示字符串中以第 $i$ 个字符结尾的字符串的最大有效子串长度。根据题意，$s[i]$ 为 <code>&#39;(&#39;</code> 时 $dp[i]=0$，有效的子串结尾肯定是 <code>&#39;)&#39;</code>，可列出动态方程：</p>\n<p>当 $s[i]$ 为 <code>&#39;)&#39;</code> 且 $s[i-1]$ 为 <code>&#39;(&#39;</code> 时，也就是 “$……()$”，</p>\n<script type=\"math/tex; mode=display\">\ndp[i] = dp[i-2] + 2</script><p>当 $s[i]$ 为 <code>&#39;)&#39;</code> 且 $s[i-1]$ 为 <code>&#39;)&#39;</code> 时，也就是 “$……))$”，如果倒数第二个 <code>&#39;)&#39;</code> 是一个有效字符串 $sub_s$ 的一部分，且 $s[i-\\mbox{len}(sub_s)-1]$ 为 <code>&#39;(&#39;</code> 。此时的最长有效子串的长度即为 $sub_s$ 加上 $2$ 再加上 $dp[i-\\mbox{len}(sub_s)-2]$：</p>\n<script type=\"math/tex; mode=display\">\ndp[i] = dp[i-1] + 2 + dp[i-dp[i-1]-2]</script><p>最后的结果为 $dp$ 数组中的最大值。</p>\n<p>上面两条方程都要注意判断下标 $i-2$ 和 $i-dp[i-1]-2$ 的值，不要小于 $0$。</p>\n<h2 id=\"代码-4\"><a href=\"#代码-4\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">longestValidParentheses</span><span class=\"params\">(self, s: str)</span> -&gt; int:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> len(s) &lt;= <span class=\"number\">1</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">        dp = [<span class=\"number\">0</span>]</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, len(s)):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> s[i] == <span class=\"string\">')'</span>:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> s[i<span class=\"number\">-1</span>] == <span class=\"string\">'('</span>:</span><br><span class=\"line\">                    dp.append(dp[max(i<span class=\"number\">-2</span>, <span class=\"number\">0</span>)] + <span class=\"number\">2</span>)</span><br><span class=\"line\">                <span class=\"keyword\">elif</span> s[i<span class=\"number\">-1</span>] == <span class=\"string\">')'</span> <span class=\"keyword\">and</span> i-dp[i<span class=\"number\">-1</span>]<span class=\"number\">-1</span> &gt;= <span class=\"number\">0</span> <span class=\"keyword\">and</span> s[i-dp[i<span class=\"number\">-1</span>]<span class=\"number\">-1</span>] == <span class=\"string\">'('</span>:</span><br><span class=\"line\">                    dp.append(dp[i<span class=\"number\">-1</span>] + <span class=\"number\">2</span> + dp[max(i-dp[i<span class=\"number\">-1</span>]<span class=\"number\">-2</span>, <span class=\"number\">0</span>)])</span><br><span class=\"line\">                <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                    dp.append(<span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                dp.append(<span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> max(dp)</span><br></pre></td></tr></table></figure>\n<h1 id=\"35-搜索插入位置\"><a href=\"#35-搜索插入位置\" class=\"headerlink\" title=\"35. 搜索插入位置\"></a>35. 搜索插入位置</h1><p><a href=\"https://leetcode-cn.com/problems/search-insert-position/\" target=\"_blank\" rel=\"noopener\">https://leetcode-cn.com/problems/search-insert-position/</a></p>\n<h2 id=\"题目描述-5\"><a href=\"#题目描述-5\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p>\n<p>你可以假设数组中无重复元素。</p>\n<p>示例 1:</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: [<span class=\"number\">1</span>,<span class=\"number\">3</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>], <span class=\"number\">5</span></span><br><span class=\"line\">输出: <span class=\"number\">2</span></span><br></pre></td></tr></table></figure>\n<p>示例 2:</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: [<span class=\"number\">1</span>,<span class=\"number\">3</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>], <span class=\"number\">2</span></span><br><span class=\"line\">输出: <span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n<p>示例 3:</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: [<span class=\"number\">1</span>,<span class=\"number\">3</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>], <span class=\"number\">7</span></span><br><span class=\"line\">输出: <span class=\"number\">4</span></span><br></pre></td></tr></table></figure>\n<p>示例 4:</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: [<span class=\"number\">1</span>,<span class=\"number\">3</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>], <span class=\"number\">0</span></span><br><span class=\"line\">输出: <span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"思路-5\"><a href=\"#思路-5\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>二分查找，每次排除当前数组中一半的元素。</p>\n<p>注意递归边界为 <code>left &gt;= right</code>，<code>target</code> 在 <code>nums</code> 不存在有两种情况：</p>\n<ul>\n<li>当 <code>left &gt; right</code> 时，数组 <code>nums</code> 中不存在与 <code>target</code> 相等的元素，此时 <code>nums[left]</code> 为 <code>nums</code> 中第一个大于 <code>target</code> 的元素，<code>left</code> 即为 <code>target</code> 应该插入的位置；</li>\n<li>当 <code>left == right</code> 时，此时 <code>left</code> 和 <code>right</code> 应该都指向 <code>nums</code> 中最后一个元素（因为 <code>mid</code> 总是向下取整，这种情况下 <code>left</code> 每次都 <code>+1</code>，直到指向最后一个元素），此时需要额外判断 <code>target</code> 与最后一个元素的大小，<code>target</code> 大则将其插入到数组末尾。</li>\n</ul>\n<h2 id=\"代码-5\"><a href=\"#代码-5\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">searchInsert</span><span class=\"params\">(self, nums: List[int], target: int)</span> -&gt; int:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.getInsertIndex(nums, <span class=\"number\">0</span>, len(nums)<span class=\"number\">-1</span>, target)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">getInsertIndex</span><span class=\"params\">(self, nums, left, right, target)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> left &gt;= right:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> target &gt; nums[left]:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> left + <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> left</span><br><span class=\"line\">        mid = (left + right) // <span class=\"number\">2</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> target == nums[mid]:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> mid</span><br><span class=\"line\">        <span class=\"keyword\">if</span> target &lt; nums[mid]:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> self.getInsertIndex(nums, left, mid<span class=\"number\">-1</span>, target)</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> self.getInsertIndex(nums, mid+<span class=\"number\">1</span>, right, target)</span><br></pre></td></tr></table></figure>\n<h1 id=\"94-二叉树的中序遍历\"><a href=\"#94-二叉树的中序遍历\" class=\"headerlink\" title=\"94. 二叉树的中序遍历\"></a>94. 二叉树的中序遍历</h1><p><a href=\"https://leetcode-cn.com/problems/binary-tree-inorder-traversal/\" target=\"_blank\" rel=\"noopener\">https://leetcode-cn.com/problems/binary-tree-inorder-traversal/</a></p>\n<h2 id=\"题目描述-6\"><a href=\"#题目描述-6\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>给定一个二叉树，返回它的中序 遍历。</p>\n<p>示例:</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: [<span class=\"number\">1</span>,<span class=\"literal\">null</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]</span><br><span class=\"line\">   <span class=\"number\">1</span></span><br><span class=\"line\">    \\</span><br><span class=\"line\">     <span class=\"number\">2</span></span><br><span class=\"line\">    /</span><br><span class=\"line\">   <span class=\"number\">3</span></span><br><span class=\"line\"></span><br><span class=\"line\">输出: [<span class=\"number\">1</span>,<span class=\"number\">3</span>,<span class=\"number\">2</span>]</span><br></pre></td></tr></table></figure>\n<p>进阶: 递归算法很简单，你可以通过迭代算法完成吗？</p>\n<h2 id=\"思路-6\"><a href=\"#思路-6\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>这里可以用两种方法，递归和迭代，前者比较简单就不说了，主要讲后者。</p>\n<p>迭代算法中需要用到一个栈，每到一个节点先将其入栈，遍历其左子树，然后访问该节点，访问完后该节点就可以出栈了，最后遍历其右子树。</p>\n<h2 id=\"代码-6\"><a href=\"#代码-6\" class=\"headerlink\" title=\"代码\"></a>代码</h2><p>数据结构：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"># class TreeNode:</span></span><br><span class=\"line\"><span class=\"comment\">#     def __init__(self, x):</span></span><br><span class=\"line\"><span class=\"comment\">#         self.val = x</span></span><br><span class=\"line\"><span class=\"comment\">#         self.left = None</span></span><br><span class=\"line\"><span class=\"comment\">#         self.right = None</span></span><br></pre></td></tr></table></figure>\n<p>递归：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">inorderTraversal</span><span class=\"params\">(self, root: TreeNode)</span> -&gt; List[int]:</span></span><br><span class=\"line\">        ans = []</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">helper</span><span class=\"params\">(root)</span>:</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> root:</span><br><span class=\"line\">                helper(root.left)</span><br><span class=\"line\">                ans.append(root.val)</span><br><span class=\"line\">                helper(root.right)</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\"></span><br><span class=\"line\">        helper(root)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<p>迭代：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">inorderTraversal</span><span class=\"params\">(self, root: TreeNode)</span> -&gt; List[int]:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> root:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> []</span><br><span class=\"line\">        ans, v = [], []</span><br><span class=\"line\">        cur = root</span><br><span class=\"line\">        <span class=\"keyword\">while</span> cur <span class=\"keyword\">or</span> v:</span><br><span class=\"line\">            <span class=\"keyword\">while</span> cur:</span><br><span class=\"line\">                v.append(cur)</span><br><span class=\"line\">                cur = cur.left</span><br><span class=\"line\">            cur = v.pop()</span><br><span class=\"line\">            ans.append(cur.val)</span><br><span class=\"line\">            cur = cur.right</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<h1 id=\"96-不同的二叉搜索树\"><a href=\"#96-不同的二叉搜索树\" class=\"headerlink\" title=\"96. 不同的二叉搜索树\"></a>96. 不同的二叉搜索树</h1><p><a href=\"https://leetcode-cn.com/problems/unique-binary-search-trees/\" target=\"_blank\" rel=\"noopener\">https://leetcode-cn.com/problems/unique-binary-search-trees/</a></p>\n<h2 id=\"题目描述-7\"><a href=\"#题目描述-7\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>给定一个整数 n，求以 1 … n 为节点组成的二叉搜索树有多少种？</p>\n<p>示例:</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: <span class=\"number\">3</span></span><br><span class=\"line\">输出: <span class=\"number\">5</span></span><br><span class=\"line\">解释:</span><br><span class=\"line\">给定 n = <span class=\"number\">3</span>, 一共有 <span class=\"number\">5</span> 种不同结构的二叉搜索树:</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"number\">1</span>         <span class=\"number\">3</span>     <span class=\"number\">3</span>      <span class=\"number\">2</span>      <span class=\"number\">1</span></span><br><span class=\"line\">    \\       /     /      / \\      \\</span><br><span class=\"line\">     <span class=\"number\">3</span>     <span class=\"number\">2</span>     <span class=\"number\">1</span>      <span class=\"number\">1</span>   <span class=\"number\">3</span>      <span class=\"number\">2</span></span><br><span class=\"line\">    /     /       \\                 \\</span><br><span class=\"line\">   <span class=\"number\">2</span>     <span class=\"number\">1</span>         <span class=\"number\">2</span>                 <span class=\"number\">3</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"思路-7\"><a href=\"#思路-7\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>动态规划：</p>\n<ul>\n<li>用 <code>dp[n]</code> 表示以 1 … n 为节点组成的二叉搜索树的数量，<code>f[i]</code> 表示 i 为根节点的二叉搜索树的数量；</li>\n<li>结果即为以各个节点作为根节点的数量总和：<code>dp[n] = f[1] + f[2] + ... + f[n]</code>；</li>\n<li>当 i 为根节点时，其左子树的节点数为 i-1，右子树的节点数为 n-i，因此有：<code>f[i] = f[i-1] * f[n-i]</code>；</li>\n<li><code>dp[n] = dp[0]*dp[n-1] + dp[1]*dp[n-2] + ... + dp[n-1]*dp[0]</code>。</li>\n</ul>\n<p>当 n 为1或0时，只有一种情况，即 <code>dp[0] = dp[1] = 1</code>。</p>\n<p>还有一种方法是递归，也是利用上面的公式。</p>\n<h2 id=\"代码-7\"><a href=\"#代码-7\" class=\"headerlink\" title=\"代码\"></a>代码</h2><p>动态规划：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">numTrees</span><span class=\"params\">(self, n: int)</span> -&gt; int:</span></span><br><span class=\"line\">        dp = [<span class=\"number\">0</span>] * (n + <span class=\"number\">1</span>)</span><br><span class=\"line\">        dp[<span class=\"number\">0</span>] = dp[<span class=\"number\">1</span>] = <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">2</span>, n+<span class=\"number\">1</span>):</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, i+<span class=\"number\">1</span>):</span><br><span class=\"line\">                dp[i] += dp[j<span class=\"number\">-1</span>] * dp[i-j]</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[n]</span><br></pre></td></tr></table></figure>\n<p>递归：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">numTrees</span><span class=\"params\">(self, n: int)</span> -&gt; int:</span></span><br><span class=\"line\">        memo = [<span class=\"number\">0</span>] * (n + <span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">helper</span><span class=\"params\">(n)</span>:</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> n == <span class=\"number\">1</span> <span class=\"keyword\">or</span> n == <span class=\"number\">0</span>: <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> memo[n] &gt; <span class=\"number\">0</span>:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> memo[n]</span><br><span class=\"line\">            <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">0</span>, n):</span><br><span class=\"line\">                memo[n] += helper(i) * helper(n-i<span class=\"number\">-1</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> memo[n]</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> helper(n)</span><br></pre></td></tr></table></figure>\n<h1 id=\"97-交错字符串\"><a href=\"#97-交错字符串\" class=\"headerlink\" title=\"97. 交错字符串\"></a>97. 交错字符串</h1><p><a href=\"https://leetcode-cn.com/problems/interleaving-string/\" target=\"_blank\" rel=\"noopener\">https://leetcode-cn.com/problems/interleaving-string/</a></p>\n<h2 id=\"题目描述-8\"><a href=\"#题目描述-8\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>给定三个字符串 s1, s2, s3, 验证 s3 是否是由 s1 和 s2 交错组成的。</p>\n<p>示例 1:</p>\n<figure class=\"highlight nix\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: <span class=\"attr\">s1</span> = <span class=\"string\">\"aabcc\"</span>, <span class=\"attr\">s2</span> = <span class=\"string\">\"dbbca\"</span>, <span class=\"attr\">s3</span> = <span class=\"string\">\"aadbbcbcac\"</span></span><br><span class=\"line\">输出: <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n<p>示例 2:</p>\n<figure class=\"highlight nix\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: <span class=\"attr\">s1</span> = <span class=\"string\">\"aabcc\"</span>, <span class=\"attr\">s2</span> = <span class=\"string\">\"dbbca\"</span>, <span class=\"attr\">s3</span> = <span class=\"string\">\"aadbbbaccc\"</span></span><br><span class=\"line\">输出: <span class=\"literal\">false</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"思路-8\"><a href=\"#思路-8\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>动态规划，用 <code>dp[i][j]</code> 表示 <code>s1</code> 的前 <code>i</code> 个字符和 <code>s2</code> 的前 <code>j</code> 个字符是否能交错组成 <code>s3</code> 的前 <code>i+j</code> 个字符。若 <code>s1[i]==s3[i+j]</code>，那么 <code>dp[i][j]</code> 是否为真则取决于 <code>s1</code> 的前 <code>i-1</code>（<code>s2</code> 的前 <code>j-1</code>）个字符和 <code>s2</code> 的前 <code>j</code> <code>s1</code> 的前 <code>i</code>）个字符是否能交错组成 <code>s3</code> 的前 <code>i+j-1</code> 个字符，即 <code>dp[i-1][j]</code>（<code>dp[i][j-1]</code>）是否为真。</p>\n<p>可得状态转移方程：</p>\n<ul>\n<li><code>dp[i][j] = (dp[i-1][j] and s1[i-1]==s3[i+j-1]) or (dp[i][j-1] and s2[j-1]==s3[i+j-1])</code>；</li>\n<li>边界条件为<code>dp[0][0] = True</code>。</li>\n</ul>\n<p>当 <code>s1</code> 和 <code>s2</code> 长度之和不等于 <code>s3</code> 长度时，直接输出 <code>False</code>。</p>\n<p>时间复杂度为 O(MN)。</p>\n<h2 id=\"代码-8\"><a href=\"#代码-8\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isInterleave</span><span class=\"params\">(self, s1: str, s2: str, s3: str)</span> -&gt; bool:</span></span><br><span class=\"line\">        n, m = len(s1), len(s2)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> n + m != len(s3):</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">        dp = [[<span class=\"literal\">False</span>] * (m + <span class=\"number\">1</span>) <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(n + <span class=\"number\">1</span>)]</span><br><span class=\"line\">        dp[<span class=\"number\">0</span>][<span class=\"number\">0</span>] = <span class=\"literal\">True</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n + <span class=\"number\">1</span>):</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(m + <span class=\"number\">1</span>):</span><br><span class=\"line\">                <span class=\"keyword\">if</span> i &gt; <span class=\"number\">0</span>:</span><br><span class=\"line\">                    dp[i][j] = dp[i][j] <span class=\"keyword\">or</span> (dp[i<span class=\"number\">-1</span>][j] <span class=\"keyword\">and</span> s1[i<span class=\"number\">-1</span>]==s3[i+j<span class=\"number\">-1</span>])</span><br><span class=\"line\">                <span class=\"keyword\">if</span> j &gt; <span class=\"number\">0</span>:</span><br><span class=\"line\">                    dp[i][j] = dp[i][j] <span class=\"keyword\">or</span> (dp[i][j<span class=\"number\">-1</span>] <span class=\"keyword\">and</span> s2[j<span class=\"number\">-1</span>]==s3[i+j<span class=\"number\">-1</span>])</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[n][m]</span><br></pre></td></tr></table></figure>\n<h1 id=\"100-相同的树\"><a href=\"#100-相同的树\" class=\"headerlink\" title=\"100. 相同的树\"></a>100. 相同的树</h1><p><a href=\"https://leetcode-cn.com/problems/same-tree/\" target=\"_blank\" rel=\"noopener\">https://leetcode-cn.com/problems/same-tree/</a></p>\n<h2 id=\"题目描述-9\"><a href=\"#题目描述-9\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>给定两个二叉树，编写一个函数来检验它们是否相同。</p>\n<p>如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。</p>\n<p>示例 1:</p>\n<pre><code>输入:       1         1\n          / \\       / \\\n         2   3     2   3\n\n        [1,2,3],   [1,2,3]\n\n输出: true\n</code></pre><p>示例 2:</p>\n<pre><code>输入:      1          1\n          /           \\\n         2             2\n\n        [1,2],     [1,null,2]\n\n输出: false\n</code></pre><p>示例 3:</p>\n<pre><code>输入:       1         1\n          / \\       / \\\n         2   1     1   2\n\n        [1,2,1],   [1,1,2]\n\n输出: false\n</code></pre><h2 id=\"思路-9\"><a href=\"#思路-9\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>就是二叉树的遍历，用递归判断两棵树对应节点是否存在以及值是否相等即可。</p>\n<h2 id=\"代码-9\"><a href=\"#代码-9\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"># class TreeNode:</span></span><br><span class=\"line\"><span class=\"comment\">#     def __init__(self, x):</span></span><br><span class=\"line\"><span class=\"comment\">#         self.val = x</span></span><br><span class=\"line\"><span class=\"comment\">#         self.left = None</span></span><br><span class=\"line\"><span class=\"comment\">#         self.right = None</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isSameTree</span><span class=\"params\">(self, p: TreeNode, q: TreeNode)</span> -&gt; bool:</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">helper</span><span class=\"params\">(p, q)</span>:</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> p <span class=\"keyword\">and</span> <span class=\"keyword\">not</span> q: <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> p <span class=\"keyword\">and</span> <span class=\"keyword\">not</span> q <span class=\"keyword\">or</span> <span class=\"keyword\">not</span> p <span class=\"keyword\">and</span> q: <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> p.val != q.val: <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> helper(p.left, q.left) <span class=\"keyword\">and</span> helper(p.right, q.right)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> helper(p, q)</span><br></pre></td></tr></table></figure>\n<h1 id=\"101-对称二叉树\"><a href=\"#101-对称二叉树\" class=\"headerlink\" title=\"101. 对称二叉树\"></a>101. 对称二叉树</h1><p><a href=\"https://leetcode-cn.com/problems/symmetric-tree/\" target=\"_blank\" rel=\"noopener\">https://leetcode-cn.com/problems/symmetric-tree/</a></p>\n<h2 id=\"题目描述-10\"><a href=\"#题目描述-10\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>给定一个二叉树，检查它是否是镜像对称的。</p>\n<p>例如，二叉树 [1,2,2,3,4,4,3] 是对称的。</p>\n<pre><code>    1\n   / \\\n  2   2\n / \\ / \\\n3  4 4  3\n</code></pre><p>但是下面这个 <code>[1,2,2,null,3,null,3]</code> 则不是镜像对称的:</p>\n<pre><code>    1\n   / \\\n  2   2\n   \\   \\\n   3    3\n</code></pre><p>进阶：</p>\n<p>你可以运用递归和迭代两种方法解决这个问题吗？</p>\n<h2 id=\"思路-10\"><a href=\"#思路-10\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>可以通过判断根节点的两棵子树 $p,q$ 是否是镜像的。遍历的方式与第100题类似，只是这次两者不再按相同的顺序遍历，而是按镜像的方式：</p>\n<ul>\n<li>$p$ 遍历其左子树时，$q$ 遍历其右子树；</li>\n<li>$p$ 遍历其右子树时，$q$ 遍历其左子树。</li>\n</ul>\n<h2 id=\"代码-10\"><a href=\"#代码-10\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isSymmetric</span><span class=\"params\">(self, root: TreeNode)</span> -&gt; bool:</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">helper</span><span class=\"params\">(p, q)</span>:</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> p <span class=\"keyword\">and</span> <span class=\"keyword\">not</span> q: <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> p <span class=\"keyword\">and</span> <span class=\"keyword\">not</span> q <span class=\"keyword\">or</span> <span class=\"keyword\">not</span> p <span class=\"keyword\">and</span> q: <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> p.val != q.val: <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> helper(p.left, q.right) <span class=\"keyword\">and</span> helper(p.right, q.left)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> root <span class=\"keyword\">and</span> root.left <span class=\"keyword\">and</span> root.right:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> helper(root.left, root.right)</span><br><span class=\"line\">        <span class=\"keyword\">elif</span> root <span class=\"keyword\">and</span> <span class=\"keyword\">not</span> root.left <span class=\"keyword\">and</span> <span class=\"keyword\">not</span> root.right <span class=\"keyword\">or</span> <span class=\"keyword\">not</span> root:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"102-二叉树的层序遍历\"><a href=\"#102-二叉树的层序遍历\" class=\"headerlink\" title=\"102. 二叉树的层序遍历\"></a>102. 二叉树的层序遍历</h1><p><a href=\"https://leetcode-cn.com/problems/binary-tree-level-order-traversal/\" target=\"_blank\" rel=\"noopener\">https://leetcode-cn.com/problems/binary-tree-level-order-traversal/</a></p>\n<h2 id=\"题目描述-11\"><a href=\"#题目描述-11\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>给你一个二叉树，请你返回其按 <strong>层序遍历</strong> 得到的节点值。 （即逐层地，从左到右访问所有节点）。</p>\n<p>示例：<br>二叉树：<code>[3,9,20,null,null,15,7]</code>,</p>\n<pre><code>    3\n   / \\\n  9  20\n    /  \\\n   15   7\n</code></pre><p>返回其层次遍历结果：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[</span><br><span class=\"line\">  [<span class=\"number\">3</span>],</span><br><span class=\"line\">  [<span class=\"number\">9</span>,<span class=\"number\">20</span>],</span><br><span class=\"line\">  [<span class=\"number\">15</span>,<span class=\"number\">7</span>]</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n<h2 id=\"思路-11\"><a href=\"#思路-11\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>最简单的方法是用递归，按前序遍历二叉树中的节点，记录访问节点的层数，每层用一个列表 <code>ans[d]</code> ( <code>d</code> 表示当前节点所在层的深度)保存节点值。</p>\n<p>另一种思路是使用BFS，使用一个队列 <code>queue</code> 存放待访问的节点，每到一层都用 <code>s</code> 存当前层节点的个数，每访问到一个节点就将其值存入答案列表中对应的位置，并将其左右子节点存入队列。</p>\n<h2 id=\"代码-11\"><a href=\"#代码-11\" class=\"headerlink\" title=\"代码\"></a>代码</h2><p>递归，前序遍历：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">levelOrder</span><span class=\"params\">(self, root: TreeNode)</span> -&gt; List[List[int]]:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> root: <span class=\"keyword\">return</span> []</span><br><span class=\"line\">        ans = []</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">helper</span><span class=\"params\">(node, d)</span>:</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> node: <span class=\"keyword\">return</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> len(ans) == d:</span><br><span class=\"line\">                ans.append([])</span><br><span class=\"line\">            ans[d].append(node.val)</span><br><span class=\"line\">            helper(node.left, d+<span class=\"number\">1</span>)</span><br><span class=\"line\">            helper(node.right, d+<span class=\"number\">1</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\"></span><br><span class=\"line\">        helper(root, <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<p>BFS：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">levelOrder</span><span class=\"params\">(self, root: TreeNode)</span> -&gt; List[List[int]]:</span></span><br><span class=\"line\">        queue = collections.deque()</span><br><span class=\"line\">        queue.append(root)</span><br><span class=\"line\">        ans = []</span><br><span class=\"line\">        <span class=\"keyword\">while</span> queue:</span><br><span class=\"line\">            s = len(queue)</span><br><span class=\"line\">            d = []</span><br><span class=\"line\">            <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(s):</span><br><span class=\"line\">                node = queue.popleft()</span><br><span class=\"line\">                <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> node:</span><br><span class=\"line\">                    <span class=\"keyword\">continue</span></span><br><span class=\"line\">                d.append(node.val)</span><br><span class=\"line\">                queue.append(node.left)</span><br><span class=\"line\">                queue.append(node.right)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> d:</span><br><span class=\"line\">                ans.append(d)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<h1 id=\"107-二叉树的层次遍历-II\"><a href=\"#107-二叉树的层次遍历-II\" class=\"headerlink\" title=\"107. 二叉树的层次遍历 II\"></a>107. 二叉树的层次遍历 II</h1><p><a href=\"https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/\" target=\"_blank\" rel=\"noopener\">https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/</a></p>\n<h2 id=\"题目描述-12\"><a href=\"#题目描述-12\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）</p>\n<p>例如：<br>给定二叉树 <code>[3,9,20,null,null,15,7]</code>,</p>\n<pre><code>    3\n   / \\\n  9  20\n    /  \\\n   15   7\n</code></pre><p>返回其自底向上的层次遍历为：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[</span><br><span class=\"line\">  [<span class=\"number\">15</span>,<span class=\"number\">7</span>],</span><br><span class=\"line\">  [<span class=\"number\">9</span>,<span class=\"number\">20</span>],</span><br><span class=\"line\">  [<span class=\"number\">3</span>]</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n<h2 id=\"思路-12\"><a href=\"#思路-12\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>与层次遍历一样，只是输出的时候倒序输出即可，也是有两种方法：递归前序遍历和BFS。</p>\n<h2 id=\"代码-12\"><a href=\"#代码-12\" class=\"headerlink\" title=\"代码\"></a>代码</h2><p>前序遍历，递归：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">levelOrderBottom</span><span class=\"params\">(self, root: TreeNode)</span> -&gt; List[List[int]]:</span></span><br><span class=\"line\">        ans = []</span><br><span class=\"line\">        self.helper(root, <span class=\"number\">0</span>, ans)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans[::<span class=\"number\">-1</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">helper</span><span class=\"params\">(self, node, depth, ans)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> node:</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> len(ans) == depth:</span><br><span class=\"line\">            ans.append([])</span><br><span class=\"line\">        ans[depth].append(node.val)</span><br><span class=\"line\">        self.helper(node.left, depth+<span class=\"number\">1</span>, ans)</span><br><span class=\"line\">        self.helper(node.right, depth+<span class=\"number\">1</span>, ans)</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br></pre></td></tr></table></figure>\n<p>BFS：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">levelOrderBottom</span><span class=\"params\">(self, root: TreeNode)</span> -&gt; List[List[int]]:</span></span><br><span class=\"line\">        queue = collections.deque()</span><br><span class=\"line\">        queue.append(root)</span><br><span class=\"line\">        ans = []</span><br><span class=\"line\">        <span class=\"keyword\">while</span> queue:</span><br><span class=\"line\">            size = len(queue)</span><br><span class=\"line\">            t = []</span><br><span class=\"line\">            <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(size):</span><br><span class=\"line\">                p = queue.popleft()</span><br><span class=\"line\">                <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> p:</span><br><span class=\"line\">                    <span class=\"keyword\">continue</span></span><br><span class=\"line\">                t.append(p.val)</span><br><span class=\"line\">                queue.append(p.left)</span><br><span class=\"line\">                queue.append(p.right)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> t:</span><br><span class=\"line\">                ans.append(t)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans[::<span class=\"number\">-1</span>]</span><br></pre></td></tr></table></figure>\n<h1 id=\"110-平衡二叉树\"><a href=\"#110-平衡二叉树\" class=\"headerlink\" title=\"110. 平衡二叉树\"></a>110. 平衡二叉树</h1><p><a href=\"https://leetcode-cn.com/problems/balanced-binary-tree/\" target=\"_blank\" rel=\"noopener\">https://leetcode-cn.com/problems/balanced-binary-tree/</a></p>\n<h2 id=\"题目描述-13\"><a href=\"#题目描述-13\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>给定一个二叉树，判断它是否是高度平衡的二叉树。</p>\n<p>本题中，一棵高度平衡二叉树定义为：</p>\n<p><em>一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1。</em></p>\n<p>示例 1:</p>\n<p>给定二叉树 <code>[3,9,20,null,null,15,7]</code></p>\n<pre><code>    3\n   / \\\n  9  20\n    /  \\\n   15   7\n</code></pre><p>返回 <code>true</code> 。</p>\n<p>示例 2:</p>\n<p>给定二叉树 <code>[1,2,2,3,3,null,null,4,4]</code></p>\n<pre><code>       1\n      / \\\n     2   2\n    / \\\n   3   3\n  / \\\n 4   4\n</code></pre><p>返回 <code>false</code> 。</p>\n<h2 id=\"思路-13\"><a href=\"#思路-13\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>有两种解法，分别是自顶向下和自底向上。</p>\n<p>自顶向下(暴力法)比较容易想到，首先计算根节点左右子树的深度，然后比较它们的差是否小于2，然后计算根节点的左右子节点的左右子树的深度，以此类推。</p>\n<p>自底向上则是在计算节点的深度时就判断其左右子树的深度大小，若大于2则直接返回，效率要比自顶向下高很多。</p>\n<h2 id=\"代码-13\"><a href=\"#代码-13\" class=\"headerlink\" title=\"代码\"></a>代码</h2><p>自顶向下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isBalanced</span><span class=\"params\">(self, root: TreeNode)</span> -&gt; bool:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> root: <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> abs(self.helper(root.left) - self.helper(root.right)) &lt; <span class=\"number\">2</span> <span class=\"keyword\">and</span> \\</span><br><span class=\"line\">            self.isBalanced(root.left) <span class=\"keyword\">and</span> self.isBalanced(root.right)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">helper</span><span class=\"params\">(self, node)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> node: <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> max(self.helper(node.left), self.helper(node.right))+<span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n<p>自底向上：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isBalanced</span><span class=\"params\">(self, root: TreeNode)</span> -&gt; bool:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.helper(root) != <span class=\"number\">-1</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">helper</span><span class=\"params\">(self, node)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> node: <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">        left = self.helper(node.left)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> left == <span class=\"number\">-1</span>: <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">        right = self.helper(node.right)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> right == <span class=\"number\">-1</span>: <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> max(left, right)+<span class=\"number\">1</span> <span class=\"keyword\">if</span> abs(left - right) &lt; <span class=\"number\">2</span> <span class=\"keyword\">else</span> <span class=\"number\">-1</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"112-路径总和\"><a href=\"#112-路径总和\" class=\"headerlink\" title=\"112. 路径总和\"></a>112. 路径总和</h1><p><a href=\"https://leetcode-cn.com/problems/path-sum/\" target=\"_blank\" rel=\"noopener\">https://leetcode-cn.com/problems/path-sum/</a></p>\n<h2 id=\"题目描述-14\"><a href=\"#题目描述-14\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。</p>\n<p>说明: 叶子节点是指没有子节点的节点。</p>\n<p>示例:<br>给定如下二叉树，以及目标和 <code>sum = 22</code>，</p>\n<pre><code>          5\n         / \\\n        4   8\n       /   / \\\n      11  13  4\n     /  \\      \\\n    7    2      1\n</code></pre><p>返回 <code>true</code>, 因为存在目标和为 22 的根节点到叶子节点的路径 <code>5-&gt;4-&gt;11-&gt;2</code>。</p>\n<h2 id=\"思路-14\"><a href=\"#思路-14\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>递归，前序遍历二叉树，统计路径总和，到叶子节点时判断路径总和与目标和 <code>sum</code>  是否相等。</p>\n<h2 id=\"代码-14\"><a href=\"#代码-14\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">hasPathSum</span><span class=\"params\">(self, root: TreeNode, sum: int)</span> -&gt; bool:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> root: <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">helper</span><span class=\"params\">(node, s)</span>:</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> node: <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">            t = node.val + s</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> node.left <span class=\"keyword\">and</span> <span class=\"keyword\">not</span> node.right:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> t == sum:</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\">                <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>: <span class=\"keyword\">return</span> helper(node.left, t) <span class=\"keyword\">or</span> helper(node.right, t)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> helper(root, <span class=\"number\">0</span>)</span><br></pre></td></tr></table></figure>\n<h1 id=\"120-三角形最小路径和\"><a href=\"#120-三角形最小路径和\" class=\"headerlink\" title=\"120. 三角形最小路径和\"></a>120. 三角形最小路径和</h1><p><a href=\"https://leetcode-cn.com/problems/triangle/\" target=\"_blank\" rel=\"noopener\">https://leetcode-cn.com/problems/triangle/</a></p>\n<h2 id=\"题目描述-15\"><a href=\"#题目描述-15\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。</p>\n<p><strong>相邻的结点</strong> 在这里指的是 <code>下标</code> 与 <code>上一层结点下标</code> 相同或者等于 <code>上一层结点下标 + 1</code> 的两个结点。</p>\n<p>例如，给定三角形：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[</span><br><span class=\"line\">     [<span class=\"number\">2</span>],</span><br><span class=\"line\">    [<span class=\"number\">3</span>,<span class=\"number\">4</span>],</span><br><span class=\"line\">   [<span class=\"number\">6</span>,<span class=\"number\">5</span>,<span class=\"number\">7</span>],</span><br><span class=\"line\">  [<span class=\"number\">4</span>,<span class=\"number\">1</span>,<span class=\"number\">8</span>,<span class=\"number\">3</span>]</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n<p>自顶向下的最小路径和为 <code>11</code>（即，2 + 3 + 5 + 1 = 11）。</p>\n<p>说明：</p>\n<p>如果你可以只使用 O(n) 的额外空间（n 为三角形的总行数）来解决这个问题，那么你的算法会很加分。</p>\n<h2 id=\"思路-15\"><a href=\"#思路-15\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>动态规划：</p>\n<ul>\n<li><code>dp[i][j]</code> 表示第 <code>i</code> 行第 <code>j</code> 列节点到最底层的最小路径和，自底向上计算。</li>\n<li><code>dp[i][j] = triangle[i][j] + min(dp[i+1][j], dp[i+1][j+1])</code>.</li>\n</ul>\n<p>计算完后 <code>dp[0][0]</code> 为最终答案。</p>\n<h2 id=\"代码-15\"><a href=\"#代码-15\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">minimumTotal</span><span class=\"params\">(self, triangle: List[List[int]])</span> -&gt; int:</span></span><br><span class=\"line\">        dp = triangle[:]</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(triangle)<span class=\"number\">-2</span>, <span class=\"number\">-1</span>, <span class=\"number\">-1</span>):</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(i+<span class=\"number\">1</span>):</span><br><span class=\"line\">                dp[i][j] = triangle[i][j] + min(dp[i+<span class=\"number\">1</span>][j], dp[i+<span class=\"number\">1</span>][j+<span class=\"number\">1</span>])</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[<span class=\"number\">0</span>][<span class=\"number\">0</span>]</span><br></pre></td></tr></table></figure>\n<h1 id=\"121-买卖股票的最佳时机\"><a href=\"#121-买卖股票的最佳时机\" class=\"headerlink\" title=\"121. 买卖股票的最佳时机\"></a>121. 买卖股票的最佳时机</h1><p><a href=\"https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/\" target=\"_blank\" rel=\"noopener\">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/</a></p>\n<h2 id=\"题目描述-16\"><a href=\"#题目描述-16\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p>\n<p>如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。</p>\n<p>注意：你不能在买入股票前卖出股票。</p>\n<p>示例 1:</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: [<span class=\"number\">7</span>,<span class=\"number\">1</span>,<span class=\"number\">5</span>,<span class=\"number\">3</span>,<span class=\"number\">6</span>,<span class=\"number\">4</span>]</span><br><span class=\"line\">输出: <span class=\"number\">5</span></span><br><span class=\"line\">解释: 在第 <span class=\"number\">2</span> 天（股票价格 = <span class=\"number\">1</span>）的时候买入，在第 <span class=\"number\">5</span> 天（股票价格 = <span class=\"number\">6</span>）的时候卖出，最大利润 = <span class=\"number\">6</span><span class=\"number\">-1</span> = <span class=\"number\">5</span> 。</span><br><span class=\"line\">     注意利润不能是 <span class=\"number\">7</span><span class=\"number\">-1</span> = <span class=\"number\">6</span>, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。</span><br></pre></td></tr></table></figure>\n<p>示例 2:</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: [<span class=\"number\">7</span>,<span class=\"number\">6</span>,<span class=\"number\">4</span>,<span class=\"number\">3</span>,<span class=\"number\">1</span>]</span><br><span class=\"line\">输出: <span class=\"number\">0</span></span><br><span class=\"line\">解释: 在这种情况下, 没有交易完成, 所以最大利润为 <span class=\"number\">0</span>。</span><br></pre></td></tr></table></figure>\n<h2 id=\"思路-16\"><a href=\"#思路-16\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>因为有时间因素，因此不能简单地用最大值减去最小值。可以用维护两个变量<code>minp</code>和<code>maxp</code>，其中<code>minp</code>记录到当前为止的最小价格，<code>maxp</code>记录当前为止的最大差价。通过对数组的一遍扫描，每扫描到一个值就与<code>minp</code>作比较、计算当前值与<code>minp</code>的差价，若大于<code>maxp</code>则更新。</p>\n<h2 id=\"代码-16\"><a href=\"#代码-16\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">maxProfit</span><span class=\"params\">(self, prices: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">        maxp = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> len(prices) &gt; <span class=\"number\">0</span>:</span><br><span class=\"line\">            minp = prices[<span class=\"number\">0</span>]</span><br><span class=\"line\">            <span class=\"keyword\">for</span> price <span class=\"keyword\">in</span> prices:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> price &lt; minp:</span><br><span class=\"line\">                    minp = price</span><br><span class=\"line\">                <span class=\"keyword\">if</span> price - minp &gt; maxp:</span><br><span class=\"line\">                    maxp = price - minp</span><br><span class=\"line\">        <span class=\"keyword\">return</span> maxp</span><br></pre></td></tr></table></figure>\n<h1 id=\"152-乘积最大子数组\"><a href=\"#152-乘积最大子数组\" class=\"headerlink\" title=\"152. 乘积最大子数组\"></a>152. 乘积最大子数组</h1><p><a href=\"https://leetcode-cn.com/problems/maximum-product-subarray/\" target=\"_blank\" rel=\"noopener\">https://leetcode-cn.com/problems/maximum-product-subarray/</a></p>\n<h2 id=\"题目描述-17\"><a href=\"#题目描述-17\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>给你一个整数数组 <code>nums</code> ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。</p>\n<p>示例 1:</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: [<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">-2</span>,<span class=\"number\">4</span>]</span><br><span class=\"line\">输出: <span class=\"number\">6</span></span><br><span class=\"line\">解释: 子数组 [<span class=\"number\">2</span>,<span class=\"number\">3</span>] 有最大乘积 <span class=\"number\">6</span>。</span><br></pre></td></tr></table></figure>\n<p>示例 2:</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: [<span class=\"number\">-2</span>,<span class=\"number\">0</span>,<span class=\"number\">-1</span>]</span><br><span class=\"line\">输出: <span class=\"number\">0</span></span><br><span class=\"line\">解释: 结果不能为 <span class=\"number\">2</span>, 因为 [<span class=\"number\">-2</span>,<span class=\"number\">-1</span>] 不是子数组。</span><br></pre></td></tr></table></figure>\n<h2 id=\"思路-17\"><a href=\"#思路-17\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>可以用动态规划。因为负负得正，所以当前的数为负的话，与前一个数的最小值相乘有可能得到比最大值更大的数。因此需要维护两个变量：当前的最大值和最小值。</p>\n<p>动态方程如下：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{aligned}\nmaxDP[i+1] &= \\max(dmax[i+1] \\cdot nums[i], \\  nums[i],\\  dmin[i] \\cdot nums[i])\\\\\nminDP[i+1] &= \\min(dmax[i+1] \\cdot nums[i],\\  nums[i],\\  dmin[i] \\cdot nums[i])\\\\\nDP[i+1] &= \\max(DP[i],\\ maxDP[i+1])\n\\end{aligned}</script><p>当<code>nums[i]</code>为0时，<code>dmax</code>和<code>dmin</code>都为0，于是需要从<code>nums[i+1]</code>重新开始。</p>\n<h2 id=\"代码-17\"><a href=\"#代码-17\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">maxProduct</span><span class=\"params\">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> len(nums)==<span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">elif</span> len(nums)==<span class=\"number\">1</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> nums[<span class=\"number\">0</span>]</span><br><span class=\"line\">        m = dmax = dmin = nums[<span class=\"number\">0</span>]</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, len(nums)):</span><br><span class=\"line\">            tmp = dmax</span><br><span class=\"line\">            dmax = max(max(dmax*nums[i], nums[i]), dmin*nums[i])</span><br><span class=\"line\">            dmin = min(min(tmp*nums[i], nums[i]), dmin*nums[i])</span><br><span class=\"line\">            m = max(dmax, m)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> m</span><br></pre></td></tr></table></figure>\n<h1 id=\"167-两数之和-II-输入有序数组\"><a href=\"#167-两数之和-II-输入有序数组\" class=\"headerlink\" title=\"167. 两数之和 II - 输入有序数组\"></a>167. 两数之和 II - 输入有序数组</h1><p><a href=\"https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/\" target=\"_blank\" rel=\"noopener\">https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/</a></p>\n<h2 id=\"题目描述-18\"><a href=\"#题目描述-18\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。</p>\n<p>函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。</p>\n<p>说明:</p>\n<ul>\n<li>返回的下标值（index1 和 index2）不是从零开始的。</li>\n<li>你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。</li>\n</ul>\n<p>示例:</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: bers = [<span class=\"number\">2</span>, <span class=\"number\">7</span>, <span class=\"number\">11</span>, <span class=\"number\">15</span>], target = <span class=\"number\">9</span></span><br><span class=\"line\">输出: [<span class=\"number\">1</span>,<span class=\"number\">2</span>]</span><br><span class=\"line\">解释: <span class=\"number\">2</span> 与 <span class=\"number\">7</span> 之和等于目标数 <span class=\"number\">9</span> 。因此 index1 = <span class=\"number\">1</span>, index2 = <span class=\"number\">2</span> 。</span><br></pre></td></tr></table></figure>\n<h2 id=\"思路-18\"><a href=\"#思路-18\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>遍历数组，将访问过的元素的索引存储在哈希表 <code>d</code> 中，<code>d[val]</code> 存储的是值为 <code>val</code> 的元素的索引。</p>\n<ul>\n<li>每访问到一个元素，计算其与目标数的差值 <code>k = target - val</code>；</li>\n<li>在 <code>d</code> 中查找 <code>k</code>，若 <code>k</code> 存在则直接返回 <code>[d[k], val的index]</code>（后访问的 <code>index</code> 肯定比先访问的大）；</li>\n<li>若 <code>k</code> 不存在则将 <code>val</code> 的 <code>index</code> 存储在哈希表中。</li>\n</ul>\n<p>时间复杂度 $O(N)$，遍历了一次数组；空间复杂度 $O(N)$，用到了一个哈希表存储数组中的元素的索引值。</p>\n<h2 id=\"代码-18\"><a href=\"#代码-18\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">twoSum</span><span class=\"params\">(self, numbers: List[int], target: int)</span> -&gt; List[int]:</span></span><br><span class=\"line\">        n = len(numbers)</span><br><span class=\"line\">        d = dict()</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">            k = target - numbers[i]</span><br><span class=\"line\">            <span class=\"keyword\">if</span> k <span class=\"keyword\">in</span> d:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> [d[k], i+<span class=\"number\">1</span>]</span><br><span class=\"line\">            d[numbers[i]] = i + <span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"169-多数元素\"><a href=\"#169-多数元素\" class=\"headerlink\" title=\"169. 多数元素\"></a>169. 多数元素</h1><p><a href=\"https://leetcode-cn.com/problems/majority-element/\" target=\"_blank\" rel=\"noopener\">https://leetcode-cn.com/problems/majority-element/</a></p>\n<h2 id=\"题目描述-19\"><a href=\"#题目描述-19\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数大于 <code>⌊ n/2 ⌋</code> 的元素。</p>\n<p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p>\n<p>示例 1:</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: [<span class=\"number\">3</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]</span><br><span class=\"line\">输出: <span class=\"number\">3</span></span><br></pre></td></tr></table></figure>\n<p>示例 2:</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: [<span class=\"number\">2</span>,<span class=\"number\">2</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">2</span>]</span><br><span class=\"line\">输出: <span class=\"number\">2</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"思路-19\"><a href=\"#思路-19\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>这里可以使用摩尔投票法：</p>\n<p>候选人<code>k</code>初始化为数组第一个元素<code>nums[0]</code>，票数<code>cnt</code>初始化为1。从第二个元素<code>nums[1]</code>开始遍历，遇到与候选人相同的数则把票数加1，遇到不同的则把票数减1，如果票数减完之后为0，则更换当前数<code>nums[i]</code>为候选人并把票数重设为1。</p>\n<p>因为多数元素的个数肯定比其它元素的个数之和多，因此其票数在最后肯定是<code>&gt;= 1</code>的。</p>\n<h2 id=\"代码-19\"><a href=\"#代码-19\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">majorityElement</span><span class=\"params\">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> len(nums) &lt; <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">        cnt = <span class=\"number\">1</span></span><br><span class=\"line\">        k = nums[<span class=\"number\">0</span>]</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, len(nums)):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> nums[i] == k:</span><br><span class=\"line\">                cnt += <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                cnt -= <span class=\"number\">1</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> cnt == <span class=\"number\">0</span>:</span><br><span class=\"line\">                    cnt = <span class=\"number\">1</span></span><br><span class=\"line\">                    k = nums[i]</span><br><span class=\"line\">        <span class=\"keyword\">return</span> k</span><br></pre></td></tr></table></figure>\n<h1 id=\"174-地下城游戏\"><a href=\"#174-地下城游戏\" class=\"headerlink\" title=\"174. 地下城游戏\"></a>174. 地下城游戏</h1><p><a href=\"https://leetcode-cn.com/problems/dungeon-game/\" target=\"_blank\" rel=\"noopener\">https://leetcode-cn.com/problems/dungeon-game/</a></p>\n<h2 id=\"题目描述-20\"><a href=\"#题目描述-20\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>一些恶魔抓住了公主（<strong>P</strong>）并将她关在了地下城的右下角。地下城是由 M x N 个房间组成的二维网格。我们英勇的骑士（<strong>K</strong>）最初被安置在左上角的房间里，他必须穿过地下城并通过对抗恶魔来拯救公主。</p>\n<p>骑士的初始健康点数为一个正整数。如果他的健康点数在某一时刻降至 0 或以下，他会立即死亡。</p>\n<p>有些房间由恶魔守卫，因此骑士在进入这些房间时会失去健康点数（若房间里的值为负整数，则表示骑士将损失健康点数）；其他房间要么是空的（房间里的值为 0），要么包含增加骑士健康点数的魔法球（若房间里的值为正整数，则表示骑士将增加健康点数）。</p>\n<p>为了尽快到达公主，骑士决定每次只向右或向下移动一步。</p>\n<p><strong>编写一个函数来计算确保骑士能够拯救到公主所需的最低初始健康点数。</strong></p>\n<p>例如，考虑到如下布局的地下城，如果骑士遵循最佳路径 <code>右 -&gt; 右 -&gt; 下 -&gt; 下</code>，则骑士的初始健康点数至少为 <strong>7</strong>。</p>\n<p><img src=\"http://images.yingwai.top/picgo/174f1.png\" alt=\"\"></p>\n<p>说明:</p>\n<ul>\n<li><p>骑士的健康点数没有上限。</p>\n</li>\n<li><p>任何房间都可能对骑士的健康点数造成威胁，也可能增加骑士的健康点数，包括骑士进入的左上角房间以及公主被监禁的右下角房间。</p>\n</li>\n</ul>\n<h2 id=\"思路-20\"><a href=\"#思路-20\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>反向动态规划，从右下往左上遍历列表，用 <code>dp[i][j]</code> 来表示从房间 <code>(i, j)</code> 到达终点的最低初始健康点数，则可以得到</p>\n<ul>\n<li>此房间到终点的 <code>dp</code> 值为：此房间右边和下边的房间的 <code>dp</code> 值中较小的那一个，加上此房间需要消耗的生命值 <code>dungeon[i][j]</code> (注意初始值不能小于 <strong>1</strong>)；</li>\n<li><code>dp[i][j] = max(min(dp[i+1][j], dp[i][j+1]) - dungeon[i][j], 1)</code>.</li>\n</ul>\n<p>对于最后一行或一列中，除终点以外的元素 <code>dp[i][j]</code> 要用到的 <code>dp[i+1][j]</code> 和 <code>dp[i][j+1]</code>，将它们赋值为无穷大；而对于终点 <code>dp[m-1][n-1]</code>，将 <code>dp[m][n-1]</code> 和 <code>dp[m-1][n]</code> 赋值为 1。</p>\n<h2 id=\"代码-20\"><a href=\"#代码-20\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">calculateMinimumHP</span><span class=\"params\">(self, dungeon: List[List[int]])</span> -&gt; int:</span></span><br><span class=\"line\">        m, n = len(dungeon), len(dungeon[<span class=\"number\">0</span>])</span><br><span class=\"line\">        BIG = float(<span class=\"string\">\"inf\"</span>)</span><br><span class=\"line\">        dp = [[BIG] * (n + <span class=\"number\">1</span>) <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(m + <span class=\"number\">1</span>)]</span><br><span class=\"line\">        dp[m<span class=\"number\">-1</span>][n] = dp[m][n<span class=\"number\">-1</span>] = <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(m<span class=\"number\">-1</span>, <span class=\"number\">-1</span>, <span class=\"number\">-1</span>):</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(n<span class=\"number\">-1</span>, <span class=\"number\">-1</span>, <span class=\"number\">-1</span>):</span><br><span class=\"line\">                dp[i][j] = max(min(dp[i+<span class=\"number\">1</span>][j], dp[i][j+<span class=\"number\">1</span>]) - dungeon[i][j], <span class=\"number\">1</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[<span class=\"number\">0</span>][<span class=\"number\">0</span>]</span><br></pre></td></tr></table></figure>\n<h1 id=\"198-打家劫舍\"><a href=\"#198-打家劫舍\" class=\"headerlink\" title=\"198. 打家劫舍\"></a>198. 打家劫舍</h1><p><a href=\"https://leetcode-cn.com/problems/house-robber/\" target=\"_blank\" rel=\"noopener\">https://leetcode-cn.com/problems/house-robber/</a></p>\n<h2 id=\"题目描述-21\"><a href=\"#题目描述-21\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p>\n<p>给定一个代表每个房屋存放金额的非负整数数组，计算你不触动警报装置的情况下，一夜之内能够偷窃到的最高金额。</p>\n<p>示例 1:</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">1</span>]</span><br><span class=\"line\">输出: <span class=\"number\">4</span></span><br><span class=\"line\">解释: 偷窃 <span class=\"number\">1</span> 号房屋 (金额 = <span class=\"number\">1</span>) ，然后偷窃 <span class=\"number\">3</span> 号房屋 (金额 = <span class=\"number\">3</span>)。</span><br><span class=\"line\">     偷窃到的最高金额 = <span class=\"number\">1</span> + <span class=\"number\">3</span> = <span class=\"number\">4</span> 。</span><br></pre></td></tr></table></figure>\n<p>示例 2:</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: [<span class=\"number\">2</span>,<span class=\"number\">7</span>,<span class=\"number\">9</span>,<span class=\"number\">3</span>,<span class=\"number\">1</span>]</span><br><span class=\"line\">输出: <span class=\"number\">12</span></span><br><span class=\"line\">解释: 偷窃 <span class=\"number\">1</span> 号房屋 (金额 = <span class=\"number\">2</span>), 偷窃 <span class=\"number\">3</span> 号房屋 (金额 = <span class=\"number\">9</span>)，接着偷窃 <span class=\"number\">5</span> 号房屋 (金额 = <span class=\"number\">1</span>)。</span><br><span class=\"line\">     偷窃到的最高金额 = <span class=\"number\">2</span> + <span class=\"number\">9</span> + <span class=\"number\">1</span> = <span class=\"number\">12</span> 。</span><br></pre></td></tr></table></figure>\n<h2 id=\"思路-21\"><a href=\"#思路-21\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>动态规划，用 $\\rm dp[i]$ 表示前 $\\rm i$ 个房间能偷到的最大值，根据题目条件有以下动态方程：</p>\n<script type=\"math/tex; mode=display\">\n\\rm dp[i] = \\max (dp[i-1], dp[i-2] + nums[i])</script><h2 id=\"代码-21\"><a href=\"#代码-21\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">rob</span><span class=\"params\">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> len(nums) &lt;= <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">elif</span> len(nums) == <span class=\"number\">1</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> nums[<span class=\"number\">0</span>]</span><br><span class=\"line\">        dp = []</span><br><span class=\"line\">        dp.append(nums[<span class=\"number\">0</span>])</span><br><span class=\"line\">        dp.append(max(nums[<span class=\"number\">0</span>], nums[<span class=\"number\">1</span>]))</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">2</span>, len(nums)):</span><br><span class=\"line\">            dp.append(max(dp[i<span class=\"number\">-1</span>], dp[i<span class=\"number\">-2</span>] + nums[i]))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[len(nums)<span class=\"number\">-1</span>]</span><br></pre></td></tr></table></figure>\n<h1 id=\"257-二叉树的所有路径\"><a href=\"#257-二叉树的所有路径\" class=\"headerlink\" title=\"257. 二叉树的所有路径\"></a>257. 二叉树的所有路径</h1><p><a href=\"https://leetcode-cn.com/problems/binary-tree-paths/\" target=\"_blank\" rel=\"noopener\">https://leetcode-cn.com/problems/binary-tree-paths/</a></p>\n<h2 id=\"题目描述-22\"><a href=\"#题目描述-22\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>给定一个二叉树，返回所有从根节点到叶子节点的路径。</p>\n<p>说明: 叶子节点是指没有子节点的节点。</p>\n<p>示例:</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入:</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"number\">1</span></span><br><span class=\"line\"> /   \\</span><br><span class=\"line\"><span class=\"number\">2</span>     <span class=\"number\">3</span></span><br><span class=\"line\"> \\</span><br><span class=\"line\">  <span class=\"number\">5</span></span><br><span class=\"line\"></span><br><span class=\"line\">输出: [<span class=\"string\">\"1-&gt;2-&gt;5\"</span>, <span class=\"string\">\"1-&gt;3\"</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">解释: 所有根节点到叶子节点的路径为: <span class=\"number\">1</span>-&gt;<span class=\"number\">2</span>-&gt;<span class=\"number\">5</span>, <span class=\"number\">1</span>-&gt;<span class=\"number\">3</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"思路-22\"><a href=\"#思路-22\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>递归，用一个字符串 <code>s</code> 记录当前的路径，访问到叶子节点时将其加入最终结果的列表 <code>ans</code> 中。访问到叶子节点或空节点时返回。</p>\n<h2 id=\"代码-22\"><a href=\"#代码-22\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">binaryTreePaths</span><span class=\"params\">(self, root: TreeNode)</span> -&gt; List[str]:</span></span><br><span class=\"line\">        ans = []</span><br><span class=\"line\">        s = <span class=\"string\">\"\"</span></span><br><span class=\"line\">        self.helper(root, ans, s, <span class=\"number\">1</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">helper</span><span class=\"params\">(self, node, ans, s, depth)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> node:</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">        s = s + <span class=\"string\">\"-&gt;\"</span> + str(node.val) <span class=\"keyword\">if</span> depth &gt; <span class=\"number\">1</span> <span class=\"keyword\">else</span> s + str(node.val)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> node.left <span class=\"keyword\">and</span> <span class=\"keyword\">not</span> node.right:</span><br><span class=\"line\">            ans.append(s)</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">        self.helper(node.left, ans, s, depth+<span class=\"number\">1</span>)</span><br><span class=\"line\">        self.helper(node.right, ans, s, depth+<span class=\"number\">1</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"287-寻找重复数\"><a href=\"#287-寻找重复数\" class=\"headerlink\" title=\"287. 寻找重复数\"></a>287. 寻找重复数</h1><p><a href=\"https://leetcode-cn.com/problems/find-the-duplicate-number/\" target=\"_blank\" rel=\"noopener\">https://leetcode-cn.com/problems/find-the-duplicate-number/</a></p>\n<h2 id=\"题目描述-23\"><a href=\"#题目描述-23\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。</p>\n<p>示例 1:</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: [<span class=\"number\">1</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">2</span>,<span class=\"number\">2</span>]</span><br><span class=\"line\">输出: <span class=\"number\">2</span></span><br></pre></td></tr></table></figure>\n<p>示例 2:</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: [<span class=\"number\">3</span>,<span class=\"number\">1</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">2</span>]</span><br><span class=\"line\">输出: <span class=\"number\">3</span></span><br></pre></td></tr></table></figure>\n<p>说明：</p>\n<ol>\n<li>不能更改原数组（假设数组是只读的）。</li>\n<li>只能使用额外的 $O(1)$ 的空间。</li>\n<li>时间复杂度小于 $O(n^2)$ 。</li>\n<li>数组中只有一个重复的数字，但它可能不止重复出现一次。</li>\n</ol>\n<h2 id=\"思路-23\"><a href=\"#思路-23\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>由于题目限制了空间，所以打表法之类的方法就无法使用。可以用二分法：</p>\n<p>对于给定题目条件的数组 <code>nums</code>，设<code>mid</code>为 1 到 n 的中位数。扫描数组，若数组中小于等于<code>mid</code>的数的数量严格大于<code>mid</code>，则可以确定重复的数就在 1 到<code>mid</code>之间，反之则在<code>mid</code>到 n 之间。</p>\n<h2 id=\"代码-23\"><a href=\"#代码-23\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">findDuplicate</span><span class=\"params\">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">        size = len(nums)</span><br><span class=\"line\">        left = <span class=\"number\">1</span></span><br><span class=\"line\">        right = size - <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> left &lt; right:</span><br><span class=\"line\">            cnt = <span class=\"number\">0</span></span><br><span class=\"line\">            mid = left + (right - left) // <span class=\"number\">2</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> num <span class=\"keyword\">in</span> nums:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> num &lt;= mid:</span><br><span class=\"line\">                    cnt += <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> cnt &gt; mid:</span><br><span class=\"line\">                right = mid</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                left = mid + <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> left</span><br></pre></td></tr></table></figure>\n<h1 id=\"300-最长上升子序列\"><a href=\"#300-最长上升子序列\" class=\"headerlink\" title=\"300. 最长上升子序列\"></a>300. 最长上升子序列</h1><p><a href=\"https://leetcode-cn.com/problems/longest-increasing-subsequence/\" target=\"_blank\" rel=\"noopener\">https://leetcode-cn.com/problems/longest-increasing-subsequence/</a></p>\n<h2 id=\"题目描述-24\"><a href=\"#题目描述-24\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>给定一个无序的整数数组，找到其中最长上升子序列的长度。</p>\n<p>示例:</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: [<span class=\"number\">10</span>,<span class=\"number\">9</span>,<span class=\"number\">2</span>,<span class=\"number\">5</span>,<span class=\"number\">3</span>,<span class=\"number\">7</span>,<span class=\"number\">101</span>,<span class=\"number\">18</span>]</span><br><span class=\"line\">输出: <span class=\"number\">4</span> </span><br><span class=\"line\">解释: 最长的上升子序列是 [<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">7</span>,<span class=\"number\">101</span>]，它的长度是 <span class=\"number\">4</span>。</span><br></pre></td></tr></table></figure>\n<p>说明:</p>\n<ul>\n<li>可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。</li>\n<li>你算法的时间复杂度应该为 $O(n^2)$。</li>\n</ul>\n<p>进阶: 你能将算法的时间复杂度降低到 $O(n \\log{n})$ 吗?</p>\n<h2 id=\"思路-24\"><a href=\"#思路-24\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>$O(n \\log{n})$ 还没想到，这里介绍 $O(n^2)$ 的动态规划方法：</p>\n<p>用 $\\rm dp[i]$ 表示以第 $\\rm i$ 个元素结尾的最长上升子序列的长度，则可以得到以下的状态转移方程：</p>\n<script type=\"math/tex; mode=display\">\n\\rm dp[i] = \\max(dp[i], dp[j] + 1),\\ nums[j] < nums[i],\\  j < i.</script><p>扫描完整个数组后，$\\rm dp$ 数组中的最大值即为结果。</p>\n<h2 id=\"代码-24\"><a href=\"#代码-24\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">lengthOfLIS</span><span class=\"params\">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> len(nums) &lt;= <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">        dp = []     <span class=\"comment\"># 存以第i个元素结尾的最长上升子序列的长度</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(nums)):</span><br><span class=\"line\">            dp.append(<span class=\"number\">1</span>)</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(i):</span><br><span class=\"line\">                <span class=\"keyword\">if</span> nums[j] &lt; nums[i]:</span><br><span class=\"line\">                    dp[i] = max(dp[i], dp[j]+<span class=\"number\">1</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> max(dp)</span><br></pre></td></tr></table></figure>\n<h1 id=\"309-最佳买卖股票时机含冷冻期\"><a href=\"#309-最佳买卖股票时机含冷冻期\" class=\"headerlink\" title=\"309. 最佳买卖股票时机含冷冻期\"></a>309. 最佳买卖股票时机含冷冻期</h1><p><a href=\"https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/\" target=\"_blank\" rel=\"noopener\">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/</a></p>\n<h2 id=\"题目描述-25\"><a href=\"#题目描述-25\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。</p>\n<p>设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:</p>\n<ul>\n<li>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</li>\n<li>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。</li>\n</ul>\n<p>示例:</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">0</span>,<span class=\"number\">2</span>]</span><br><span class=\"line\">输出: <span class=\"number\">3</span> </span><br><span class=\"line\">解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]</span><br></pre></td></tr></table></figure>\n<h2 id=\"思路-25\"><a href=\"#思路-25\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>动态规划，用两个数组来存储状态：</p>\n<ol>\n<li><code>hold[i]</code> 表示在第 <code>i</code> 天结束时持有股票、此时的最大收益，有两种情况：<ul>\n<li>昨天持有股票，今天休息；</li>\n<li>前天卖出，今天买入；</li>\n<li><code>hold[i] = max(hold[i-1], unhold[i-2] - prices[i])</code>。</li>\n</ul>\n</li>\n<li><code>unhold[i]</code> 表示在第 <code>i</code> 天结束时未持有股票、此时的最大收益，也有两种情况：<ul>\n<li>昨天也没持有股票，今天休息；</li>\n<li>昨天持有，今天卖出；</li>\n<li><code>unhold[i] = max(unhold[i-1], hold[i-1] + prices[i])</code>。</li>\n</ul>\n</li>\n</ol>\n<p>最终结果是 <code>unhold[n-1]</code>。</p>\n<p>初始情况：</p>\n<ul>\n<li>第 <code>0</code> 天持有股票即在当天买入股票，<code>hold[0] = -prices[0]</code>；</li>\n<li>第 <code>1</code> 天持有股票有前一天买入或是当天买入两种情况，<code>hold[1] = max(-prices[0], -prices[1])</code>；</li>\n<li>第 <code>0</code> 天未持有股票即当天休息，<code>unhold[0] = 0</code>。</li>\n</ul>\n<h2 id=\"代码-25\"><a href=\"#代码-25\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">maxProfit</span><span class=\"params\">(self, prices: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> len(prices) &lt; <span class=\"number\">2</span>: <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">        hold, unhold = [], []</span><br><span class=\"line\">        hold.append(-prices[<span class=\"number\">0</span>])</span><br><span class=\"line\">        unhold.append(<span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, len(prices)):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> i == <span class=\"number\">1</span>:</span><br><span class=\"line\">                hold.append(max(-prices[<span class=\"number\">0</span>], -prices[<span class=\"number\">1</span>]))</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                hold.append(max(hold[i<span class=\"number\">-1</span>], unhold[i<span class=\"number\">-2</span>] - prices[i]))</span><br><span class=\"line\">            unhold.append(max(unhold[i<span class=\"number\">-1</span>], hold[i<span class=\"number\">-1</span>] + prices[i]))        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> unhold[len(prices) - <span class=\"number\">1</span>]</span><br></pre></td></tr></table></figure>\n<h1 id=\"312-戳气球\"><a href=\"#312-戳气球\" class=\"headerlink\" title=\"312. 戳气球\"></a>312. 戳气球</h1><p><a href=\"https://leetcode-cn.com/problems/burst-balloons/\" target=\"_blank\" rel=\"noopener\">https://leetcode-cn.com/problems/burst-balloons/</a></p>\n<h2 id=\"题目描述-26\"><a href=\"#题目描述-26\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>有 <code>n</code> 个气球，编号为 <code>0</code> 到 <code>n-1</code>，每个气球上都标有一个数字，这些数字存在数组 <code>nums</code> 中。</p>\n<p>现在要求你戳破所有的气球。如果你戳破气球 <code>i</code> ，就可以获得 <code>nums[left] * nums[i] * nums[right]</code> 个硬币。 这里的 <code>left</code> 和 <code>right</code> 代表和 <code>i</code> 相邻的两个气球的序号。注意当你戳破了气球 <code>i</code> 后，气球 <code>left</code> 和气球 <code>right</code> 就变成了相邻的气球。</p>\n<p>求所能获得硬币的最大数量。</p>\n<p>说明:</p>\n<ul>\n<li>你可以假设 <code>nums[-1] = nums[n] = 1</code>，但注意它们不是真实存在的所以并不能被戳破。</li>\n<li>0 ≤ <code>n</code> ≤ 500, 0 ≤ <code>nums[i]</code> ≤ 100</li>\n</ul>\n<p>示例:</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: [<span class=\"number\">3</span>,<span class=\"number\">1</span>,<span class=\"number\">5</span>,<span class=\"number\">8</span>]</span><br><span class=\"line\">输出: <span class=\"number\">167</span> </span><br><span class=\"line\">解释: nums = [<span class=\"number\">3</span>,<span class=\"number\">1</span>,<span class=\"number\">5</span>,<span class=\"number\">8</span>] --&gt; [<span class=\"number\">3</span>,<span class=\"number\">5</span>,<span class=\"number\">8</span>] --&gt;   [<span class=\"number\">3</span>,<span class=\"number\">8</span>]   --&gt;  [<span class=\"number\">8</span>]  --&gt; []</span><br><span class=\"line\">     coins =  <span class=\"number\">3</span>*<span class=\"number\">1</span>*<span class=\"number\">5</span>      +  <span class=\"number\">3</span>*<span class=\"number\">5</span>*<span class=\"number\">8</span>    +  <span class=\"number\">1</span>*<span class=\"number\">3</span>*<span class=\"number\">8</span>      + <span class=\"number\">1</span>*<span class=\"number\">8</span>*<span class=\"number\">1</span>   = <span class=\"number\">167</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"思路-26\"><a href=\"#思路-26\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>动态规划，用 <code>dp[i][j]</code> 表示戳破气球 <code>i</code> 和气球 <code>j</code> 之间所有气球所能获得硬币的最大数量：</p>\n<ul>\n<li>当气球 <code>i</code> 和 <code>j</code> 相邻时，<code>dp[i][j]</code> 为0；</li>\n<li>令 <code>k</code> 为气球 <code>i</code> 和气球 <code>j</code> 之间最后戳破的气球序号，对于每个 <code>i</code> 和 <code>j</code>（<code>i</code> 小于 <code>j</code>），遍历所有的 <code>k</code>，取其中的最大值赋值给 <code>dp[i][j]</code>，可得以下状态转移方程：</li>\n<li><code>dp[i][j] = max(dp[i][j], dp[i][k] + dp[k][j] + nums[i]*nums[k]*nums[j])</code>.</li>\n</ul>\n<p>注意要令 <code>nums</code> 的两个边界赋值为1。</p>\n<p>时间复杂度为 $O(N^3)$。</p>\n<h2 id=\"代码-26\"><a href=\"#代码-26\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">maxCoins</span><span class=\"params\">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">        points = [<span class=\"number\">1</span>] + nums + [<span class=\"number\">1</span>]</span><br><span class=\"line\">        n = len(nums)</span><br><span class=\"line\">        dp = [[<span class=\"number\">0</span>] * (n+<span class=\"number\">2</span>) <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(n+<span class=\"number\">2</span>)]</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n, <span class=\"number\">-1</span>, <span class=\"number\">-1</span>):</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(i+<span class=\"number\">1</span>, n+<span class=\"number\">2</span>):</span><br><span class=\"line\">                <span class=\"keyword\">for</span> k <span class=\"keyword\">in</span> range(i+<span class=\"number\">1</span>, j):</span><br><span class=\"line\">                    dp[i][j] = max(dp[i][j], dp[i][k] + dp[k][j] + points[k]*points[i]*points[j])</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[<span class=\"number\">0</span>][<span class=\"number\">-1</span>]</span><br></pre></td></tr></table></figure>\n<h1 id=\"315-计算右侧小于当前元素的个数\"><a href=\"#315-计算右侧小于当前元素的个数\" class=\"headerlink\" title=\"315. 计算右侧小于当前元素的个数\"></a>315. 计算右侧小于当前元素的个数</h1><p><a href=\"https://leetcode-cn.com/problems/count-of-smaller-numbers-after-self/\" target=\"_blank\" rel=\"noopener\">https://leetcode-cn.com/problems/count-of-smaller-numbers-after-self/</a></p>\n<h2 id=\"题目描述-27\"><a href=\"#题目描述-27\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>给定一个整数数组 nums，按要求返回一个新数组 counts。数组 counts 有该性质： <code>counts[i]</code> 的值是  <code>nums[i]</code> 右侧小于 <code>nums[i]</code> 的元素的数量。</p>\n<p>示例:</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: [<span class=\"number\">5</span>,<span class=\"number\">2</span>,<span class=\"number\">6</span>,<span class=\"number\">1</span>]</span><br><span class=\"line\">输出: [<span class=\"number\">2</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">0</span>] </span><br><span class=\"line\">解释:</span><br><span class=\"line\"><span class=\"number\">5</span> 的右侧有 <span class=\"number\">2</span> 个更小的元素 (<span class=\"number\">2</span> 和 <span class=\"number\">1</span>).</span><br><span class=\"line\"><span class=\"number\">2</span> 的右侧仅有 <span class=\"number\">1</span> 个更小的元素 (<span class=\"number\">1</span>).</span><br><span class=\"line\"><span class=\"number\">6</span> 的右侧有 <span class=\"number\">1</span> 个更小的元素 (<span class=\"number\">1</span>).</span><br><span class=\"line\"><span class=\"number\">1</span> 的右侧有 <span class=\"number\">0</span> 个更小的元素.</span><br></pre></td></tr></table></figure>\n<h2 id=\"思路-27\"><a href=\"#思路-27\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>二分查找，从后向前遍历 <code>nums</code>，使用一个辅助数组 <code>sorted_nums</code> 保存 <code>nums[i]</code> 右侧的元素的升序排列，<code>counts[i]</code> 的值即为 <code>nums[i]</code> 插入 <code>sorted_nums</code> 后的索引：</p>\n<ol>\n<li>在 <code>sorted_nums</code> 中查找第一个小于等于 <code>nums[i]</code> 的元素的索引，此索引即为<code>nums</code> 中 <code>nums[i]</code> 右侧小于该元素的元素数量；</li>\n<li>将其添加到 <code>ans</code> 数组中；</li>\n<li>将 <code>nums[i]</code> 插入到 <code>sorted_nums</code> 中的对应位置，继续遍历，直到遍历完整个数组。</li>\n</ol>\n<p>最后 <code>ans</code> 的倒序即为答案。</p>\n<h2 id=\"代码-27\"><a href=\"#代码-27\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">countSmaller</span><span class=\"params\">(self, nums: List[int])</span> -&gt; List[int]:</span></span><br><span class=\"line\">        sorted_nums, ans = [], []</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> reversed(range(len(nums))): </span><br><span class=\"line\">            t = self.findIndex(nums[i], sorted_nums)</span><br><span class=\"line\">            sorted_nums.insert(t, nums[i])</span><br><span class=\"line\">            ans.append(t)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans[::<span class=\"number\">-1</span>]</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">findIndex</span><span class=\"params\">(self, n, sorted_nums)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> len(sorted_nums) == <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">        left, right = <span class=\"number\">0</span>, len(sorted_nums)<span class=\"number\">-1</span></span><br><span class=\"line\">        mid = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> left &lt; right:</span><br><span class=\"line\">            mid = left + right &gt;&gt; <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> n &gt; sorted_nums[mid]:</span><br><span class=\"line\">                left = mid + <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                right = mid</span><br><span class=\"line\">        <span class=\"keyword\">if</span> n &gt; sorted_nums[left]:</span><br><span class=\"line\">            left += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> left</span><br></pre></td></tr></table></figure>\n<h1 id=\"322-零钱兑换\"><a href=\"#322-零钱兑换\" class=\"headerlink\" title=\"322. 零钱兑换\"></a>322. 零钱兑换</h1><p><a href=\"https://leetcode-cn.com/problems/coin-change/\" target=\"_blank\" rel=\"noopener\">https://leetcode-cn.com/problems/coin-change/</a></p>\n<h2 id=\"题目描述-28\"><a href=\"#题目描述-28\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 <code>-1</code>。</p>\n<p>示例 1:</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: coins = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">5</span>], amount = <span class=\"number\">11</span></span><br><span class=\"line\">输出: <span class=\"number\">3</span> </span><br><span class=\"line\">解释: <span class=\"number\">11</span> = <span class=\"number\">5</span> + <span class=\"number\">5</span> + <span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n<p>示例 2:</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: coins = [<span class=\"number\">2</span>], amount = <span class=\"number\">3</span></span><br><span class=\"line\">输出: <span class=\"number\">-1</span></span><br></pre></td></tr></table></figure>\n<p>说明:<br>你可以认为每种硬币的数量是无限的。</p>\n<h2 id=\"思路-28\"><a href=\"#思路-28\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>首先想到了贪心，但会复杂一点，迟点再研究一下，这里用了动态规划。根据题意，要求 <code>amount</code> 的最少硬币数，可以先对 <code>coins</code> 中的每一个面额 <code>coin</code> 进行遍历，求子问题 $dp(amount-coin)$ 的最小值。</p>\n<p>可以列出状态转移方程</p>\n<script type=\"math/tex; mode=display\">\ndp(n) = \\left\\{ \\begin{array}{lcl}\n -1, & n < 0\\\\\n 0, & n = 0\\\\\n \\min\\{dp(n-coin)+1|coin \\in coins\\}, & n > 0\n\\end{array}\\right.</script><h2 id=\"代码-28\"><a href=\"#代码-28\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">coinChange</span><span class=\"params\">(self, coins: List[int], amount: int)</span> -&gt; int:</span></span><br><span class=\"line\">        memo = dict()</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dp</span><span class=\"params\">(n)</span>:</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> n <span class=\"keyword\">in</span> memo:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> memo[n]</span><br><span class=\"line\">            <span class=\"keyword\">if</span> n == <span class=\"number\">0</span>:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> n &lt; <span class=\"number\">0</span>:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">            ans = float(<span class=\"string\">\"inf\"</span>)</span><br><span class=\"line\">            <span class=\"keyword\">for</span> coin <span class=\"keyword\">in</span> coins:</span><br><span class=\"line\">                subproblem = dp(n - coin)</span><br><span class=\"line\">                <span class=\"keyword\">if</span> subproblem == <span class=\"number\">-1</span>:</span><br><span class=\"line\">                    <span class=\"keyword\">continue</span></span><br><span class=\"line\">                ans = min(ans, subproblem + <span class=\"number\">1</span>)</span><br><span class=\"line\">            memo[n] = ans <span class=\"keyword\">if</span> ans!=float(inf) <span class=\"keyword\">else</span> <span class=\"number\">-1</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> memo[n]</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp(amount)</span><br></pre></td></tr></table></figure>\n<h1 id=\"350-两个数组的交集-II\"><a href=\"#350-两个数组的交集-II\" class=\"headerlink\" title=\"350. 两个数组的交集 II\"></a>350. 两个数组的交集 II</h1><p><a href=\"https://leetcode-cn.com/problems/intersection-of-two-arrays-ii/\" target=\"_blank\" rel=\"noopener\">https://leetcode-cn.com/problems/intersection-of-two-arrays-ii/</a></p>\n<h2 id=\"题目描述-29\"><a href=\"#题目描述-29\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>给定两个数组，编写一个函数来计算它们的交集。</p>\n<p>示例 1:</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: nums1 = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">2</span>,<span class=\"number\">1</span>], nums2 = [<span class=\"number\">2</span>,<span class=\"number\">2</span>]</span><br><span class=\"line\">输出: [<span class=\"number\">2</span>,<span class=\"number\">2</span>]</span><br></pre></td></tr></table></figure>\n<p>示例 2:</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: nums1 = [<span class=\"number\">4</span>,<span class=\"number\">9</span>,<span class=\"number\">5</span>], nums2 = [<span class=\"number\">9</span>,<span class=\"number\">4</span>,<span class=\"number\">9</span>,<span class=\"number\">8</span>,<span class=\"number\">4</span>]</span><br><span class=\"line\">输出: [<span class=\"number\">4</span>,<span class=\"number\">9</span>]</span><br></pre></td></tr></table></figure>\n<p>说明：</p>\n<ul>\n<li>输出结果中每个元素出现的次数，应与元素在两个数组中出现的次数一致。</li>\n<li>我们可以不考虑输出结果的顺序。</li>\n</ul>\n<p>进阶:</p>\n<ul>\n<li>如果给定的数组已经排好序呢？你将如何优化你的算法？</li>\n<li>如果 nums1 的大小比 nums2 小很多，哪种方法更优？</li>\n<li>如果 nums2 的元素存储在磁盘上，磁盘内存是有限的，并且你不能一次加载所有的元素到内存中，你该怎么办？</li>\n</ul>\n<h2 id=\"思路-29\"><a href=\"#思路-29\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>两种方法：</p>\n<ul>\n<li>遍历 <code>nums1</code>，用一个字典存储 <code>d</code> 其中元素的个数，然后遍历 <code>nums2</code> 若扫描到的元素 <code>nums2[i]</code> 在字典中存在且 <code>d[nums2[i]] &gt; 0</code>，则将该元素加入 <code>ans</code> 并将 <code>d[nums2[i]]</code> 自减 1。</li>\n<li>先对两个数组进行排序，然后用两个指针 <code>i, j</code> 分别指向排序完的数组的头元素。从头元素开始扫描，当 <code>nums1[i] &gt; nums2[j]</code> 时 <code>j</code> 往后移，反之 <code>i</code> 往后移，两个元素相等时将其加入 <code>ans</code>，当遍历完其中一个数组后结束循环。</li>\n</ul>\n<h2 id=\"代码-29\"><a href=\"#代码-29\" class=\"headerlink\" title=\"代码\"></a>代码</h2><p>哈希表：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">intersect</span><span class=\"params\">(self, nums1: List[int], nums2: List[int])</span> -&gt; List[int]:</span></span><br><span class=\"line\">        d = dict()</span><br><span class=\"line\">        ans = []</span><br><span class=\"line\">        <span class=\"keyword\">for</span> num <span class=\"keyword\">in</span> nums1:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> num <span class=\"keyword\">in</span> d:</span><br><span class=\"line\">                d[num] += <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                d[num] = <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> num <span class=\"keyword\">in</span> nums2:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> num <span class=\"keyword\">in</span> d <span class=\"keyword\">and</span> d[num] &gt; <span class=\"number\">0</span>:</span><br><span class=\"line\">                ans.append(num)</span><br><span class=\"line\">                d[num] -= <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<p>排序方法：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">intersect</span><span class=\"params\">(self, nums1: List[int], nums2: List[int])</span> -&gt; List[int]:</span></span><br><span class=\"line\">        nums1.sort()</span><br><span class=\"line\">        nums2.sort()</span><br><span class=\"line\">        i = j = <span class=\"number\">0</span></span><br><span class=\"line\">        ans = []</span><br><span class=\"line\">        <span class=\"keyword\">while</span> i &lt; len(nums1) <span class=\"keyword\">and</span> j &lt; len(nums2):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> nums1[i] == nums2[j]:</span><br><span class=\"line\">                ans.append(nums1[i])</span><br><span class=\"line\">                i += <span class=\"number\">1</span></span><br><span class=\"line\">                j += <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">elif</span> nums1[i] &gt; nums2[j]:</span><br><span class=\"line\">                j += <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                i += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<h1 id=\"394-字符串解码\"><a href=\"#394-字符串解码\" class=\"headerlink\" title=\"394. 字符串解码\"></a>394. 字符串解码</h1><p><a href=\"https://leetcode-cn.com/problems/decode-string/\" target=\"_blank\" rel=\"noopener\">https://leetcode-cn.com/problems/decode-string/</a></p>\n<h2 id=\"题目描述-30\"><a href=\"#题目描述-30\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>给定一个经过编码的字符串，返回它解码后的字符串。</p>\n<p>编码规则为: <code>k[encoded_string]</code>，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。</p>\n<p>你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。</p>\n<p>此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 <code>3a</code> 或 <code>2[4]</code> 的输入。</p>\n<p>示例:</p>\n<figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">s</span> = <span class=\"string\">\"3[a]2[bc]\"</span>, 返回 <span class=\"string\">\"aaabcbc\"</span>.</span><br><span class=\"line\"><span class=\"attribute\">s</span> = <span class=\"string\">\"3[a2[c]]\"</span>, 返回 <span class=\"string\">\"accaccacc\"</span>.</span><br><span class=\"line\"><span class=\"attribute\">s</span> = <span class=\"string\">\"2[abc]3[cd]ef\"</span>, 返回 <span class=\"string\">\"abcabccdcdcdef\"</span>.</span><br></pre></td></tr></table></figure>\n<h2 id=\"思路-30\"><a href=\"#思路-30\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>这里可以使用栈，对字符串按顺序扫描：</p>\n<ol>\n<li>将右括号以外的字符全部入栈，直到扫描到右括号；</li>\n<li>扫描到右括号则开始退栈，保存在一个字符串<code>ss</code>中，直到遇到左括号；</li>\n<li>根据题目的条件，在左括号前面的一定是数字，此时就可以统计当前字符串出现的次数<code>t</code>，把<code>ss</code>复制<code>t</code>次重新入栈；</li>\n<li>最后把栈中所有元素拼接在一起即可。</li>\n</ol>\n<h2 id=\"代码-30\"><a href=\"#代码-30\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">decodeString</span><span class=\"params\">(self, s: str)</span> -&gt; str:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> len(s) &lt;= <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">\"\"</span></span><br><span class=\"line\">        ans = <span class=\"string\">\"\"</span></span><br><span class=\"line\">        tmps = []   <span class=\"comment\"># 栈</span></span><br><span class=\"line\">        i = <span class=\"number\">1</span></span><br><span class=\"line\">        tmps.append(s[<span class=\"number\">0</span>])</span><br><span class=\"line\">        ss, t = <span class=\"string\">\"\"</span>, <span class=\"string\">\"\"</span>\t<span class=\"comment\"># 分别存当前字符串和当前的次数</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> i &lt; len(s):</span><br><span class=\"line\">            w = s[i]</span><br><span class=\"line\">            <span class=\"keyword\">if</span> w == <span class=\"string\">']'</span>:\t<span class=\"comment\"># 扫描到右括号则开始退栈，直到遇到左括号</span></span><br><span class=\"line\">                <span class=\"keyword\">while</span> tmps[<span class=\"number\">-1</span>] != <span class=\"string\">'['</span>:</span><br><span class=\"line\">                    ss = tmps.pop() + ss</span><br><span class=\"line\">                tmps.pop()      <span class=\"comment\"># 将左括号退栈</span></span><br><span class=\"line\">                <span class=\"keyword\">while</span> len(tmps) &gt; <span class=\"number\">0</span> <span class=\"keyword\">and</span> tmps[<span class=\"number\">-1</span>].isdigit():\t\t<span class=\"comment\"># 统计次数</span></span><br><span class=\"line\">                    t = tmps.pop() + t</span><br><span class=\"line\">                tmps.append(ss*int(t))</span><br><span class=\"line\">                ss, t = <span class=\"string\">\"\"</span>, <span class=\"string\">\"\"</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                tmps.append(w)</span><br><span class=\"line\">            i += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> tmp <span class=\"keyword\">in</span> tmps:</span><br><span class=\"line\">            ans = ans + tmp</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<h1 id=\"409-最长回文串\"><a href=\"#409-最长回文串\" class=\"headerlink\" title=\"409. 最长回文串\"></a>409. 最长回文串</h1><p><a href=\"https://leetcode-cn.com/problems/longest-palindrome/\" target=\"_blank\" rel=\"noopener\">https://leetcode-cn.com/problems/longest-palindrome/</a></p>\n<h2 id=\"题目描述-31\"><a href=\"#题目描述-31\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>给定一个包含大写字母和小写字母的字符串，找到通过这些字母构造成的最长的回文串。</p>\n<p>在构造过程中，请注意区分大小写。比如 <code>&quot;Aa&quot;</code> 不能当做一个回文字符串。</p>\n<p>注意:<br>假设字符串的长度不会超过 1010。</p>\n<p>示例 1:</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">输入:</span></span><br><span class=\"line\"><span class=\"string\">\"abccccdd\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">输出:</span></span><br><span class=\"line\">7</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">解释:</span></span><br><span class=\"line\">我们可以构造的最长的回文串是<span class=\"string\">\"dccaccd\"</span>, 它的长度是 7。</span><br></pre></td></tr></table></figure>\n<h2 id=\"思路-31\"><a href=\"#思路-31\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>由题意可知回文串中奇数的字母只能出现在中间，即只能选取一个来构造回文串。因此可以先统计每个字母在字符串中出现的个数存在字典中，然后遍历字典，将数量为偶数的直接累加；数量为奇数的则判断前面是否已出现了奇数，若不是则直接累加，若是则只选取偶数数量的当前字母，即把当前数量 $-1$ 再累加。</p>\n<h2 id=\"代码-31\"><a href=\"#代码-31\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">longestPalindrome</span><span class=\"params\">(self, s: str)</span> -&gt; int:</span></span><br><span class=\"line\">        d = dict()</span><br><span class=\"line\">        ans = <span class=\"number\">0</span></span><br><span class=\"line\">        flag = <span class=\"number\">0</span>    <span class=\"comment\"># 判断前面有无加奇数</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> w <span class=\"keyword\">in</span> s:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> w <span class=\"keyword\">in</span> d:</span><br><span class=\"line\">                d[w] += <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                d[w] = <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> value <span class=\"keyword\">in</span> d.values():</span><br><span class=\"line\">            <span class=\"keyword\">if</span> value%<span class=\"number\">2</span>==<span class=\"number\">0</span>:</span><br><span class=\"line\">                ans += value</span><br><span class=\"line\">            <span class=\"keyword\">elif</span> flag:</span><br><span class=\"line\">                ans += value - <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                ans += value</span><br><span class=\"line\">                flag = <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<h1 id=\"563-二叉树的坡度\"><a href=\"#563-二叉树的坡度\" class=\"headerlink\" title=\"563. 二叉树的坡度\"></a>563. 二叉树的坡度</h1><p><a href=\"https://leetcode-cn.com/problems/binary-tree-tilt/\" target=\"_blank\" rel=\"noopener\">https://leetcode-cn.com/problems/binary-tree-tilt/</a></p>\n<h2 id=\"题目描述-32\"><a href=\"#题目描述-32\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>给定一个二叉树，计算整个树的坡度。</p>\n<p>一个树的节点的坡度定义即为，该节点左子树的结点之和和右子树结点之和的差的绝对值。空结点的的坡度是0。</p>\n<p>整个树的坡度就是其所有节点的坡度之和。</p>\n<p>示例：</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：</span><br><span class=\"line\">         <span class=\"number\">1</span></span><br><span class=\"line\">       /   \\</span><br><span class=\"line\">      <span class=\"number\">2</span>     <span class=\"number\">3</span></span><br><span class=\"line\">输出：<span class=\"number\">1</span></span><br><span class=\"line\">解释：</span><br><span class=\"line\">结点 <span class=\"number\">2</span> 的坡度: <span class=\"number\">0</span></span><br><span class=\"line\">结点 <span class=\"number\">3</span> 的坡度: <span class=\"number\">0</span></span><br><span class=\"line\">结点 <span class=\"number\">1</span> 的坡度: |<span class=\"number\">2</span><span class=\"number\">-3</span>| = <span class=\"number\">1</span></span><br><span class=\"line\">树的坡度 : <span class=\"number\">0</span> + <span class=\"number\">0</span> + <span class=\"number\">1</span> = <span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n<p>提示：</p>\n<p>任何子树的结点的和不会超过 32 位整数的范围。<br>坡度的值不会超过 32 位整数的范围。</p>\n<h2 id=\"思路-32\"><a href=\"#思路-32\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>递归，后序遍历二叉树，用一个变量 <code>tilt</code> 存储累计坡度，访问节点时更新 <code>tilt = tilt + |(左子树节点之和 - 右子树节点之和)|</code>，然后返回以当前节点为根节点的二叉树节点之和。</p>\n<p>递归边界为访问到空节点，返回 0。</p>\n<h2 id=\"代码-32\"><a href=\"#代码-32\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">findTilt</span><span class=\"params\">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class=\"line\">        tilt = [<span class=\"number\">0</span>]</span><br><span class=\"line\">        self.recur(root, tilt)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> tilt[<span class=\"number\">0</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">recur</span><span class=\"params\">(self, node, tilt)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> node:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">        left = self.recur(node.left, tilt)</span><br><span class=\"line\">        right = self.recur(node.right, tilt)</span><br><span class=\"line\">        tilt[<span class=\"number\">0</span>] += abs(left - right)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> left + right + node.val</span><br></pre></td></tr></table></figure>\n<h1 id=\"623-在二叉树中增加一行\"><a href=\"#623-在二叉树中增加一行\" class=\"headerlink\" title=\"623. 在二叉树中增加一行\"></a>623. 在二叉树中增加一行</h1><p><a href=\"https://leetcode-cn.com/problems/add-one-row-to-tree/\" target=\"_blank\" rel=\"noopener\">https://leetcode-cn.com/problems/add-one-row-to-tree/</a></p>\n<h2 id=\"题目描述-33\"><a href=\"#题目描述-33\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>给定一个二叉树，根节点为第1层，深度为 1。在其第 <code>d</code> 层追加一行值为 <code>v</code> 的节点。</p>\n<p>添加规则：给定一个深度值 <code>d</code> （正整数），针对深度为 <code>d-1</code> 层的每一非空节点 <code>N</code>，为 <code>N</code> 创建两个值为 <code>v</code> 的左子树和右子树。</p>\n<p>将 <code>N</code> 原先的左子树，连接为新节点 <code>v</code> 的左子树；将 <code>N</code> 原先的右子树，连接为新节点 <code>v</code> 的右子树。</p>\n<p>如果 <code>d</code> 的值为 1，深度 d - 1 不存在，则创建一个新的根节点 <code>v</code>，原先的整棵树将作为 <code>v</code> 的左子树。</p>\n<p>示例 1:</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: </span><br><span class=\"line\">二叉树如下所示:</span><br><span class=\"line\">       <span class=\"number\">4</span></span><br><span class=\"line\">     /   \\</span><br><span class=\"line\">    <span class=\"number\">2</span>     <span class=\"number\">6</span></span><br><span class=\"line\">   / \\   / </span><br><span class=\"line\">  <span class=\"number\">3</span>   <span class=\"number\">1</span> <span class=\"number\">5</span>   </span><br><span class=\"line\"></span><br><span class=\"line\">v = <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">d = <span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\">输出: </span><br><span class=\"line\">       <span class=\"number\">4</span></span><br><span class=\"line\">      / \\</span><br><span class=\"line\">     <span class=\"number\">1</span>   <span class=\"number\">1</span></span><br><span class=\"line\">    /     \\</span><br><span class=\"line\">   <span class=\"number\">2</span>       <span class=\"number\">6</span></span><br><span class=\"line\">  / \\     / </span><br><span class=\"line\"> <span class=\"number\">3</span>   <span class=\"number\">1</span>   <span class=\"number\">5</span></span><br></pre></td></tr></table></figure>\n<p>示例 2:</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: </span><br><span class=\"line\">二叉树如下所示:</span><br><span class=\"line\">      <span class=\"number\">4</span></span><br><span class=\"line\">     /   </span><br><span class=\"line\">    <span class=\"number\">2</span>    </span><br><span class=\"line\">   / \\   </span><br><span class=\"line\">  <span class=\"number\">3</span>   <span class=\"number\">1</span>    </span><br><span class=\"line\"></span><br><span class=\"line\">v = <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">d = <span class=\"number\">3</span></span><br><span class=\"line\"></span><br><span class=\"line\">输出: </span><br><span class=\"line\">      <span class=\"number\">4</span></span><br><span class=\"line\">     /   </span><br><span class=\"line\">    <span class=\"number\">2</span></span><br><span class=\"line\">   / \\    </span><br><span class=\"line\">  <span class=\"number\">1</span>   <span class=\"number\">1</span></span><br><span class=\"line\"> /     \\  </span><br><span class=\"line\"><span class=\"number\">3</span>       <span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n<p>注意:</p>\n<p>输入的深度值 d 的范围是：[1，二叉树最大深度 + 1]。<br>输入的二叉树至少有一个节点。</p>\n<h2 id=\"思路-33\"><a href=\"#思路-33\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>深度优先搜索(递归)，在访问到深度为 <code>d-1</code> 的节点则在它们下面增加子节点然后返回。</p>\n<p>注意 <code>d = 1</code> 的特殊情况和访问到空节点的情况。</p>\n<h2 id=\"代码-33\"><a href=\"#代码-33\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">addOneRow</span><span class=\"params\">(self, root: TreeNode, v: int, d: int)</span> -&gt; TreeNode:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> d == <span class=\"number\">1</span>:</span><br><span class=\"line\">            newnode = TreeNode(v)</span><br><span class=\"line\">            newnode.left = root</span><br><span class=\"line\">            root = newnode</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            self.helper(root, d, v, <span class=\"number\">1</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">helper</span><span class=\"params\">(self, node, d, v, depth)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> node: <span class=\"keyword\">return</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> depth == d - <span class=\"number\">1</span>:</span><br><span class=\"line\">            lnode, rnode = node.left, node.right</span><br><span class=\"line\">            n1, n2 = TreeNode(v), TreeNode(v)</span><br><span class=\"line\">            n1.left, n2.right = lnode, rnode</span><br><span class=\"line\">            node.left, node.right = n1, n2</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">        self.helper(node.left, d, v, depth + <span class=\"number\">1</span>)</span><br><span class=\"line\">        self.helper(node.right, d, v, depth + <span class=\"number\">1</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"637-二叉树的层平均值\"><a href=\"#637-二叉树的层平均值\" class=\"headerlink\" title=\"637. 二叉树的层平均值\"></a>637. 二叉树的层平均值</h1><p><a href=\"https://leetcode-cn.com/problems/average-of-levels-in-binary-tree/\" target=\"_blank\" rel=\"noopener\">https://leetcode-cn.com/problems/average-of-levels-in-binary-tree/</a></p>\n<h2 id=\"题目描述-34\"><a href=\"#题目描述-34\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>给定一个非空二叉树, 返回一个由每层节点平均值组成的数组。</p>\n<p>示例 1：</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：</span><br><span class=\"line\">    <span class=\"number\">3</span></span><br><span class=\"line\">   / \\</span><br><span class=\"line\">  <span class=\"number\">9</span>  <span class=\"number\">20</span></span><br><span class=\"line\">    /  \\</span><br><span class=\"line\">   <span class=\"number\">15</span>   <span class=\"number\">7</span></span><br><span class=\"line\">输出：[<span class=\"number\">3</span>, <span class=\"number\">14.5</span>, <span class=\"number\">11</span>]</span><br><span class=\"line\">解释：</span><br><span class=\"line\">第 <span class=\"number\">0</span> 层的平均值是 <span class=\"number\">3</span> ,  第<span class=\"number\">1</span>层是 <span class=\"number\">14.5</span> , 第<span class=\"number\">2</span>层是 <span class=\"number\">11</span> 。因此返回 [<span class=\"number\">3</span>, <span class=\"number\">14.5</span>, <span class=\"number\">11</span>] 。</span><br></pre></td></tr></table></figure>\n<p>提示：</p>\n<p>节点值的范围在32位有符号整数范围内。</p>\n<h2 id=\"思路-34\"><a href=\"#思路-34\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>BFS，套模板，逐层计算均值即可。</p>\n<h2 id=\"代码-34\"><a href=\"#代码-34\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">averageOfLevels</span><span class=\"params\">(self, root: TreeNode)</span> -&gt; List[float]:</span></span><br><span class=\"line\">        queue = collections.deque()</span><br><span class=\"line\">        queue.append(root)</span><br><span class=\"line\">        ans = []</span><br><span class=\"line\">        <span class=\"keyword\">if</span> root:</span><br><span class=\"line\">            <span class=\"keyword\">while</span> queue:</span><br><span class=\"line\">                size = len(queue)</span><br><span class=\"line\">                s = <span class=\"number\">0</span></span><br><span class=\"line\">                <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(size):</span><br><span class=\"line\">                    node = queue.popleft()</span><br><span class=\"line\">                    s += node.val</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> node.left:</span><br><span class=\"line\">                        queue.append(node.left)</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> node.right:</span><br><span class=\"line\">                        queue.append(node.right)</span><br><span class=\"line\">                <span class=\"keyword\">if</span> size:</span><br><span class=\"line\">                    ans.append(s/size)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<h1 id=\"785-判断二分图\"><a href=\"#785-判断二分图\" class=\"headerlink\" title=\"785. 判断二分图\"></a>785. 判断二分图</h1><p><a href=\"https://leetcode-cn.com/problems/is-graph-bipartite/\" target=\"_blank\" rel=\"noopener\">https://leetcode-cn.com/problems/is-graph-bipartite/</a></p>\n<h2 id=\"题目描述-35\"><a href=\"#题目描述-35\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>给定一个无向图 <code>graph</code>，当这个图为二分图时返回 <code>true</code>。</p>\n<p>如果我们能将一个图的节点集合分割成两个独立的子集A和B，并使图中的每一条边的两个节点一个来自A集合，一个来自B集合，我们就将这个图称为二分图。</p>\n<p>graph将会以邻接表方式给出，<code>graph[i]</code> 表示图中与节点 <code>i</code> 相连的所有节点。每个节点都是一个在 <code>0</code> 到 <code>graph.length-1</code> 之间的整数。这图中没有自环和平行边： <code>graph[i]</code> 中不存在 <code>i</code>，并且 <code>graph[i]</code> 中没有重复的值。</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">示例 <span class=\"number\">1</span>:</span><br><span class=\"line\">输入: [[<span class=\"number\">1</span>,<span class=\"number\">3</span>], [<span class=\"number\">0</span>,<span class=\"number\">2</span>], [<span class=\"number\">1</span>,<span class=\"number\">3</span>], [<span class=\"number\">0</span>,<span class=\"number\">2</span>]]</span><br><span class=\"line\">输出: <span class=\"literal\">true</span></span><br><span class=\"line\">解释: </span><br><span class=\"line\">无向图如下:</span><br><span class=\"line\"><span class=\"number\">0</span>---<span class=\"number\">-1</span></span><br><span class=\"line\">|    |</span><br><span class=\"line\">|    |</span><br><span class=\"line\"><span class=\"number\">3</span>---<span class=\"number\">-2</span></span><br><span class=\"line\">我们可以将节点分成两组: &#123;<span class=\"number\">0</span>, <span class=\"number\">2</span>&#125; 和 &#123;<span class=\"number\">1</span>, <span class=\"number\">3</span>&#125;。</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">示例 <span class=\"number\">2</span>:</span><br><span class=\"line\">输入: [[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>], [<span class=\"number\">0</span>,<span class=\"number\">2</span>], [<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">3</span>], [<span class=\"number\">0</span>,<span class=\"number\">2</span>]]</span><br><span class=\"line\">输出: <span class=\"literal\">false</span></span><br><span class=\"line\">解释: </span><br><span class=\"line\">无向图如下:</span><br><span class=\"line\"><span class=\"number\">0</span>---<span class=\"number\">-1</span></span><br><span class=\"line\">| \\  |</span><br><span class=\"line\">|  \\ |</span><br><span class=\"line\"><span class=\"number\">3</span>---<span class=\"number\">-2</span></span><br><span class=\"line\">我们不能将节点分割成两个独立的子集。</span><br></pre></td></tr></table></figure>\n<p>注意:</p>\n<ul>\n<li><code>graph</code> 的长度范围为 <code>[1, 100]</code>。</li>\n<li><code>graph[i]</code> 中的元素的范围为 <code>[0, graph.length - 1]</code>。</li>\n<li><code>graph[i]</code> 不会包含 <code>i</code> 或者有重复的值。</li>\n<li>图是无向的: 如果 <code>j</code> 在 <code>graph[i]</code> 里边, 那么 <code>i</code> 也会在 <code>graph[j]</code> 里边。</li>\n</ul>\n<h2 id=\"思路-35\"><a href=\"#思路-35\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>BFS，遍历所有节点，用 <code>visited</code> 数组标记节点是否已经被访问（初始值为 <code>0</code>）：</p>\n<ul>\n<li>对当前未访问的节点 <code>i</code>，<ol>\n<li>将 <code>visited[i]</code> 标记为 <code>1</code>；</li>\n<li>把 <code>i</code> 的相邻节点 <code>j</code> 标记为 <code>-1</code>，然后继续对 <code>j</code> 的相邻节点标记为 <code>-visited[j]</code>，直到所有连接在一起的节点都被访问；</li>\n<li>如果上一步在标记时，<code>i</code> 的某个相邻节点 <code>j</code> 的标记值 <code>visited[j] = visited[i]</code>，则说明无法将图中节点分割，返回 <code>false</code>。</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"代码-35\"><a href=\"#代码-35\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isBipartite</span><span class=\"params\">(self, graph: List[List[int]])</span> -&gt; bool:</span></span><br><span class=\"line\">        visited = [<span class=\"number\">0</span>] * len(graph)</span><br><span class=\"line\">        queue = collections.deque()</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(graph)):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> visited[i] != <span class=\"number\">0</span>:</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>              </span><br><span class=\"line\">            visited[i] = <span class=\"number\">1</span></span><br><span class=\"line\">            queue.append(i)</span><br><span class=\"line\">            <span class=\"keyword\">while</span> queue:</span><br><span class=\"line\">                cur = queue.popleft()</span><br><span class=\"line\">                <span class=\"keyword\">for</span> node <span class=\"keyword\">in</span> graph[cur]:</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> visited[node] == <span class=\"number\">0</span>:</span><br><span class=\"line\">                        visited[node] = -visited[cur]</span><br><span class=\"line\">                        queue.append(node)</span><br><span class=\"line\">                    <span class=\"keyword\">elif</span> visited[node] == visited[cur]:</span><br><span class=\"line\">                        <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"974-和可被-K-整除的子数组\"><a href=\"#974-和可被-K-整除的子数组\" class=\"headerlink\" title=\"974. 和可被 K 整除的子数组\"></a>974. 和可被 K 整除的子数组</h1><p><a href=\"https://leetcode-cn.com/problems/subarray-sums-divisible-by-k/\" target=\"_blank\" rel=\"noopener\">https://leetcode-cn.com/problems/subarray-sums-divisible-by-k/</a></p>\n<h2 id=\"题目描述-36\"><a href=\"#题目描述-36\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>给定一个整数数组 A，返回其中元素之和可被 K 整除的（连续、非空）子数组的数目。</p>\n<p>示例：</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：A = [<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">0</span>,<span class=\"number\">-2</span>,<span class=\"number\">-3</span>,<span class=\"number\">1</span>], K = <span class=\"number\">5</span></span><br><span class=\"line\">输出：<span class=\"number\">7</span></span><br><span class=\"line\">解释：</span><br><span class=\"line\">有 <span class=\"number\">7</span> 个子数组满足其元素之和可被 K = <span class=\"number\">5</span> 整除：</span><br><span class=\"line\">[<span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">0</span>, <span class=\"number\">-2</span>, <span class=\"number\">-3</span>, <span class=\"number\">1</span>], [<span class=\"number\">5</span>], [<span class=\"number\">5</span>, <span class=\"number\">0</span>], [<span class=\"number\">5</span>, <span class=\"number\">0</span>, <span class=\"number\">-2</span>, <span class=\"number\">-3</span>], [<span class=\"number\">0</span>], [<span class=\"number\">0</span>, <span class=\"number\">-2</span>, <span class=\"number\">-3</span>], [<span class=\"number\">-2</span>, <span class=\"number\">-3</span>]</span><br></pre></td></tr></table></figure>\n<p>提示：</p>\n<ol>\n<li><code>1 &lt;= A.length &lt;= 30000</code></li>\n<li><code>-10000 &lt;= A[i] &lt;= 10000</code></li>\n<li><code>2 &lt;= K &lt;= 10000</code></li>\n</ol>\n<h2 id=\"思路-36\"><a href=\"#思路-36\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>一个前缀和的问题。设 $\\rm presum[i]$是数组 $\\rm A$ 第 $\\rm i$ 个元素的前缀和，那么 $\\rm A[i]$ 就可以表示为 $\\rm presum[i] - presum[i-1]$，子数组 $\\rm A[k]$ 到 $\\rm A[i]$ 的和就是 $\\rm presum[i] - presum[k-1]$。</p>\n<p>题目要求的是满足 $\\rm presum[i] - presum[k-1] \\bmod K = 0$ 的子数组 $\\rm [A[k],…,A[i]]$ 的个数，根据同余定理，可以把问题转换为求同余的 $\\rm presum[i]$ 的个数。每扫描到数组中的一个数，就检查哈希表中有没有同余的数组，若有则计算同余的数量，若无把当前模 $\\rm K$ 的余数保存在哈希表中，一次遍历即可解决问题。</p>\n<h2 id=\"代码-36\"><a href=\"#代码-36\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">subarraysDivByK</span><span class=\"params\">(self, A: List[int], K: int)</span> -&gt; int:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> len(A)==<span class=\"number\">0</span> <span class=\"keyword\">or</span> K==<span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">        d = &#123;<span class=\"number\">0</span>:<span class=\"number\">1</span>&#125;</span><br><span class=\"line\">        presum, cnt = <span class=\"number\">0</span>, <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> a <span class=\"keyword\">in</span> A:</span><br><span class=\"line\">            presum += a</span><br><span class=\"line\">            m = presum % K</span><br><span class=\"line\">            s = d.get(m, <span class=\"number\">0</span>)</span><br><span class=\"line\">            cnt += s</span><br><span class=\"line\">            d[m] = s + <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> cnt</span><br></pre></td></tr></table></figure>\n<h1 id=\"994-腐烂的橘子\"><a href=\"#994-腐烂的橘子\" class=\"headerlink\" title=\"994. 腐烂的橘子\"></a>994. 腐烂的橘子</h1><p><a href=\"https://leetcode-cn.com/problems/rotting-oranges/\" target=\"_blank\" rel=\"noopener\">https://leetcode-cn.com/problems/rotting-oranges/</a></p>\n<h2 id=\"题目描述-37\"><a href=\"#题目描述-37\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>在给定的网格中，每个单元格可以有以下三个值之一：</p>\n<p>值 <code>0</code> 代表空单元格；<br>值 <code>1</code> 代表新鲜橘子；<br>值 <code>2</code> 代表腐烂的橘子。<br>每分钟，任何与腐烂的橘子（在 4 个正方向上）相邻的新鲜橘子都会腐烂。</p>\n<p>返回直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 <code>-1</code>。</p>\n<p>示例 1：</p>\n<p><img src=\"http://images.yingwai.top/picgo/oranges.png\" alt=\"\"></p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：[[<span class=\"number\">2</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>],[<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">0</span>],[<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>]]</span><br><span class=\"line\">输出：<span class=\"number\">4</span></span><br></pre></td></tr></table></figure>\n<p>示例 2：</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：[[<span class=\"number\">2</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>],[<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>],[<span class=\"number\">1</span>,<span class=\"number\">0</span>,<span class=\"number\">1</span>]]</span><br><span class=\"line\">输出：<span class=\"number\">-1</span></span><br><span class=\"line\">解释：左下角的橘子（第 <span class=\"number\">2</span> 行， 第 <span class=\"number\">0</span> 列）永远不会腐烂，因为腐烂只会发生在 <span class=\"number\">4</span> 个正向上。</span><br></pre></td></tr></table></figure>\n<p>示例 3：</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：[[<span class=\"number\">0</span>,<span class=\"number\">2</span>]]</span><br><span class=\"line\">输出：<span class=\"number\">0</span></span><br><span class=\"line\">解释：因为 <span class=\"number\">0</span> 分钟时已经没有新鲜橘子了，所以答案就是 <span class=\"number\">0</span> 。</span><br></pre></td></tr></table></figure>\n<p>提示：</p>\n<ol>\n<li><code>1 &lt;= grid.length &lt;= 10</code></li>\n<li><code>1 &lt;= grid[0].length &lt;= 10</code></li>\n<li><code>grid[i][j]</code>仅为<code>0</code>、<code>1</code>或<code>2</code></li>\n</ol>\n<h2 id=\"思路-37\"><a href=\"#思路-37\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>广度优先搜索，一圈一圈往外腐蚀。</p>\n<h2 id=\"代码-37\"><a href=\"#代码-37\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">orangesRotting</span><span class=\"params\">(self, grid: List[List[int]])</span> -&gt; int:</span></span><br><span class=\"line\">        dx = [<span class=\"number\">-1</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>]</span><br><span class=\"line\">        dy = [<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">-1</span>, <span class=\"number\">1</span>]</span><br><span class=\"line\">        rotlist = list()    <span class=\"comment\"># 腐烂橘子的队列</span></span><br><span class=\"line\">        minute = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(grid)):</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(len(grid[<span class=\"number\">0</span>])):</span><br><span class=\"line\">                <span class=\"keyword\">if</span> grid[i][j] == <span class=\"number\">2</span>:</span><br><span class=\"line\">                    rotlist.append([i, j])</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> rotlist:  <span class=\"comment\"># BFS循环</span></span><br><span class=\"line\">            newrotlist = list()</span><br><span class=\"line\">            <span class=\"keyword\">for</span> rotorange <span class=\"keyword\">in</span> rotlist:   <span class=\"comment\"># 当前腐烂橘子的坐标</span></span><br><span class=\"line\">                x0 = rotorange[<span class=\"number\">0</span>]</span><br><span class=\"line\">                y0 = rotorange[<span class=\"number\">1</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">4</span>):  <span class=\"comment\"># 四个相邻方向的橘子腐烂</span></span><br><span class=\"line\">                    x = x0 + dx[i]</span><br><span class=\"line\">                    y = y0 + dy[i]</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> <span class=\"number\">0</span>&lt;=x&lt;len(grid) <span class=\"keyword\">and</span> <span class=\"number\">0</span>&lt;=y&lt;len(grid[<span class=\"number\">0</span>]) <span class=\"keyword\">and</span> grid[x][y]==<span class=\"number\">1</span>:</span><br><span class=\"line\">                        grid[x][y] = <span class=\"number\">2</span></span><br><span class=\"line\">                        newrotlist.append([x, y])</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> newrotlist:</span><br><span class=\"line\">                <span class=\"keyword\">break</span></span><br><span class=\"line\"></span><br><span class=\"line\">            minute += <span class=\"number\">1</span></span><br><span class=\"line\">            rotlist = newrotlist[:]     <span class=\"comment\"># 更新腐烂队列</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> row <span class=\"keyword\">in</span> grid:</span><br><span class=\"line\">                <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> row:</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> i == <span class=\"number\">1</span>:  <span class=\"comment\"># 还有新鲜的</span></span><br><span class=\"line\">                        <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> minute</span><br></pre></td></tr></table></figure>\n<h1 id=\"1305-两棵二叉搜索树中的所有元素\"><a href=\"#1305-两棵二叉搜索树中的所有元素\" class=\"headerlink\" title=\"1305. 两棵二叉搜索树中的所有元素\"></a>1305. 两棵二叉搜索树中的所有元素</h1><p><a href=\"https://leetcode-cn.com/problems/all-elements-in-two-binary-search-trees/\" target=\"_blank\" rel=\"noopener\">https://leetcode-cn.com/problems/all-elements-in-two-binary-search-trees/</a></p>\n<h2 id=\"题目描述-38\"><a href=\"#题目描述-38\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>给你 root1 和 root2 这两棵二叉搜索树。</p>\n<p>请你返回一个列表，其中包含 两棵树 中的所有整数并按 升序 排序。</p>\n<p>示例 1：</p>\n<p><img src=\"http://images.yingwai.top/picgo/lc1305f1.png\" alt=\"\"></p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：root1 = [<span class=\"number\">2</span>,<span class=\"number\">1</span>,<span class=\"number\">4</span>], root2 = [<span class=\"number\">1</span>,<span class=\"number\">0</span>,<span class=\"number\">3</span>]</span><br><span class=\"line\">输出：[<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>]</span><br></pre></td></tr></table></figure>\n<p>示例 2：</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：root1 = [<span class=\"number\">0</span>,<span class=\"number\">-10</span>,<span class=\"number\">10</span>], root2 = [<span class=\"number\">5</span>,<span class=\"number\">1</span>,<span class=\"number\">7</span>,<span class=\"number\">0</span>,<span class=\"number\">2</span>]</span><br><span class=\"line\">输出：[<span class=\"number\">-10</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">5</span>,<span class=\"number\">7</span>,<span class=\"number\">10</span>]</span><br></pre></td></tr></table></figure>\n<p>示例 3：</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：root1 = [], root2 = [<span class=\"number\">5</span>,<span class=\"number\">1</span>,<span class=\"number\">7</span>,<span class=\"number\">0</span>,<span class=\"number\">2</span>]</span><br><span class=\"line\">输出：[<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">5</span>,<span class=\"number\">7</span>]</span><br></pre></td></tr></table></figure>\n<p>示例 4：</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：root1 = [<span class=\"number\">0</span>,<span class=\"number\">-10</span>,<span class=\"number\">10</span>], root2 = []</span><br><span class=\"line\">输出：[<span class=\"number\">-10</span>,<span class=\"number\">0</span>,<span class=\"number\">10</span>]</span><br></pre></td></tr></table></figure>\n<p>示例 5：</p>\n<p><img src=\"http://images.yingwai.top/picgo/lc1305f2.png\" alt=\"\"></p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：root1 = [<span class=\"number\">1</span>,<span class=\"literal\">null</span>,<span class=\"number\">8</span>], root2 = [<span class=\"number\">8</span>,<span class=\"number\">1</span>]</span><br><span class=\"line\">输出：[<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">8</span>,<span class=\"number\">8</span>]</span><br></pre></td></tr></table></figure>\n<p>提示：</p>\n<ul>\n<li>每棵树最多有 <code>5000</code> 个节点。</li>\n<li>每个节点的值在 <code>[-10^5, 10^5]</code> 之间。</li>\n</ul>\n<h2 id=\"思路-38\"><a href=\"#思路-38\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>利用二叉搜索树性质，中序遍历得到每棵树的节点值的升序排列，然后再使用归并排序得到最终的结果数组。</p>\n<ul>\n<li>时间复杂度 $O(M + N)$，中序遍历和归并排序都是 $O(M + N)$，其中 $M,N$ 分别为两棵树的节点个数；</li>\n<li>空间复杂度 $O(M+N)$，用到两个额外的数组来存储每棵树的升序排列。</li>\n</ul>\n<h2 id=\"代码-38\"><a href=\"#代码-38\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">getAllElements</span><span class=\"params\">(self, root1: TreeNode, root2: TreeNode)</span> -&gt; List[int]:</span></span><br><span class=\"line\">        t1, t2 = [], []</span><br><span class=\"line\">        ans = []</span><br><span class=\"line\">        self.helper(root1, t1)</span><br><span class=\"line\">        self.helper(root2, t2)</span><br><span class=\"line\">        i, j = <span class=\"number\">0</span>, <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> i &lt; len(t1) <span class=\"keyword\">or</span> j &lt; len(t2):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> i &lt; len(t1) <span class=\"keyword\">and</span> (j == len(t2) <span class=\"keyword\">or</span> t1[i] &lt; t2[j]):</span><br><span class=\"line\">                ans.append(t1[i])</span><br><span class=\"line\">                i += <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                ans.append(t2[j])</span><br><span class=\"line\">                j += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">helper</span><span class=\"params\">(self, node, t)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> node: <span class=\"keyword\">return</span></span><br><span class=\"line\">        self.helper(node.left, t)</span><br><span class=\"line\">        t.append(node.val)</span><br><span class=\"line\">        self.helper(node.right, t)</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"面试题-16-11-跳水板\"><a href=\"#面试题-16-11-跳水板\" class=\"headerlink\" title=\"面试题 16.11. 跳水板\"></a>面试题 16.11. 跳水板</h1><p><a href=\"https://leetcode-cn.com/problems/diving-board-lcci/\" target=\"_blank\" rel=\"noopener\">https://leetcode-cn.com/problems/diving-board-lcci/</a></p>\n<h2 id=\"题目描述-39\"><a href=\"#题目描述-39\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>你正在使用一堆木板建造跳水板。有两种类型的木板，其中长度较短的木板长度为<code>shorter</code>，长度较长的木板长度为<code>longer</code>。你必须正好使用<code>k</code>块木板。编写一个方法，生成跳水板所有可能的长度。</p>\n<p>返回的长度需要从小到大排列。</p>\n<p>示例：</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：</span><br><span class=\"line\">shorter = <span class=\"number\">1</span></span><br><span class=\"line\">longer = <span class=\"number\">2</span></span><br><span class=\"line\">k = <span class=\"number\">3</span></span><br><span class=\"line\">输出： &#123;<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>&#125;</span><br></pre></td></tr></table></figure>\n<p>提示：</p>\n<ul>\n<li>0 &lt; shorter &lt;= longer</li>\n<li>0 &lt;= k &lt;= 100000</li>\n</ul>\n<h2 id=\"思路-39\"><a href=\"#思路-39\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>因为每次都必须要正好使用 <code>k</code> 块木板，所以有以下公式</p>\n<script type=\"math/tex; mode=display\">\nans[i] = shorter\\times i + longer \\times (k-i)</script><p>其中 $0 \\leq i \\leq k$。</p>\n<p>在 $longer &gt; shorter$ 的情况下，为什么每种组合下建造的跳水板长度都是不一样的？考虑以下两种不同的组合：第一种组合，有 $i$ 块短木板，则跳水板的长度是 $shorter \\times i + longer \\times (k−i)$；第二种组合，有 $j$ 块短木板，则跳水板的长度是 $shorter \\times j+longer \\times (k−j)$。其中 $0 \\leq i&lt;j \\leq k$。则两种不同的组合下的跳水板长度之差为：</p>\n<script type=\"math/tex; mode=display\">\n(shorter \\times j+longer \\times (k−j)) - (shorter \\times i + longer \\times (k−i)) = (longer - shorter) \\times (i - j)</script><p>因为 $longer &gt; shorter$ 且 $i&lt;j$，因此上式 $&lt;0$。</p>\n<p>然后要考虑到极端情况：</p>\n<ul>\n<li>$k = 0$：直接输出空列表。</li>\n<li>$longer = shorter$：输出列表中只有一个元素 $ans = [shorter(longer) \\times k]$。</li>\n</ul>\n<h2 id=\"代码-39\"><a href=\"#代码-39\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">divingBoard</span><span class=\"params\">(self, shorter: int, longer: int, k: int)</span> -&gt; List[int]:</span></span><br><span class=\"line\">        ans = []</span><br><span class=\"line\">        <span class=\"keyword\">if</span> k &gt; <span class=\"number\">0</span>:</span><br><span class=\"line\">            s, l = k, <span class=\"number\">0</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> shorter == longer:</span><br><span class=\"line\">                ans.append(shorter*s)</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                <span class=\"keyword\">while</span> l &lt;= k:</span><br><span class=\"line\">                    ans.append(shorter*s + longer*l)</span><br><span class=\"line\">                    s -= <span class=\"number\">1</span></span><br><span class=\"line\">                    l += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<h1 id=\"面试题-17-12-BiNode\"><a href=\"#面试题-17-12-BiNode\" class=\"headerlink\" title=\"面试题 17. 12. BiNode\"></a>面试题 17. 12. BiNode</h1><p><a href=\"https://leetcode-cn.com/problems/binode-lcci/\" target=\"_blank\" rel=\"noopener\">https://leetcode-cn.com/problems/binode-lcci/</a></p>\n<h2 id=\"题目描述-40\"><a href=\"#题目描述-40\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>二叉树数据结构 <code>TreeNode</code> 可用来表示单向链表（其中 <code>left</code> 置空，<code>right</code> 为下一个链表节点）。实现一个方法，把二叉搜索树转换为单向链表，要求依然符合二叉搜索树的性质，转换操作应是原址的，也就是在原始的二叉搜索树上直接修改。</p>\n<p>返回转换后的单向链表的头节点。</p>\n<p>注意：本题相对原题稍作改动</p>\n<p>示例：</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入： [<span class=\"number\">4</span>,<span class=\"number\">2</span>,<span class=\"number\">5</span>,<span class=\"number\">1</span>,<span class=\"number\">3</span>,<span class=\"literal\">null</span>,<span class=\"number\">6</span>,<span class=\"number\">0</span>]</span><br><span class=\"line\">输出： [<span class=\"number\">0</span>,<span class=\"literal\">null</span>,<span class=\"number\">1</span>,<span class=\"literal\">null</span>,<span class=\"number\">2</span>,<span class=\"literal\">null</span>,<span class=\"number\">3</span>,<span class=\"literal\">null</span>,<span class=\"number\">4</span>,<span class=\"literal\">null</span>,<span class=\"number\">5</span>,<span class=\"literal\">null</span>,<span class=\"number\">6</span>]</span><br></pre></td></tr></table></figure>\n<p>提示：</p>\n<ul>\n<li>节点数量不会超过 100000。</li>\n</ul>\n<h2 id=\"思路-40\"><a href=\"#思路-40\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>中序遍历，用 <code>pre</code> 记录上一个处理的节点，访问到一个新的节点 <code>p</code> 时，将 <code>pre.right</code> 指向 <code>p</code> 并把 <code>p.left</code> 置空。</p>\n<p>注意要将第一个处理的节点作为根节点。</p>\n<h2 id=\"代码-40\"><a href=\"#代码-40\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">convertBiNode</span><span class=\"params\">(self, root: TreeNode)</span> -&gt; TreeNode:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> root:</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">        s = []</span><br><span class=\"line\">        p, pre = root, <span class=\"literal\">None</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> s <span class=\"keyword\">or</span> p:</span><br><span class=\"line\">            <span class=\"keyword\">while</span> p:</span><br><span class=\"line\">                s.append(p)</span><br><span class=\"line\">                p = p.left</span><br><span class=\"line\">            p = s.pop()</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> pre:</span><br><span class=\"line\">                root = p</span><br><span class=\"line\">                root.left = <span class=\"literal\">None</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                pre.right = p</span><br><span class=\"line\">                p.left = <span class=\"literal\">None</span></span><br><span class=\"line\">            pre = p</span><br><span class=\"line\">            p = p.right</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root</span><br></pre></td></tr></table></figure>\n<h1 id=\"面试题-17-13-恢复空格\"><a href=\"#面试题-17-13-恢复空格\" class=\"headerlink\" title=\"面试题 17.13. 恢复空格\"></a>面试题 17.13. 恢复空格</h1><p><a href=\"https://leetcode-cn.com/problems/re-space-lcci/\" target=\"_blank\" rel=\"noopener\">https://leetcode-cn.com/problems/re-space-lcci/</a></p>\n<h2 id=\"题目描述-41\"><a href=\"#题目描述-41\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>哦，不！你不小心把一个长篇文章中的空格、标点都删掉了，并且大写也弄成了小写。像句子<code>&quot;I reset the computer. It still didn’t boot!&quot;</code>已经变成了<code>&quot;iresetthecomputeritstilldidntboot&quot;</code>。在处理标点符号和大小写之前，你得先把它断成词语。当然了，你有一本厚厚的词典<code>dictionary</code>，不过，有些词没在词典里。假设文章用<code>sentence</code>表示，设计一个算法，把文章断开，要求未识别的字符最少，返回未识别的字符数。</p>\n<p>注意：本题相对原题稍作改动，只需返回未识别的字符数</p>\n<p>示例：</p>\n<figure class=\"highlight smalltalk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：</span><br><span class=\"line\">dictionary = [<span class=\"comment\">\"looked\"</span>,<span class=\"comment\">\"just\"</span>,<span class=\"comment\">\"like\"</span>,<span class=\"comment\">\"her\"</span>,<span class=\"comment\">\"brother\"</span>]</span><br><span class=\"line\">sentence = <span class=\"comment\">\"jesslookedjustliketimherbrother\"</span></span><br><span class=\"line\">输出： <span class=\"number\">7</span></span><br><span class=\"line\">解释： 断句后为<span class=\"comment\">\"jess looked just like tim her brother\"</span>，共<span class=\"number\">7</span>个未识别字符。</span><br></pre></td></tr></table></figure>\n<p>提示：</p>\n<ul>\n<li><code>0 &lt;= len(sentence) &lt;= 1000</code></li>\n<li><code>dictionary</code>中总字符数不超过 <code>150000</code>。</li>\n<li>你可以认为<code>dictionary</code>和<code>sentence</code>中只包含小写字母。</li>\n</ul>\n<h2 id=\"思路-41\"><a href=\"#思路-41\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>动态规划，用 $dp[i]$ 表示<code>sentence</code>中以第 $index$ 个字符结尾的字符串中未识别的字符数，其中 $i = index + 1$（这里令 $dp[0]=0$，因为可能出现前 $k$ 个字符组成一个词，这样做利于判断）。对于每个 $index$，都对<code>dictionary</code>进行一次遍历，用 $len$ 表示<code>dictionary</code>中每个词的长度，则可以得到动态方程：</p>\n<p>每扫描到一个 $i$，都先把 $dp[i]$ 初始化为 $i$，然后有</p>\n<p>当<code>sentence</code>中第 $index - len + 1$ 到 第 $index$ 个字符在<code>dictionary</code>中时，</p>\n<script type=\"math/tex; mode=display\">\ndp[i] = \\min (dp[i],dp[i-len])</script><p>其它情况，</p>\n<script type=\"math/tex; mode=display\">\ndp[i] = (dp[i], dp[i-1]+1)</script><p>最后 $dp$ 数组中的最后一个元素即为结果。</p>\n<h2 id=\"代码-41\"><a href=\"#代码-41\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">respace</span><span class=\"params\">(self, dictionary: List[str], sentence: str)</span> -&gt; int:</span></span><br><span class=\"line\">        dp = []</span><br><span class=\"line\">        dp.append(<span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, len(sentence)+<span class=\"number\">1</span>):</span><br><span class=\"line\">            index = i - <span class=\"number\">1</span></span><br><span class=\"line\">            t = i</span><br><span class=\"line\">            <span class=\"keyword\">for</span> word <span class=\"keyword\">in</span> dictionary:</span><br><span class=\"line\">                l = len(word)</span><br><span class=\"line\">                <span class=\"keyword\">if</span> index + <span class=\"number\">1</span> - l &gt;= <span class=\"number\">0</span> <span class=\"keyword\">and</span> sentence[index-l+<span class=\"number\">1</span>:index+<span class=\"number\">1</span>] <span class=\"keyword\">in</span> dictionary:</span><br><span class=\"line\">                    t = min(t, dp[i-l])</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> i - l == <span class=\"number\">0</span>:</span><br><span class=\"line\">                        <span class=\"keyword\">break</span></span><br><span class=\"line\">                t = min(t, dp[i<span class=\"number\">-1</span>]+<span class=\"number\">1</span>)</span><br><span class=\"line\">            dp.append(t)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[len(sentence)]</span><br></pre></td></tr></table></figure>"},{"title":"Java接口、多态总结","date":"2020-08-23T16:08:43.000Z","_content":"\n----\n\n<!--more-->\n\n# 接口、多态总结\n\n## 接口\n\n接口是功能的集合，同样可看做是一种数据类型，是比抽象类更为抽象的”类”。\n接口只描述所应该具备的方法，并没有具体实现，具体的实现由接口的实现类(相当于接口的子类)来完成。这样将功能的定义与实现分离，优化了程序设计。\n请记住：一切事物均有功能，即一切事物均有接口。\n\n接口的出现避免了单继承的局限性。父类中定义的事物的基本功能。接口中定义的事物的扩展功能。\n\n\n\n### 接口的特点\n\n1. 定义一个接口用 `interface` 关键字：\n\n   ```java\n   public interface 接口名 {\n       抽象方法1;\n       抽象方法2;\n   }\n   ```\n\n2. 一个类实现一个接口，实现 `implements` 关键字：\n\n   ```java\n   class 类名 implements 接口名 {\n       \n   }\n   ```\n\n3. 接口不能直接创建对象\n\n   通过多态的方式，由子类来创建对象，接口多态。\n\n\n\n### 接口中的成员特点\n\n* 成员变量：\n\n  只能是 `final` 修饰的常量\n\n  默认修饰符：`public static final`\n\n* 构造方法：\n\n  无\n\n* 成员方法：\n\n  只能是抽象方法\n\n  默认修饰符：`public abstract`\n\n\n\n### 类与类、类与接口、接口与接口之间的关系\n\n* 类与类：\n\n  继承关系，单继承，可以是多层继承\n\n* 类与接口：\n\n  实现关系，单实现，也可以多实现（因为没有方法冲突的问题）\n\n* 接口与接口：\n\n  继承关系，单继承，也可以是多继承\n\nJava中的类可以继承一个父类的同时，实现多个接口\n\n\n\n## 多态\n\n多态是继封装、继承之后，面向对象的第三大特性。\n\n现实事物经常会体现出多种形态，如学生，学生是人的一种，则一个具体的同学张三既是学生也是人，即出现两种形态。\n\nJava作为面向对象的语言，同样可以描述一个事物的多种形态。如Student类继承了Person类，一个Student的对象便既是Student，又是Person。\n\nJava中多态的代码体现在一个子类对象(实现类对象)既可以给这个子类(实现类对象)引用变量赋值，又可以给这个子类(实现类对象)的父类(接口)变量赋值。\n\n如Student类可以为Person类的子类。那么一个Student对象既可以赋值给一个Student类型的引用，也可以赋值给一个Person类型的引用。\n\n最终多态体现为父类引用变量可以指向子类对象。\n\n多态的前提是必须有子父类关系或者类实现接口关系，否则无法完成多态。\n\n在使用多态后的父类引用变量调用方法时，会调用子类重写后的方法。\n\n\n\n### 多态使用的前提\n\n1. 有继承或者实现关系\n2. 要方法重写\n3. 父类引用指向子类对象\n\n\n\n### 多态的成员访问特点\n\n方法的运行看右边（子类），其它都看左边（父类）。\n\n\n\n### 多态的利弊\n\n好处：提高了程序的扩展性\n\n弊端：不能访问子类特有的功能\n\n\n\n### 多态的分类\n\n* 类的多态\n\n  ```java\n  abstract class Fu {\n      public abstract void method();\n  }\n  class Zi extends Fu {\n  \tpublic void method(){\n  \t\tSystem.out.println(“重写父类抽象方法”);\n  \t}\n  }\n  //类的多态使用\n  Fu fu= new Zi();\n  ```\n\n* 接口的多态\n\n  ```java\n  interface Fu {\n  \tpublic abstract void method();\n  }\n  class Zi implements Fu {\n  \tpublic void method(){\n          System.out.println(“重写接口抽象方法”);\n  }\n  }\n  //接口的多态使用\n  Fu fu = new Zi();\n  ```\n\n\n\n## `instanceof` 关键字\n\n格式：`对象名 instanceof 类名`\n\n返回值：`true, false`\n\n作用：判断指定的对象是否为给定类创建的对象\n\n","source":"_posts/Java接口、多态总结.md","raw":"---\ntitle: Java接口、多态总结\ndate: 2020-08-24 00:08:43\ncategories: Coding\ntags: Java\n---\n\n----\n\n<!--more-->\n\n# 接口、多态总结\n\n## 接口\n\n接口是功能的集合，同样可看做是一种数据类型，是比抽象类更为抽象的”类”。\n接口只描述所应该具备的方法，并没有具体实现，具体的实现由接口的实现类(相当于接口的子类)来完成。这样将功能的定义与实现分离，优化了程序设计。\n请记住：一切事物均有功能，即一切事物均有接口。\n\n接口的出现避免了单继承的局限性。父类中定义的事物的基本功能。接口中定义的事物的扩展功能。\n\n\n\n### 接口的特点\n\n1. 定义一个接口用 `interface` 关键字：\n\n   ```java\n   public interface 接口名 {\n       抽象方法1;\n       抽象方法2;\n   }\n   ```\n\n2. 一个类实现一个接口，实现 `implements` 关键字：\n\n   ```java\n   class 类名 implements 接口名 {\n       \n   }\n   ```\n\n3. 接口不能直接创建对象\n\n   通过多态的方式，由子类来创建对象，接口多态。\n\n\n\n### 接口中的成员特点\n\n* 成员变量：\n\n  只能是 `final` 修饰的常量\n\n  默认修饰符：`public static final`\n\n* 构造方法：\n\n  无\n\n* 成员方法：\n\n  只能是抽象方法\n\n  默认修饰符：`public abstract`\n\n\n\n### 类与类、类与接口、接口与接口之间的关系\n\n* 类与类：\n\n  继承关系，单继承，可以是多层继承\n\n* 类与接口：\n\n  实现关系，单实现，也可以多实现（因为没有方法冲突的问题）\n\n* 接口与接口：\n\n  继承关系，单继承，也可以是多继承\n\nJava中的类可以继承一个父类的同时，实现多个接口\n\n\n\n## 多态\n\n多态是继封装、继承之后，面向对象的第三大特性。\n\n现实事物经常会体现出多种形态，如学生，学生是人的一种，则一个具体的同学张三既是学生也是人，即出现两种形态。\n\nJava作为面向对象的语言，同样可以描述一个事物的多种形态。如Student类继承了Person类，一个Student的对象便既是Student，又是Person。\n\nJava中多态的代码体现在一个子类对象(实现类对象)既可以给这个子类(实现类对象)引用变量赋值，又可以给这个子类(实现类对象)的父类(接口)变量赋值。\n\n如Student类可以为Person类的子类。那么一个Student对象既可以赋值给一个Student类型的引用，也可以赋值给一个Person类型的引用。\n\n最终多态体现为父类引用变量可以指向子类对象。\n\n多态的前提是必须有子父类关系或者类实现接口关系，否则无法完成多态。\n\n在使用多态后的父类引用变量调用方法时，会调用子类重写后的方法。\n\n\n\n### 多态使用的前提\n\n1. 有继承或者实现关系\n2. 要方法重写\n3. 父类引用指向子类对象\n\n\n\n### 多态的成员访问特点\n\n方法的运行看右边（子类），其它都看左边（父类）。\n\n\n\n### 多态的利弊\n\n好处：提高了程序的扩展性\n\n弊端：不能访问子类特有的功能\n\n\n\n### 多态的分类\n\n* 类的多态\n\n  ```java\n  abstract class Fu {\n      public abstract void method();\n  }\n  class Zi extends Fu {\n  \tpublic void method(){\n  \t\tSystem.out.println(“重写父类抽象方法”);\n  \t}\n  }\n  //类的多态使用\n  Fu fu= new Zi();\n  ```\n\n* 接口的多态\n\n  ```java\n  interface Fu {\n  \tpublic abstract void method();\n  }\n  class Zi implements Fu {\n  \tpublic void method(){\n          System.out.println(“重写接口抽象方法”);\n  }\n  }\n  //接口的多态使用\n  Fu fu = new Zi();\n  ```\n\n\n\n## `instanceof` 关键字\n\n格式：`对象名 instanceof 类名`\n\n返回值：`true, false`\n\n作用：判断指定的对象是否为给定类创建的对象\n\n","slug":"Java接口、多态总结","published":1,"updated":"2020-08-23T16:09:24.087Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cke7ahvf00000lgpsd6pl3s7m","content":"<hr>\n<a id=\"more\"></a>\n<h1 id=\"接口、多态总结\"><a href=\"#接口、多态总结\" class=\"headerlink\" title=\"接口、多态总结\"></a>接口、多态总结</h1><h2 id=\"接口\"><a href=\"#接口\" class=\"headerlink\" title=\"接口\"></a>接口</h2><p>接口是功能的集合，同样可看做是一种数据类型，是比抽象类更为抽象的”类”。<br>接口只描述所应该具备的方法，并没有具体实现，具体的实现由接口的实现类(相当于接口的子类)来完成。这样将功能的定义与实现分离，优化了程序设计。<br>请记住：一切事物均有功能，即一切事物均有接口。</p>\n<p>接口的出现避免了单继承的局限性。父类中定义的事物的基本功能。接口中定义的事物的扩展功能。</p>\n<h3 id=\"接口的特点\"><a href=\"#接口的特点\" class=\"headerlink\" title=\"接口的特点\"></a>接口的特点</h3><ol>\n<li><p>定义一个接口用 <code>interface</code> 关键字：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> 接口名 </span>&#123;</span><br><span class=\"line\">    抽象方法<span class=\"number\">1</span>;</span><br><span class=\"line\">    抽象方法<span class=\"number\">2</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>一个类实现一个接口，实现 <code>implements</code> 关键字：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> 类名 <span class=\"keyword\">implements</span> 接口名 </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>接口不能直接创建对象</p>\n<p>通过多态的方式，由子类来创建对象，接口多态。</p>\n</li>\n</ol>\n<h3 id=\"接口中的成员特点\"><a href=\"#接口中的成员特点\" class=\"headerlink\" title=\"接口中的成员特点\"></a>接口中的成员特点</h3><ul>\n<li><p>成员变量：</p>\n<p>只能是 <code>final</code> 修饰的常量</p>\n<p>默认修饰符：<code>public static final</code></p>\n</li>\n<li><p>构造方法：</p>\n<p>无</p>\n</li>\n<li><p>成员方法：</p>\n<p>只能是抽象方法</p>\n<p>默认修饰符：<code>public abstract</code></p>\n</li>\n</ul>\n<h3 id=\"类与类、类与接口、接口与接口之间的关系\"><a href=\"#类与类、类与接口、接口与接口之间的关系\" class=\"headerlink\" title=\"类与类、类与接口、接口与接口之间的关系\"></a>类与类、类与接口、接口与接口之间的关系</h3><ul>\n<li><p>类与类：</p>\n<p>继承关系，单继承，可以是多层继承</p>\n</li>\n<li><p>类与接口：</p>\n<p>实现关系，单实现，也可以多实现（因为没有方法冲突的问题）</p>\n</li>\n<li><p>接口与接口：</p>\n<p>继承关系，单继承，也可以是多继承</p>\n</li>\n</ul>\n<p>Java中的类可以继承一个父类的同时，实现多个接口</p>\n<h2 id=\"多态\"><a href=\"#多态\" class=\"headerlink\" title=\"多态\"></a>多态</h2><p>多态是继封装、继承之后，面向对象的第三大特性。</p>\n<p>现实事物经常会体现出多种形态，如学生，学生是人的一种，则一个具体的同学张三既是学生也是人，即出现两种形态。</p>\n<p>Java作为面向对象的语言，同样可以描述一个事物的多种形态。如Student类继承了Person类，一个Student的对象便既是Student，又是Person。</p>\n<p>Java中多态的代码体现在一个子类对象(实现类对象)既可以给这个子类(实现类对象)引用变量赋值，又可以给这个子类(实现类对象)的父类(接口)变量赋值。</p>\n<p>如Student类可以为Person类的子类。那么一个Student对象既可以赋值给一个Student类型的引用，也可以赋值给一个Person类型的引用。</p>\n<p>最终多态体现为父类引用变量可以指向子类对象。</p>\n<p>多态的前提是必须有子父类关系或者类实现接口关系，否则无法完成多态。</p>\n<p>在使用多态后的父类引用变量调用方法时，会调用子类重写后的方法。</p>\n<h3 id=\"多态使用的前提\"><a href=\"#多态使用的前提\" class=\"headerlink\" title=\"多态使用的前提\"></a>多态使用的前提</h3><ol>\n<li>有继承或者实现关系</li>\n<li>要方法重写</li>\n<li>父类引用指向子类对象</li>\n</ol>\n<h3 id=\"多态的成员访问特点\"><a href=\"#多态的成员访问特点\" class=\"headerlink\" title=\"多态的成员访问特点\"></a>多态的成员访问特点</h3><p>方法的运行看右边（子类），其它都看左边（父类）。</p>\n<h3 id=\"多态的利弊\"><a href=\"#多态的利弊\" class=\"headerlink\" title=\"多态的利弊\"></a>多态的利弊</h3><p>好处：提高了程序的扩展性</p>\n<p>弊端：不能访问子类特有的功能</p>\n<h3 id=\"多态的分类\"><a href=\"#多态的分类\" class=\"headerlink\" title=\"多态的分类\"></a>多态的分类</h3><ul>\n<li><p>类的多态</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Fu</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">method</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Zi</span> <span class=\"keyword\">extends</span> <span class=\"title\">Fu</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">method</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(“重写父类抽象方法”);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//类的多态使用</span></span><br><span class=\"line\">Fu fu= <span class=\"keyword\">new</span> Zi();</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>接口的多态</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Fu</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">method</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Zi</span> <span class=\"keyword\">implements</span> <span class=\"title\">Fu</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">method</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        System.out.println(“重写接口抽象方法”);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//接口的多态使用</span></span><br><span class=\"line\">Fu fu = <span class=\"keyword\">new</span> Zi();</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"instanceof-关键字\"><a href=\"#instanceof-关键字\" class=\"headerlink\" title=\"instanceof 关键字\"></a><code>instanceof</code> 关键字</h2><p>格式：<code>对象名 instanceof 类名</code></p>\n<p>返回值：<code>true, false</code></p>\n<p>作用：判断指定的对象是否为给定类创建的对象</p>\n","site":{"data":{}},"excerpt":"<hr>","more":"<h1 id=\"接口、多态总结\"><a href=\"#接口、多态总结\" class=\"headerlink\" title=\"接口、多态总结\"></a>接口、多态总结</h1><h2 id=\"接口\"><a href=\"#接口\" class=\"headerlink\" title=\"接口\"></a>接口</h2><p>接口是功能的集合，同样可看做是一种数据类型，是比抽象类更为抽象的”类”。<br>接口只描述所应该具备的方法，并没有具体实现，具体的实现由接口的实现类(相当于接口的子类)来完成。这样将功能的定义与实现分离，优化了程序设计。<br>请记住：一切事物均有功能，即一切事物均有接口。</p>\n<p>接口的出现避免了单继承的局限性。父类中定义的事物的基本功能。接口中定义的事物的扩展功能。</p>\n<h3 id=\"接口的特点\"><a href=\"#接口的特点\" class=\"headerlink\" title=\"接口的特点\"></a>接口的特点</h3><ol>\n<li><p>定义一个接口用 <code>interface</code> 关键字：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> 接口名 </span>&#123;</span><br><span class=\"line\">    抽象方法<span class=\"number\">1</span>;</span><br><span class=\"line\">    抽象方法<span class=\"number\">2</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>一个类实现一个接口，实现 <code>implements</code> 关键字：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> 类名 <span class=\"keyword\">implements</span> 接口名 </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>接口不能直接创建对象</p>\n<p>通过多态的方式，由子类来创建对象，接口多态。</p>\n</li>\n</ol>\n<h3 id=\"接口中的成员特点\"><a href=\"#接口中的成员特点\" class=\"headerlink\" title=\"接口中的成员特点\"></a>接口中的成员特点</h3><ul>\n<li><p>成员变量：</p>\n<p>只能是 <code>final</code> 修饰的常量</p>\n<p>默认修饰符：<code>public static final</code></p>\n</li>\n<li><p>构造方法：</p>\n<p>无</p>\n</li>\n<li><p>成员方法：</p>\n<p>只能是抽象方法</p>\n<p>默认修饰符：<code>public abstract</code></p>\n</li>\n</ul>\n<h3 id=\"类与类、类与接口、接口与接口之间的关系\"><a href=\"#类与类、类与接口、接口与接口之间的关系\" class=\"headerlink\" title=\"类与类、类与接口、接口与接口之间的关系\"></a>类与类、类与接口、接口与接口之间的关系</h3><ul>\n<li><p>类与类：</p>\n<p>继承关系，单继承，可以是多层继承</p>\n</li>\n<li><p>类与接口：</p>\n<p>实现关系，单实现，也可以多实现（因为没有方法冲突的问题）</p>\n</li>\n<li><p>接口与接口：</p>\n<p>继承关系，单继承，也可以是多继承</p>\n</li>\n</ul>\n<p>Java中的类可以继承一个父类的同时，实现多个接口</p>\n<h2 id=\"多态\"><a href=\"#多态\" class=\"headerlink\" title=\"多态\"></a>多态</h2><p>多态是继封装、继承之后，面向对象的第三大特性。</p>\n<p>现实事物经常会体现出多种形态，如学生，学生是人的一种，则一个具体的同学张三既是学生也是人，即出现两种形态。</p>\n<p>Java作为面向对象的语言，同样可以描述一个事物的多种形态。如Student类继承了Person类，一个Student的对象便既是Student，又是Person。</p>\n<p>Java中多态的代码体现在一个子类对象(实现类对象)既可以给这个子类(实现类对象)引用变量赋值，又可以给这个子类(实现类对象)的父类(接口)变量赋值。</p>\n<p>如Student类可以为Person类的子类。那么一个Student对象既可以赋值给一个Student类型的引用，也可以赋值给一个Person类型的引用。</p>\n<p>最终多态体现为父类引用变量可以指向子类对象。</p>\n<p>多态的前提是必须有子父类关系或者类实现接口关系，否则无法完成多态。</p>\n<p>在使用多态后的父类引用变量调用方法时，会调用子类重写后的方法。</p>\n<h3 id=\"多态使用的前提\"><a href=\"#多态使用的前提\" class=\"headerlink\" title=\"多态使用的前提\"></a>多态使用的前提</h3><ol>\n<li>有继承或者实现关系</li>\n<li>要方法重写</li>\n<li>父类引用指向子类对象</li>\n</ol>\n<h3 id=\"多态的成员访问特点\"><a href=\"#多态的成员访问特点\" class=\"headerlink\" title=\"多态的成员访问特点\"></a>多态的成员访问特点</h3><p>方法的运行看右边（子类），其它都看左边（父类）。</p>\n<h3 id=\"多态的利弊\"><a href=\"#多态的利弊\" class=\"headerlink\" title=\"多态的利弊\"></a>多态的利弊</h3><p>好处：提高了程序的扩展性</p>\n<p>弊端：不能访问子类特有的功能</p>\n<h3 id=\"多态的分类\"><a href=\"#多态的分类\" class=\"headerlink\" title=\"多态的分类\"></a>多态的分类</h3><ul>\n<li><p>类的多态</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Fu</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">method</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Zi</span> <span class=\"keyword\">extends</span> <span class=\"title\">Fu</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">method</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(“重写父类抽象方法”);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//类的多态使用</span></span><br><span class=\"line\">Fu fu= <span class=\"keyword\">new</span> Zi();</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>接口的多态</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Fu</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">method</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Zi</span> <span class=\"keyword\">implements</span> <span class=\"title\">Fu</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">method</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        System.out.println(“重写接口抽象方法”);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//接口的多态使用</span></span><br><span class=\"line\">Fu fu = <span class=\"keyword\">new</span> Zi();</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"instanceof-关键字\"><a href=\"#instanceof-关键字\" class=\"headerlink\" title=\"instanceof 关键字\"></a><code>instanceof</code> 关键字</h2><p>格式：<code>对象名 instanceof 类名</code></p>\n<p>返回值：<code>true, false</code></p>\n<p>作用：判断指定的对象是否为给定类创建的对象</p>"},{"title":"Java构造方法总结","date":"2020-08-23T16:09:49.000Z","_content":"\n----\n\n<!--more-->\n\n# 构造方法总结\n\n## `this` 关键字\n\n`this` 关键字，本类对象的引用\n\n* `this` 是在方法中使用的，哪个对象调用了该方法，那么 `this` 就代表调用该方法的对象引用\n\n* `this` 什么时候存在的？当创建对象的时候，`this` 存在的\n\n* `this` 的作用：用来区别同名的成员变量与局部变量（`this.成员变量`）\n\n  ```java\n  public void setName(String name) {\n      this.name = name;\n  }\n  ```\n\n\n\n## 构造方法\n\n用来给类的成员进行初始化操作\n\n* 格式：\n\n  ```java\n  修饰符 类名 (参数列表) {\n      ...\n  }\n  ```\n\n* 构造方法的特点：\n\n  1. 方法名与类名想同\n  2. 没有返回值，也没有返回值类型，连 `void` 也没有\n\n* 构造方法什么时候会被调用执行？\n\n  只有在创建对象的时候才可以被调用\n\n\n\n## `super` 关键字\n\n指的是父类的存储空间（理解为父类的引用）\n\n* 调用父类的成员变量：\n\n  `super.成员变量;`\n\n* 调用父类的构造方法：\n\n  `super(参数);`\n\n* 调用方法的成员方法：\n\n  `super.成员方法();`\n\n\n\n## 继承中的构造方法注意事项\n\n1. 如果我们手动给出了构造方法，编译器不会再给我们提供默认的空参数构造方法；\n\n   如果我们没有写任何的构造方法，编译器提供给我们一个空参数构造方法\n\n2. 在构造方法中，默认的第一条语句为 `super();`\n\n   它是用来访问父类中的空参数构造方法，进行父类成员的初始化操作\n\n3. 当父类中没有空参数构造方法的时候，怎么办？\n\n   * 通过 `super(参数);` 访问父类有参数的构造方法\n\n   * 通过 `this(参数);` 访问本类中其他构造方法\n\n     注意：*本类中的其他构造方法已经能够正常访问父类构造方法*\n\n4. `super(参数);` 与 `this(参数);` 不能同时在构造方法中存在","source":"_posts/Java构造方法总结.md","raw":"---\ntitle: Java构造方法总结\ndate: 2020-08-24 00:09:49\ncategories: Coding\ntags: Java\n---\n\n----\n\n<!--more-->\n\n# 构造方法总结\n\n## `this` 关键字\n\n`this` 关键字，本类对象的引用\n\n* `this` 是在方法中使用的，哪个对象调用了该方法，那么 `this` 就代表调用该方法的对象引用\n\n* `this` 什么时候存在的？当创建对象的时候，`this` 存在的\n\n* `this` 的作用：用来区别同名的成员变量与局部变量（`this.成员变量`）\n\n  ```java\n  public void setName(String name) {\n      this.name = name;\n  }\n  ```\n\n\n\n## 构造方法\n\n用来给类的成员进行初始化操作\n\n* 格式：\n\n  ```java\n  修饰符 类名 (参数列表) {\n      ...\n  }\n  ```\n\n* 构造方法的特点：\n\n  1. 方法名与类名想同\n  2. 没有返回值，也没有返回值类型，连 `void` 也没有\n\n* 构造方法什么时候会被调用执行？\n\n  只有在创建对象的时候才可以被调用\n\n\n\n## `super` 关键字\n\n指的是父类的存储空间（理解为父类的引用）\n\n* 调用父类的成员变量：\n\n  `super.成员变量;`\n\n* 调用父类的构造方法：\n\n  `super(参数);`\n\n* 调用方法的成员方法：\n\n  `super.成员方法();`\n\n\n\n## 继承中的构造方法注意事项\n\n1. 如果我们手动给出了构造方法，编译器不会再给我们提供默认的空参数构造方法；\n\n   如果我们没有写任何的构造方法，编译器提供给我们一个空参数构造方法\n\n2. 在构造方法中，默认的第一条语句为 `super();`\n\n   它是用来访问父类中的空参数构造方法，进行父类成员的初始化操作\n\n3. 当父类中没有空参数构造方法的时候，怎么办？\n\n   * 通过 `super(参数);` 访问父类有参数的构造方法\n\n   * 通过 `this(参数);` 访问本类中其他构造方法\n\n     注意：*本类中的其他构造方法已经能够正常访问父类构造方法*\n\n4. `super(参数);` 与 `this(参数);` 不能同时在构造方法中存在","slug":"Java构造方法总结","published":1,"updated":"2020-08-23T16:10:36.191Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cke7ahvf40001lgps2ll957lt","content":"<hr>\n<a id=\"more\"></a>\n<h1 id=\"构造方法总结\"><a href=\"#构造方法总结\" class=\"headerlink\" title=\"构造方法总结\"></a>构造方法总结</h1><h2 id=\"this-关键字\"><a href=\"#this-关键字\" class=\"headerlink\" title=\"this 关键字\"></a><code>this</code> 关键字</h2><p><code>this</code> 关键字，本类对象的引用</p>\n<ul>\n<li><p><code>this</code> 是在方法中使用的，哪个对象调用了该方法，那么 <code>this</code> 就代表调用该方法的对象引用</p>\n</li>\n<li><p><code>this</code> 什么时候存在的？当创建对象的时候，<code>this</code> 存在的</p>\n</li>\n<li><p><code>this</code> 的作用：用来区别同名的成员变量与局部变量（<code>this.成员变量</code>）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setName</span><span class=\"params\">(String name)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"构造方法\"><a href=\"#构造方法\" class=\"headerlink\" title=\"构造方法\"></a>构造方法</h2><p>用来给类的成员进行初始化操作</p>\n<ul>\n<li><p>格式：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">修饰符 类名 (参数列表) &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>构造方法的特点：</p>\n<ol>\n<li>方法名与类名想同</li>\n<li>没有返回值，也没有返回值类型，连 <code>void</code> 也没有</li>\n</ol>\n</li>\n<li><p>构造方法什么时候会被调用执行？</p>\n<p>只有在创建对象的时候才可以被调用</p>\n</li>\n</ul>\n<h2 id=\"super-关键字\"><a href=\"#super-关键字\" class=\"headerlink\" title=\"super 关键字\"></a><code>super</code> 关键字</h2><p>指的是父类的存储空间（理解为父类的引用）</p>\n<ul>\n<li><p>调用父类的成员变量：</p>\n<p><code>super.成员变量;</code></p>\n</li>\n<li><p>调用父类的构造方法：</p>\n<p><code>super(参数);</code></p>\n</li>\n<li><p>调用方法的成员方法：</p>\n<p><code>super.成员方法();</code></p>\n</li>\n</ul>\n<h2 id=\"继承中的构造方法注意事项\"><a href=\"#继承中的构造方法注意事项\" class=\"headerlink\" title=\"继承中的构造方法注意事项\"></a>继承中的构造方法注意事项</h2><ol>\n<li><p>如果我们手动给出了构造方法，编译器不会再给我们提供默认的空参数构造方法；</p>\n<p>如果我们没有写任何的构造方法，编译器提供给我们一个空参数构造方法</p>\n</li>\n<li><p>在构造方法中，默认的第一条语句为 <code>super();</code></p>\n<p>它是用来访问父类中的空参数构造方法，进行父类成员的初始化操作</p>\n</li>\n<li><p>当父类中没有空参数构造方法的时候，怎么办？</p>\n<ul>\n<li><p>通过 <code>super(参数);</code> 访问父类有参数的构造方法</p>\n</li>\n<li><p>通过 <code>this(参数);</code> 访问本类中其他构造方法</p>\n<p>注意：<em>本类中的其他构造方法已经能够正常访问父类构造方法</em></p>\n</li>\n</ul>\n</li>\n<li><p><code>super(参数);</code> 与 <code>this(参数);</code> 不能同时在构造方法中存在</p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"<hr>","more":"<h1 id=\"构造方法总结\"><a href=\"#构造方法总结\" class=\"headerlink\" title=\"构造方法总结\"></a>构造方法总结</h1><h2 id=\"this-关键字\"><a href=\"#this-关键字\" class=\"headerlink\" title=\"this 关键字\"></a><code>this</code> 关键字</h2><p><code>this</code> 关键字，本类对象的引用</p>\n<ul>\n<li><p><code>this</code> 是在方法中使用的，哪个对象调用了该方法，那么 <code>this</code> 就代表调用该方法的对象引用</p>\n</li>\n<li><p><code>this</code> 什么时候存在的？当创建对象的时候，<code>this</code> 存在的</p>\n</li>\n<li><p><code>this</code> 的作用：用来区别同名的成员变量与局部变量（<code>this.成员变量</code>）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setName</span><span class=\"params\">(String name)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"构造方法\"><a href=\"#构造方法\" class=\"headerlink\" title=\"构造方法\"></a>构造方法</h2><p>用来给类的成员进行初始化操作</p>\n<ul>\n<li><p>格式：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">修饰符 类名 (参数列表) &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>构造方法的特点：</p>\n<ol>\n<li>方法名与类名想同</li>\n<li>没有返回值，也没有返回值类型，连 <code>void</code> 也没有</li>\n</ol>\n</li>\n<li><p>构造方法什么时候会被调用执行？</p>\n<p>只有在创建对象的时候才可以被调用</p>\n</li>\n</ul>\n<h2 id=\"super-关键字\"><a href=\"#super-关键字\" class=\"headerlink\" title=\"super 关键字\"></a><code>super</code> 关键字</h2><p>指的是父类的存储空间（理解为父类的引用）</p>\n<ul>\n<li><p>调用父类的成员变量：</p>\n<p><code>super.成员变量;</code></p>\n</li>\n<li><p>调用父类的构造方法：</p>\n<p><code>super(参数);</code></p>\n</li>\n<li><p>调用方法的成员方法：</p>\n<p><code>super.成员方法();</code></p>\n</li>\n</ul>\n<h2 id=\"继承中的构造方法注意事项\"><a href=\"#继承中的构造方法注意事项\" class=\"headerlink\" title=\"继承中的构造方法注意事项\"></a>继承中的构造方法注意事项</h2><ol>\n<li><p>如果我们手动给出了构造方法，编译器不会再给我们提供默认的空参数构造方法；</p>\n<p>如果我们没有写任何的构造方法，编译器提供给我们一个空参数构造方法</p>\n</li>\n<li><p>在构造方法中，默认的第一条语句为 <code>super();</code></p>\n<p>它是用来访问父类中的空参数构造方法，进行父类成员的初始化操作</p>\n</li>\n<li><p>当父类中没有空参数构造方法的时候，怎么办？</p>\n<ul>\n<li><p>通过 <code>super(参数);</code> 访问父类有参数的构造方法</p>\n</li>\n<li><p>通过 <code>this(参数);</code> 访问本类中其他构造方法</p>\n<p>注意：<em>本类中的其他构造方法已经能够正常访问父类构造方法</em></p>\n</li>\n</ul>\n</li>\n<li><p><code>super(参数);</code> 与 <code>this(参数);</code> 不能同时在构造方法中存在</p>\n</li>\n</ol>"},{"title":"Java继承、抽象总结","date":"2020-08-23T16:06:13.000Z","_content":"\n----\n\n<!--more-->\n\n# 继承\n\n* 继承：是指在一个现有类的基础上去构建一个新的类，构建出来的新类被称作子类，现有类被称作父类，子类会自动拥有父类所有。\n\n* 继承的好处：可继承的属性和方法。\n\n  * 提高了代表的可维护性\n  * 提高了代码的复用性\n  * 让类与类之间产生了继承关系\n\n* 继承的弊端：\n\n  * 类与类之间的耦合度过高\n\n* 继承特点：\n\n  * java中类只能够单继承，不能多继承，可以多层继承\n\n    ```java\n    class Yy extends Object {}\n    \n    class Fu extends Yy{}\n    \n    class Zi extends Fu {}\n    ```\n\n    所有的类都直接或者间接的继承了 Object类，Object类称为祖宗类\n\n* 继承的注意事项：\n\n  1. 使用关键字 `extends` 让类与类之间 产生继承关系\n\n  2. 父类私有的成员，子类不能继承，因为根本看不到\n\n  3. 不能为了继承某个功能而随意进行继承操作， 必须要符合 is a 的关系\n\n     苹果 is a 水果\n\n     男人 is a 人\n\n     狗  is a 人 ， 这种情况就不能继承了\n\n* 继承中的成员变量关系：\n\n  * 不同名的变量：\n\n    子类直接继承使用\n\n  * 同名的变量：\n\n    默认访问的是子类自己的成员变量, 想访问父类中的同名变量，请使用 `super.成员变量;`\n\n* 继承中的成员方法关系：\n\n  * 不同名的方法：\n\n    子类直接继承使用\n\n  * 同名的方法：\n\n    默认访问的是子类自己的成员方法，想访问父类中的同名方法，请使用 super.成员方法();\n\n\n\n* super:用来表示当前对象中包含的父类对象空间的引用\n\n  * 调用父类的成员变量：\n\n    `super.成员变量;`\n\n  * 调用方法的成员方法:\n\n    `super.成员方法();`\n\n* 方法重写(override)：指在子父类中，出现了方法声明相同的情况，也叫做方法覆盖，方法复写\n\n  * 方法重写的注意事项：\n    1. 子类的方法声明要与父类相同\n    2. 子类要重写方法的方法，方法的权限修饰符不能比父类的更低\n    3. 父类私有的方法，子类不能够进行方法重写\n\n* 方法重载(overload)：指 在同一个类中，多个方法名称相同，它们的参数列表不同(个数不同，数据类型不同)\n\n\n\n# 抽象\n\n* 抽象方法： 方法只有声明部分，没有方法体\n\n* 抽象类： 包含抽象方法的类，一定是抽象类\n\n  使用 `abstract` 修饰的类，是抽象类\n\n* 抽象类的特点：\n\n  1. 抽象类与抽象方法都必须使用 `abstract` 来修饰\n  2. 抽象类不能直接创建对象\n  3. 抽象类中可以有抽象方法，也可以没有抽象方法\n  4. 抽象类的子类\n     * 实现了抽象方法的具体类\n     * 抽象类\n\n* 抽象类面试题：\n\n  1. 抽象类中是否可以没有抽象方法？如果可以，那么，该类还定义成抽象类有意义吗？为什么？\n  2. 可以没有抽象方法，有意义，不会让其他人直接创建该类对象","source":"_posts/Java继承、抽象总结.md","raw":"---\ntitle: Java继承、抽象总结\ndate: 2020-08-24 00:06:13\ncategories: Coding\ntags: [Java, 面向对象]\n---\n\n----\n\n<!--more-->\n\n# 继承\n\n* 继承：是指在一个现有类的基础上去构建一个新的类，构建出来的新类被称作子类，现有类被称作父类，子类会自动拥有父类所有。\n\n* 继承的好处：可继承的属性和方法。\n\n  * 提高了代表的可维护性\n  * 提高了代码的复用性\n  * 让类与类之间产生了继承关系\n\n* 继承的弊端：\n\n  * 类与类之间的耦合度过高\n\n* 继承特点：\n\n  * java中类只能够单继承，不能多继承，可以多层继承\n\n    ```java\n    class Yy extends Object {}\n    \n    class Fu extends Yy{}\n    \n    class Zi extends Fu {}\n    ```\n\n    所有的类都直接或者间接的继承了 Object类，Object类称为祖宗类\n\n* 继承的注意事项：\n\n  1. 使用关键字 `extends` 让类与类之间 产生继承关系\n\n  2. 父类私有的成员，子类不能继承，因为根本看不到\n\n  3. 不能为了继承某个功能而随意进行继承操作， 必须要符合 is a 的关系\n\n     苹果 is a 水果\n\n     男人 is a 人\n\n     狗  is a 人 ， 这种情况就不能继承了\n\n* 继承中的成员变量关系：\n\n  * 不同名的变量：\n\n    子类直接继承使用\n\n  * 同名的变量：\n\n    默认访问的是子类自己的成员变量, 想访问父类中的同名变量，请使用 `super.成员变量;`\n\n* 继承中的成员方法关系：\n\n  * 不同名的方法：\n\n    子类直接继承使用\n\n  * 同名的方法：\n\n    默认访问的是子类自己的成员方法，想访问父类中的同名方法，请使用 super.成员方法();\n\n\n\n* super:用来表示当前对象中包含的父类对象空间的引用\n\n  * 调用父类的成员变量：\n\n    `super.成员变量;`\n\n  * 调用方法的成员方法:\n\n    `super.成员方法();`\n\n* 方法重写(override)：指在子父类中，出现了方法声明相同的情况，也叫做方法覆盖，方法复写\n\n  * 方法重写的注意事项：\n    1. 子类的方法声明要与父类相同\n    2. 子类要重写方法的方法，方法的权限修饰符不能比父类的更低\n    3. 父类私有的方法，子类不能够进行方法重写\n\n* 方法重载(overload)：指 在同一个类中，多个方法名称相同，它们的参数列表不同(个数不同，数据类型不同)\n\n\n\n# 抽象\n\n* 抽象方法： 方法只有声明部分，没有方法体\n\n* 抽象类： 包含抽象方法的类，一定是抽象类\n\n  使用 `abstract` 修饰的类，是抽象类\n\n* 抽象类的特点：\n\n  1. 抽象类与抽象方法都必须使用 `abstract` 来修饰\n  2. 抽象类不能直接创建对象\n  3. 抽象类中可以有抽象方法，也可以没有抽象方法\n  4. 抽象类的子类\n     * 实现了抽象方法的具体类\n     * 抽象类\n\n* 抽象类面试题：\n\n  1. 抽象类中是否可以没有抽象方法？如果可以，那么，该类还定义成抽象类有意义吗？为什么？\n  2. 可以没有抽象方法，有意义，不会让其他人直接创建该类对象","slug":"Java继承、抽象总结","published":1,"updated":"2020-08-23T16:07:26.006Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cke7ahvgj0008lgps9vvpfl17","content":"<hr>\n<a id=\"more\"></a>\n<h1 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h1><ul>\n<li><p>继承：是指在一个现有类的基础上去构建一个新的类，构建出来的新类被称作子类，现有类被称作父类，子类会自动拥有父类所有。</p>\n</li>\n<li><p>继承的好处：可继承的属性和方法。</p>\n<ul>\n<li>提高了代表的可维护性</li>\n<li>提高了代码的复用性</li>\n<li>让类与类之间产生了继承关系</li>\n</ul>\n</li>\n<li><p>继承的弊端：</p>\n<ul>\n<li>类与类之间的耦合度过高</li>\n</ul>\n</li>\n<li><p>继承特点：</p>\n<ul>\n<li><p>java中类只能够单继承，不能多继承，可以多层继承</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Yy</span> <span class=\"keyword\">extends</span> <span class=\"title\">Object</span> </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Fu</span> <span class=\"keyword\">extends</span> <span class=\"title\">Yy</span></span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Zi</span> <span class=\"keyword\">extends</span> <span class=\"title\">Fu</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>\n<p>所有的类都直接或者间接的继承了 Object类，Object类称为祖宗类</p>\n</li>\n</ul>\n</li>\n<li><p>继承的注意事项：</p>\n<ol>\n<li><p>使用关键字 <code>extends</code> 让类与类之间 产生继承关系</p>\n</li>\n<li><p>父类私有的成员，子类不能继承，因为根本看不到</p>\n</li>\n<li><p>不能为了继承某个功能而随意进行继承操作， 必须要符合 is a 的关系</p>\n<p>苹果 is a 水果</p>\n<p>男人 is a 人</p>\n<p>狗  is a 人 ， 这种情况就不能继承了</p>\n</li>\n</ol>\n</li>\n<li><p>继承中的成员变量关系：</p>\n<ul>\n<li><p>不同名的变量：</p>\n<p>子类直接继承使用</p>\n</li>\n<li><p>同名的变量：</p>\n<p>默认访问的是子类自己的成员变量, 想访问父类中的同名变量，请使用 <code>super.成员变量;</code></p>\n</li>\n</ul>\n</li>\n<li><p>继承中的成员方法关系：</p>\n<ul>\n<li><p>不同名的方法：</p>\n<p>子类直接继承使用</p>\n</li>\n<li><p>同名的方法：</p>\n<p>默认访问的是子类自己的成员方法，想访问父类中的同名方法，请使用 super.成员方法();</p>\n</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p>super:用来表示当前对象中包含的父类对象空间的引用</p>\n<ul>\n<li><p>调用父类的成员变量：</p>\n<p><code>super.成员变量;</code></p>\n</li>\n<li><p>调用方法的成员方法:</p>\n<p><code>super.成员方法();</code></p>\n</li>\n</ul>\n</li>\n<li><p>方法重写(override)：指在子父类中，出现了方法声明相同的情况，也叫做方法覆盖，方法复写</p>\n<ul>\n<li>方法重写的注意事项：<ol>\n<li>子类的方法声明要与父类相同</li>\n<li>子类要重写方法的方法，方法的权限修饰符不能比父类的更低</li>\n<li>父类私有的方法，子类不能够进行方法重写</li>\n</ol>\n</li>\n</ul>\n</li>\n<li><p>方法重载(overload)：指 在同一个类中，多个方法名称相同，它们的参数列表不同(个数不同，数据类型不同)</p>\n</li>\n</ul>\n<h1 id=\"抽象\"><a href=\"#抽象\" class=\"headerlink\" title=\"抽象\"></a>抽象</h1><ul>\n<li><p>抽象方法： 方法只有声明部分，没有方法体</p>\n</li>\n<li><p>抽象类： 包含抽象方法的类，一定是抽象类</p>\n<p>使用 <code>abstract</code> 修饰的类，是抽象类</p>\n</li>\n<li><p>抽象类的特点：</p>\n<ol>\n<li>抽象类与抽象方法都必须使用 <code>abstract</code> 来修饰</li>\n<li>抽象类不能直接创建对象</li>\n<li>抽象类中可以有抽象方法，也可以没有抽象方法</li>\n<li>抽象类的子类<ul>\n<li>实现了抽象方法的具体类</li>\n<li>抽象类</li>\n</ul>\n</li>\n</ol>\n</li>\n<li><p>抽象类面试题：</p>\n<ol>\n<li>抽象类中是否可以没有抽象方法？如果可以，那么，该类还定义成抽象类有意义吗？为什么？</li>\n<li>可以没有抽象方法，有意义，不会让其他人直接创建该类对象</li>\n</ol>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<hr>","more":"<h1 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h1><ul>\n<li><p>继承：是指在一个现有类的基础上去构建一个新的类，构建出来的新类被称作子类，现有类被称作父类，子类会自动拥有父类所有。</p>\n</li>\n<li><p>继承的好处：可继承的属性和方法。</p>\n<ul>\n<li>提高了代表的可维护性</li>\n<li>提高了代码的复用性</li>\n<li>让类与类之间产生了继承关系</li>\n</ul>\n</li>\n<li><p>继承的弊端：</p>\n<ul>\n<li>类与类之间的耦合度过高</li>\n</ul>\n</li>\n<li><p>继承特点：</p>\n<ul>\n<li><p>java中类只能够单继承，不能多继承，可以多层继承</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Yy</span> <span class=\"keyword\">extends</span> <span class=\"title\">Object</span> </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Fu</span> <span class=\"keyword\">extends</span> <span class=\"title\">Yy</span></span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Zi</span> <span class=\"keyword\">extends</span> <span class=\"title\">Fu</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>\n<p>所有的类都直接或者间接的继承了 Object类，Object类称为祖宗类</p>\n</li>\n</ul>\n</li>\n<li><p>继承的注意事项：</p>\n<ol>\n<li><p>使用关键字 <code>extends</code> 让类与类之间 产生继承关系</p>\n</li>\n<li><p>父类私有的成员，子类不能继承，因为根本看不到</p>\n</li>\n<li><p>不能为了继承某个功能而随意进行继承操作， 必须要符合 is a 的关系</p>\n<p>苹果 is a 水果</p>\n<p>男人 is a 人</p>\n<p>狗  is a 人 ， 这种情况就不能继承了</p>\n</li>\n</ol>\n</li>\n<li><p>继承中的成员变量关系：</p>\n<ul>\n<li><p>不同名的变量：</p>\n<p>子类直接继承使用</p>\n</li>\n<li><p>同名的变量：</p>\n<p>默认访问的是子类自己的成员变量, 想访问父类中的同名变量，请使用 <code>super.成员变量;</code></p>\n</li>\n</ul>\n</li>\n<li><p>继承中的成员方法关系：</p>\n<ul>\n<li><p>不同名的方法：</p>\n<p>子类直接继承使用</p>\n</li>\n<li><p>同名的方法：</p>\n<p>默认访问的是子类自己的成员方法，想访问父类中的同名方法，请使用 super.成员方法();</p>\n</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p>super:用来表示当前对象中包含的父类对象空间的引用</p>\n<ul>\n<li><p>调用父类的成员变量：</p>\n<p><code>super.成员变量;</code></p>\n</li>\n<li><p>调用方法的成员方法:</p>\n<p><code>super.成员方法();</code></p>\n</li>\n</ul>\n</li>\n<li><p>方法重写(override)：指在子父类中，出现了方法声明相同的情况，也叫做方法覆盖，方法复写</p>\n<ul>\n<li>方法重写的注意事项：<ol>\n<li>子类的方法声明要与父类相同</li>\n<li>子类要重写方法的方法，方法的权限修饰符不能比父类的更低</li>\n<li>父类私有的方法，子类不能够进行方法重写</li>\n</ol>\n</li>\n</ul>\n</li>\n<li><p>方法重载(overload)：指 在同一个类中，多个方法名称相同，它们的参数列表不同(个数不同，数据类型不同)</p>\n</li>\n</ul>\n<h1 id=\"抽象\"><a href=\"#抽象\" class=\"headerlink\" title=\"抽象\"></a>抽象</h1><ul>\n<li><p>抽象方法： 方法只有声明部分，没有方法体</p>\n</li>\n<li><p>抽象类： 包含抽象方法的类，一定是抽象类</p>\n<p>使用 <code>abstract</code> 修饰的类，是抽象类</p>\n</li>\n<li><p>抽象类的特点：</p>\n<ol>\n<li>抽象类与抽象方法都必须使用 <code>abstract</code> 来修饰</li>\n<li>抽象类不能直接创建对象</li>\n<li>抽象类中可以有抽象方法，也可以没有抽象方法</li>\n<li>抽象类的子类<ul>\n<li>实现了抽象方法的具体类</li>\n<li>抽象类</li>\n</ul>\n</li>\n</ol>\n</li>\n<li><p>抽象类面试题：</p>\n<ol>\n<li>抽象类中是否可以没有抽象方法？如果可以，那么，该类还定义成抽象类有意义吗？为什么？</li>\n<li>可以没有抽象方法，有意义，不会让其他人直接创建该类对象</li>\n</ol>\n</li>\n</ul>"},{"title":"Java的final、static、匿名对象、内部类、包的声明与访问、访问修饰符以及代码块","date":"2020-08-24T12:21:48.000Z","_content":"\n----\n\n<!--more-->\n\n# final、static、匿名对象、内部类、包的声明与访问、访问修饰符以及代码块\n\n## `final`\n\n关键字，最终的意思。\n\n* `final` 修饰的类：最终的类，不能被继承。\n* `final` 修饰的变量：相当于是一个常量，在编译生成 .class 文件后，该变量未常量值。\n* `final` 修饰的方法：最终的方法，子类不能重写，可以继承过来使用。\n\n\n\n## `static` \n\n关键字，静态的意思。\n\n可以用来修饰类中的成员（成员变量，成员方法）\n\n注意：也可以用来修饰成员内部类\n\n* 特点：\n\n  被静态所修饰的成员，会被所有的对象所共享\n\n  被静态所修饰的成员，可以通过类名直接调用，方便\n\n  * `Person.county = \"中国\";`\n  * `Person.method();`\n\n* 注意事项：\n\n  静态的成员，随着类的加载而加载，优先于对象存在\n\n  在静态方法中，没有 `this` 关键字\n\n  静态方法中，只能调用静态的成员（静态成员变量，静态成员方法）\n\n![静态的共享数据](http://images.yingwai.top/picgo/JavaSE13f2.JPG)\n\n<center>\n    <i>静态的共享数据</i>\n</center>\n\n\n\n![静态的内存图](http://images.yingwai.top/picgo/JavaSE13f1.JPG)\n\n<center>\n    <i>静态的内存图</i>\n</center>\n\n\n\n## 匿名对象\n\n一个没有名字的对象。\n\n* 特点：\n\n  创建匿名对象直接使用，没有对象名\n\n  匿名对象在没有指定其引用变量时，只能使用一次\n\n  匿名对象可以作为方法接收得参数、方法返回值使用\n\n\n\n## 内部类\n\n在一个类中，定义了一个新类，这个新的类就是内部类。\n\n```java\nclass A { // 外部类\n    class B { // 内部类\n    }\n}\n```\n\n* 特点\n\n  内部类可以直接访问外部类的成员，包含私有的成员\n\n\n\n## 包的声明与访问\n\n* 类中包的声明格式：\n\n  `package 包名.包名.包名…;`\n\n* 带有包的类，创建对象格式：`包名.类名 变量名 = new 包名.类名();`\n\n  `cn.itcast.Demo d = new cn.itcast.Demo();`\n\n* 导包的格式：\n\n  `import 包名.类名;`\n\n\n\n## 权限修饰符\n\n`public`：公共的\n\n`protected`：受保护的\n\n`default`：默认的（可以不写）\n\n`private`：私有的\n\n|                  | `public` | `protected` | `default` | `private` |\n| ---------------- | :------: | :---------: | :-------: | :-------: |\n| 在当前类中       | $\\surd$  |   $\\surd$   |  $\\surd$  |  $\\surd$  |\n| 同一包中的其他类 | $\\surd$  |   $\\surd$   |  $\\surd$  |           |\n| 不同包中的子类   | $\\surd$  |   $\\surd$   |           |           |\n| 不同包中的其他类 | $\\surd$  |             |           |           |\n\n\n\n## 代码块\n\n局部代码块：定义在方法中的，用来限制变量的作用范围\n\n构造代码块：定义在类中方法外，用来给对象中的成员初始化赋值\n\n静态代码块：定义在类中方法外，用来给类的静态成员初始化赋值\n\n\n\n","source":"_posts/Java的final、static、匿名对象、内部类、包的声明与访问、访问修饰符以及代码块.md","raw":"---\ntitle: Java的final、static、匿名对象、内部类、包的声明与访问、访问修饰符以及代码块\ndate: 2020-08-24 20:21:48\ncategories: Coding\ntags: Java\n---\n\n----\n\n<!--more-->\n\n# final、static、匿名对象、内部类、包的声明与访问、访问修饰符以及代码块\n\n## `final`\n\n关键字，最终的意思。\n\n* `final` 修饰的类：最终的类，不能被继承。\n* `final` 修饰的变量：相当于是一个常量，在编译生成 .class 文件后，该变量未常量值。\n* `final` 修饰的方法：最终的方法，子类不能重写，可以继承过来使用。\n\n\n\n## `static` \n\n关键字，静态的意思。\n\n可以用来修饰类中的成员（成员变量，成员方法）\n\n注意：也可以用来修饰成员内部类\n\n* 特点：\n\n  被静态所修饰的成员，会被所有的对象所共享\n\n  被静态所修饰的成员，可以通过类名直接调用，方便\n\n  * `Person.county = \"中国\";`\n  * `Person.method();`\n\n* 注意事项：\n\n  静态的成员，随着类的加载而加载，优先于对象存在\n\n  在静态方法中，没有 `this` 关键字\n\n  静态方法中，只能调用静态的成员（静态成员变量，静态成员方法）\n\n![静态的共享数据](http://images.yingwai.top/picgo/JavaSE13f2.JPG)\n\n<center>\n    <i>静态的共享数据</i>\n</center>\n\n\n\n![静态的内存图](http://images.yingwai.top/picgo/JavaSE13f1.JPG)\n\n<center>\n    <i>静态的内存图</i>\n</center>\n\n\n\n## 匿名对象\n\n一个没有名字的对象。\n\n* 特点：\n\n  创建匿名对象直接使用，没有对象名\n\n  匿名对象在没有指定其引用变量时，只能使用一次\n\n  匿名对象可以作为方法接收得参数、方法返回值使用\n\n\n\n## 内部类\n\n在一个类中，定义了一个新类，这个新的类就是内部类。\n\n```java\nclass A { // 外部类\n    class B { // 内部类\n    }\n}\n```\n\n* 特点\n\n  内部类可以直接访问外部类的成员，包含私有的成员\n\n\n\n## 包的声明与访问\n\n* 类中包的声明格式：\n\n  `package 包名.包名.包名…;`\n\n* 带有包的类，创建对象格式：`包名.类名 变量名 = new 包名.类名();`\n\n  `cn.itcast.Demo d = new cn.itcast.Demo();`\n\n* 导包的格式：\n\n  `import 包名.类名;`\n\n\n\n## 权限修饰符\n\n`public`：公共的\n\n`protected`：受保护的\n\n`default`：默认的（可以不写）\n\n`private`：私有的\n\n|                  | `public` | `protected` | `default` | `private` |\n| ---------------- | :------: | :---------: | :-------: | :-------: |\n| 在当前类中       | $\\surd$  |   $\\surd$   |  $\\surd$  |  $\\surd$  |\n| 同一包中的其他类 | $\\surd$  |   $\\surd$   |  $\\surd$  |           |\n| 不同包中的子类   | $\\surd$  |   $\\surd$   |           |           |\n| 不同包中的其他类 | $\\surd$  |             |           |           |\n\n\n\n## 代码块\n\n局部代码块：定义在方法中的，用来限制变量的作用范围\n\n构造代码块：定义在类中方法外，用来给对象中的成员初始化赋值\n\n静态代码块：定义在类中方法外，用来给类的静态成员初始化赋值\n\n\n\n","slug":"Java的final、static、匿名对象、内部类、包的声明与访问、访问修饰符以及代码块","published":1,"updated":"2020-08-24T12:27:32.586Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cke8hxlmr0000tkps30hv1hnt","content":"<hr>\n<a id=\"more\"></a>\n<h1 id=\"final、static、匿名对象、内部类、包的声明与访问、访问修饰符以及代码块\"><a href=\"#final、static、匿名对象、内部类、包的声明与访问、访问修饰符以及代码块\" class=\"headerlink\" title=\"final、static、匿名对象、内部类、包的声明与访问、访问修饰符以及代码块\"></a>final、static、匿名对象、内部类、包的声明与访问、访问修饰符以及代码块</h1><h2 id=\"final\"><a href=\"#final\" class=\"headerlink\" title=\"final\"></a><code>final</code></h2><p>关键字，最终的意思。</p>\n<ul>\n<li><code>final</code> 修饰的类：最终的类，不能被继承。</li>\n<li><code>final</code> 修饰的变量：相当于是一个常量，在编译生成 .class 文件后，该变量未常量值。</li>\n<li><code>final</code> 修饰的方法：最终的方法，子类不能重写，可以继承过来使用。</li>\n</ul>\n<h2 id=\"static\"><a href=\"#static\" class=\"headerlink\" title=\"static\"></a><code>static</code></h2><p>关键字，静态的意思。</p>\n<p>可以用来修饰类中的成员（成员变量，成员方法）</p>\n<p>注意：也可以用来修饰成员内部类</p>\n<ul>\n<li><p>特点：</p>\n<p>被静态所修饰的成员，会被所有的对象所共享</p>\n<p>被静态所修饰的成员，可以通过类名直接调用，方便</p>\n<ul>\n<li><code>Person.county = &quot;中国&quot;;</code></li>\n<li><code>Person.method();</code></li>\n</ul>\n</li>\n<li><p>注意事项：</p>\n<p>静态的成员，随着类的加载而加载，优先于对象存在</p>\n<p>在静态方法中，没有 <code>this</code> 关键字</p>\n<p>静态方法中，只能调用静态的成员（静态成员变量，静态成员方法）</p>\n</li>\n</ul>\n<p><img src=\"http://images.yingwai.top/picgo/JavaSE13f2.JPG\" alt=\"静态的共享数据\"></p>\n<center>\n    <i>静态的共享数据</i>\n</center>\n\n\n\n<p><img src=\"http://images.yingwai.top/picgo/JavaSE13f1.JPG\" alt=\"静态的内存图\"></p>\n<center>\n    <i>静态的内存图</i>\n</center>\n\n\n\n<h2 id=\"匿名对象\"><a href=\"#匿名对象\" class=\"headerlink\" title=\"匿名对象\"></a>匿名对象</h2><p>一个没有名字的对象。</p>\n<ul>\n<li><p>特点：</p>\n<p>创建匿名对象直接使用，没有对象名</p>\n<p>匿名对象在没有指定其引用变量时，只能使用一次</p>\n<p>匿名对象可以作为方法接收得参数、方法返回值使用</p>\n</li>\n</ul>\n<h2 id=\"内部类\"><a href=\"#内部类\" class=\"headerlink\" title=\"内部类\"></a>内部类</h2><p>在一个类中，定义了一个新类，这个新的类就是内部类。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> </span>&#123; <span class=\"comment\">// 外部类</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> </span>&#123; <span class=\"comment\">// 内部类</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>特点</p>\n<p>内部类可以直接访问外部类的成员，包含私有的成员</p>\n</li>\n</ul>\n<h2 id=\"包的声明与访问\"><a href=\"#包的声明与访问\" class=\"headerlink\" title=\"包的声明与访问\"></a>包的声明与访问</h2><ul>\n<li><p>类中包的声明格式：</p>\n<p><code>package 包名.包名.包名…;</code></p>\n</li>\n<li><p>带有包的类，创建对象格式：<code>包名.类名 变量名 = new 包名.类名();</code></p>\n<p><code>cn.itcast.Demo d = new cn.itcast.Demo();</code></p>\n</li>\n<li><p>导包的格式：</p>\n<p><code>import 包名.类名;</code></p>\n</li>\n</ul>\n<h2 id=\"权限修饰符\"><a href=\"#权限修饰符\" class=\"headerlink\" title=\"权限修饰符\"></a>权限修饰符</h2><p><code>public</code>：公共的</p>\n<p><code>protected</code>：受保护的</p>\n<p><code>default</code>：默认的（可以不写）</p>\n<p><code>private</code>：私有的</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th></th>\n<th style=\"text-align:center\"><code>public</code></th>\n<th style=\"text-align:center\"><code>protected</code></th>\n<th style=\"text-align:center\"><code>default</code></th>\n<th style=\"text-align:center\"><code>private</code></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>在当前类中</td>\n<td style=\"text-align:center\">$\\surd$</td>\n<td style=\"text-align:center\">$\\surd$</td>\n<td style=\"text-align:center\">$\\surd$</td>\n<td style=\"text-align:center\">$\\surd$</td>\n</tr>\n<tr>\n<td>同一包中的其他类</td>\n<td style=\"text-align:center\">$\\surd$</td>\n<td style=\"text-align:center\">$\\surd$</td>\n<td style=\"text-align:center\">$\\surd$</td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td>不同包中的子类</td>\n<td style=\"text-align:center\">$\\surd$</td>\n<td style=\"text-align:center\">$\\surd$</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td>不同包中的其他类</td>\n<td style=\"text-align:center\">$\\surd$</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n</tr>\n</tbody>\n</table>\n</div>\n<h2 id=\"代码块\"><a href=\"#代码块\" class=\"headerlink\" title=\"代码块\"></a>代码块</h2><p>局部代码块：定义在方法中的，用来限制变量的作用范围</p>\n<p>构造代码块：定义在类中方法外，用来给对象中的成员初始化赋值</p>\n<p>静态代码块：定义在类中方法外，用来给类的静态成员初始化赋值</p>\n","site":{"data":{}},"excerpt":"<hr>","more":"<h1 id=\"final、static、匿名对象、内部类、包的声明与访问、访问修饰符以及代码块\"><a href=\"#final、static、匿名对象、内部类、包的声明与访问、访问修饰符以及代码块\" class=\"headerlink\" title=\"final、static、匿名对象、内部类、包的声明与访问、访问修饰符以及代码块\"></a>final、static、匿名对象、内部类、包的声明与访问、访问修饰符以及代码块</h1><h2 id=\"final\"><a href=\"#final\" class=\"headerlink\" title=\"final\"></a><code>final</code></h2><p>关键字，最终的意思。</p>\n<ul>\n<li><code>final</code> 修饰的类：最终的类，不能被继承。</li>\n<li><code>final</code> 修饰的变量：相当于是一个常量，在编译生成 .class 文件后，该变量未常量值。</li>\n<li><code>final</code> 修饰的方法：最终的方法，子类不能重写，可以继承过来使用。</li>\n</ul>\n<h2 id=\"static\"><a href=\"#static\" class=\"headerlink\" title=\"static\"></a><code>static</code></h2><p>关键字，静态的意思。</p>\n<p>可以用来修饰类中的成员（成员变量，成员方法）</p>\n<p>注意：也可以用来修饰成员内部类</p>\n<ul>\n<li><p>特点：</p>\n<p>被静态所修饰的成员，会被所有的对象所共享</p>\n<p>被静态所修饰的成员，可以通过类名直接调用，方便</p>\n<ul>\n<li><code>Person.county = &quot;中国&quot;;</code></li>\n<li><code>Person.method();</code></li>\n</ul>\n</li>\n<li><p>注意事项：</p>\n<p>静态的成员，随着类的加载而加载，优先于对象存在</p>\n<p>在静态方法中，没有 <code>this</code> 关键字</p>\n<p>静态方法中，只能调用静态的成员（静态成员变量，静态成员方法）</p>\n</li>\n</ul>\n<p><img src=\"http://images.yingwai.top/picgo/JavaSE13f2.JPG\" alt=\"静态的共享数据\"></p>\n<center>\n    <i>静态的共享数据</i>\n</center>\n\n\n\n<p><img src=\"http://images.yingwai.top/picgo/JavaSE13f1.JPG\" alt=\"静态的内存图\"></p>\n<center>\n    <i>静态的内存图</i>\n</center>\n\n\n\n<h2 id=\"匿名对象\"><a href=\"#匿名对象\" class=\"headerlink\" title=\"匿名对象\"></a>匿名对象</h2><p>一个没有名字的对象。</p>\n<ul>\n<li><p>特点：</p>\n<p>创建匿名对象直接使用，没有对象名</p>\n<p>匿名对象在没有指定其引用变量时，只能使用一次</p>\n<p>匿名对象可以作为方法接收得参数、方法返回值使用</p>\n</li>\n</ul>\n<h2 id=\"内部类\"><a href=\"#内部类\" class=\"headerlink\" title=\"内部类\"></a>内部类</h2><p>在一个类中，定义了一个新类，这个新的类就是内部类。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> </span>&#123; <span class=\"comment\">// 外部类</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> </span>&#123; <span class=\"comment\">// 内部类</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>特点</p>\n<p>内部类可以直接访问外部类的成员，包含私有的成员</p>\n</li>\n</ul>\n<h2 id=\"包的声明与访问\"><a href=\"#包的声明与访问\" class=\"headerlink\" title=\"包的声明与访问\"></a>包的声明与访问</h2><ul>\n<li><p>类中包的声明格式：</p>\n<p><code>package 包名.包名.包名…;</code></p>\n</li>\n<li><p>带有包的类，创建对象格式：<code>包名.类名 变量名 = new 包名.类名();</code></p>\n<p><code>cn.itcast.Demo d = new cn.itcast.Demo();</code></p>\n</li>\n<li><p>导包的格式：</p>\n<p><code>import 包名.类名;</code></p>\n</li>\n</ul>\n<h2 id=\"权限修饰符\"><a href=\"#权限修饰符\" class=\"headerlink\" title=\"权限修饰符\"></a>权限修饰符</h2><p><code>public</code>：公共的</p>\n<p><code>protected</code>：受保护的</p>\n<p><code>default</code>：默认的（可以不写）</p>\n<p><code>private</code>：私有的</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th></th>\n<th style=\"text-align:center\"><code>public</code></th>\n<th style=\"text-align:center\"><code>protected</code></th>\n<th style=\"text-align:center\"><code>default</code></th>\n<th style=\"text-align:center\"><code>private</code></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>在当前类中</td>\n<td style=\"text-align:center\">$\\surd$</td>\n<td style=\"text-align:center\">$\\surd$</td>\n<td style=\"text-align:center\">$\\surd$</td>\n<td style=\"text-align:center\">$\\surd$</td>\n</tr>\n<tr>\n<td>同一包中的其他类</td>\n<td style=\"text-align:center\">$\\surd$</td>\n<td style=\"text-align:center\">$\\surd$</td>\n<td style=\"text-align:center\">$\\surd$</td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td>不同包中的子类</td>\n<td style=\"text-align:center\">$\\surd$</td>\n<td style=\"text-align:center\">$\\surd$</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td>不同包中的其他类</td>\n<td style=\"text-align:center\">$\\surd$</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n</tr>\n</tbody>\n</table>\n</div>\n<h2 id=\"代码块\"><a href=\"#代码块\" class=\"headerlink\" title=\"代码块\"></a>代码块</h2><p>局部代码块：定义在方法中的，用来限制变量的作用范围</p>\n<p>构造代码块：定义在类中方法外，用来给对象中的成员初始化赋值</p>\n<p>静态代码块：定义在类中方法外，用来给类的静态成员初始化赋值</p>"}],"PostAsset":[],"PostCategory":[{"post_id":"cke79q4oy000588ps42t38zvn","category_id":"cke79q4ov000288ps7sav52vb","_id":"cke79q4p1000c88ps5r8vc38p"},{"post_id":"cke79q4oq000088psciln8rit","category_id":"cke79q4ov000288ps7sav52vb","_id":"cke79q4p4000g88psgvfmbcc9"},{"post_id":"cke79q4oz000688ps1e2n8hcf","category_id":"cke79q4ov000288ps7sav52vb","_id":"cke79q4p5000j88ps445t2tjh"},{"post_id":"cke79q4p0000a88psadba07mm","category_id":"cke79q4ov000288ps7sav52vb","_id":"cke79q4p6000m88ps5y7a39y1"},{"post_id":"cke79q4ou000188ps230b9874","category_id":"cke79q4oz000788ps1940ajsc","_id":"cke79q4p8000p88psc0b9a7nt"},{"post_id":"cke79q4p1000b88ps3xzyfean","category_id":"cke79q4ov000288ps7sav52vb","_id":"cke79q4pa000s88psdfjmd9lh"},{"post_id":"cke79q4p3000f88psaooq4u6e","category_id":"cke79q4ov000288ps7sav52vb","_id":"cke79q4pb000w88psgicd7ndl"},{"post_id":"cke79q4ox000488ps9sx231zg","category_id":"cke79q4ov000288ps7sav52vb","_id":"cke79q4pd001088psdlfmco4h"},{"post_id":"cke79q4p9000r88ps7v7t8qh9","category_id":"cke79q4ov000288ps7sav52vb","_id":"cke79q4pf001288ps9xetfvlw"},{"post_id":"cke79q4p4000i88pscqcu31r9","category_id":"cke79q4p6000n88pscung8yy8","_id":"cke79q4pg001688psc1u77npu"},{"post_id":"cke79q4pa000u88ps31wdbhfo","category_id":"cke79q4ov000288ps7sav52vb","_id":"cke79q4ph001988psh6vk6xt5"},{"post_id":"cke79q4pb000z88ps4x2n1i67","category_id":"cke79q4p6000n88pscung8yy8","_id":"cke79q4ph001b88psbcjo056m"},{"post_id":"cke79q4p5000l88ps7hj78kqc","category_id":"cke79q4pb000v88ps071w2vhf","_id":"cke79q4pi001f88pse7qe9458"},{"post_id":"cke79q4pe001188psgvujbx1n","category_id":"cke79q4ov000288ps7sav52vb","_id":"cke79q4pj001i88pscg7j8698"},{"post_id":"cke79q4pf001588ps9crk5p8x","category_id":"cke79q4p6000n88pscung8yy8","_id":"cke79q4pk001m88psb409cgyk"},{"post_id":"cke79q4p6000o88psaelxbozy","category_id":"cke79q4p6000n88pscung8yy8","_id":"cke79q4pk001n88ps7nyqflh8"},{"post_id":"cke79q4pg001888pse6shhc9z","category_id":"cke79q4ov000288ps7sav52vb","_id":"cke79q4pl001q88psdsxkacsa"},{"post_id":"cke79q4ph001a88ps5wkjblu9","category_id":"cke79q4oz000788ps1940ajsc","_id":"cke79q4pl001s88ps5vy2dxd7"},{"post_id":"cke79q4pi001e88pscluqhnvp","category_id":"cke79q4oz000788ps1940ajsc","_id":"cke79q4pn001v88pshs2mh5a6"},{"post_id":"cke79q4pj001h88ps93ru5blo","category_id":"cke79q4oz000788ps1940ajsc","_id":"cke79q4pn001w88psg76k7vc4"},{"post_id":"cke79q4pk001l88ps93ss48fq","category_id":"cke79q4oz000788ps1940ajsc","_id":"cke79q4po001y88ps9to9hw65"},{"post_id":"cke79q4ti004488psg4d2b3pm","category_id":"cke79q4oz000788ps1940ajsc","_id":"cke79q4tn004c88psa6ma9fix"},{"post_id":"cke79q4tj004688psal20d540","category_id":"cke79q4oz000788ps1940ajsc","_id":"cke79q4to004f88pscf5ygjo6"},{"post_id":"cke79q4tl004988ps1wz4dep5","category_id":"cke79q4oz000788ps1940ajsc","_id":"cke79q4tp004j88ps837u2xdd"},{"post_id":"cke79q4tm004b88ps1yag47sr","category_id":"cke79q4oz000788ps1940ajsc","_id":"cke79q4tq004m88ps5pb54bnz"},{"post_id":"cke79q4tn004e88ps2zq23kxk","category_id":"cke79q4oz000788ps1940ajsc","_id":"cke79q4tt004q88psc0tlambi"},{"post_id":"cke79q4tp004i88ps1c75bhk0","category_id":"cke79q4oz000788ps1940ajsc","_id":"cke79q4tu004t88ps78439i9y"},{"post_id":"cke79q4tq004l88ps4h9fbz47","category_id":"cke79q4oz000788ps1940ajsc","_id":"cke79q4tv004x88ps0utuboqq"},{"post_id":"cke79q4tt004p88ps6tu39m8r","category_id":"cke79q4oz000788ps1940ajsc","_id":"cke79q4tw004z88ps6blybibl"},{"post_id":"cke79q4tu004s88psd81khzfn","category_id":"cke79q4oz000788ps1940ajsc","_id":"cke79q4ty005288ps4iqf1rbf"},{"post_id":"cke79q4tv004w88psb6v2hppz","category_id":"cke79q4pb000v88ps071w2vhf","_id":"cke79q4ty005488ps18n4fkgh"},{"post_id":"cke7ahvf00000lgpsd6pl3s7m","category_id":"cke79q4pb000v88ps071w2vhf","_id":"cke7ahvfc0003lgps6y51ffyk"},{"post_id":"cke7ahvf40001lgps2ll957lt","category_id":"cke79q4pb000v88ps071w2vhf","_id":"cke7ahvfc0004lgps0bzi27cl"},{"post_id":"cke7ahvgj0008lgps9vvpfl17","category_id":"cke79q4pb000v88ps071w2vhf","_id":"cke7ahvgm000algpsa6jk2l16"},{"post_id":"cke8hxlmr0000tkps30hv1hnt","category_id":"cke79q4pb000v88ps071w2vhf","_id":"cke8hxlmy0002tkps3ns75l02"}],"PostTag":[{"post_id":"cke79q4oq000088psciln8rit","tag_id":"cke79q4ow000388ps99sodpji","_id":"cke79q4p0000988ps37dy348k"},{"post_id":"cke79q4ou000188ps230b9874","tag_id":"cke79q4oz000888ps0d07ccnw","_id":"cke79q4p4000h88psdfp93wt4"},{"post_id":"cke79q4ox000488ps9sx231zg","tag_id":"cke79q4p2000e88ps95qeepcs","_id":"cke79q4pa000t88ps6mly7rew"},{"post_id":"cke79q4ox000488ps9sx231zg","tag_id":"cke79q4p5000k88ps5q8yagck","_id":"cke79q4pb000x88ps3rp824qs"},{"post_id":"cke79q4pe001188psgvujbx1n","tag_id":"cke79q4p2000e88ps95qeepcs","_id":"cke79q4pg001788psa4shc7kk"},{"post_id":"cke79q4oy000588ps42t38zvn","tag_id":"cke79q4p2000e88ps95qeepcs","_id":"cke79q4pi001d88psdm1shxrf"},{"post_id":"cke79q4oy000588ps42t38zvn","tag_id":"cke79q4p5000k88ps5q8yagck","_id":"cke79q4pj001g88ps6nc1b3t8"},{"post_id":"cke79q4oy000588ps42t38zvn","tag_id":"cke79q4pf001488psdryxedly","_id":"cke79q4pk001k88ps9qtfdsj5"},{"post_id":"cke79q4oz000688ps1e2n8hcf","tag_id":"cke79q4p2000e88ps95qeepcs","_id":"cke79q4pl001p88pscnfs6dpv"},{"post_id":"cke79q4oz000688ps1e2n8hcf","tag_id":"cke79q4p5000k88ps5q8yagck","_id":"cke79q4pl001r88ps7og238gz"},{"post_id":"cke79q4p0000a88psadba07mm","tag_id":"cke79q4p2000e88ps95qeepcs","_id":"cke79q4pn001u88ps96z11kug"},{"post_id":"cke79q4p1000b88ps3xzyfean","tag_id":"cke79q4pl001t88ps1j99gg8j","_id":"cke79q4po002088pshwib293u"},{"post_id":"cke79q4p1000b88ps3xzyfean","tag_id":"cke79q4pn001x88ps4d8s6dlf","_id":"cke79q4po002188psfuk069a7"},{"post_id":"cke79q4p3000f88psaooq4u6e","tag_id":"cke79q4po001z88ps052e1d0d","_id":"cke79q4po002388ps6vsfb2hm"},{"post_id":"cke79q4p4000i88pscqcu31r9","tag_id":"cke79q4po002288pse1dublbp","_id":"cke79q4pp002788psg94bhq96"},{"post_id":"cke79q4p4000i88pscqcu31r9","tag_id":"cke79q4oz000888ps0d07ccnw","_id":"cke79q4pp002888ps48qofpc0"},{"post_id":"cke79q4p4000i88pscqcu31r9","tag_id":"cke79q4po002488ps39mh74ge","_id":"cke79q4pp002a88psfa882dwz"},{"post_id":"cke79q4p4000i88pscqcu31r9","tag_id":"cke79q4po002588pseoacgojg","_id":"cke79q4pp002b88ps8tl1c23x"},{"post_id":"cke79q4p5000l88ps7hj78kqc","tag_id":"cke79q4pp002688psdbrch6ap","_id":"cke79q4pq002d88psbi0186w2"},{"post_id":"cke79q4p5000l88ps7hj78kqc","tag_id":"cke79q4pp002988ps5l0acu69","_id":"cke79q4pq002e88ps777zepcy"},{"post_id":"cke79q4p6000o88psaelxbozy","tag_id":"cke79q4oz000888ps0d07ccnw","_id":"cke79q4pq002g88psftxq0kaf"},{"post_id":"cke79q4p6000o88psaelxbozy","tag_id":"cke79q4po002288pse1dublbp","_id":"cke79q4pq002h88psd9c66tmj"},{"post_id":"cke79q4p9000r88ps7v7t8qh9","tag_id":"cke79q4pq002f88psd8cudlju","_id":"cke79q4pr002l88ps2l9i3hwc"},{"post_id":"cke79q4p9000r88ps7v7t8qh9","tag_id":"cke79q4pq002i88ps5mo18zcu","_id":"cke79q4ps002m88ps2bjy3ghs"},{"post_id":"cke79q4p9000r88ps7v7t8qh9","tag_id":"cke79q4pr002j88psdgyrh8cu","_id":"cke79q4ps002o88psb52nbtmt"},{"post_id":"cke79q4pa000u88ps31wdbhfo","tag_id":"cke79q4pp002688psdbrch6ap","_id":"cke79q4ps002p88pshrzu8r2w"},{"post_id":"cke79q4pb000z88ps4x2n1i67","tag_id":"cke79q4ps002n88ps7a858jjz","_id":"cke79q4ps002r88psdwci5a3x"},{"post_id":"cke79q4pb000z88ps4x2n1i67","tag_id":"cke79q4oz000888ps0d07ccnw","_id":"cke79q4ps002s88pscox4flr6"},{"post_id":"cke79q4pf001588ps9crk5p8x","tag_id":"cke79q4ps002q88ps6kn21hp6","_id":"cke79q4pt002w88pseeji07u7"},{"post_id":"cke79q4pf001588ps9crk5p8x","tag_id":"cke79q4ps002t88ps28rfc4fo","_id":"cke79q4pt002x88psbk212rkb"},{"post_id":"cke79q4pf001588ps9crk5p8x","tag_id":"cke79q4pt002u88pshfybhvcz","_id":"cke79q4pu002z88ps50ap2jao"},{"post_id":"cke79q4pg001888pse6shhc9z","tag_id":"cke79q4pt002v88psfycr3m2j","_id":"cke79q4pu003188psc024794h"},{"post_id":"cke79q4pg001888pse6shhc9z","tag_id":"cke79q4pn001x88ps4d8s6dlf","_id":"cke79q4pu003288psez689xq9"},{"post_id":"cke79q4ph001a88ps5wkjblu9","tag_id":"cke79q4po002288pse1dublbp","_id":"cke79q4pv003688psaeie8yri"},{"post_id":"cke79q4ph001a88ps5wkjblu9","tag_id":"cke79q4oz000888ps0d07ccnw","_id":"cke79q4pw003788ps9df7gxk1"},{"post_id":"cke79q4ph001a88ps5wkjblu9","tag_id":"cke79q4po002488ps39mh74ge","_id":"cke79q4pw003988ps1l6b6gtv"},{"post_id":"cke79q4ph001a88ps5wkjblu9","tag_id":"cke79q4po002588pseoacgojg","_id":"cke79q4pw003a88psb00y6nw6"},{"post_id":"cke79q4pi001e88pscluqhnvp","tag_id":"cke79q4po002288pse1dublbp","_id":"cke79q4py003h88psg35q5ydj"},{"post_id":"cke79q4pi001e88pscluqhnvp","tag_id":"cke79q4pw003888ps1coxfotw","_id":"cke79q4py003i88pshqmxgm94"},{"post_id":"cke79q4pi001e88pscluqhnvp","tag_id":"cke79q4po002488ps39mh74ge","_id":"cke79q4py003k88ps2acs9qdv"},{"post_id":"cke79q4pi001e88pscluqhnvp","tag_id":"cke79q4oz000888ps0d07ccnw","_id":"cke79q4py003l88ps76of9url"},{"post_id":"cke79q4pi001e88pscluqhnvp","tag_id":"cke79q4pw003c88psds4zb2py","_id":"cke79q4q0003n88ps1eya2rc6"},{"post_id":"cke79q4pi001e88pscluqhnvp","tag_id":"cke79q4px003d88ps4grqelhn","_id":"cke79q4q0003o88ps644m3bit"},{"post_id":"cke79q4pi001e88pscluqhnvp","tag_id":"cke79q4px003e88pshygw3u4i","_id":"cke79q4q0003q88ps3h3k19w7"},{"post_id":"cke79q4pi001e88pscluqhnvp","tag_id":"cke79q4po002588pseoacgojg","_id":"cke79q4q0003r88psatsxeg0w"},{"post_id":"cke79q4pj001h88ps93ru5blo","tag_id":"cke79q4py003g88ps6ed53a5p","_id":"cke79q4q1003t88ps7wn0bygb"},{"post_id":"cke79q4pj001h88ps93ru5blo","tag_id":"cke79q4py003j88pse98o18we","_id":"cke79q4q1003u88psb3vcamoq"},{"post_id":"cke79q4pk001l88ps93ss48fq","tag_id":"cke79q4po002488ps39mh74ge","_id":"cke79q4q2003y88ps342mgycx"},{"post_id":"cke79q4pk001l88ps93ss48fq","tag_id":"cke79q4po002288pse1dublbp","_id":"cke79q4q2003z88ps2n5kfwvg"},{"post_id":"cke79q4pk001l88ps93ss48fq","tag_id":"cke79q4pw003888ps1coxfotw","_id":"cke79q4q3004088ps8p6d3cmt"},{"post_id":"cke79q4pk001l88ps93ss48fq","tag_id":"cke79q4px003d88ps4grqelhn","_id":"cke79q4q3004188ps8o7kchga"},{"post_id":"cke79q4pk001l88ps93ss48fq","tag_id":"cke79q4px003e88pshygw3u4i","_id":"cke79q4q3004288psfg5d1bpt"},{"post_id":"cke79q4pk001l88ps93ss48fq","tag_id":"cke79q4po002588pseoacgojg","_id":"cke79q4q3004388ps16584qvl"},{"post_id":"cke79q4tj004688psal20d540","tag_id":"cke79q4po002288pse1dublbp","_id":"cke79q4tm004a88ps8iau2kj9"},{"post_id":"cke79q4tj004688psal20d540","tag_id":"cke79q4oz000888ps0d07ccnw","_id":"cke79q4tn004d88psg1khhsli"},{"post_id":"cke79q4tj004688psal20d540","tag_id":"cke79q4po002588pseoacgojg","_id":"cke79q4to004h88ps2fpz13x7"},{"post_id":"cke79q4tl004988ps1wz4dep5","tag_id":"cke79q4ps002n88ps7a858jjz","_id":"cke79q4tq004k88psf87fgubs"},{"post_id":"cke79q4tl004988ps1wz4dep5","tag_id":"cke79q4po002488ps39mh74ge","_id":"cke79q4tt004o88ps0jsh1p6i"},{"post_id":"cke79q4tl004988ps1wz4dep5","tag_id":"cke79q4pw003888ps1coxfotw","_id":"cke79q4tu004r88pse7ju4fn5"},{"post_id":"cke79q4tn004e88ps2zq23kxk","tag_id":"cke79q4po002488ps39mh74ge","_id":"cke79q4tv004v88ps9zihc327"},{"post_id":"cke79q4tn004e88ps2zq23kxk","tag_id":"cke79q4px003d88ps4grqelhn","_id":"cke79q4tw004y88psd8fjazvz"},{"post_id":"cke79q4tn004e88ps2zq23kxk","tag_id":"cke79q4ps002n88ps7a858jjz","_id":"cke79q4tx005088ps1ic8abmz"},{"post_id":"cke79q4tp004i88ps1c75bhk0","tag_id":"cke79q4oz000888ps0d07ccnw","_id":"cke79q4ty005388ps0qtvabw4"},{"post_id":"cke79q4tp004i88ps1c75bhk0","tag_id":"cke79q4po002488ps39mh74ge","_id":"cke79q4ty005588psfa4w3lng"},{"post_id":"cke79q4tp004i88ps1c75bhk0","tag_id":"cke79q4po002288pse1dublbp","_id":"cke79q4ty005688psezbhcx11"},{"post_id":"cke79q4tp004i88ps1c75bhk0","tag_id":"cke79q4pw003888ps1coxfotw","_id":"cke79q4tz005788psgq6444bu"},{"post_id":"cke79q4ti004488psg4d2b3pm","tag_id":"cke79q4tl004888pshffo8f4t","_id":"cke79q4tz005888psgra22jhs"},{"post_id":"cke79q4ti004488psg4d2b3pm","tag_id":"cke79q4to004g88psclehaoxl","_id":"cke79q4tz005988ps1dazclks"},{"post_id":"cke79q4tt004p88ps6tu39m8r","tag_id":"cke79q4po002488ps39mh74ge","_id":"cke79q4tz005a88ps3m707ki5"},{"post_id":"cke79q4tt004p88ps6tu39m8r","tag_id":"cke79q4px003d88ps4grqelhn","_id":"cke79q4tz005b88psbcvm93k2"},{"post_id":"cke79q4tt004p88ps6tu39m8r","tag_id":"cke79q4ps002n88ps7a858jjz","_id":"cke79q4tz005c88psaog510ai"},{"post_id":"cke79q4tm004b88ps1yag47sr","tag_id":"cke79q4po002288pse1dublbp","_id":"cke79q4tz005d88ps3an410wy"},{"post_id":"cke79q4tm004b88ps1yag47sr","tag_id":"cke79q4oz000888ps0d07ccnw","_id":"cke79q4u0005e88pshow999d2"},{"post_id":"cke79q4tm004b88ps1yag47sr","tag_id":"cke79q4tq004n88ps8io5ex8f","_id":"cke79q4u0005f88psfodkehw9"},{"post_id":"cke79q4tu004s88psd81khzfn","tag_id":"cke79q4po002288pse1dublbp","_id":"cke79q4u0005g88ps500o3cjd"},{"post_id":"cke79q4tu004s88psd81khzfn","tag_id":"cke79q4po002488ps39mh74ge","_id":"cke79q4u0005h88ps8b2n7vxk"},{"post_id":"cke79q4tu004s88psd81khzfn","tag_id":"cke79q4pw003888ps1coxfotw","_id":"cke79q4u0005i88ps6pujfx82"},{"post_id":"cke79q4tu004s88psd81khzfn","tag_id":"cke79q4px003e88pshygw3u4i","_id":"cke79q4u0005j88psd67aha1t"},{"post_id":"cke79q4tu004s88psd81khzfn","tag_id":"cke79q4px003d88ps4grqelhn","_id":"cke79q4u0005k88ps6td566i8"},{"post_id":"cke79q4tu004s88psd81khzfn","tag_id":"cke79q4po002588pseoacgojg","_id":"cke79q4u1005l88psd57n4w48"},{"post_id":"cke79q4tq004l88ps4h9fbz47","tag_id":"cke79q4pw003c88psds4zb2py","_id":"cke79q4u1005m88pshggs8uw9"},{"post_id":"cke79q4tq004l88ps4h9fbz47","tag_id":"cke79q4po002288pse1dublbp","_id":"cke79q4u1005n88ps2n2y37hh"},{"post_id":"cke79q4tq004l88ps4h9fbz47","tag_id":"cke79q4po002488ps39mh74ge","_id":"cke79q4u1005o88ps4wusfhtq"},{"post_id":"cke79q4tq004l88ps4h9fbz47","tag_id":"cke79q4po002588pseoacgojg","_id":"cke79q4u1005p88ps9flrgns8"},{"post_id":"cke79q4tq004l88ps4h9fbz47","tag_id":"cke79q4tu004u88psellccac7","_id":"cke79q4u1005q88psf5sfebgz"},{"post_id":"cke79q4tv004w88psb6v2hppz","tag_id":"cke79q4tx005188pshlawbkrq","_id":"cke79q4u1005r88psa82z8uym"},{"post_id":"cke7ahvf00000lgpsd6pl3s7m","tag_id":"cke7ahvf60002lgpsh4mkfqiv","_id":"cke7ahvfe0006lgpsba6n2ke6"},{"post_id":"cke7ahvf40001lgps2ll957lt","tag_id":"cke7ahvf60002lgpsh4mkfqiv","_id":"cke7ahvfe0007lgpsc0mf45ph"},{"post_id":"cke7ahvgj0008lgps9vvpfl17","tag_id":"cke7ahvf60002lgpsh4mkfqiv","_id":"cke7ahvgm000blgps8egb7914"},{"post_id":"cke7ahvgj0008lgps9vvpfl17","tag_id":"cke7ahvgl0009lgps8qwzh53h","_id":"cke7ahvgm000clgpsb77z5egz"},{"post_id":"cke8hxlmr0000tkps30hv1hnt","tag_id":"cke7ahvf60002lgpsh4mkfqiv","_id":"cke8hxlmx0001tkpsfxabfrtd"}],"Tag":[{"name":"C++","_id":"cke79q4ow000388ps99sodpji"},{"name":"密码学","_id":"cke79q4oz000888ps0d07ccnw"},{"name":"Hexo","_id":"cke79q4p2000e88ps95qeepcs"},{"name":"NexT","_id":"cke79q4p5000k88ps5q8yagck"},{"name":"不蒜子","_id":"cke79q4pf001488psdryxedly"},{"name":"Jupyter","_id":"cke79q4pl001t88ps1j99gg8j"},{"name":"Linux","_id":"cke79q4pn001x88ps4d8s6dlf"},{"name":"LaTeX","_id":"cke79q4po001z88ps052e1d0d"},{"name":"MPC","_id":"cke79q4po002288pse1dublbp"},{"name":"PPML","_id":"cke79q4po002488ps39mh74ge"},{"name":"Secret Sharing","_id":"cke79q4po002588pseoacgojg"},{"name":"Python","_id":"cke79q4pp002688psdbrch6ap"},{"name":"PyTorch","_id":"cke79q4pp002988ps5l0acu69"},{"name":"Zotero","_id":"cke79q4pq002f88psd8cudlju"},{"name":"坚果云","_id":"cke79q4pq002i88ps5mo18zcu"},{"name":"PaperShip","_id":"cke79q4pr002j88psdgyrh8cu"},{"name":"HE","_id":"cke79q4ps002n88ps7a858jjz"},{"name":"群","_id":"cke79q4ps002q88ps6kn21hp6"},{"name":"环","_id":"cke79q4ps002t88ps28rfc4fo"},{"name":"近世代数","_id":"cke79q4pt002u88pshfybhvcz"},{"name":"Ubuntu","_id":"cke79q4pt002v88psfycr3m2j"},{"name":"Neural Network","_id":"cke79q4pw003888ps1coxfotw"},{"name":"SVM","_id":"cke79q4pw003c88psds4zb2py"},{"name":"Linear Regression","_id":"cke79q4px003d88ps4grqelhn"},{"name":"Logistic Regression","_id":"cke79q4px003e88pshygw3u4i"},{"name":"数据挖掘","_id":"cke79q4py003g88ps6ed53a5p"},{"name":"推荐系统","_id":"cke79q4py003j88pse98o18we"},{"name":"JavaScript","_id":"cke79q4tl004888pshffo8f4t"},{"name":"测试","_id":"cke79q4to004g88psclehaoxl"},{"name":"Garbled Circuit","_id":"cke79q4tq004n88ps8io5ex8f"},{"name":"HIV co-receptor prediction","_id":"cke79q4tu004u88psellccac7"},{"name":"LeetCode","_id":"cke79q4tx005188pshlawbkrq"},{"name":"Java","_id":"cke7ahvf60002lgpsh4mkfqiv"},{"name":"面向对象","_id":"cke7ahvgl0009lgps8qwzh53h"}]}}